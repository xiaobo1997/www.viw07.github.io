[TOC]

![image-20201122160732523](https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20201122160732523.png)

# 1.锁优化和升级

参考 `深入浅出多线程`  `java并发编程的艺术`

## 锁状态

> 在锁机制中描述了各个锁 状态

### 无锁





### 偏向锁

> 如果这个线程获取了这个对象的锁，那么下一次就不需要在次获取这个对象的锁了，

**介绍：**

偏向锁会偏向于第⼀个访问锁的线程，如果在接下来的运⾏过程中，该锁没有被其 他的线程访问，则持有偏向锁的线

程将永远不需要触发同步。也就是说，偏向锁在 资源⽆竞争情况下消除了同步语句，连**CAS**操作都不做了，提⾼了程

序的运⾏性 能。

**原理：**

通过对象头中的线程ID来标识判断

第一次进入同步，对象头记录线程id

第二次线程进入，判断线程id是否锁的Mark Word是否存在这个id

![image-20201122145754226](https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20201122145754226.png)

**偏向锁的获得和撤销:**

​		==偏向锁升级成轻量级锁时，==会暂停拥有偏向锁的线程，重置偏向锁标识，这个过程看起来容易，实则开销还是很大的

​		撤销锁使用的是 等待存在竞争时才撤销偏向锁，此时偏向锁的进程才会释放锁

![img](http://concurrent.redspider.group/article/02/imgs/偏向锁.png)



> 关闭偏向锁
>
> 场景：如果应用程序里所有的锁通常处于竞争状态，那么偏向锁就会是一种累赘，

```
-XX:UseBiasedLocking=false   //程序默认会进入轻量级锁状态。默认是打开的
```



### 轻量级锁 



> 多个线程在不同时段获取同一把锁，即不存在锁竞争的情况，也就没有线程阻塞。针对这种情况，JVM采用轻量级锁来避免线程的阻塞与唤醒。
>
> ==如果一个线程尝试CAS获取一个偏向锁，但是失败了，锁就会膨胀为轻量级锁==



> 轻量级锁的加锁

​		线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并 将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用 CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失 败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。 

**自旋**：不断的循环去获取锁

- 防止自旋消耗大量资源的解决方法：

- 1.指定自旋的次数
- 2.JDK有自适应自旋锁

==轻量级锁会升级 重量级：如果自旋到一定程度（和JVM、操作系统相关），依然没有获取到锁，称为自旋失败，那么这个线程会阻塞。同时这个锁就会**升级成重量级锁**。==





> 轻量级锁的解锁

在释放锁时，当前线程会使用CAS操作将Displaced Mark Word的内容复制回锁的Mark Word里面。如果没有发生竞争，那么这个复制的操作会成功。如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁，那么CAS操作会失败，此时会释放锁并唤醒被阻塞的线程。

![img](http://concurrent.redspider.group/article/02/imgs/轻量级锁流程图.png)

### 重量级锁

> 如果一个线程在一定的自旋次数中没有获得轻量级锁，那么此时锁会膨胀为重量级锁。

> 实现

重量级锁依赖于操作系统的互斥量（mutex） 实现的，而操作系统中线程间状态的转换需要相对比较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗CPU。



当多个线程同时请求某个对象锁时，对象锁会设置几种状态用来区分请求的线程：

```
Contention List：所有请求锁的线程将被首先放置到该竞争队列
Entry List：Contention List中那些满足条件的线程被移到Entry List
Wait Set：那些调用wait方法被阻塞的线程被放置到Wait Set
OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck
Owner：获得锁的线程称为Owner
!Owner：释放锁的线程
```



```
当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个ObjectWaiter对象插入到Contention List的队列的队首，然后调用park函数挂起当前线程。

当线程释放锁时，会从Contention List或EntryList中挑选一个线程唤醒，被选中的线程叫做Heir presumptive即假定继承人，假定继承人被唤醒后会尝试获得锁，但synchronized是非公平的，所以假定继承人不一定能获得锁。这是因为对于重量级锁，线程先自旋尝试获得锁，这样做的目的是为了减少执行操作系统同步操作带来的开销。如果自旋不成功再进入等待队列。这对那些已经在等待队列中的线程来说，稍微显得不公平，还有一个不公平的地方是自旋线程可能会抢占了Ready线程的锁。

如果线程获得锁后调用Object.wait方法，则会将线程加入到WaitSet中，当被Object.notify唤醒后，会将线程从WaitSet移动到Contention List或EntryList中去。需要注意的是，当调用一个锁对象的wait或notify方法时，如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁。
```

参考 `深入浅出多线程`  `https://blog.csdn.net/gentlezuo/article/details/91410716`

# 2.锁升级策略总结

> 每一个线程在准备获取共享资源时： 第一步，检查MarkWord（锁对象）里面是不是放的自己的线程id ,如果是，表示当前线程是处于 “偏向锁” 。
>
> 第二步，如果MarkWord不是自己的程序id，锁升级，这时候，用CAS(比较交换)来执行切换，新的线程根据MarkWord里面现有的线程id，通知之前线程暂停，之前线程将Markword的内容置为空。
>
> 第三步，两个线程都把锁对象的HashCode复制到自己新建的用于存储锁的记录空间，接着开始通过CAS操作， 把锁对象的MarKword的内容修改为自己新建的记录空间的地址的方式竞争MarkWord。
>
> 第四步，第三步中成功执行CAS的获得资源，失败的则进入自旋 。
>
> 第五步，自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源释放锁)，则整个状态依然处于 轻量级锁的状态（因为此时是有竞争的），
>
> 第六步，如果自旋失败 ，进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己（线程通信）。

# 3.锁对比



> 表来自 `Java并发编程的艺术`
>
> 有点难懂，回头继续看看，现在起码有个小概念



| 锁       | 优点                                                         | 缺点                                             | 适用场景                             |
| -------- | ------------------------------------------------------------ | ------------------------------------------------ | ------------------------------------ |
| 偏向锁   | 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗。 | 适用于只有一个线程访问同步块场景。   |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度。                   | 如果始终得不到锁竞争的线程使用自旋会消耗CPU。    | 追求响应时间。同步块执行速度非常快。 |
| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU。                            | 线程阻塞，响应时间缓慢。                         | 追求吞吐量。同步块执行时间较长。     |