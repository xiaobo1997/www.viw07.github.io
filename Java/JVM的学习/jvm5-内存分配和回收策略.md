[TOC]



# 1.内存分配和回收策略


对象在内存的分配是在堆上分配的，主要是在新生代的伊甸区，比较少是直接在老年代分配的，**分配规则不固定**



## 什么时候MinorGC  Full GC



### Minor GC  

Minor GC 主要是对 新生代GC（包括伊甸区和幸存区），因为对象存活时间比较短，比较频繁，速度快

触发条件： 当伊甸区的空间不够，会触发 Minor GC，

工作流程：

- 1.不停的创建新对象，对达到了设置的值或者是默认的值 就会触发 minor gc,
- 2.之后 会把minor gc  和幸存区A的存活对象移动到 幸存区B上，然后这些对象的年龄+1
- 3.熬过一定的次数 以后，幸存B 的对象进入 老年代的区域，
- 4.次数可以通过设置  这个阈值是可以通过 `-XX:MaxTenuringThreshold` 参数指定。





### maior gc/Full GC

full gc 是发生在老年代，因为老年代的对象是存活时间比较久的。而且他的内存空间也是比较大的，执行速度比较慢，多次minor gc 可能伴随着一次full gc

触发full gc 

- 1.System.gc()的调用
- 2.老年代空间不足，full gc 后还不足 java.lang.OutOfMemoryError: Java heap space
- 3.担保失败，也就是 空间分配担保失败
- 4.对象的大小 超过 幸存区B和老年代的可用内存











## 内存分配策略



### 对象优先在伊甸区分配



大多数情况下  对象是在 新生代中的伊甸分配，没有空间 触发 young gc



### 大对象直接进入老年代

大对象是需要连续内存的对象，比如长字符串，以及数组，

经常出现 大对象会提取触发 GC，来获取这个的内存空间，

可以通过设置来改变大于多少直接在老年代分配，直接就避免了在 新生代和老年代中的频繁的 移动复制



###  长期存活的对象进入老年代

我们可以通过为对象设置年龄计数器，

熬过多少次GC 就进入老年代，

`-XX:MaxTenuringThreshold` 用来定义年龄的阈值。



### 动态对象判断

就是说，如果这个对象在幸存区中 的年龄超过了 这个幸存区所有对象年龄的平均值，直接进入老年代，



### 空间分配担保

就是说 老年代给新生代空间在担保，检查保证老年代的连续内存空间是超过新生代所有对象的和，可以是超过的话，minor gc 没问题，如果不超过的话 首先看是否允许担保失败，如果允许就会检查老年代连续内存是不是一直超过young 空间，如果是就会young gc，如果不是或者不允许担保失败，就可能就会  full gc