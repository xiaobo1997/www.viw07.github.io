[TOC]


# 1.内存模型的三大特性



## 概念

> 为什么有这三个

因为java内存模型是为了处理并发中的原子，可见，有序 而创建的。



### 原子

> 怎么保证

Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，

基本数据类型的访问、读写都是具备原子性的（例外就是long和double的非原子性）



> 显式使用

Java内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作。这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。



### 可见

> 是什么

可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。

volatile ，synchronized和final。能实现可见性，

Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，

### 有序

> 什么意思

主要是：指令重排序”现象和“工作内存与主内存同步延迟

保证有序就需要 禁止指令重排序



# 2.先行发生原则



## 概念

> 先行发生是Java内存模型中定义的两项操作之间的偏序关系，比如说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。

我的理解是，每一次为了维护内存模型中的有序性 如加 synchronized 和volatile  等 这样是比较重的，这样你需要去每一个地方加上，这样我们就有了一个原则，也就是happens-before 原则， 这样我们通过规则就可以解决并发环境中操作冲突的问题。这个规则的话就可以让我们对一个操作的执行结果对另外一个操作而言是可见的。这样又解决了并发共享变量一致性问题



简单说明一下happens-before，前面在多线程中写了一点点，但是还没有没有理解，

```java
i = 1; // 线程A   1 

j = i; // 线程B   2

i = 2; // 线程C    3
```

如果没有这个原则，  3在2之前执行，那么是会改变 j原本正常的值

那么等线程B去读的时侯就是一个过期的值， 就不满足线程安全的要求，

happens-before---也可以说是线程安全的一个标准吧，