[TOC]



![image-20201122144911521](https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20201122144911521.png)

# 1.锁机制--同步



## 介绍

> 先说一下java世界中有哪些锁
>
> 因为看这一块很容易看不懂，想看有哪些锁，以及大概的作用，这方面比较难，一个知识点一篇都不够总结，这里只是学习 然后上网找资料 然后看书 并不深入。

- 1.公平锁/非公平锁
  - 公平锁：指多个线程按照申请锁的顺序来获取锁。
  - 非公平：获取锁的顺序并不是按照申请锁的顺序。Synchronized，ReentrantLock可以通过构造方法变公平锁
- 2.可重入锁(递归锁)
  - ：同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。
  - 如ReentrantLock，Synchronized
  - 可重入锁的一个好处是可一定程度避免死锁。
- 3.互斥锁/读写锁
  - 互斥锁在Java中的具体实现就是ReentrantLock
  - 读写锁在Java中的具体实现就是ReadWriteLock
- 4.乐观锁/悲观锁
  - 乐观锁:乐观的认为，同一个数据的并发操作，是不会发生修改的,不加锁的并发操作是不会有问题的。乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。场景：读
  - 悲观锁: 认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。悲观的认为，不加锁的并发操作一定会出问题。场景：写
- 5.分段锁
  - 不是一个具体的锁，如ConcurrentHashMap（这个并发容器类的加锁机制是基于粒度更小的分段锁）。分段锁相当于锁容器中的其中一个对象（一部分数据）。当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率。数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。
  - `https://cloud.tencent.com/developer/article/1150780`
  - `https://cloud.tencent.com/developer/article/1513197`
- 6.偏向锁/轻量级锁/重量级锁
  - 偏向锁：偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。
  - 轻量级锁：在没有多线程竞争的情况下，使用轻量级锁能够减少性能消耗，但是当多个线程同时竞争锁时，轻量级锁会升级为重量级锁。
  - 重量级锁： 当有其他线程占用锁时，当前线程会进入阻塞状态。
- 7.自旋锁
  - 当一个线程A尝试进入同步代码块，但是当前的锁已经被线程B占有时，线程A不立即进入阻塞状态，而是不停的采用循环的方式，等待线程B释放锁。如果B可以在很短时间释放资源，这样就减少了因为锁竞争而降低性能，减少了上下文切换。缺点：循环会消耗CPU 做到释放资源之间这一点时间的无用功
- 8.独享锁/共享锁
  - 独享锁是指该锁一次只能被一个线程所持有。ReentrantLock,Synchronized
  - 共享锁是指该锁可被多个线程所持有。ReadWriteLock(读锁是共享锁，写锁是独享锁)
  - 读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。



> java锁的状态
>
> 获取锁和释放锁都会带来性能的消耗

- 1.无锁状态：无锁就是没有对资源进行锁定，任何线程都可以尝试去修改它

- 2.偏向锁状态

- 3.轻量级锁状态

- 4.重量级锁状态

> 锁的升级和降级
>
> 参考：`https://www.jianshu.com/p/9932047a89be`

锁是可以升级也可以降级，只不过降低的条件比较苛刻，而升级相对于比较容易。并且多次降级对VM性能有影响。

HotSpot JVM 锁降级发生在 stop the world，



参考学习 JVM的知识 `《深入理解Java虚拟机》`



> java中锁的作用

在大多数实际的多线程应用中， 两个或两个以上的线程需要共享对同一数据的存取。如果两个线程存取相同的对象， 并且每一个线程都调用了一个修改该对象状态的方法，将会发生数据不一致。

**保证在任意时刻，只允许一个线程进行对临界区资源（被锁着的代码块）的操作**

锁旨在强制实施互斥排他、并发控制策略。

> 线程安全

在多线程中，每个线程的执行顺序，是无法预测不可控制的，那么在对数据进行读写的时候便存在由于读写顺序多乱而造成数据混乱错误的可能性。造成线程不安全

多个线程可以同时安全调用的代码称为线程安全。 如果一段代码是线程安全的，则它不包含竞争条件。 仅当多个线程更新共享资源时，才会出现争用条件。

> CAS: compare and swap

比较并设置。用于在硬件层面上提供原子性操作。在 Intel 处理器中，比较并交换通过指令cmpxchg实现。 比较是否和给定的数值一致，如果一致则修改，不一致则不修改。







