[TOC]



# 1.GC策略







## 1. 如何判断对象是否可回收

> 首先我们再一次知道   GC回收主要是 堆和方法区，
>
> 我们知道 在运行期 才知道 哪些对象是会创建的，
>
> 然后 内存分配和回收都是动态的
>
> 我们需要知道 判断对象是否存活



什么是无效对象：就是一个对象没有被任何其他对象引用和变量引用。是需要被回收的



### 引用计数法

> 是什么

就是在对象头维护了一个count计数器，然后只要对象被引用了一次，就+1，如引用失效就-1

如果为0  什么对象就是无效对象。

引用计数法的效率比较高，

> 缺点

两个对象循环引用的情况下，计数器永远不为0

不能解决循环引用的问题，所以JVM不采用这种，



```
public class Test{

public Object tt  = null;

public static void main(String[] args){
 Test a = new Test();
 Test b = new Test();
 a.tt = b;
 b.tt = a;
 a = null;
 b = null;
 ......
}

}
```





### 可达性分析

![image-20201218154648702](https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20201218154648702.png)

<img src="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20201218021124252.png" alt="image-20201218021124252" style="zoom:67%;" />

> 是什么

就是说  以GCROOT为起点开始搜索，可达的对象都是活着的，不可达的对象都是无效对象

GC Root 指的是：

- java栈中引用的本地变量（栈帧的本地变量表）
- 本地方法栈中JNI引用的对象（Native方法）
- 方法区中常量引用的对象
- 方法区中类静态属性引用的对象

**不包括堆中的引用对象，这样避免了循环引用的问题**



## 2.引用类型

不同的引用类型主要是对对象的不同可达性状态和垃圾收集的影响的体现上。





> 强引用

简单的说就是  GC不会回收的对象

> 弱引用

简单的说 就是 GC内存不够会回收，第一次内存不足会清除，第二次不足会内存溢出

> 软引用

简单的说  就是 活不过下一个GC

> 虚引用

简单的说 就是有没有都无所谓，



## 3.回收堆中的无效对象



对于在可达性分析中**不可达的对象**来说，不一定会被GC回收



JVM 会有两个判断

- 1.判断finalize() 是否有必要执行
  - 首先 这个对象 在可达性分析中 没有GC ROOT  引用链，那他就会被**第一次标记**，后面还会标记一次，自救是在下一次标记中 对象逃跑第二次标记，
  - 首先，finalize()相当于对象的一次自救，只能一次。让对象自救 只需要重新让 这个对象 和GC ROOT 引用链 重新有关联 就可以了
  - JVM会去判断这个对象是否有必要执行 finalize() 方法， 如果对象 **没有**覆盖finalize()方法 和 finalize()方法已经**被调用**了，或者 JVM认为这个对象没必要执行 finalize()方法，那么对象基本是被回收了。
  - 如果对象被标记了 有必要执行 finalize()方法，对象会进入一个等待队列中 ，等待执行，如果 出现 超时操作，虚拟机直接执行finalize()
- 2.对象重生或死亡
  - 如果在执行finalize() 方法时   让自己 复制给了 某一个类变量 或者 对象的成员变量，那在第二次标记中 移出  即将回收的集合。如果没有就会被 GC收集器  清除
  - **任何一个对象的 finalize() 方法只会被系统自动调用一次，如果对象面临下一次回收，它的 finalize() 方法不会被再次执行，想继续在 finalize() 中自救就失效了。**





## 4.回收方法区的内存

方法区主要是存放生命周期比较长的类信息，常量，静态变量，每一次GC只有比较少的垃圾被清除，

在方法区中 主要是有两种垃圾

- 1.废弃的变量
- 2.无用的类



那么有这两种垃圾就需要去判断

1.怎么判断 废弃变量

只要常量池中的变量不被任何引用变量或者是 对象引用，那么这些变量就会被清除，

2.怎么判断类是无用的

如果一个类是无用的，需要满足下面三个条件：

- 1.这个类的所有对象都被清除了
- 2.加载这个类的类加载器都被回收了， 判断比较两个对象是否相等一定是在 同一个类加载器下面
- 3.该类的java.lang.Class 对象没有在任何地方被引用，无法在如何地方通过reflect访问该类的方法

**一个类被加载到方法区时，在堆上创建对象。这个对象在类被加载方法区创建，在方法区删除这个类是清除**



# 2.垃圾收集算法



##  标记-清除算法

图参考CYC2018，地址后面发

![image-20201218155706548](https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20201218155706548.png)



**标记：**

遍历所有的 GC ROOT ，然后把所有GC ROOT不可达的对象 标记为回收的对象

**清除：**

遍历堆中所有的对象，将标记的对象全部清除。然后清除掉标记（在之前被标记的那些对象）

**缺点：**

- 1.标记和清除都需要遍历，影响性能，效率不高
- 2.会产生大量的不连续的内存碎片，这样的话如果有大对象被创建而没有合适的内存空间分配给它，那么就不得已触发下一次GC



## 复制算法



![image-20201218163655481](https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20201218163655481.png)



**收集算法是为解决标记-清除方法的效率问题**

大概意思是：先将内存按容量分成两块，然后每一次GC 要清除的对象就复制到另外一块，然后把那一块清除掉



优点：

- 1.不会像标记-清除算法那样出现 空间的问题，就是大对象放不下

缺点：

- 1.内存变下了，空间浪费了，空间利用率太低了





![image-20201219100815667](https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20201219100815667.png)





**这是一种用于新生代的GC算法，JVM把堆中分为  新， 老，元， **

**然后新 又按照 8:1:1分 分别是伊甸园  两个幸存者  **

**这是为了解决空间利用率的问题，**

**每一次把使用 伊甸 和其中一块幸存A，然后在回收后 把 伊甸 和幸存A 存活的对象 一次复制到  幸存B上，然后清除掉  伊甸 和幸存A 的空间，**

这样的问题是 ，如果回收后存活的对象超过了 10 % ，这样就需要老年代进行分配担保

分配担保：如果为对象分配内存时  伊甸和 幸存A  无法存放下来，会触发  MinorGC（新生代GC） 进行垃圾收集。但如果 Minor GC 过后依然有超过 10% 的对象存活，这样存活的大对象直接通过分配担保机制进入老年代，



## 标记-整理算法



![image-20201218163454517](https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20201218163454517.png)



**标记：**

遍历GC ROOT  然后将存活的对象标记

**整理**：

移动所有存活的对象，并且按照内存地址依次排列，然后把最后一个存活的对象后面全部回收，

**这是老年代的垃圾收集算法，因为老年代 的对象一般寿命比较长，而老年代的对象大部分是在垃圾回收中存活的，而如果像复制算法那样，有太多的对象需要复制过去了。**



## 分代收集算法



> 现在主流的的虚拟机采用的GC算法

根据对象存活的周期不同 把 内存分 新 老，JDK8 之前 还有永久代，换成了 元空间

![image-20201219103643086](https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20201219103643086.png)



### 基本概念



- 1.Minor GC =  young GC = 发生在新生代的GC，比较频繁，速度比较快
- 2.major GC = full GC = 一般发生在老年代 方法区 的GC ，这个堆都要GC，所以叫 full GC
- 3.full GC 速度比  minor GC 慢很多
- 4.大对象直接进入 老年代



### 新

大多数对象被新创建好 以后放在这里，但是大部分对象马上在GC ROOT中 不可达，因此这些新对象可能在这里创建就在这里 清除了，这里的GC 我们叫  minor gc

然后一下我们可以设置GC的次数为多少次以后，伊甸区+幸存的对象放被放入 老年代（因为这个对象已经经过了这么多次GC 还活着，熬过了这么多次GC）



一般默认是 新生代： 老年代 是 1：8 来设置 堆中的 新生代  和 老年代 中的 相当大小

默认是 1：8，我们自己可以设置新老相对大小，这样 新是 可以跟着 堆动态扩展

```xml
-XX:NewSize=64m -XX:MaxNewSize=1024m -XX:NewRatio=8
```



### 老

对象没有变的不可达，而且经过了一定的次数从新生代中存活下来，就会被拷贝到这里，

而且大对象也会直接到这里，因此这里的空间也要足够大，full GC 并 minor GC 少

对象从 full GC 清除 我们叫  **full GC**



### 元

元空间是在JDK8 后出现的，元空间换掉了 之前的永久代，

大概原因是因为 两个JVM要合并，然后一个有永代，一个没有，和 这里的不好控制，出现内存泄漏的问题

元空间是  JVM内存外的 本地内存中， 这里和 堆不相连，



###  小结

对于  新生代  采用 复制算法，因为每一次GC经常有对象创建  和清除

对于  老年代  采用  标记-清除  标记-整理  ，因为对象的存活 比较高，并且没有其他看见来担保他



## JDK 8 内存模型（图来自网络）



<img src="http://dufyun.gitee.io/images_bed/images/techy/JVM03-03-6.png" style="zoom: 50%;" />

<img src="http://dufyun.gitee.io/images_bed/images/techy/JVM03-03-5.png" style="zoom:50%;" />