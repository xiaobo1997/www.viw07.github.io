

[TOC]

# 内存溢出



> 内存溢出： 就是 某一个对象应该被回收 但是因为GCRoot的存在 而没有被回收，



## OOM异常



### 堆内存异常

> 我们只要不断地创建对象，并且保证GCRoots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常

解决思路是通过工具对dump出来的堆快照进行分析，如何分析是内存泄漏还是内存溢出

 主要是这些设置

```java
/**
    VM Args:
    //这两个参数保证了堆中的可分配内存固定为20M
    -Xms20m
    -Xmx20m  
   
    -XX:+HeapDumpOnOutOfMemoryError 
    //文件生成的位置，作则生成在桌面的一个目录
    -XX:HeapDumpPath=/Users/xxx/Desktop/dump/ 
 */
```

**如果是内存泄漏的话**，还需要去具体分析 泄漏对象 到GCRoot对象引用链，找到泄漏对象是与哪些GCROOT 相关联 然后导致连接收集器无法收集，然后定位对象的创建位置，就可以分析出大概的代码位置



**如果不是内存泄漏**，换句话说就是内存中的对象确实都是必须存活的，那就应当检查Java虚拟机的堆参数（-Xmx与-Xms）设置，与机器的内存对比，看看是否还有向上调整的空间。再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。



### 栈内存异常

> 这个相当于在Java栈中 一个顶栈需要的内存空间 超过了  java顶帐 所提供的最大值，放不下了，就会抛出这个异常  
>
> 其实还可以这样说， 一个线程请求的栈深度 超过了 虚拟机所能提供的最大栈深度，
>
> 如果虚拟机是允许扩展的，而扩展以后的栈不能等待 所应该给他分配的内存大小，会抛OutOfMemoryError



**HotSpot是不允许虚拟机栈的动态扩展**



可以提供改变 虚拟机栈的大小参数-Xss  人为的调整大小



如果要复现这个 问题  需要你

- 1.定义大量的局部变量，增加方法栈中 的本地变量表的长度
- 2.减少 虚拟机栈的大小



如果多线程的情况下，不能减少线程的大小，那么可以减少堆大小，减少栈容量



### 方法区和运行时常量池溢出



> 方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，要达成的条件是比较苛刻的。在经常运行时生成大量动态类的应用场景里，就应该特别关注这些类的回收状况。



要复现这个问题 可以所以CGLib 来操作字节码文件生成加载大量的的动态类



在JDK8 元空间代替了永久代

元空间的设置参数



```
-XX：MaxMetaspaceSize：设置元空间最大值，默认是-1，即不限制，
或者说只受限于本地内存大小

-XX：MetaspaceSize：
指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，
同时收集器会对该值进行调整：如果释放了大量的空间，就适当降低该值；
如果释放了很少的空间，那么在不超过-XX：MaxMetaspaceSize（如果设置了的话）
的情况下提高这个值

-XX：MinMetaspaceFreeRatio：作用是在垃圾收集之后控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率
```



### 直接内存溢出

> 当你发现 分析dump文件 很小  基本明显看得到没有异常， 只是出现了OOM， 那么可能就是 直接内存溢出了，
>
> 直接内存是 虚拟机外的内存空间，是本地方法的内存，可以考虑是不是你 代码NIO操作的问题导致



## 导出OOM文件



### 方法1.

- 使用  `jps [-l]` 查看进程pid
- 使用 `top ` 看系统运行的资源情况
- 使用 `jstack [-l] pid > xxx.log` 导出 堆dump 







## 分析OOM文件





# 内存泄漏



> 内存泄漏：堆中有太多的不可回收的对象，导致无法创建新对象

要满足内存泄漏的对象需要满足下面两个条件

- 1，这些对象是GCROOT可达的
- 2，这些对象是无用的，也就是说对象在以后程序中都不会再使用了

满足上面两个推荐  GC就不会回收他们了，那么问题就来了，他们占内存啊



用什么工具可以查出来内存泄漏

- **MemoryAnalyzer**：一个功能丰富的 JAVA 堆转储文件分析工具，可以帮助你发现内存漏洞和减少内存消耗
- **EclipseMAT**：是一款开源的JAVA内存分析软件，查找内存泄漏，能容易找到大块内存并验证谁在一直占用它，它是基于Eclipse RCP(Rich Client Platform)，可以下载RCP的独立版本或者Eclipse的插件
- **JProbe**：分析Java的内存泄漏。