


# 1.JVM模型和内存结构分区



## JMM内存区域



![image-20201122234131321](https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20201122234131321.png)



### 线程私有



#### 程序计数器

> 定义：

程序计数器作用相当于是当前线程所执行的字节码的行号指示器。每一个线程都有自己的程序计数器。

> 作用：

主要是实现代码流程的控制，比如让字节码解释器改变程序计数器来有序的读取命令

还有就是在多线程的情况下，时间片切换时 程序计数器就是保存当前线程执行到这里了，下一次切换回来的时侯就知道执行到哪里了。相当于一个标记的功能

> 特性：

首先他是线程私有的。

其次他的生命周期和线程保存一致，

并且他不会出现OOM，也是唯一一个不会OOM的内存区域

执行native方法时，计数器为未定义

#### Java虚拟机栈

<img src="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20201216014346637.png" alt="image-20201216014346637" style="zoom:50%;" />

> 是什么

java虚拟机栈也称之为java栈，他主要是来描述java方法运行过程的内存模型。

虚拟机会为每一个要执行的方法创建一块叫 栈帧 的区域，这里面保存着方法运行时的一些信息，比如， 局部变量，操作数栈，方法出口的信息，常量池的引用等 

每一个方法从执行到结束，就相当于一次入栈和出栈的过程

<img src="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20201216014500190.png" alt="image-20201216014500190" style="zoom:50%;" />

**栈顶是当前正在执行的栈帧，而每一个栈帧又相当于一个正在执行的方法，那么程序计数器也是指向这里的地址。**



> 特性：

java虚拟机栈是线程私有的

在这里不需要考虑变量同步的问题，因为这里的数据不是线程共享的，也没有缓存一致性的问题。

我们可以手动设置虚拟机参数来 每一个线程的java栈的大小，如 `java -Xss2M HackTheJava`，如果是在运行过程中，那么大小就不会改变了。所以需要提前设置

在这里会出现两个异常：

- 1.StackOverFlowError ：若 Java 虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度时，抛出 StackOverFlowError 异常。而此时可能内存空间还有。
- 2.OutOfMemoryError ：若允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展时，抛出 OutOfMemoryError 异常。



#### 本地方法栈



> 是什么

我们知道，native方法是用c写的，本地方法栈是为本地服务的。

本地方法栈是为JVM为了运行本地方法而准备的空间

> 特点：

方法执行结束后，相应的栈帧也会出栈，并释放内存空间。也会抛出 StackOverFlowError 和 OutOfMemoryError 异常。

在HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一。

###  线程共享



#### 堆

> 是什么

堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中。这里也是GC的主要区域。

> 特点

这里线程共享。整个虚拟机只有一个堆，所有线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个。

创建时机：在虚拟机启动时创建

现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同的区域存放不同生命周期的对象采取不同的垃圾回收算法。堆可以分为：新生代(Eden 区 From Survior To Survivor)、老年代。

堆是可以扩展大小的。如果扩展失败就会抛出OutOfMemoryError (当线程请求分配内存，但堆已满，且内存已无法再扩展时)



可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。

```ini
java -Xms1M -Xmx2M HackTheJava
```

![image-20201216020750063](https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20201216020750063.png)

- 1新生代：有大量的短对象，新生代还被细分了三个
- 2.老年代：在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。 而且大对象直接进入老年代
- 3.永久代（方法区）：





#### 方法区



> 是什么

方法区主要是存 已经被加载的类信息（包含：类版本、字段、方法、接口），常量，静态变量，即时编译器编译后的代码

> 特点

共享数据。

整个虚拟机中只有一个方法区。

方法区中的信息一般需要长期存在，把方法区称为“永久代”。

和Java堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出OutOfMemoryError异常。

对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。

HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间(永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中)，它位于本地内存中，而不是虚拟机内存中。



#### 运行时常量池

方法区中存放：类信息、常量、静态变量、即时编译器编译后的代码。常量就存放在运行时常量池中。

当类被 Java 虚拟机加载后， .class 文件中的常量就存放在方法区的运行时常量池中。除了在编译期生成的常量， 而且在运行期间，可以向常量池中添加新的常量。如 String 类的 intern() 方法就能在运行期间向常量池中添加字符串常量。



### 直接内存

> 是什么

**直接内存是除 Java 虚拟机之外的内存，直接内存**不属于虚拟机运行时数据区的一部分，也不是`Java`虚拟机规范中定义的内存区域。 `Java NIO`允许`Java`程序直接访问**直接内存**，通常**直接内存**的速度会优于**Java堆内存**。因此，对于读写频繁、性能要求高的场景，可以考虑使用直接内存。



可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。



> 特别

直接内存的大小不受 Java 虚拟机控制，但既然是内存，当内存不足时就会抛出 OutOfMemoryError 异常。



> 比较
>
> 直接内存与堆内存比较



- 直接内存申请空间耗费更高的性能（更重）
- 直接内存读取 IO 的性能要优于普通的堆内存。
- 直接内存作用链： 本地 IO -> 直接内存 -> 本地 IO
- 堆内存作用链：本地 IO -> 直接内存 -> 非直接内存 -> 直接内存 -> 本地 IO

一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。

# 2.内存交互操作



## 工作内存和主内存之间的交互操作

### 概念



> 工作内存和主内存之间的交互数据操作



> 线程不能直接操作主内存中的变量，必须先拷贝一份到自己的工作内存中



> 各个线程是只能访问自己的私有的工作内存，而在java世界中，线程通信又是通过共享内存这个模式，这里就涉及到多个线程通信去拷贝主内存中的值到自己的工作内存中。也就是会涉及到线程工作内存一致性的问题，在并发中有说到。



> JMM其实是一个抽象的概念，下图是JMM的一个抽象概念图

![image-20201215230806973](https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20201215230806973.png)

### 动作



> JMM定义了8种操作来完成工作内存和主内存变量的传递(从主内存中读取到工作内存中，然后同步回主内存)，虚拟机定义每一个操作都是原子操作,这8个操作定义了主内和工作内存交互的协议。

> 不同线程之间交互数据主要的步骤是



- 1.lock（锁定）-这一步是作用在主内存中，把变量先标记为线程独占
- 2.unlock(解锁)-作用主内存，把变量释放出来
- 3.read(读取)--作用主内存，把变量从主内存中传输到自己的工作内存中，主要是为了后面的load使用
- 4.load(加载)--在工作内存中进行，把读取而来的变量拷贝到工作内存副本中
- 5.use--使用--作用工作内存中，把工作内存中的变量传递给执行引擎,表示要使用这个变量
- 6.assign--赋值--在工作内存中，把从执行引擎中接收到的值赋给变量，需要虚拟机的赋值字节码命令
- 7.store---存储--在工作内存中，把工作内存中的变量值同步回主内存，主要是为了后一步的写入
- 8.write--写入--在主内存中，把store存储的值写回到主内存中的变量中



**注意：**

如果需要把主内存中的变量读取到工作内存中，需要执行 read + load ，并且是按s顺序执行，不允许单独出现

如果需要把工作内存中的变量写回主内存中，需要按照顺序执行，store-+ write   不允许单独出现

如果在工作内存中改变了变量（出现了新的assign赋值操作），必须写回到主内存中，否则不允许

变量只能在主内存中 产生，

lock多少次，unlock就要多少次

一个变量同时只能被一个线程执行lock操作，并且执行了lock操作，将会清空线程工作内存中的值

