

[TOC]





# 简单



## [剑指 Offer 17. 打印从1到最大的n位数](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)--Math.pow()+for循环

难度简单86

输入数字 `n`，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。

**示例 1:**

```
输入: n = 1
输出: [1,2,3,4,5,6,7,8,9]
```

 

说明：

- 用返回一个整数列表来代替打印
- n 为正整数

```java
class Solution {
    public int[] printNumbers(int n) {
        /**
         1. 1-9 1-99 1-999  1- ((10^n)-1)次数 
         2. 循环list.add(n);
         3. list转arr
        */
       	// int value = 1;
        //int[] res = new int[];
        int end = (int)Math.pow(10, n) - 1; // 10^n  pow(a,b) a^b
        int[] res = new int[end];
        for(int i = 0; i < end; i++)
            res[i] = i + 1;
        return res;   
    }
}
```



## [剑指 Offer 25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)-双指针判断大小+while

难度简单87

输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。

**示例1：**

```
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```

**限制：**

```
0 <= 链表长度 <= 1000
```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        /**
        1. 考虑双指针a, b 分别开始
        2. 初始化一个辅助节点node 作为辅助头节点
        3. a>b 把b=node.next  a<b  a = node.next
        4. 两种情况， a空把剩下的的b全放入a.next后 b空相反
        5. 返回node.next
        */
       ListNode temp  = new ListNode(0);
       ListNode cur = temp;
       while(l1!=null && l2!=null){
           // l1的值<l2的值
           if(l1.val<l2.val){
            cur.next = l1;
            l1 = l1.next;
           }else{
            // l1>l2 || l1=l2
            cur.next = l2;
            l2 = l2.next;
           }
            cur = cur.next; // 移动cur指针 往前走
       }
       //合并最后一个节点 a 123  b 123 此时a 还有3 b空 c 11223 把a中的3放在最后面
       cur.next = l1!=null?l1:l2;
       return temp.next;
    }
}
```

![img](https://pic.leetcode-cn.com/915d84061f5374542070720fb667772ed45d80eeb7a25d6ac9b6baf519a547a9-Picture6.png)

## [剑指 Offer 57 - II. 和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)--滑动窗口l+r+小了r+++大了l--

难度简单219

输入一个正整数 `target` ，输出所有和为 `target` 的连续正整数序列（至少含有两个数）。

序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

 

**示例 1：**

```
输入：target = 9
输出：[[2,3,4],[4,5]]
```

**示例 2：**

```
输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]
```

 

**限制：**

- `1 <= target <= 10^5`

```java
class Solution {
    public int[][] findContinuousSequence(int target) {
        /**
        1. >=3 才有  从 1-（targer/2)+1 中找，超过就跳出
        2. 123456789  123=6<9 1234=10>9 234=9  34<9 345<9 45=9 
        3. 一开始先维护 三个大小的区间 
        */
        int a=1,b=2,s=3;
        List<int[]> res  = new ArrayList<>();
        while(a<b){
            if(s==target){
                int[] arr = new int[b-a+1];
                for(int k=a;k<=b;k++){
                    arr[k-a] = k;
                }
                res.add(arr);
            }
            //2.3>target  说明现在的a+b大了，那就s - a 试试，然后 a右移 也就是 +1
            if(s>=target){
                s-=a;
                a++;
            }
            // 3. 3<target 说明现在的a+b小了，那就 
            if(s<target){
                b++;
                s+=b;
            }
        }
        return res.toArray(new int[0][]);
    }
}
```



## [剑指 Offer 57. 和为s的两个数字](https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/)--前后指针+判断

难度简单82收藏分享切换为英文接收动态反馈

输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。

 

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[2,7] 或者 [7,2]
```

**示例 2：**

```
输入：nums = [10,26,30,31,47,60], target = 40
输出：[10,30] 或者 [30,10]
```

 

**限制：**

- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^6`

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        // 1.双指针 一个前一个后 小了就左走，大了向右走
        int start = 0,end=nums.length-1;
        while(start<end){
            int s = nums[start]+nums[end];
            if(s<target) start++;
            else if(s>target) end--;
            else {
            return new int[]{nums[start],nums[end]};
        }
        }
        return new int[0];
    }
}
```



## [剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)-约瑟夫环+固定公式(p+m)%i

难度简单311收藏分享切换为英文接收动态反馈

0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

 

**示例 1：**

```
输入: n = 5, m = 3
输出: 3
```

**示例 2：**

```
输入: n = 10, m = 17
输出: 2
```

==【https://blog.csdn.net/u011500062/article/details/72855826】==

约瑟夫环，公式推出来的，大学白学了，完全看不懂在讲什么，流下了粘贴复制的眼泪

```java
class Solution {
    public int lastRemaining(int n, int m) {
        //  0 1 2 3 4  m = 3    第一次删除2 第二次删除0  第三次删除4  第四次删除1
        // x = 1,1,0,3
        // int x = 0;
        // for(int i =2;i<=n;i++){
        //     x = (x+m)%i;
        // }
        // return x;
        int p=0;
	for(int i=2;i<=n;i++)
	{
		p=(p+m)%i;  // 1,1,0,3
	}
	// return p+1;
    return p;
    }
}
```

## [剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)--快慢指针i j +  i先走为奇和j换  再j++

难度简单93收藏分享切换为英文接收动态反馈

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

 

**示例：**

```
输入：nums = [1,2,3,4]
输出：[1,3,2,4] 
注：[3,1,2,4] 也是正确的答案之一。
```

 

**提示：**

1. `0 <= nums.length <= 50000`
2. `1 <= nums[i] <= 10000`

```java
class Solution {
    public int[] exchange(int[] nums) {
        /**
        可以快慢指针，双指针
        1.创建一个一样size的数组
        2.两个指针一个从前一个从后遍历
        3.双数 从后面开始放，单数在前面开始放
        4.指针碰撞 就放中间
        
        下面是快慢指针
        */
        int len=nums.length;
        if(len==1) return nums;
        int j=0;
        for(int i=0;i<len;i++){//i is on the right,j is on the left 
            if((nums[i]%2!=0)){ // 寻找奇数 交换位置
               int temp=nums[i];
                nums[i]=nums[j];
                nums[j]=temp;
                j++;
            }       
        }
        return nums;
    }
}
```



## [剑指 Offer 50. 第一个只出现一次的字符](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)-- 转字符数组+map(c,boolean)+两次foreach遍历return map ture

难度简单80收藏分享切换为英文接收动态反馈

在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。

**示例:**

```
s = "abaccdeff"
返回 "b"

s = "" 
返回 " "
```



```java
class Solution {
    public char firstUniqChar(String s) {
      
        /**
        1.遍历字符串，放入map中，key是 字符串，value是出现的次数
        2.维护顺序，
        3.取出第一个为1的,
        */
        /**
        或者 把字符存map，中，key是每一个字符，value 是 如果char存在就false 不存在就true
        */
        Map<Character,Boolean> map = new HashMap<>();
        char[] ch = s.toCharArray();
        for(char c : ch){
            map.put(c,!map.containsKey(c));
        }
        for(char c : ch){
            if(map.get(c)) return c;
        }
        return ' ';
    }
}
```

## [剑指 Offer 42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)--两次Math.max(a,a+1) a已知前n项和 再和前n+1项和 做比较  +for循环遍历

难度简单221收藏分享切换为英文接收动态反馈

输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

 

**示例1:**

```
输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```



```java
class Solution {
    public int maxSubArray(int[] nums) {
        /**
        -2 1 -3 4
        1. -2
        2. -2  < -2 + 1 = 1
        3. 1 > -2+1+(-3) = 1
        4. 1 > -2+1+(-3)+4 = 1 最大的  -2 1
        */
       int res = nums[0];
       for(int i = 1;i<nums.length;i++){
           nums[i] += Math.max(nums[i-1],0);
            res = Math.max(res,nums[i]);
       }
       return res;
    }
}
```



## [剑指 Offer 11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)--二分查找+mid>r在后半部分 mid<r在 前半部分 

难度简单262收藏分享切换为英文接收动态反馈

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 `[3,4,5,1,2]` 为 `[1,2,3,4,5]` 的一个旋转，该数组的最小值为1。 

**示例 1：**

```
输入：[3,4,5,1,2]
输出：1
```

**示例 2：**

```
输入：[2,2,2,0,1]
输出：0
```



```java
class Solution {
    public int minArray(int[] numbers) {
        /**
        遍历一边数组，或者二分查找，
        */
        int left = 0,rigth= numbers.length -1;
        while(left<rigth){
            int mid = left+(rigth-left)/2;
            if(numbers[mid]>numbers[rigth]) left = mid+1;
            else if (numbers[mid]<numbers[rigth]) rigth= mid;
            else  rigth -- ;
        }
        return numbers[left];
    }
}

```



## [剑指 Offer 61. 扑克牌中的顺子](https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)--先排序+遍历有几个王+极差小于5

难度简单106收藏分享切换为英文接收动态反馈

从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。

 

**示例 1:**

```
输入: [1,2,3,4,5]
输出: True
```

 

**示例 2:**

```
输入: [0,0,1,2,5]
输出: True
```



```java


class Solution {
    public boolean isStraight(int[] nums) {
        /**
        排序+遍历，
        0 0 1 3 4  => 1 2 3 4 5 
        4-nums[2] = 3 <5 
        */
        int joker = 0;
        Arrays.sort(nums);
        for(int i = 0;i<4;i++){
               if(nums[i]==0) joker ++;
               else if(nums[i]==nums[i+1]) return false; 
        }
        return nums[4]-nums[joker]<5;
    }
}
```

## [剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)-dfs+先取一个左或右防止引用覆盖+左右交换位置

难度简单111收藏分享切换为英文接收动态反馈

请完成一个函数，输入一个二叉树，该函数输出它的镜像。

例如输入：

```
  	4
   /   \
  2     7
 / \   / \
1   3 6   9
```


镜像输出：

```
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

 

**示例 1：**

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```



```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode mirrorTree(TreeNode root) {
            if(root==null) return null;
            TreeNode temp = root.left;
            root.left =  mirrorTree(root.right);
            root.right = mirrorTree(temp);
            return root;
    }
}
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode mirrorTree(TreeNode root) {
        /**
        辅助栈 这个更好理解
        */
        if(root == null)  return null;
        Stack<TreeNode> stack = new Stack<>(){{ add(root); }};
        while(!stack.isEmpty()){
            TreeNode node = stack.pop();
            if(node.left!=null) stack.add(node.left);
            if(node.right!=null) stack.add(node.right);
            TreeNode temp = node.left;
            node.left = node.right;
            node.right = temp; 
        }
        return root;
    }
}
```

## [剑指 Offer 55 - I. 二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)--递归+退出条件+Math.max(对left递归,对right递归) 然后 最后一个加1

难度简单98收藏分享切换为英文接收动态反馈

输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。

例如：

给定二叉树 `[3,9,20,null,null,15,7]`，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
      // DFS
         if(root == null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        /**
        BFS 通过队列实现，从根节点开始，每一层的所有节点放入队列queue中，
        然后如果当前正在遍历的节点 如果有左右子树，就放入队列中 ，然后层次+1；
        继续遍历下一层，在上一步已经把节点放入了，直到队列为空，说明
        当前遍历的节点没有子节点了
        */
        if(null == root ) return 0;
        List<TreeNode> queue  = new LinkedList<>();
        List<TreeNode> tmp = null;
        queue.add(root);
        int res = 0;
        while(!queue.isEmpty()){
            tmp = new LinkedList<>();
            for(TreeNode node : queue){
                if(node.left != null) tmp.add(node.left);
                if(node.right != null) tmp.add(node.right);
            }
            queue = tmp;
            res++;
        }
        return res;

    }
}
```



## [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)-中序遍历是递增+放到list中+取出倒数第k个

难度简单132收藏分享切换为英文接收动态反馈

给定一棵二叉搜索树，请找出其中第k大的节点。

 

**示例 1:**

```
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4
```

**示例 2:**

```
输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 4
```



```java


/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int kthLargest(TreeNode root, int k) {
        /**
        中序遍历每一个节点 存入数组中，排序 取出来第k个元素
        倒中序 （二叉搜索树的一个特性：通过中序遍历所得到的序列，就是有序的。）
        */
        List<Integer> list = new ArrayList<>();
        dfs(root,list);
        return list.get(list.size()-k);
    }
  // 中序遍历
    void dfs(TreeNode root,List list){
        if(root == null) return;
        dfs(root.left,list);
        list.add(root.val);
        dfs(root.right,list);
    }
}
```



```java


/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int res = 0,count = 0;
    public int kthLargest(TreeNode root, int k) {
        /**
        方法1：遍历每一个节点 存入数组中，排序 取出来第k个元素
        方法2：倒中序，二叉搜索树是中序是有序的,二叉搜索树的中序遍历为 递增序列
         二叉搜索树 满足 左 < 中 < 右
        */
        dfs(root,k);
        return res;
    }
    void dfs(TreeNode root,int k){
        if(root.right!=null) dfs(root.right,k);
        if(k == ++count ) {
            res = root.val;
            return;
        }
        if(root.left!=null) dfs(root.left,k);
        
    }
}
```





## [剑指 Offer 68 - II. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)--dfs递归

难度简单212收藏分享切换为英文接收动态反馈

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png)

 

**示例 1:**

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
```

**示例 2:**

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
```



```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 解1   和解2是一样的，写法不一样而已
         if(root==null || root == p || root ==q ) return  root;
         TreeNode left = lowestCommonAncestor(root.left,p,q);
         TreeNode right =lowestCommonAncestor(root.right,p,q);
         if(left == null && right == null) return null;
         if(left==null) return right;
         if(right==null) return left;
         return root;
       // 解2
        if(root == null) return null;
        if(root==p || root ==q ) return root;
        TreeNode left = lowestCommonAncestor(root.left,p,q);
        TreeNode right =lowestCommonAncestor(root.right,p,q);
        if(left == null ) return right;
        else if(right == null) return left ;
        else return root;

    }
}
```



## [剑指 Offer 68 - I. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)--while+要么全在左要么全在右

难度简单108收藏分享切换为英文接收动态反馈

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png)

 

**示例 1:**

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
```

**示例 2:**

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
```

配上大佬的这一张图，比较好理解，

==【大佬的思路真的是清晰，太难了树类型的题，做不出来只能抄了，为了面试 大佬leetcode地址https://leetcode-cn.com/u/jyd/】==



<img src="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20210320084755414.png" alt="image-20210320084755414" style="zoom:50%;" />



```java


/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        /**
        要么全在左(自己或者公共)。要么全在右(自己或者公共)。或者 一边一个(根节点)，
        若 root.val < p.valroot.val<p.val ，则 pp 在 rootroot 右子树 中；
        若 root.val > p.valroot.val>p.val ，则 pp 在 rootroot 左子树 中；
        若 root.val = p.valroot.val=p.val ，则 pp 和 rootroot 指向 同一节点 。
        */
        while(root!=null){
            if(root.val>q.val && root.val >p.val) root = root.left;
            else if(root.val <q.val && root.val < p.val) root = root.right;
            else break;
        }
        return root;
    }
}

```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        /**
        要么全在左(自己或者公共)。要么全在右(自己或者公共)。或者 一边一个(根节点)，
        若 root.val < p.valroot.val<p.val ，则 pp 在 rootroot 右子树 中；
        若 root.val > p.valroot.val>p.val ，则 pp 在 rootroot 左子树 中；
        若 root.val = p.valroot.val=p.val ，则 pp 和 rootroot 指向 同一节点 。
      
        */
        // 递归
            if(root.val>q.val && root.val >p.val) return lowestCommonAncestor(root.left,p,q);
            else if(root.val <q.val && root.val < p.val)  return lowestCommonAncestor(root.right,p,q);
        return root;
    }
}
```



## [剑指 Offer 32 - II. 从上到下打印二叉树 II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)-一个结果队列一个该层队列+每一层从左到右先把节点val放入临时队列 再把每一个的左右节点放该层队列 直到该层队列全部poll完

难度简单92收藏分享切换为英文接收动态反馈

从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。

 

例如:
给定二叉树: `[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回其层次遍历结果：

```
[
  [3],
  [9,20],
  [15,7]
]
```

==【大佬的思路真的是清晰，太难了树类型的题，做不出来只能抄了，为了面试 大佬leetcode地址https://leetcode-cn.com/u/jyd/】==

<img src="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20210320091720099.png" alt="image-20210320091720099" style="zoom:50%;" />

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        /**
        用队列来实现，遍历队列中的每一个元素，看每一个元素是否都有左右节点，
        有就都放入队列中，下一次遍历用，然后把当前队列中的每一个元素的val放入结果
        队列中
        然后队列中的每一个元素就是当前层的从左到右的所有节点
        因为是一个一个遍历的，只需要做的是 把队列中正在遍历的节点的值放入辅助list  tmp中，
        然后把正在遍历的节点的两个左右子节点，放入队列中，给下一次遍历用，
        然后从队列中取的时侯，因为先进先出，取队首就可以了，
        
        */
        List<List<Integer>> resList = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        if(root!=null) queue.add(root);
        while(!queue.isEmpty()){
            List<Integer> tmp = new ArrayList<>();
            for(int i = queue.size();i>0;i--){
                TreeNode node =  queue.poll();
                tmp.add(node.val);
                if(node.left!=null) queue.add(node.left);
                if(node.right!=null) queue.add(node.right);
            }
            resList.add(tmp);
        }
        return resList;
    }
}
```





## [剑指 Offer 55 - II. 平衡二叉树(深度不超过1)](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)-offer55最大深度+递归右+递归左

难度简单124收藏分享切换为英文接收动态反馈

输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

 

**示例 1:**

给定二叉树 `[3,9,20,null,null,15,7]`

```
    3
   / \
  9  20
    /  \
   15   7
```

返回 `true` 。

**示例 2:**

给定二叉树 `[1,2,2,3,3,null,null,4,4]`

```
       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
```

返回 `false` 。



```java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isBalanced(TreeNode root) {
        /**
        先计算此树的深度，和之前[剑指 Offer 55 - I. 二叉树的深度]一样
        然后比较每一个节点的左右差
        */

        //计算每一个节点的左右节点的深度
        if(root==null) return true;
        return Math.abs(maxDepth(root.left)-maxDepth(root.right))<=1 && isBalanced(root.left)&& isBalanced(root.right);
 }
        // 计算节点深度
       int maxDepth(TreeNode root){
            if(root==null) return 0;
            return Math.max(maxDepth(root.left),maxDepth(root.right))+1;
        } 
}

```



##  [剑指 Offer 28. 对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)--递归+  (l.l,r.r) && (l.r , r.l)

难度简单146收藏分享切换为英文接收动态反馈

请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

```
    1
   / \
  2   2
   \   \
   3    3
```

 

**示例 1：**

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

**示例 2：**

```
输入：root = [1,2,2,null,3,null,3]
输出：false
```



```java

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        /**
        递归遍历，也可以 BFS，虽然更加麻烦一点，
        需要注意root == null的情况
        */
       return root==null?true:isSymmetric(root.left,root.right);
    }
    /** 递归
    		1
    	2   2
    3  3  3  3
    */
    boolean isSymmetric(TreeNode left,TreeNode right){
        if(null == left && null == right) return true;    
        if(null == left || null == right || left.val != right.val ) return false;
        // 如果是对称的 那么互换位置也是一样的
        return isSymmetric(left.left,right.right)&&isSymmetric(left.right,right.left);
    }
}

```





##  [剑指 Offer 65. 不用加减乘除做加法](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)--位运算

难度简单138收藏分享切换为英文接收动态反馈

写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。

 

**示例:**

```
输入: a = 1, b = 1
输出: 2
```

 

**提示：**

- `a`, `b` 均可能是负数或 0
- 结果不会溢出 32 位整数

```java
class Solution {
    public int add(int a, int b) {
        /**
        我首先想到也是位运算，二进制的加减乘除
        但是想不到具体的首先办法， &  |  ^  >>  <<
        1+1 =  1   ==>  1+1 = 01&01 << 1  = 01 << 1 =  10  进位是1
        剩下的就是处理负号
        */
        int res = a^b;
        int temp = (a&b)<<1;
        while(temp !=0){
            a=res;
            b=temp;
            res=a^b;
            temp= (a&b)<<1;
        }
        return res;
    }
    /**方法2
     public int add(int a, int b) {
        while(b!=0){
            int i = (a&b) << 1;
            a ^=b;  
            b  = i;
        }
        return a;
    }
    **/
}
```



##  [剑指 Offer 24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)--前后指针a1,a2+a2移动不把next指向a1



定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

 

示例:

输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL


限制：

0 <= 节点个数 <= 5000

**双指针：**

双指针然后经过大佬的图就更好理解点

```java
/**
1.首先需要两个指针 一个在前 一个在后，每次循环都向后走
2.还需要一个临时指针
3.用这三个指针实现翻转
4.相对于   1=》2=》3   cur现在是1， pre是null 临时指针是2
5.现在第一次翻转, 让2指向1，1指针null，明确是 null<=1=>2=>3
6.向左走一步
7.现在是 cur 是2 pre 是1  临时指针是3
8.实现翻转    null<=1<=2=>3
*/
public ListNode reverList(ListNode head){
  	// 申请两个指针 一个指向null 一个指向head
  	ListNode a1 = head;//在pre前面
  	ListNode a2  = null;
    while(null!=a1){
      	ListNode temp  = a1.next; //临时存放交换用
    	a1.next = a2; // cur的下一个节点指向pre 实现翻转
      	a2=a1;// pre向左走
      	a1 = temp; //cur向左走
    }
    //cur 为null 说明 pre已经是现第一个节点,返回pre
  	return a2;
}


// 方法2  前后指针 cur  pre  
 public ListNode reverseList(ListNode head) {
        ListNode cur = null,pre = head;
        while(pre!=null){
            ListNode temp = pre.next;
            pre.next = cur;
            cur = pre;
            pre = temp;
        }
        return cur;
    }
```

- 方法2的图

![方法2图](https://pic.leetcode-cn.com/9ce26a709147ad9ce6152d604efc1cc19a33dc5d467ed2aae5bc68463fdd2888.gif)

- 方法1的图

![img](https://pic.leetcode-cn.com/1c8927d9ff605502793d81ab344dbc17e16d6db2d8dd789045f56af432079519.gif)



## [剑指 Offer 06. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)--放入队列+i从前 走j从后走

难度简单91

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

 

**示例 1：**

```
输入：head = [1,3,2]
输出：[2,3,1]
```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public int[] reversePrint(ListNode head) {
 LinkedList<Integer> linkedList = new LinkedList<>();
        //把head放入栈中
        while (null!=head){
            linkedList.addLast(head.val);//尾插
            head  = head.next;//把下一个节点给当前节点
        }
        int[] arr = new int[linkedList.size()];
        for (int i = linkedList.size()-1,j=0; i >=0&&j<linkedList.size(); i--,j++) {
            arr[j] = linkedList.get(i);
        }
        return  arr;
    }
}
```





## 剑指 Offer 18. 删除链表的节点-while循环前后指针，相等就把后.next = 前.next

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

注意：此题对比原题有改动

示例 1:

输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
示例 2:

输入: head = [4,5,1,9], val = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.


说明：

题目保证链表中节点的值互不相同
若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
//双指针
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        // if(null== head.next&& head.val != target){
        //     return null;
        // }
        if(val == head.val && head.next !=null){
            return head.next;
        }
        ListNode pre = null;
        ListNode cur = head;
        while(cur.val != val){
            ListNode temp = cur.next;
            pre = cur;
            cur = temp;
        }
        pre.next = cur.next;
        return head;
    }
}
```



## [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)--前后指针保持一定距离，前指针为null停止 返回后指针



输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。

 

示例：

给定一个链表: 1->2->3->4->5, 和 k = 2.

返回链表 4->5.

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */

/**
1.用了额外的LinkedList来存储，占了额外的空间
2.遍历存入LinkedList中
3.通过 list.size()-k 取出倒数的节点
*/
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        List list  = new LinkedList<ListNode>();
        ListNode cur = head;
        while(cur!=null){
            list.add(cur);
            ListNode temp = cur.next;
            cur = temp;
        }
        return (ListNode)list.get(list.size()-k);
    }
}
```



```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */


/**
1.双指针，一个le 一个cur，le在后，cur在前，相隔k个距离
2.先让le走k个距离，这样le和cur就隔了k
3.le 和cur一起向后走，
4.le为null就返回，此时cur是新链表的头节点
*/
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        // le在后，cur在前  隔着k个单位距离
        ListNode le=head,cur=head;
        for(int i =0;i<k;i++){
            le = le.next;
        }
        while(le!=null){
            le=le.next;
            cur = cur.next;
        }
        return cur;
    }
}
```



## [剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)--双指针 +a走完走b b走完走a 总会遇见

输入两个链表，找出它们的第一个公共节点。

如下面的两个链表**：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

在节点 c1 开始相交。

 

**示例 1：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

 

**示例 2：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)

```
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

 

**示例 3：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)

```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。
```

 

**注意：**

- 如果两个链表没有交点，返回 `null`.
- 在返回结果后，两个链表仍须保持原有的结构。
- 可假定整个链表结构中没有循环。
- 程序尽量满足 O(*n*) 时间复杂度，且仅用 O(*1*) 内存。
- 本题与主站 160 题相同：https://leetcode-cn.com/problems/intersection-of-two-linked-lists/

```java
/**
1.主要是通过 a+b = b+a，
2.两个指针，a 走完 自己的走 链表b的， b走完自己的走 链表a的
3.如果他们有相交，他们就会相遇
*/
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    ListNode a = headA;
    ListNode b = headB;
    while(a!=b){
        //
        a = a==null?headB:a.next;
        b = b==null?headA:b.next;
    }
       return a;
    }
}
```





## [剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)--没看明白-原来是困难

难度简单177

给定一个数组 `nums` 和滑动窗口的大小 `k`，请找出所有滑动窗口里的最大值。

**示例:**

```
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if(k==0 || nums.length == 0 || null == nums) return nums;
        if(k==1) return nums;
        int[] resNums = new int[nums.length-(k-1)];
        Deque<Integer> deque = new LinkedList<>();
        int index = 0;
        //单调队列
        for(int i =0;i<nums.length;i++){
            //维持从大到小 需要删除 1 2  中的 1
            while(!deque.isEmpty() && nums[i]>=nums[deque.peekLast()]){
                deque.pollLast();  // 如果队列不为空 为了维持队列从左到右是从大到小，如果不满足就删队列这一个
            }
            // 添加末尾
            deque.addLast(i);
            //取出窗口中元素  如 1 2 3 4  窗口是123  下一个窗口是234  需要移除 1 保持窗口的大小
            if(deque.peekFirst() ==  (i-k)){ // 这里队列是下标，如 i=4  窗口k=3 而现在下标4已经在队列中了，窗口已经到 234了，需要删除1， 而i-k就是检查窗口的大小
                deque.pollFirst();
            }
            //如果形成了 K大小的窗口，直接取第一个，已经是窗口中最大的了
            if(i>=(k-1)){ // k是窗口大小，因为i是下标 从0开始， k需要-1
                resNums[index++] =  nums[deque.peekFirst()];
            }
        }
            return resNums;
    }
}
```



## [剑指 Offer 03. 数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

难度简单256

找出数组中重复的数字。


在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

**示例 1：**

```
输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 
```

 

**限制：**

```
2 <= n <= 100000
```

```java
/**
1.使用了额外的空间，
*/
class Solution {
    public int findRepeatNumber(int[] nums) {
        if (nums.length ==2 && nums[0] == nums[1]) {
            return nums[0];
        }
        List<Integer> collect = Arrays.stream(nums).boxed().collect(Collectors.toList());
        Collections.sort(collect);
        for (int i = 1; i < collect.size(); i++) {
            if ((collect.get(i-1) ^ collect.get(i)) == 0) return collect.get(i);
        }
        return -1;
    }
}

// 方法2
public int findRepeatNumber(int[] nums) {
        Set<Integer> res = new HashSet<>();
        for(int num : nums) {
            if(res.contains(num)) return num;
            res.add(num);
        }
        return -1;
    }
```



## [剑指 Offer 04. 二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)-两个for循环，第一层控制x，第二层控制y

难度中等209

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

 

**示例:**

现有矩阵 matrix 如下：

```
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
```

给定 target = `5`，返回 `true`。

给定 target = `20`，返回 `false`。

```java
/**
1.不优，需要改进
*/

class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {

        if(null==matrix || matrix.length == 0|| matrix[0].length == 0 ){
            return false;
        }
        int x = 0;
        int y = 0;
         x = matrix.length;
         y = matrix[0].length;
        if(x==0 && y==0) return false;
        for(int i=0;i<x;i++){   
            for(int j=0;j<y;j++){
                if((matrix[i][j]^target) == 0){
                    return true;
                }
            }
        }
        return false;
    }
}
```



## [剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)-map的value统计次数



统计一个数字在排序数组中出现的次数。

 

**示例 1:**

```
输入: nums = [5,7,7,8,8,10], target = 8
输出: 2
```

**示例 2:**

```
输入: nums = [5,7,7,8,8,10], target = 6
输出: 0
```

**限制：**

```
0 <= 数组长度 <= 50000
```



```java
/**
使用了额外的内存空间
1.如果修改的是 可以不用Map
2.因为是排序数组，所以我们只需要找到第一个target，
然后看他左边有几个和target一样的值
3.相当于二分法先查找
4.你会二分法就可以做的让面试官满意的
*/
class Solution {
    public int search(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        if(nums.length==0){
            return 0;
        }
       for(int i = 0;i<nums.length;i++){
            if(!map.containsKey(nums[i])){
                map.put(nums[i],1);
            }else {
                int temp = map.get(nums[i]);
                map.put(nums[i],temp+1);
            }
        }
        return map.get(target)==null?0:map.get(target);
    }
}
```



##  [剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)-遍历到n-1 不相等就返回

难度简单96

一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

 

**示例 1:**

```
输入: [0,1,3]
输出: 2
```

**示例 2:**

```
输入: [0,1,2,3,4,5,6,7,9]
输出: 8
```





```java
class Solution {
    public int missingNumber(int[] nums) {
            
            for(int i = 0; i<nums.length;i++ ){
                if(  i != nums[i]){
                    return i;
                }
            }
            return nums.length;
    }
}
```





##    [剑指 Offer 29. 顺时针打印矩阵](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)（不会做）

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

 

**示例 1：**

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

**示例 2：**

```
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```



## [剑指 Offer 39. 数组中出现次数超过一半的数字](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)-遍历+count=0就下一个数字，相同就count++,不同--

难度简单107

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

 

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

 

**示例 1:**

```
输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]
输出: 2
```



```java
/**
1. 和 169题相似
*/

/**
[2,2,1,1,2]
1.一个指针 分别从i=0开始；一个统计count 
2.如果下一个相同 count就+1 如果下一个不相同 count就-1 ，
3.这样就相互抵消了，最后只剩下一个出现次数最多的值
*/
class Solution {
    public int majorityElement(int[] nums) {
        int res = 0;
        int count = 0;
        for(int i:nums){
            if(count==0) res = i; 
            if(i == res ) {
            	count++;
            }else{
                count--;
            }
        }
        return res;
    }
}

```



## [剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)-LinkedList

难度简单171

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 `appendTail` 和 `deleteHead` ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，`deleteHead` 操作返回 -1 )

 

**示例 1：**

```
输入：
["CQueue","appendTail","deleteHead","deleteHead"]
[[],[3],[],[]]
输出：[null,null,3,-1]
```

**示例 2：**

```
输入：
["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]
[[],[],[5],[2],[],[]]
输出：[null,-1,null,null,5,2]
```



```java
class CQueue {
    LinkedList<Integer> a;
    LinkedList<Integer> b;

    public CQueue() {
        a = new LinkedList<>();
        b = new LinkedList<>();
    }
    
    public void appendTail(int value) {
        a.addLast(value);
    }
    
    public int deleteHead() {
        if(a.size()!=0) return a.pollFirst();
        return -1;
    }
}

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue obj = new CQueue();
 * obj.appendTail(value);
 * int param_2 = obj.deleteHead();
 */
```



## [剑指 Offer 30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)-两个Stack实现，一个正常存元素，一个只存比它上一个小的

难度简单83

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

 

**示例:**

```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.min();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.min();   --> 返回 -2.
```

```java
/**
这个大佬的好理解，维护两个栈
*/
class MinStack {
    Stack<Integer> a;
    Stack<Integer> b;

    /** initialize your data structure here. */
    public MinStack() {
        a = new Stack<>(); // 
        b = new Stack<>();// 放最小值
    }
    
    public void push(int x) {
        a.add(x);
        if(b.empty() || x<=b.peek()){
            b.add(x);
        }
    }
    
    public void pop() {
        if(a.pop().equals(b.peek())){
            b.pop();
        }
    }
    
    public int top() {
      return a.peek();
    }
    
    public int min() {
      // 直接栈顶的就是最小的
        return b.peek();
    }
}
```



## [剑指 Offer 58 - I. 翻转单词顺序](https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/)--分割字符数组-反向遍历

难度简单62

输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student. "，则输出"student. a am I"。

 

**示例 1：**

```
输入: "the sky is blue"
输出: "blue is sky the"
```

**示例 2：**

```
输入: "  hello world!  "
输出: "world! hello"
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
```

**示例 3：**

```
输入: "a good   example"
输出: "example good a"
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
```



```java
class Solution {
    public String reverseWords(String s) {
        s = s.trim();
        int index = s.length()-1,j = index;
        StringBuilder sb = new StringBuilder();
        while(index>=0){
            while(index >=0 && s.charAt(index)!=' ') index--;
            sb.append(s.substring(index+1,j+1)+" ");
            while(index>=0 && s.charAt(index)==' ') index--;
            j = index;
        }
        return sb.toString().trim();
    }
}
//方法2 
 public String reverseWords(String s) {
  	 String[] strs = s.trim.spilt("\\s+");
     StringBuilder res = new StringBuilder();
     for(int i = strs.length()-1;i>=0;i--){
        	if(strs[i]==" ") continue;
         res.append(strs[i]+" ");
     }
     return res;
 }
```





## [剑指 Offer 58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)--分割字符串

难度简单79

字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

 

**示例 1：**

```
输入: s = "abcdefg", k = 2
输出: "cdefgab"
```

**示例 2：**

```
输入: s = "lrloseumgh", k = 6
输出: "umghlrlose"
```



```java
class Solution {
    public String reverseLeftWords(String s, int n) {
    return s.substring(n)+s.substring(0,n);    
    }
}
```

```java
//方法2  
  class Solution {
    public String reverseLeftWords(String s, int n) {
        StringBuilder res = new StringBuilder();
        for(int i = n; i < s.length(); i++)
            res.append(s.charAt(i));
        for(int i = 0; i < n; i++)
            res.append(s.charAt(i));
        return res.toString();
    }
}

```



##   [剑指 Offer 15. 二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)-转二进制字符数组+遍历

难度简单83

请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。

 

**示例 1：**

```
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```

**示例 2：**

```
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
```

**示例 3：**

```
输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```

```java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        
        int temp = 0;
        if(Integer.toBinaryString(n).length()>32) return 0;
        for(char c :Integer.toBinaryString(n).toCharArray()){
            if(c == '1'){
                temp++;
            }
        }
        return temp;
    }
}
```



## [剑指 Offer 10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)-递归或者动态规划

难度简单100

写一个函数，输入 `n` ，求斐波那契（Fibonacci）数列的第 `n` 项（即 `F(N)`）。斐波那契数列的定义如下：

```
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
```

斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

 

**示例 1：**

```
输入：n = 2
输出：1
```

**示例 2：**

```
输入：n = 5
输出：5
```

```java
class Solution {
    public int fib(int n) {
        // 递归
        // 1+1+2+3+5+8
        // if(n<=1) return n;
        // return fib(n-2)+fib(n-1);
        // 动态规划
        if(n<=1) return n;
        int[] arr =new int[n+1];
        arr[0] = 0;arr[1] = 1;
        for(int i=2;i<=n;i++){
            arr[i]  = (arr[i-2]+arr[i-1])%1000000007;
        }
        return arr[n];
    }
}
```

## [剑指 Offer 10- II. 青蛙跳台阶问题](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)-动态规划，一个初始数组，dp[1],dp[2] 然后遍历 

难度简单114

一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 `n` 级的台阶总共有多少种跳法。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

**示例 1：**

```
输入：n = 2
输出：2
```

**示例 2：**

```
输入：n = 7
输出：21
```

**示例 3：**

```
输入：n = 0
输出：1
```



```java
class Solution {
    public int numWays(int n) {
        /**
        n = 1     1    
        n = 2    1+1
        n = 3    1+2 2+1  1+1+1
        */
        if(n<=1) return 1;
        int[] dp = new int[n+1];
        dp[1] = 1;
        dp[2] = 2;
        for(int i =3;i<=n;i++){
            dp[i] = dp[i-1] +dp[i-2];
            dp[i] =  dp[i]%1000000007;
        }
        return dp[n];
    }
}
```

