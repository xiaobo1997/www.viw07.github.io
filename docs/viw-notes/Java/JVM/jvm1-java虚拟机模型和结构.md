[TOC]



# 1.JVM模型



## JVM体系结构



### 结构图和作用

![image-20201216234404603](https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20201216234404603.png)

Class Files -> ClassLoader -> 运行时数据区 -> 执行引擎，本地库接口 -> 本地方法库





### JVM如何工作

JVM的主要组成：

- 类加载子系统 Class loader
- 运行时数据区 JVM 内存模型
- 执行引擎

主要是这三部分，

类别加载子系统的话，主要是动态加载类到内存中，

运行时数据区 主要是分配了内存空间，主要是五部分组成

执行引擎   主要是把运行时数据区的字节码文件执行，执行引擎读取然后执行



## HotSpot虚拟机



### 对象的创建过程

> 在程序的运行期间，会有很多对象无时无刻在被创建，



1.类加载检查

当虚拟机在.class 字节码文件中遇到了 new指令时，首先会去检查并尝试能否在常量池中定位对一个类的符号引用，然后经常这个类有没有被加载，解析，初始化，等 类加载过程，如果没有的话，就需要先去执行类加载过程。

然后就可以开始为新对象分配内存

2.为新对象分配内存

当到这一步时，说明类检查已经通过了，现在类在内存需要的大小在类加载的过程中就已经知道了，因为对象主要是在堆上活动的，创建了对象就需要在堆上给对象分配空间嘛，

在堆上分配空间主要是有两个方式

- 1.指针碰撞：这个主要是堆中的对象分配的足够整齐（是GC的复制或者是标记-整理的过程后留下来的结果），那么只需要把指针在空闲内存上移动和对象一样大小的范围就可以了
- 2.空闲列表：这个主要如果堆中内存分配的不整齐（也就是GC中的标记-清除算法留下了的结果 有碎片），那么虚拟机需要维护一个列表来告诉说哪里的内存是可以分配对象的，然后分配一块合适的空间给对象实例，



3.初始化

在这一步主要是对对象进行赋值，设置对象头信息，调用构造方法进行初始化默认值

虚拟机对对象进行设置，表面这个对象是哪个类的实例，如何才能知道 这个类的元数据 哈希，还要对象的GC分代信息，这些信息都主要是存储在对象头中，

到这里一个对象差不多算是创建出来了，但是还要让对象按照我们的意愿赋初始值，这样才算是我们想要的对象。

### 对象的内存分布

> 在多线程时提到过对象头

在HotSpot 虚拟机中， 对象的内存布局  主要是下面三个部分

- 1.对象头
- 2.实例数据
- 3.对齐填充

<img src="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20201217225955771.png" alt="image-20201217225955771" style="zoom:50%;" />





#### 对象头

在对象头中，主要是记录了对象在运行过程中的关键信息，头部嘛，

- 哈希码
- GC分代年龄
- 偏向锁的ID（在多线程锁优化中说到了这个）
- 线程持有的锁
- 偏向时间戳
- 锁的标志

![image-20201217231704040](https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20201217231704040.png)

在对象头中 还会有一个指针来说明这个对象是属于哪个类的，

如果是数组对象的话，在这里还会有数组的长度

#### 实例数据

在这里 主要是保存对象的全局变量，包括父类的全局变量，和本类的全局变量



#### 对齐填充

在这里主要是让对象的长度保持在8字节的整数倍

这是因为有些虚拟机要求的，相当于是占位符的作用，不够的补齐

### 对象的访问定位

所有的对象在存储空间都是在堆上分配的，但是对象的引用是堆栈上分配的，

对象实际上是在堆上的，但是引用地址是有区分的。

主要是下面两个

#### 1.句柄访问方式

![image-20201217231737151](https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20201217231737151.png)



如果是这个访问方式的话，在堆中需要有一块叫 句柄池的 内存空间，在里面有对象的实例数据的地址信息还有对象类型数据信息





#### 2.直接指针访问方式



![image-20201217231747940](https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20201217231747940.png)



引用类型的变量是直接存放对象的地址，就不需要 句柄池 了，直接通过引用就可以访问对象了，但是它需要考虑存储对象类信息数据地址（这个需要额外的策略）

这个方式也是 HotSpot 虚拟机 采用的方式，只需要一次 寻址操作 就可以  速度更快，