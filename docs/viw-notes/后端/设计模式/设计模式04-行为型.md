

# 策略模式



## 简单说明

**能够轻松的让我们通过替代整体算法而解决同一个问题**

> 复用抽取代码，接口根据不同的实参做不同的行为
> 1.定义一个上层接口，不同的策略去实现这个接口方法
> 2.一个上层泛型接口，调用这个接口方法，都是根据传入不同的策略类去实现不同的方法
> 3.策略可以根据客户端的不同行为做出不同的处理
> 4.可以理解为策略模式可以很好地处理if else这种业务历史代码
## 官方说明

**维基百科**

> 1.策略模式是一种运行时选择最优算法


## 代码例子


### 背景

> 1.你选择是一个登山app的开发者，你需要根据客户端传入的不同的山，来做不同的登山装备推荐


### 伪代码

```java

if("A山"){
    // to something
}else if("B山"){
    // to something
}

```

## 代码

```java

package com.viw.viwde;

import org.junit.Test;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class Design {

    @FunctionalInterface
    public interface Shop {
        void execute();
    }

    public class High implements Shop {
        @Override
        public void execute() {
            log.info("登大山的推荐");
        }
    }

    public class Small implements Shop {
        @Override
        public void execute() {
            log.info("登小山的推荐");
        }
    }

    public class ActionVO {
        private Shop shop;

        public ActionVO(Shop shop) {
            this.shop = shop;
        }

        public void changeAction(Shop shop) {
            this.shop = shop;
        }

        public void getAction() {
            shop.execute();
        }
    }

    @Test
    public void test() {
        var actionA = new ActionVO(new High());
        actionA.getAction();
        actionA.changeAction(new Small());
        actionA.getAction();
        log.info("=====");
        actionA.changeAction(Action.High);
        actionA.getAction();
        actionA.changeAction(Action.Small);
        actionA.getAction();
    }



    public class LombdaActionVO {
        public Action action;
    }

    public enum Action implements Shop {
        Small(() -> {
            log.info("small");
        }),
        High(() -> {
            log.info("high");
        });

        private  Shop shop;

        Action(Shop shop) {
            this.shop = shop;
        }

        @Override
        public void execute() {
            shop.execute();
        }
    }

}



```





