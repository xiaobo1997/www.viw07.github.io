

[TOC]



# 1.AQS

参考 `深入浅出多线程`  `Java并发编程的艺术` 以及网上很多其他的大佬的总结

## 概念

> **AQS**是`AbstractQueuedSynchronizer`的简称，即`抽象队列同步器`

- 抽象：抽象类，只实现一些主要逻辑，有些方法由子类实现；
- 队列：使用先进先出（FIFO）队列存储数据；
- 同步：实现了同步的功能。



​		AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的同步器，比ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。其实在 concurrent包中还有很多可BLOCKED的类。

​		当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器，只要子类实现它的几个`protected`用来改变同步状态state的方法就可以了，

​		AQS内部使用了一个volatile的变量state来作为资源的标识。同时定义了几个获取和改变state的protected方法，子类可以覆盖这些方法来实现自己的逻辑 

```java
// 三个都是原子操作
getState()   // 获取当前同步的状态
setState() // 设置当前同步的状态
compareAndSetState() // 使用CAS设置同步 状态
```

​		同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步 器实现锁的语义。可以这样理解二者之间的关系：锁是面向使用者的，它定义了使用者与锁交 互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；同步器面向的是锁的实现者， 它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。

> 作用

用来构建锁或者其他同步组 件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获 取线程的排队工作



> 子类的继承来使用--实现我们自定义的同步器组件前提

同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状 态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3 个方法（getState()、setState(int newState)和compareAndSetState(int expect,int update)）来进行操 作，因为它们能够保证状态的改变是安全的。



## 数据结构



> AQS类本身实现的是一些排队和阻塞的机制，比如具体线程等待队列的维护（如获取资源失败入队/唤醒出队等）。它内部使用了一个先进先出（FIFO）的双端队列，并使用了两个指针head和tail用于标识队列的头部和尾部。

![img](http://concurrent.redspider.group/article/02/imgs/AQS数据结构.png)



## 设计模式



> 同步器的设计是基于模板方法模式的，也就是说，使用者需要继承同步器并重写指定的 方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些 模板方法将会调用使用者重写的方法

同步器提供的模板方法基本上分为3类：独占式获取与释放同步状态、共享式获取与释放 同步状态和查询同步队列中的等待线程情况。自定义同步组件将使用同步器提供的模板方法 来实现自己的同步语义。

> lock组件是具体的一个实现的同步器组件



## 同步方式(资源共享模式)

AQS的核心也包括了这些方面:**同步队列，独占式锁的获取和释放，共享锁的获取和释放以及可中断锁，超时等待锁获取这些特性的实现**

> 两种资源共享模式
>
> 一般只需要实现其中一种

- 1.独占模式（Exclusive）：资源是独占的，一次只能一个线程获取。
- 2.共享模式（Share）：同时可以被多个线程获取，具体的资源个数可以通过参数指定。



## 源码分析

