<svg id="kity_svg_6" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="3578" height="31155" style="background: rgb(251, 251, 251); visibility: visible;" viewBox="0 0 3578 31155"><defs id="kity_defs_7"><linearGradient id="kity_linearGradient_17" x1="0" y1="0" x2="0" y2="1"><stop id="kity_stop_18" offset="0" stop-color="rgb(255, 255, 255)"></stop><stop id="kity_stop_19" offset="1" stop-color="rgb(204, 204, 204)"></stop></linearGradient><marker id="kity_marker_2" orient="auto" refX="6" refY="0" viewBox="-7 -7 14 14" markerWidth="7" markerHeight="7" markerUnits="userSpaceOnUse"><path id="kity_path_3" fill="rgb(123, 115, 191)" stroke="none" d="M6,0A6,6,0,1,1,-6,0A6,6,0,1,1,6,0"></path></marker></defs><g id="kity_g_8"><g id="minder1" text-rendering="optimize-speed"><g id="minder_connect_group1"><path id="kity_path_31" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M351.5,15577.5A45,15544,0,0,1,396.5,33.5"></path><path id="kity_path_33" fill="none" stroke="none" display="none"></path><path id="kity_path_35" fill="none" stroke="none" display="none"></path><path id="kity_path_37" fill="none" stroke="none" display="none"></path><path id="kity_path_39" fill="none" stroke="none" display="none"></path><path id="kity_path_41" fill="none" stroke="none" display="none"></path><path id="kity_path_43" fill="none" stroke="none" display="none"></path><path id="kity_path_45" fill="none" stroke="none" display="none"></path><path id="kity_path_47" fill="none" stroke="none" display="none"></path><path id="kity_path_49" fill="none" stroke="none" display="none"></path><path id="kity_path_51" fill="none" stroke="none" display="none"></path><path id="kity_path_53" fill="none" stroke="none" display="none"></path><path id="kity_path_55" fill="none" stroke="none" display="none"></path><path id="kity_path_57" fill="none" stroke="none" display="none"></path><path id="kity_path_59" fill="none" stroke="none" display="none"></path><path id="kity_path_61" fill="none" stroke="none" display="none"></path><path id="kity_path_63" fill="none" stroke="none" display="none"></path><path id="kity_path_65" fill="none" stroke="none" display="none"></path><path id="kity_path_67" fill="none" stroke="none" display="none"></path><path id="kity_path_69" fill="none" stroke="none" display="none"></path><path id="kity_path_71" fill="none" stroke="none" display="none"></path><path id="kity_path_73" fill="none" stroke="none" display="none"></path><path id="kity_path_75" fill="none" stroke="none" display="none"></path><path id="kity_path_77" fill="none" stroke="none" display="none"></path><path id="kity_path_79" fill="none" stroke="none" display="none"></path><path id="kity_path_81" fill="none" stroke="none" display="none"></path><path id="kity_path_83" fill="none" stroke="none" display="none"></path><path id="kity_path_85" fill="none" stroke="none" display="none"></path><path id="kity_path_87" fill="none" stroke="none" display="none"></path><path id="kity_path_89" fill="none" stroke="none" display="none"></path><path id="kity_path_91" fill="none" stroke="none" display="none"></path><path id="kity_path_93" fill="none" stroke="none" display="none"></path><path id="kity_path_95" fill="none" stroke="none" display="none"></path><path id="kity_path_97" fill="none" stroke="none" display="none"></path><path id="kity_path_99" fill="none" stroke="none" display="none"></path><path id="kity_path_101" fill="none" stroke="none" display="none"></path><path id="kity_path_103" fill="none" stroke="none" display="none"></path><path id="kity_path_105" fill="none" stroke="none" display="none"></path><path id="kity_path_107" fill="none" stroke="none" display="none"></path><path id="kity_path_109" fill="none" stroke="none" display="none"></path><path id="kity_path_111" fill="none" stroke="none" display="none"></path><path id="kity_path_113" fill="none" stroke="none" display="none"></path><path id="kity_path_115" fill="none" stroke="none" display="none"></path><path id="kity_path_117" fill="none" stroke="none" display="none"></path><path id="kity_path_119" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M351.5,15577.5A45,15502,0,0,1,396.5,75.5"></path><path id="kity_path_121" fill="none" stroke="none" display="none"></path><path id="kity_path_123" fill="none" stroke="none" display="none"></path><path id="kity_path_125" fill="none" stroke="none" display="none"></path><path id="kity_path_127" fill="none" stroke="none" display="none"></path><path id="kity_path_129" fill="none" stroke="none" display="none"></path><path id="kity_path_131" fill="none" stroke="none" display="none"></path><path id="kity_path_133" fill="none" stroke="none" display="none"></path><path id="kity_path_135" fill="none" stroke="none" display="none"></path><path id="kity_path_137" fill="none" stroke="none" display="none"></path><path id="kity_path_139" fill="none" stroke="none" display="none"></path><path id="kity_path_141" fill="none" stroke="none" display="none"></path><path id="kity_path_143" fill="none" stroke="none" display="none"></path><path id="kity_path_145" fill="none" stroke="none" display="none"></path><path id="kity_path_147" fill="none" stroke="none" display="none"></path><path id="kity_path_149" fill="none" stroke="none" display="none"></path><path id="kity_path_151" fill="none" stroke="none" display="none"></path><path id="kity_path_153" fill="none" stroke="none" display="none"></path><path id="kity_path_155" fill="none" stroke="none" display="none"></path><path id="kity_path_157" fill="none" stroke="none" display="none"></path><path id="kity_path_159" fill="none" stroke="none" display="none"></path><path id="kity_path_161" fill="none" stroke="none" display="none"></path><path id="kity_path_163" fill="none" stroke="none" display="none"></path><path id="kity_path_165" fill="none" stroke="none" display="none"></path><path id="kity_path_167" fill="none" stroke="none" display="none"></path><path id="kity_path_169" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M351.5,15577.5A45,15460,0,0,1,396.5,117.5"></path><path id="kity_path_171" fill="none" stroke="none" display="none"></path><path id="kity_path_173" fill="none" stroke="none" display="none"></path><path id="kity_path_175" fill="none" stroke="none" display="none"></path><path id="kity_path_177" fill="none" stroke="none" display="none"></path><path id="kity_path_179" fill="none" stroke="none" display="none"></path><path id="kity_path_181" fill="none" stroke="none" display="none"></path><path id="kity_path_183" fill="none" stroke="none" display="none"></path><path id="kity_path_185" fill="none" stroke="none" display="none"></path><path id="kity_path_187" fill="none" stroke="none" display="none"></path><path id="kity_path_189" fill="none" stroke="none" display="none"></path><path id="kity_path_191" fill="none" stroke="none" display="none"></path><path id="kity_path_193" fill="none" stroke="none" display="none"></path><path id="kity_path_195" fill="none" stroke="none" display="none"></path><path id="kity_path_197" fill="none" stroke="none" display="none"></path><path id="kity_path_199" fill="none" stroke="none" display="none"></path><path id="kity_path_201" fill="none" stroke="none" display="none"></path><path id="kity_path_203" fill="none" stroke="none" display="none"></path><path id="kity_path_205" fill="none" stroke="none" display="none"></path><path id="kity_path_207" fill="none" stroke="none" display="none"></path><path id="kity_path_209" fill="none" stroke="none" display="none"></path><path id="kity_path_211" fill="none" stroke="none" display="none"></path><path id="kity_path_213" fill="none" stroke="none" display="none"></path><path id="kity_path_215" fill="none" stroke="none" display="none"></path><path id="kity_path_217" fill="none" stroke="none" display="none"></path><path id="kity_path_219" fill="none" stroke="none" display="none"></path><path id="kity_path_221" fill="none" stroke="none" display="none"></path><path id="kity_path_223" fill="none" stroke="none" display="none"></path><path id="kity_path_225" fill="none" stroke="none" display="none"></path><path id="kity_path_227" fill="none" stroke="none" display="none"></path><path id="kity_path_229" fill="none" stroke="none" display="none"></path><path id="kity_path_231" fill="none" stroke="none" display="none"></path><path id="kity_path_233" fill="none" stroke="none" display="none"></path><path id="kity_path_235" fill="none" stroke="none" display="none"></path><path id="kity_path_237" fill="none" stroke="none" display="none"></path><path id="kity_path_239" fill="none" stroke="none" display="none"></path><path id="kity_path_241" fill="none" stroke="none" display="none"></path><path id="kity_path_243" fill="none" stroke="none" display="none"></path><path id="kity_path_245" fill="none" stroke="none" display="none"></path><path id="kity_path_247" fill="none" stroke="none" display="none"></path><path id="kity_path_249" fill="none" stroke="none" display="none"></path><path id="kity_path_251" fill="none" stroke="none" display="none"></path><path id="kity_path_253" fill="none" stroke="none" display="none"></path><path id="kity_path_255" fill="none" stroke="none" display="none"></path><path id="kity_path_257" fill="none" stroke="none" display="none"></path><path id="kity_path_259" fill="none" stroke="none" display="none"></path><path id="kity_path_261" fill="none" stroke="none" display="none"></path><path id="kity_path_263" fill="none" stroke="none" display="none"></path><path id="kity_path_265" fill="none" stroke="none" display="none"></path><path id="kity_path_267" fill="none" stroke="none" display="none"></path><path id="kity_path_269" fill="none" stroke="none" display="none"></path><path id="kity_path_271" fill="none" stroke="none" display="none"></path><path id="kity_path_273" fill="none" stroke="none" display="none"></path><path id="kity_path_275" fill="none" stroke="none" display="none"></path><path id="kity_path_277" fill="none" stroke="none" display="none"></path><path id="kity_path_279" fill="none" stroke="none" display="none"></path><path id="kity_path_281" fill="none" stroke="none" display="none"></path><path id="kity_path_283" fill="none" stroke="none" display="none"></path><path id="kity_path_285" fill="none" stroke="none" display="none"></path><path id="kity_path_287" fill="none" stroke="none" display="none"></path><path id="kity_path_289" fill="none" stroke="none" display="none"></path><path id="kity_path_291" fill="none" stroke="none" display="none"></path><path id="kity_path_293" fill="none" stroke="none" display="none"></path><path id="kity_path_295" fill="none" stroke="none" display="none"></path><path id="kity_path_297" fill="none" stroke="none" display="none"></path><path id="kity_path_299" fill="none" stroke="none" display="none"></path><path id="kity_path_301" fill="none" stroke="none" display="none"></path><path id="kity_path_303" fill="none" stroke="none" display="none"></path><path id="kity_path_305" fill="none" stroke="none" display="none"></path><path id="kity_path_307" fill="none" stroke="none" display="none"></path><path id="kity_path_309" fill="none" stroke="none" display="none"></path><path id="kity_path_311" fill="none" stroke="none" display="none"></path><path id="kity_path_313" fill="none" stroke="none" display="none"></path><path id="kity_path_315" fill="none" stroke="none" display="none"></path><path id="kity_path_317" fill="none" stroke="none" display="none"></path><path id="kity_path_319" fill="none" stroke="none" display="none"></path><path id="kity_path_321" fill="none" stroke="none" display="none"></path><path id="kity_path_323" fill="none" stroke="none" display="none"></path><path id="kity_path_325" fill="none" stroke="none" display="none"></path><path id="kity_path_327" fill="none" stroke="none" display="none"></path><path id="kity_path_329" fill="none" stroke="none" display="none"></path><path id="kity_path_331" fill="none" stroke="none" display="none"></path><path id="kity_path_333" fill="none" stroke="none" display="none"></path><path id="kity_path_335" fill="none" stroke="none" display="none"></path><path id="kity_path_337" fill="none" stroke="none" display="none"></path><path id="kity_path_339" fill="none" stroke="none" display="none"></path><path id="kity_path_341" fill="none" stroke="none" display="none"></path><path id="kity_path_343" fill="none" stroke="none" display="none"></path><path id="kity_path_345" fill="none" stroke="none" display="none"></path><path id="kity_path_347" fill="none" stroke="none" display="none"></path><path id="kity_path_349" fill="none" stroke="none" display="none"></path><path id="kity_path_351" fill="none" stroke="none" display="none"></path><path id="kity_path_353" fill="none" stroke="none" display="none"></path><path id="kity_path_355" fill="none" stroke="none" display="none"></path><path id="kity_path_357" fill="none" stroke="none" display="none"></path><path id="kity_path_359" fill="none" stroke="none" display="none"></path><path id="kity_path_361" fill="none" stroke="none" display="none"></path><path id="kity_path_363" fill="none" stroke="none" display="none"></path><path id="kity_path_365" fill="none" stroke="none" display="none"></path><path id="kity_path_367" fill="none" stroke="none" display="none"></path><path id="kity_path_369" fill="none" stroke="none" display="none"></path><path id="kity_path_371" fill="none" stroke="none" display="none"></path><path id="kity_path_373" fill="none" stroke="none" display="none"></path><path id="kity_path_375" fill="none" stroke="none" display="none"></path><path id="kity_path_377" fill="none" stroke="none" display="none"></path><path id="kity_path_379" fill="none" stroke="none" display="none"></path><path id="kity_path_381" fill="none" stroke="none" display="none"></path><path id="kity_path_383" fill="none" stroke="none" display="none"></path><path id="kity_path_385" fill="none" stroke="none" display="none"></path><path id="kity_path_387" fill="none" stroke="none" display="none"></path><path id="kity_path_389" fill="none" stroke="none" display="none"></path><path id="kity_path_391" fill="none" stroke="none" display="none"></path><path id="kity_path_393" fill="none" stroke="none" display="none"></path><path id="kity_path_395" fill="none" stroke="none" display="none"></path><path id="kity_path_397" fill="none" stroke="none" display="none"></path><path id="kity_path_399" fill="none" stroke="none" display="none"></path><path id="kity_path_401" fill="none" stroke="none" display="none"></path><path id="kity_path_403" fill="none" stroke="none" display="none"></path><path id="kity_path_405" fill="none" stroke="none" display="none"></path><path id="kity_path_407" fill="none" stroke="none" display="none"></path><path id="kity_path_409" fill="none" stroke="none" display="none"></path><path id="kity_path_411" fill="none" stroke="none" display="none"></path><path id="kity_path_413" fill="none" stroke="none" display="none"></path><path id="kity_path_415" fill="none" stroke="none" display="none"></path><path id="kity_path_417" fill="none" stroke="none" display="none"></path><path id="kity_path_419" fill="none" stroke="none" display="none"></path><path id="kity_path_421" fill="none" stroke="none" display="none"></path><path id="kity_path_423" fill="none" stroke="none" display="none"></path><path id="kity_path_425" fill="none" stroke="none" display="none"></path><path id="kity_path_427" fill="none" stroke="none" display="none"></path><path id="kity_path_429" fill="none" stroke="none" display="none"></path><path id="kity_path_431" fill="none" stroke="none" display="none"></path><path id="kity_path_433" fill="none" stroke="none" display="none"></path><path id="kity_path_435" fill="none" stroke="none" display="none"></path><path id="kity_path_437" fill="none" stroke="none" display="none"></path><path id="kity_path_439" fill="none" stroke="none" display="none"></path><path id="kity_path_441" fill="none" stroke="none" display="none"></path><path id="kity_path_443" fill="none" stroke="none" display="none"></path><path id="kity_path_445" fill="none" stroke="none" display="none"></path><path id="kity_path_447" fill="none" stroke="none" display="none"></path><path id="kity_path_449" fill="none" stroke="none" display="none"></path><path id="kity_path_451" fill="none" stroke="none" display="none"></path><path id="kity_path_453" fill="none" stroke="none" display="none"></path><path id="kity_path_455" fill="none" stroke="none" display="none"></path><path id="kity_path_457" fill="none" stroke="none" display="none"></path><path id="kity_path_459" fill="none" stroke="none" display="none"></path><path id="kity_path_461" fill="none" stroke="none" display="none"></path><path id="kity_path_463" fill="none" stroke="none" display="none"></path><path id="kity_path_465" fill="none" stroke="none" display="none"></path><path id="kity_path_467" fill="none" stroke="none" display="none"></path><path id="kity_path_469" fill="none" stroke="none" display="none"></path><path id="kity_path_471" fill="none" stroke="none" display="none"></path><path id="kity_path_473" fill="none" stroke="none" display="none"></path><path id="kity_path_475" fill="none" stroke="none" display="none"></path><path id="kity_path_477" fill="none" stroke="none" display="none"></path><path id="kity_path_479" fill="none" stroke="none" display="none"></path><path id="kity_path_481" fill="none" stroke="none" display="none"></path><path id="kity_path_483" fill="none" stroke="none" display="none"></path><path id="kity_path_485" fill="none" stroke="none" display="none"></path><path id="kity_path_487" fill="none" stroke="none" display="none"></path><path id="kity_path_489" fill="none" stroke="none" display="none"></path><path id="kity_path_491" fill="none" stroke="none" display="none"></path><path id="kity_path_493" fill="none" stroke="none" display="none"></path><path id="kity_path_495" fill="none" stroke="none" display="none"></path><path id="kity_path_497" fill="none" stroke="none" display="none"></path><path id="kity_path_499" fill="none" stroke="none" display="none"></path><path id="kity_path_501" fill="none" stroke="none" display="none"></path><path id="kity_path_503" fill="none" stroke="none" display="none"></path><path id="kity_path_505" fill="none" stroke="none" display="none"></path><path id="kity_path_507" fill="none" stroke="none" display="none"></path><path id="kity_path_509" fill="none" stroke="none" display="none"></path><path id="kity_path_511" fill="none" stroke="none" display="none"></path><path id="kity_path_513" fill="none" stroke="none" display="none"></path><path id="kity_path_515" fill="none" stroke="none" display="none"></path><path id="kity_path_517" fill="none" stroke="none" display="none"></path><path id="kity_path_519" fill="none" stroke="none" display="none"></path><path id="kity_path_521" fill="none" stroke="none" display="none"></path><path id="kity_path_523" fill="none" stroke="none" display="none"></path><path id="kity_path_525" fill="none" stroke="none" display="none"></path><path id="kity_path_527" fill="none" stroke="none" display="none"></path><path id="kity_path_529" fill="none" stroke="none" display="none"></path><path id="kity_path_531" fill="none" stroke="none" display="none"></path><path id="kity_path_533" fill="none" stroke="none" display="none"></path><path id="kity_path_535" fill="none" stroke="none" display="none"></path><path id="kity_path_537" fill="none" stroke="none" display="none"></path><path id="kity_path_539" fill="none" stroke="none" display="none"></path><path id="kity_path_541" fill="none" stroke="none" display="none"></path><path id="kity_path_543" fill="none" stroke="none" display="none"></path><path id="kity_path_545" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M351.5,15577.5A45,15418,0,0,1,396.5,159.5"></path><path id="kity_path_547" fill="none" stroke="none" display="none"></path><path id="kity_path_549" fill="none" stroke="none" display="none"></path><path id="kity_path_551" fill="none" stroke="none" display="none"></path><path id="kity_path_553" fill="none" stroke="none" display="none"></path><path id="kity_path_555" fill="none" stroke="none" display="none"></path><path id="kity_path_557" fill="none" stroke="none" display="none"></path><path id="kity_path_559" fill="none" stroke="none" display="none"></path><path id="kity_path_561" fill="none" stroke="none" display="none"></path><path id="kity_path_563" fill="none" stroke="none" display="none"></path><path id="kity_path_565" fill="none" stroke="none" display="none"></path><path id="kity_path_567" fill="none" stroke="none" display="none"></path><path id="kity_path_569" fill="none" stroke="none" display="none"></path><path id="kity_path_571" fill="none" stroke="none" display="none"></path><path id="kity_path_573" fill="none" stroke="none" display="none"></path><path id="kity_path_575" fill="none" stroke="none" display="none"></path><path id="kity_path_577" fill="none" stroke="none" display="none"></path><path id="kity_path_579" fill="none" stroke="none" display="none"></path><path id="kity_path_581" fill="none" stroke="none" display="none"></path><path id="kity_path_583" fill="none" stroke="none" display="none"></path><path id="kity_path_585" fill="none" stroke="none" display="none"></path><path id="kity_path_587" fill="none" stroke="none" display="none"></path><path id="kity_path_589" fill="none" stroke="none" display="none"></path><path id="kity_path_591" fill="none" stroke="none" display="none"></path><path id="kity_path_593" fill="none" stroke="none" display="none"></path><path id="kity_path_595" fill="none" stroke="none" display="none"></path><path id="kity_path_597" fill="none" stroke="none" display="none"></path><path id="kity_path_599" fill="none" stroke="none" display="none"></path><path id="kity_path_601" fill="none" stroke="none" display="none"></path><path id="kity_path_603" fill="none" stroke="none" display="none"></path><path id="kity_path_605" fill="none" stroke="none" display="none"></path><path id="kity_path_607" fill="none" stroke="none" display="none"></path><path id="kity_path_609" fill="none" stroke="none" display="none"></path><path id="kity_path_611" fill="none" stroke="none" display="none"></path><path id="kity_path_613" fill="none" stroke="none" display="none"></path><path id="kity_path_615" fill="none" stroke="none" display="none"></path><path id="kity_path_617" fill="none" stroke="none" display="none"></path><path id="kity_path_619" fill="none" stroke="none" display="none"></path><path id="kity_path_621" fill="none" stroke="none" display="none"></path><path id="kity_path_623" fill="none" stroke="none" display="none"></path><path id="kity_path_625" fill="none" stroke="none" display="none"></path><path id="kity_path_627" fill="none" stroke="none" display="none"></path><path id="kity_path_629" fill="none" stroke="none" display="none"></path><path id="kity_path_631" fill="none" stroke="none" display="none"></path><path id="kity_path_633" fill="none" stroke="none" display="none"></path><path id="kity_path_635" fill="none" stroke="none" display="none"></path><path id="kity_path_637" fill="none" stroke="none" display="none"></path><path id="kity_path_639" fill="none" stroke="none" display="none"></path><path id="kity_path_641" fill="none" stroke="none" display="none"></path><path id="kity_path_643" fill="none" stroke="none" display="none"></path><path id="kity_path_645" fill="none" stroke="none" display="none"></path><path id="kity_path_647" fill="none" stroke="none" display="none"></path><path id="kity_path_649" fill="none" stroke="none" display="none"></path><path id="kity_path_651" fill="none" stroke="none" display="none"></path><path id="kity_path_653" fill="none" stroke="none" display="none"></path><path id="kity_path_655" fill="none" stroke="none" display="none"></path><path id="kity_path_657" fill="none" stroke="none" display="none"></path><path id="kity_path_659" fill="none" stroke="none" display="none"></path><path id="kity_path_661" fill="none" stroke="none" display="none"></path><path id="kity_path_663" fill="none" stroke="none" display="none"></path><path id="kity_path_665" fill="none" stroke="none" display="none"></path><path id="kity_path_667" fill="none" stroke="none" display="none"></path><path id="kity_path_669" fill="none" stroke="none" display="none"></path><path id="kity_path_671" fill="none" stroke="none" display="none"></path><path id="kity_path_673" fill="none" stroke="none" display="none"></path><path id="kity_path_675" fill="none" stroke="none" display="none"></path><path id="kity_path_677" fill="none" stroke="none" display="none"></path><path id="kity_path_679" fill="none" stroke="none" display="none"></path><path id="kity_path_681" fill="none" stroke="none" display="none"></path><path id="kity_path_683" fill="none" stroke="none" display="none"></path><path id="kity_path_685" fill="none" stroke="none" display="none"></path><path id="kity_path_687" fill="none" stroke="none" display="none"></path><path id="kity_path_689" fill="none" stroke="none" display="none"></path><path id="kity_path_691" fill="none" stroke="none" display="none"></path><path id="kity_path_693" fill="none" stroke="none" display="none"></path><path id="kity_path_695" fill="none" stroke="none" display="none"></path><path id="kity_path_697" fill="none" stroke="none" display="none"></path><path id="kity_path_699" fill="none" stroke="none" display="none"></path><path id="kity_path_701" fill="none" stroke="none" display="none"></path><path id="kity_path_703" fill="none" stroke="none" display="none"></path><path id="kity_path_705" fill="none" stroke="none" display="none"></path><path id="kity_path_707" fill="none" stroke="none" display="none"></path><path id="kity_path_709" fill="none" stroke="none" display="none"></path><path id="kity_path_711" fill="none" stroke="none" display="none"></path><path id="kity_path_713" fill="none" stroke="none" display="none"></path><path id="kity_path_715" fill="none" stroke="none" display="none"></path><path id="kity_path_717" fill="none" stroke="none" display="none"></path><path id="kity_path_719" fill="none" stroke="none" display="none"></path><path id="kity_path_721" fill="none" stroke="none" display="none"></path><path id="kity_path_723" fill="none" stroke="none" display="none"></path><path id="kity_path_725" fill="none" stroke="none" display="none"></path><path id="kity_path_727" fill="none" stroke="none" display="none"></path><path id="kity_path_729" fill="none" stroke="none" display="none"></path><path id="kity_path_731" fill="none" stroke="none" display="none"></path><path id="kity_path_733" fill="none" stroke="none" display="none"></path><path id="kity_path_735" fill="none" stroke="none" display="none"></path><path id="kity_path_737" fill="none" stroke="none" display="none"></path><path id="kity_path_739" fill="none" stroke="none" display="none"></path><path id="kity_path_741" fill="none" stroke="none" display="none"></path><path id="kity_path_743" fill="none" stroke="none" display="none"></path><path id="kity_path_745" fill="none" stroke="none" display="none"></path><path id="kity_path_747" fill="none" stroke="none" display="none"></path><path id="kity_path_749" fill="none" stroke="none" display="none"></path><path id="kity_path_751" fill="none" stroke="none" display="none"></path><path id="kity_path_753" fill="none" stroke="none" display="none"></path><path id="kity_path_755" fill="none" stroke="none" display="none"></path><path id="kity_path_757" fill="none" stroke="none" display="none"></path><path id="kity_path_759" fill="none" stroke="none" display="none"></path><path id="kity_path_761" fill="none" stroke="none" display="none"></path><path id="kity_path_763" fill="none" stroke="none" display="none"></path><path id="kity_path_765" fill="none" stroke="none" display="none"></path><path id="kity_path_767" fill="none" stroke="none" display="none"></path><path id="kity_path_769" fill="none" stroke="none" display="none"></path><path id="kity_path_771" fill="none" stroke="none" display="none"></path><path id="kity_path_773" fill="none" stroke="none" display="none"></path><path id="kity_path_775" fill="none" stroke="none" display="none"></path><path id="kity_path_777" fill="none" stroke="none" display="none"></path><path id="kity_path_779" fill="none" stroke="none" display="none"></path><path id="kity_path_781" fill="none" stroke="none" display="none"></path><path id="kity_path_783" fill="none" stroke="none" display="none"></path><path id="kity_path_785" fill="none" stroke="none" display="none"></path><path id="kity_path_787" fill="none" stroke="none" display="none"></path><path id="kity_path_789" fill="none" stroke="none" display="none"></path><path id="kity_path_791" fill="none" stroke="none" display="none"></path><path id="kity_path_793" fill="none" stroke="none" display="none"></path><path id="kity_path_795" fill="none" stroke="none" display="none"></path><path id="kity_path_797" fill="none" stroke="none" display="none"></path><path id="kity_path_799" fill="none" stroke="none" display="none"></path><path id="kity_path_801" fill="none" stroke="none" display="none"></path><path id="kity_path_803" fill="none" stroke="none" display="none"></path><path id="kity_path_805" fill="none" stroke="none" display="none"></path><path id="kity_path_807" fill="none" stroke="none" display="none"></path><path id="kity_path_809" fill="none" stroke="none" display="none"></path><path id="kity_path_811" fill="none" stroke="none" display="none"></path><path id="kity_path_813" fill="none" stroke="none" display="none"></path><path id="kity_path_815" fill="none" stroke="none" display="none"></path><path id="kity_path_817" fill="none" stroke="none" display="none"></path><path id="kity_path_819" fill="none" stroke="none" display="none"></path><path id="kity_path_821" fill="none" stroke="none" display="none"></path><path id="kity_path_823" fill="none" stroke="none" display="none"></path><path id="kity_path_825" fill="none" stroke="none" display="none"></path><path id="kity_path_827" fill="none" stroke="none" display="none"></path><path id="kity_path_829" fill="none" stroke="none" display="none"></path><path id="kity_path_831" fill="none" stroke="none" display="none"></path><path id="kity_path_833" fill="none" stroke="none" display="none"></path><path id="kity_path_835" fill="none" stroke="none" display="none"></path><path id="kity_path_837" fill="none" stroke="none" display="none"></path><path id="kity_path_839" fill="none" stroke="none" display="none"></path><path id="kity_path_841" fill="none" stroke="none" display="none"></path><path id="kity_path_843" fill="none" stroke="none" display="none"></path><path id="kity_path_845" fill="none" stroke="none" display="none"></path><path id="kity_path_847" fill="none" stroke="none" display="none"></path><path id="kity_path_849" fill="none" stroke="none" display="none"></path><path id="kity_path_851" fill="none" stroke="none" display="none"></path><path id="kity_path_853" fill="none" stroke="none" display="none"></path><path id="kity_path_855" fill="none" stroke="none" display="none"></path><path id="kity_path_857" fill="none" stroke="none" display="none"></path><path id="kity_path_859" fill="none" stroke="none" display="none"></path><path id="kity_path_861" fill="none" stroke="none" display="none"></path><path id="kity_path_863" fill="none" stroke="none" display="none"></path><path id="kity_path_865" fill="none" stroke="none" display="none"></path><path id="kity_path_867" fill="none" stroke="none" display="none"></path><path id="kity_path_869" fill="none" stroke="none" display="none"></path><path id="kity_path_871" fill="none" stroke="none" display="none"></path><path id="kity_path_873" fill="none" stroke="none" display="none"></path><path id="kity_path_875" fill="none" stroke="none" display="none"></path><path id="kity_path_877" fill="none" stroke="none" display="none"></path><path id="kity_path_879" fill="none" stroke="none" display="none"></path><path id="kity_path_881" fill="none" stroke="none" display="none"></path><path id="kity_path_883" fill="none" stroke="none" display="none"></path><path id="kity_path_885" fill="none" stroke="none" display="none"></path><path id="kity_path_887" fill="none" stroke="none" display="none"></path><path id="kity_path_889" fill="none" stroke="none" display="none"></path><path id="kity_path_891" fill="none" stroke="none" display="none"></path><path id="kity_path_893" fill="none" stroke="none" display="none"></path><path id="kity_path_895" fill="none" stroke="none" display="none"></path><path id="kity_path_897" fill="none" stroke="none" display="none"></path><path id="kity_path_899" fill="none" stroke="none" display="none"></path><path id="kity_path_901" fill="none" stroke="none" display="none"></path><path id="kity_path_903" fill="none" stroke="none" display="none"></path><path id="kity_path_905" fill="none" stroke="none" display="none"></path><path id="kity_path_907" fill="none" stroke="none" display="none"></path><path id="kity_path_909" fill="none" stroke="none" display="none"></path><path id="kity_path_911" fill="none" stroke="none" display="none"></path><path id="kity_path_913" fill="none" stroke="none" display="none"></path><path id="kity_path_915" fill="none" stroke="none" display="none"></path><path id="kity_path_917" fill="none" stroke="none" display="none"></path><path id="kity_path_919" fill="none" stroke="none" display="none"></path><path id="kity_path_921" fill="none" stroke="none" display="none"></path><path id="kity_path_923" fill="none" stroke="none" display="none"></path><path id="kity_path_925" fill="none" stroke="none" display="none"></path><path id="kity_path_927" fill="none" stroke="none" display="none"></path><path id="kity_path_929" fill="none" stroke="none" display="none"></path><path id="kity_path_931" fill="none" stroke="none" display="none"></path><path id="kity_path_933" fill="none" stroke="none" display="none"></path><path id="kity_path_935" fill="none" stroke="none" display="none"></path><path id="kity_path_937" fill="none" stroke="none" display="none"></path><path id="kity_path_939" fill="none" stroke="none" display="none"></path><path id="kity_path_941" fill="none" stroke="none" display="none"></path><path id="kity_path_943" fill="none" stroke="none" display="none"></path><path id="kity_path_945" fill="none" stroke="none" display="none"></path><path id="kity_path_947" fill="none" stroke="none" display="none"></path><path id="kity_path_949" fill="none" stroke="none" display="none"></path><path id="kity_path_951" fill="none" stroke="none" display="none"></path><path id="kity_path_953" fill="none" stroke="none" display="none"></path><path id="kity_path_955" fill="none" stroke="none" display="none"></path><path id="kity_path_957" fill="none" stroke="none" display="none"></path><path id="kity_path_959" fill="none" stroke="none" display="none"></path><path id="kity_path_961" fill="none" stroke="none" display="none"></path><path id="kity_path_963" fill="none" stroke="none" display="none"></path><path id="kity_path_965" fill="none" stroke="none" display="none"></path><path id="kity_path_967" fill="none" stroke="none" display="none"></path><path id="kity_path_969" fill="none" stroke="none" display="none"></path><path id="kity_path_971" fill="none" stroke="none" display="none"></path><path id="kity_path_973" fill="none" stroke="none" display="none"></path><path id="kity_path_975" fill="none" stroke="none" display="none"></path><path id="kity_path_977" fill="none" stroke="none" display="none"></path><path id="kity_path_979" fill="none" stroke="none" display="none"></path><path id="kity_path_981" fill="none" stroke="none" display="none"></path><path id="kity_path_983" fill="none" stroke="none" display="none"></path><path id="kity_path_985" fill="none" stroke="none" display="none"></path><path id="kity_path_987" fill="none" stroke="none" display="none"></path><path id="kity_path_989" fill="none" stroke="none" display="none"></path><path id="kity_path_991" fill="none" stroke="none" display="none"></path><path id="kity_path_993" fill="none" stroke="none" display="none"></path><path id="kity_path_995" fill="none" stroke="none" display="none"></path><path id="kity_path_997" fill="none" stroke="none" display="none"></path><path id="kity_path_999" fill="none" stroke="none" display="none"></path><path id="kity_path_1001" fill="none" stroke="none" display="none"></path><path id="kity_path_1003" fill="none" stroke="none" display="none"></path><path id="kity_path_1005" fill="none" stroke="none" display="none"></path><path id="kity_path_1007" fill="none" stroke="none" display="none"></path><path id="kity_path_1009" fill="none" stroke="none" display="none"></path><path id="kity_path_1011" fill="none" stroke="none" display="none"></path><path id="kity_path_1013" fill="none" stroke="none" display="none"></path><path id="kity_path_1015" fill="none" stroke="none" display="none"></path><path id="kity_path_1017" fill="none" stroke="none" display="none"></path><path id="kity_path_1019" fill="none" stroke="none" display="none"></path><path id="kity_path_1021" fill="none" stroke="none" display="none"></path><path id="kity_path_1023" fill="none" stroke="none" display="none"></path><path id="kity_path_1025" fill="none" stroke="none" display="none"></path><path id="kity_path_1027" fill="none" stroke="none" display="none"></path><path id="kity_path_1029" fill="none" stroke="none" display="none"></path><path id="kity_path_1031" fill="none" stroke="none" display="none"></path><path id="kity_path_1033" fill="none" stroke="none" display="none"></path><path id="kity_path_1035" fill="none" stroke="none" display="none"></path><path id="kity_path_1037" fill="none" stroke="none" display="none"></path><path id="kity_path_1039" fill="none" stroke="none" display="none"></path><path id="kity_path_1041" fill="none" stroke="none" display="none"></path><path id="kity_path_1043" fill="none" stroke="none" display="none"></path><path id="kity_path_1045" fill="none" stroke="none" display="none"></path><path id="kity_path_1047" fill="none" stroke="none" display="none"></path><path id="kity_path_1049" fill="none" stroke="none" display="none"></path><path id="kity_path_1051" fill="none" stroke="none" display="none"></path><path id="kity_path_1053" fill="none" stroke="none" display="none"></path><path id="kity_path_1055" fill="none" stroke="none" display="none"></path><path id="kity_path_1057" fill="none" stroke="none" display="none"></path><path id="kity_path_1059" fill="none" stroke="none" display="none"></path><path id="kity_path_1061" fill="none" stroke="none" display="none"></path><path id="kity_path_1063" fill="none" stroke="none" display="none"></path><path id="kity_path_1065" fill="none" stroke="none" display="none"></path><path id="kity_path_1067" fill="none" stroke="none" display="none"></path><path id="kity_path_1069" fill="none" stroke="none" display="none"></path><path id="kity_path_1071" fill="none" stroke="none" display="none"></path><path id="kity_path_1073" fill="none" stroke="none" display="none"></path><path id="kity_path_1075" fill="none" stroke="none" display="none"></path><path id="kity_path_1077" fill="none" stroke="none" display="none"></path><path id="kity_path_1079" fill="none" stroke="none" display="none"></path><path id="kity_path_1081" fill="none" stroke="none" display="none"></path><path id="kity_path_1083" fill="none" stroke="none" display="none"></path><path id="kity_path_1085" fill="none" stroke="none" display="none"></path><path id="kity_path_1087" fill="none" stroke="none" display="none"></path><path id="kity_path_1089" fill="none" stroke="none" display="none"></path><path id="kity_path_1091" fill="none" stroke="none" display="none"></path><path id="kity_path_1093" fill="none" stroke="none" display="none"></path><path id="kity_path_1095" fill="none" stroke="none" display="none"></path><path id="kity_path_1097" fill="none" stroke="none" display="none"></path><path id="kity_path_1099" fill="none" stroke="none" display="none"></path><path id="kity_path_1101" fill="none" stroke="none" display="none"></path><path id="kity_path_1103" fill="none" stroke="none" display="none"></path><path id="kity_path_1105" fill="none" stroke="none" display="none"></path><path id="kity_path_1107" fill="none" stroke="none" display="none"></path><path id="kity_path_1109" fill="none" stroke="none" display="none"></path><path id="kity_path_1111" fill="none" stroke="none" display="none"></path><path id="kity_path_1113" fill="none" stroke="none" display="none"></path><path id="kity_path_1115" fill="none" stroke="none" display="none"></path><path id="kity_path_1117" fill="none" stroke="none" display="none"></path><path id="kity_path_1119" fill="none" stroke="none" display="none"></path><path id="kity_path_1121" fill="none" stroke="none" display="none"></path><path id="kity_path_1123" fill="none" stroke="none" display="none"></path><path id="kity_path_1125" fill="none" stroke="none" display="none"></path><path id="kity_path_1127" fill="none" stroke="none" display="none"></path><path id="kity_path_1129" fill="none" stroke="none" display="none"></path><path id="kity_path_1131" fill="none" stroke="none" display="none"></path><path id="kity_path_1133" fill="none" stroke="none" display="none"></path><path id="kity_path_1135" fill="none" stroke="none" display="none"></path><path id="kity_path_1137" fill="none" stroke="none" display="none"></path><path id="kity_path_1139" fill="none" stroke="none" display="none"></path><path id="kity_path_1141" fill="none" stroke="none" display="none"></path><path id="kity_path_1143" fill="none" stroke="none" display="none"></path><path id="kity_path_1145" fill="none" stroke="none" display="none"></path><path id="kity_path_1147" fill="none" stroke="none" display="none"></path><path id="kity_path_1149" fill="none" stroke="none" display="none"></path><path id="kity_path_1151" fill="none" stroke="none" display="none"></path><path id="kity_path_1153" fill="none" stroke="none" display="none"></path><path id="kity_path_1155" fill="none" stroke="none" display="none"></path><path id="kity_path_1157" fill="none" stroke="none" display="none"></path><path id="kity_path_1159" fill="none" stroke="none" display="none"></path><path id="kity_path_1161" fill="none" stroke="none" display="none"></path><path id="kity_path_1163" fill="none" stroke="none" display="none"></path><path id="kity_path_1165" fill="none" stroke="none" display="none"></path><path id="kity_path_1167" fill="none" stroke="none" display="none"></path><path id="kity_path_1169" fill="none" stroke="none" display="none"></path><path id="kity_path_1171" fill="none" stroke="none" display="none"></path><path id="kity_path_1173" fill="none" stroke="none" display="none"></path><path id="kity_path_1175" fill="none" stroke="none" display="none"></path><path id="kity_path_1177" fill="none" stroke="none" display="none"></path><path id="kity_path_1179" fill="none" stroke="none" display="none"></path><path id="kity_path_1181" fill="none" stroke="none" display="none"></path><path id="kity_path_1183" fill="none" stroke="none" display="none"></path><path id="kity_path_1185" fill="none" stroke="none" display="none"></path><path id="kity_path_1187" fill="none" stroke="none" display="none"></path><path id="kity_path_1189" fill="none" stroke="none" display="none"></path><path id="kity_path_1191" fill="none" stroke="none" display="none"></path><path id="kity_path_1193" fill="none" stroke="none" display="none"></path><path id="kity_path_1195" fill="none" stroke="none" display="none"></path><path id="kity_path_1197" fill="none" stroke="none" display="none"></path><path id="kity_path_1199" fill="none" stroke="none" display="none"></path><path id="kity_path_1201" fill="none" stroke="none" display="none"></path><path id="kity_path_1203" fill="none" stroke="none" display="none"></path><path id="kity_path_1205" fill="none" stroke="none" display="none"></path><path id="kity_path_1207" fill="none" stroke="none" display="none"></path><path id="kity_path_1209" fill="none" stroke="none" display="none"></path><path id="kity_path_1211" fill="none" stroke="none" display="none"></path><path id="kity_path_1213" fill="none" stroke="none" display="none"></path><path id="kity_path_1215" fill="none" stroke="none" display="none"></path><path id="kity_path_1217" fill="none" stroke="none" display="none"></path><path id="kity_path_1219" fill="none" stroke="none" display="none"></path><path id="kity_path_1221" fill="none" stroke="none" display="none"></path><path id="kity_path_1223" fill="none" stroke="none" display="none"></path><path id="kity_path_1225" fill="none" stroke="none" display="none"></path><path id="kity_path_1227" fill="none" stroke="none" display="none"></path><path id="kity_path_1229" fill="none" stroke="none" display="none"></path><path id="kity_path_1231" fill="none" stroke="none" display="none"></path><path id="kity_path_1233" fill="none" stroke="none" display="none"></path><path id="kity_path_1235" fill="none" stroke="none" display="none"></path><path id="kity_path_1237" fill="none" stroke="none" display="none"></path><path id="kity_path_1239" fill="none" stroke="none" display="none"></path><path id="kity_path_1241" fill="none" stroke="none" display="none"></path><path id="kity_path_1243" fill="none" stroke="none" display="none"></path><path id="kity_path_1245" fill="none" stroke="none" display="none"></path><path id="kity_path_1247" fill="none" stroke="none" display="none"></path><path id="kity_path_1249" fill="none" stroke="none" display="none"></path><path id="kity_path_1251" fill="none" stroke="none" display="none"></path><path id="kity_path_1253" fill="none" stroke="none" display="none"></path><path id="kity_path_1255" fill="none" stroke="none" display="none"></path><path id="kity_path_1257" fill="none" stroke="none" display="none"></path><path id="kity_path_1259" fill="none" stroke="none" display="none"></path><path id="kity_path_1261" fill="none" stroke="none" display="none"></path><path id="kity_path_1263" fill="none" stroke="none" display="none"></path><path id="kity_path_1265" fill="none" stroke="none" display="none"></path><path id="kity_path_1267" fill="none" stroke="none" display="none"></path><path id="kity_path_1269" fill="none" stroke="none" display="none"></path><path id="kity_path_1271" fill="none" stroke="none" display="none"></path><path id="kity_path_1273" fill="none" stroke="none" display="none"></path><path id="kity_path_1275" fill="none" stroke="none" display="none"></path><path id="kity_path_1277" fill="none" stroke="none" display="none"></path><path id="kity_path_1279" fill="none" stroke="none" display="none"></path><path id="kity_path_1281" fill="none" stroke="none" display="none"></path><path id="kity_path_1283" fill="none" stroke="none" display="none"></path><path id="kity_path_1285" fill="none" stroke="none" display="none"></path><path id="kity_path_1287" fill="none" stroke="none" display="none"></path><path id="kity_path_1289" fill="none" stroke="none" display="none"></path><path id="kity_path_1291" fill="none" stroke="none" display="none"></path><path id="kity_path_1293" fill="none" stroke="none" display="none"></path><path id="kity_path_1295" fill="none" stroke="none" display="none"></path><path id="kity_path_1297" fill="none" stroke="none" display="none"></path><path id="kity_path_1299" fill="none" stroke="none" display="none"></path><path id="kity_path_1301" fill="none" stroke="none" display="none"></path><path id="kity_path_1303" fill="none" stroke="none" display="none"></path><path id="kity_path_1305" fill="none" stroke="none" display="none"></path><path id="kity_path_1307" fill="none" stroke="none" display="none"></path><path id="kity_path_1309" fill="none" stroke="none" display="none"></path><path id="kity_path_1311" fill="none" stroke="none" display="none"></path><path id="kity_path_1313" fill="none" stroke="none" display="none"></path><path id="kity_path_1315" fill="none" stroke="none" display="none"></path><path id="kity_path_1317" fill="none" stroke="none" display="none"></path><path id="kity_path_1319" fill="none" stroke="none" display="none"></path><path id="kity_path_1321" fill="none" stroke="none" display="none"></path><path id="kity_path_1323" fill="none" stroke="none" display="none"></path><path id="kity_path_1325" fill="none" stroke="none" display="none"></path><path id="kity_path_1327" fill="none" stroke="none" display="none"></path><path id="kity_path_1329" fill="none" stroke="none" display="none"></path><path id="kity_path_1331" fill="none" stroke="none" display="none"></path><path id="kity_path_1333" fill="none" stroke="none" display="none"></path><path id="kity_path_1335" fill="none" stroke="none" display="none"></path><path id="kity_path_1337" fill="none" stroke="none" display="none"></path><path id="kity_path_1339" fill="none" stroke="none" display="none"></path><path id="kity_path_1341" fill="none" stroke="none" display="none"></path><path id="kity_path_1343" fill="none" stroke="none" display="none"></path><path id="kity_path_1345" fill="none" stroke="none" display="none"></path><path id="kity_path_1347" fill="none" stroke="none" display="none"></path><path id="kity_path_1349" fill="none" stroke="none" display="none"></path><path id="kity_path_1351" fill="none" stroke="none" display="none"></path><path id="kity_path_1353" fill="none" stroke="none" display="none"></path><path id="kity_path_1355" fill="none" stroke="none" display="none"></path><path id="kity_path_1357" fill="none" stroke="none" display="none"></path><path id="kity_path_1359" fill="none" stroke="none" display="none"></path><path id="kity_path_1361" fill="none" stroke="none" display="none"></path><path id="kity_path_1363" fill="none" stroke="none" display="none"></path><path id="kity_path_1365" fill="none" stroke="none" display="none"></path><path id="kity_path_1367" fill="none" stroke="none" display="none"></path><path id="kity_path_1369" fill="none" stroke="none" display="none"></path><path id="kity_path_1371" fill="none" stroke="none" display="none"></path><path id="kity_path_1373" fill="none" stroke="none" display="none"></path><path id="kity_path_1375" fill="none" stroke="none" display="none"></path><path id="kity_path_1377" fill="none" stroke="none" display="none"></path><path id="kity_path_1379" fill="none" stroke="none" display="none"></path><path id="kity_path_1381" fill="none" stroke="none" display="none"></path><path id="kity_path_1383" fill="none" stroke="none" display="none"></path><path id="kity_path_1385" fill="none" stroke="none" display="none"></path><path id="kity_path_1387" fill="none" stroke="none" display="none"></path><path id="kity_path_1389" fill="none" stroke="none" display="none"></path><path id="kity_path_1391" fill="none" stroke="none" display="none"></path><path id="kity_path_1393" fill="none" stroke="none" display="none"></path><path id="kity_path_1395" fill="none" stroke="none" display="none"></path><path id="kity_path_1397" fill="none" stroke="none" display="none"></path><path id="kity_path_1399" fill="none" stroke="none" display="none"></path><path id="kity_path_1401" fill="none" stroke="none" display="none"></path><path id="kity_path_1403" fill="none" stroke="none" display="none"></path><path id="kity_path_1405" fill="none" stroke="none" display="none"></path><path id="kity_path_1407" fill="none" stroke="none" display="none"></path><path id="kity_path_1409" fill="none" stroke="none" display="none"></path><path id="kity_path_1411" fill="none" stroke="none" display="none"></path><path id="kity_path_1413" fill="none" stroke="none" display="none"></path><path id="kity_path_1415" fill="none" stroke="none" display="none"></path><path id="kity_path_1417" fill="none" stroke="none" display="none"></path><path id="kity_path_1419" fill="none" stroke="none" display="none"></path><path id="kity_path_1421" fill="none" stroke="none" display="none"></path><path id="kity_path_1423" fill="none" stroke="none" display="none"></path><path id="kity_path_1425" fill="none" stroke="none" display="none"></path><path id="kity_path_1427" fill="none" stroke="none" display="none"></path><path id="kity_path_1429" fill="none" stroke="none" display="none"></path><path id="kity_path_1431" fill="none" stroke="none" display="none"></path><path id="kity_path_1433" fill="none" stroke="none" display="none"></path><path id="kity_path_1435" fill="none" stroke="none" display="none"></path><path id="kity_path_1437" fill="none" stroke="none" display="none"></path><path id="kity_path_1439" fill="none" stroke="none" display="none"></path><path id="kity_path_1441" fill="none" stroke="none" display="none"></path><path id="kity_path_1443" fill="none" stroke="none" display="none"></path><path id="kity_path_1445" fill="none" stroke="none" display="none"></path><path id="kity_path_1447" fill="none" stroke="none" display="none"></path><path id="kity_path_1449" fill="none" stroke="none" display="none"></path><path id="kity_path_1451" fill="none" stroke="none" display="none"></path><path id="kity_path_1453" fill="none" stroke="none" display="none"></path><path id="kity_path_1455" fill="none" stroke="none" display="none"></path><path id="kity_path_1457" fill="none" stroke="none" display="none"></path><path id="kity_path_1459" fill="none" stroke="none" display="none"></path><path id="kity_path_1461" fill="none" stroke="none" display="none"></path><path id="kity_path_1463" fill="none" stroke="none" display="none"></path><path id="kity_path_1465" fill="none" stroke="none" display="none"></path><path id="kity_path_1467" fill="none" stroke="none" display="none"></path><path id="kity_path_1469" fill="none" stroke="none" display="none"></path><path id="kity_path_1471" fill="none" stroke="none" display="none"></path><path id="kity_path_1473" fill="none" stroke="none" display="none"></path><path id="kity_path_1475" fill="none" stroke="none" display="none"></path><path id="kity_path_1477" fill="none" stroke="none" display="none"></path><path id="kity_path_1479" fill="none" stroke="none" display="none"></path><path id="kity_path_1481" fill="none" stroke="none" display="none"></path><path id="kity_path_1483" fill="none" stroke="none" display="none"></path><path id="kity_path_1485" fill="none" stroke="none" display="none"></path><path id="kity_path_1487" fill="none" stroke="none" display="none"></path><path id="kity_path_1489" fill="none" stroke="none" display="none"></path><path id="kity_path_1491" fill="none" stroke="none" display="none"></path><path id="kity_path_1493" fill="none" stroke="none" display="none"></path><path id="kity_path_1495" fill="none" stroke="none" display="none"></path><path id="kity_path_1497" fill="none" stroke="none" display="none"></path><path id="kity_path_1499" fill="none" stroke="none" display="none"></path><path id="kity_path_1501" fill="none" stroke="none" display="none"></path><path id="kity_path_1503" fill="none" stroke="none" display="none"></path><path id="kity_path_1505" fill="none" stroke="none" display="none"></path><path id="kity_path_1507" fill="none" stroke="none" display="none"></path><path id="kity_path_1509" fill="none" stroke="none" display="none"></path><path id="kity_path_1511" fill="none" stroke="none" display="none"></path><path id="kity_path_1513" fill="none" stroke="none" display="none"></path><path id="kity_path_1515" fill="none" stroke="none" display="none"></path><path id="kity_path_1517" fill="none" stroke="none" display="none"></path><path id="kity_path_1519" fill="none" stroke="none" display="none"></path><path id="kity_path_1521" fill="none" stroke="none" display="none"></path><path id="kity_path_1523" fill="none" stroke="none" display="none"></path><path id="kity_path_1525" fill="none" stroke="none" display="none"></path><path id="kity_path_1527" fill="none" stroke="none" display="none"></path><path id="kity_path_1529" fill="none" stroke="none" display="none"></path><path id="kity_path_1531" fill="none" stroke="none" display="none"></path><path id="kity_path_1533" fill="none" stroke="none" display="none"></path><path id="kity_path_1535" fill="none" stroke="none" display="none"></path><path id="kity_path_1537" fill="none" stroke="none" display="none"></path><path id="kity_path_1539" fill="none" stroke="none" display="none"></path><path id="kity_path_1541" fill="none" stroke="none" display="none"></path><path id="kity_path_1543" fill="none" stroke="none" display="none"></path><path id="kity_path_1545" fill="none" stroke="none" display="none"></path><path id="kity_path_1547" fill="none" stroke="none" display="none"></path><path id="kity_path_1549" fill="none" stroke="none" display="none"></path><path id="kity_path_1551" fill="none" stroke="none" display="none"></path><path id="kity_path_1553" fill="none" stroke="none" display="none"></path><path id="kity_path_1555" fill="none" stroke="none" display="none"></path><path id="kity_path_1557" fill="none" stroke="none" display="none"></path><path id="kity_path_1559" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M351.5,15577.5A45,15376,0,0,1,396.5,201.5"></path><path id="kity_path_1561" fill="none" stroke="none" display="none"></path><path id="kity_path_1563" fill="none" stroke="none" display="none"></path><path id="kity_path_1565" fill="none" stroke="none" display="none"></path><path id="kity_path_1567" fill="none" stroke="none" display="none"></path><path id="kity_path_1569" fill="none" stroke="none" display="none"></path><path id="kity_path_1571" fill="none" stroke="none" display="none"></path><path id="kity_path_1573" fill="none" stroke="none" display="none"></path><path id="kity_path_1575" fill="none" stroke="none" display="none"></path><path id="kity_path_1577" fill="none" stroke="none" display="none"></path><path id="kity_path_1579" fill="none" stroke="none" display="none"></path><path id="kity_path_1581" fill="none" stroke="none" display="none"></path><path id="kity_path_1583" fill="none" stroke="none" display="none"></path><path id="kity_path_1585" fill="none" stroke="none" display="none"></path><path id="kity_path_1587" fill="none" stroke="none" display="none"></path><path id="kity_path_1589" fill="none" stroke="none" display="none"></path><path id="kity_path_1591" fill="none" stroke="none" display="none"></path><path id="kity_path_1593" fill="none" stroke="none" display="none"></path><path id="kity_path_1595" fill="none" stroke="none" display="none"></path><path id="kity_path_1597" fill="none" stroke="none" display="none"></path><path id="kity_path_1599" fill="none" stroke="none" display="none"></path><path id="kity_path_1601" fill="none" stroke="none" display="none"></path><path id="kity_path_1603" fill="none" stroke="none" display="none"></path><path id="kity_path_1605" fill="none" stroke="none" display="none"></path><path id="kity_path_1607" fill="none" stroke="none" display="none"></path><path id="kity_path_1609" fill="none" stroke="none" display="none"></path><path id="kity_path_1611" fill="none" stroke="none" display="none"></path><path id="kity_path_1613" fill="none" stroke="none" display="none"></path><path id="kity_path_1615" fill="none" stroke="none" display="none"></path><path id="kity_path_1617" fill="none" stroke="none" display="none"></path><path id="kity_path_1619" fill="none" stroke="none" display="none"></path><path id="kity_path_1621" fill="none" stroke="none" display="none"></path><path id="kity_path_1623" fill="none" stroke="none" display="none"></path><path id="kity_path_1625" fill="none" stroke="none" display="none"></path><path id="kity_path_1627" fill="none" stroke="none" display="none"></path><path id="kity_path_1629" fill="none" stroke="none" display="none"></path><path id="kity_path_1631" fill="none" stroke="none" display="none"></path><path id="kity_path_1633" fill="none" stroke="none" display="none"></path><path id="kity_path_1635" fill="none" stroke="none" display="none"></path><path id="kity_path_1637" fill="none" stroke="none" display="none"></path><path id="kity_path_1639" fill="none" stroke="none" display="none"></path><path id="kity_path_1641" fill="none" stroke="none" display="none"></path><path id="kity_path_1643" fill="none" stroke="none" display="none"></path><path id="kity_path_1645" fill="none" stroke="none" display="none"></path><path id="kity_path_1647" fill="none" stroke="none" display="none"></path><path id="kity_path_1649" fill="none" stroke="none" display="none"></path><path id="kity_path_1651" fill="none" stroke="none" display="none"></path><path id="kity_path_1653" fill="none" stroke="none" display="none"></path><path id="kity_path_1655" fill="none" stroke="none" display="none"></path><path id="kity_path_1657" fill="none" stroke="none" display="none"></path><path id="kity_path_1659" fill="none" stroke="none" display="none"></path><path id="kity_path_1661" fill="none" stroke="none" display="none"></path><path id="kity_path_1663" fill="none" stroke="none" display="none"></path><path id="kity_path_1665" fill="none" stroke="none" display="none"></path><path id="kity_path_1667" fill="none" stroke="none" display="none"></path><path id="kity_path_1669" fill="none" stroke="none" display="none"></path><path id="kity_path_1671" fill="none" stroke="none" display="none"></path><path id="kity_path_1673" fill="none" stroke="none" display="none"></path><path id="kity_path_1675" fill="none" stroke="none" display="none"></path><path id="kity_path_1677" fill="none" stroke="none" display="none"></path><path id="kity_path_1679" fill="none" stroke="none" display="none"></path><path id="kity_path_1681" fill="none" stroke="none" display="none"></path><path id="kity_path_1683" fill="none" stroke="none" display="none"></path><path id="kity_path_1685" fill="none" stroke="none" display="none"></path><path id="kity_path_1687" fill="none" stroke="none" display="none"></path><path id="kity_path_1689" fill="none" stroke="none" display="none"></path><path id="kity_path_1691" fill="none" stroke="none" display="none"></path><path id="kity_path_1693" fill="none" stroke="none" display="none"></path><path id="kity_path_1695" fill="none" stroke="none" display="none"></path><path id="kity_path_1697" fill="none" stroke="none" display="none"></path><path id="kity_path_1699" fill="none" stroke="none" display="none"></path><path id="kity_path_1701" fill="none" stroke="none" display="none"></path><path id="kity_path_1703" fill="none" stroke="none" display="none"></path><path id="kity_path_1705" fill="none" stroke="none" display="none"></path><path id="kity_path_1707" fill="none" stroke="none" display="none"></path><path id="kity_path_1709" fill="none" stroke="none" display="none"></path><path id="kity_path_1711" fill="none" stroke="none" display="none"></path><path id="kity_path_1713" fill="none" stroke="none" display="none"></path><path id="kity_path_1715" fill="none" stroke="none" display="none"></path><path id="kity_path_1717" fill="none" stroke="none" display="none"></path><path id="kity_path_1719" fill="none" stroke="none" display="none"></path><path id="kity_path_1721" fill="none" stroke="none" display="none"></path><path id="kity_path_1723" fill="none" stroke="none" display="none"></path><path id="kity_path_1725" fill="none" stroke="none" display="none"></path><path id="kity_path_1727" fill="none" stroke="none" display="none"></path><path id="kity_path_1729" fill="none" stroke="none" display="none"></path><path id="kity_path_1731" fill="none" stroke="none" display="none"></path><path id="kity_path_1733" fill="none" stroke="none" display="none"></path><path id="kity_path_1735" fill="none" stroke="none" display="none"></path><path id="kity_path_1737" fill="none" stroke="none" display="none"></path><path id="kity_path_1739" fill="none" stroke="none" display="none"></path><path id="kity_path_1741" fill="none" stroke="none" display="none"></path><path id="kity_path_1743" fill="none" stroke="none" display="none"></path><path id="kity_path_1745" fill="none" stroke="none" display="none"></path><path id="kity_path_1747" fill="none" stroke="none" display="none"></path><path id="kity_path_1749" fill="none" stroke="none" display="none"></path><path id="kity_path_1751" fill="none" stroke="none" display="none"></path><path id="kity_path_1753" fill="none" stroke="none" display="none"></path><path id="kity_path_1755" fill="none" stroke="none" display="none"></path><path id="kity_path_1757" fill="none" stroke="none" display="none"></path><path id="kity_path_1759" fill="none" stroke="none" display="none"></path><path id="kity_path_1761" fill="none" stroke="none" display="none"></path><path id="kity_path_1763" fill="none" stroke="none" display="none"></path><path id="kity_path_1765" fill="none" stroke="none" display="none"></path><path id="kity_path_1767" fill="none" stroke="none" display="none"></path><path id="kity_path_1769" fill="none" stroke="none" display="none"></path><path id="kity_path_1771" fill="none" stroke="none" display="none"></path><path id="kity_path_1773" fill="none" stroke="none" display="none"></path><path id="kity_path_1775" fill="none" stroke="none" display="none"></path><path id="kity_path_1777" fill="none" stroke="none" display="none"></path><path id="kity_path_1779" fill="none" stroke="none" display="none"></path><path id="kity_path_1781" fill="none" stroke="none" display="none"></path><path id="kity_path_1783" fill="none" stroke="none" display="none"></path><path id="kity_path_1785" fill="none" stroke="none" display="none"></path><path id="kity_path_1787" fill="none" stroke="none" display="none"></path><path id="kity_path_1789" fill="none" stroke="none" display="none"></path><path id="kity_path_1791" fill="none" stroke="none" display="none"></path><path id="kity_path_1793" fill="none" stroke="none" display="none"></path><path id="kity_path_1795" fill="none" stroke="none" display="none"></path><path id="kity_path_1797" fill="none" stroke="none" display="none"></path><path id="kity_path_1799" fill="none" stroke="none" display="none"></path><path id="kity_path_1801" fill="none" stroke="none" display="none"></path><path id="kity_path_1803" fill="none" stroke="none" display="none"></path><path id="kity_path_1805" fill="none" stroke="none" display="none"></path><path id="kity_path_1807" fill="none" stroke="none" display="none"></path><path id="kity_path_1809" fill="none" stroke="none" display="none"></path><path id="kity_path_1811" fill="none" stroke="none" display="none"></path><path id="kity_path_1813" fill="none" stroke="none" display="none"></path><path id="kity_path_1815" fill="none" stroke="none" display="none"></path><path id="kity_path_1817" fill="none" stroke="none" display="none"></path><path id="kity_path_1819" fill="none" stroke="none" display="none"></path><path id="kity_path_1821" fill="none" stroke="none" display="none"></path><path id="kity_path_1823" fill="none" stroke="none" display="none"></path><path id="kity_path_1825" fill="none" stroke="none" display="none"></path><path id="kity_path_1827" fill="none" stroke="none" display="none"></path><path id="kity_path_1829" fill="none" stroke="none" display="none"></path><path id="kity_path_1831" fill="none" stroke="none" display="none"></path><path id="kity_path_1833" fill="none" stroke="none" display="none"></path><path id="kity_path_1835" fill="none" stroke="none" display="none"></path><path id="kity_path_1837" fill="none" stroke="none" display="none"></path><path id="kity_path_1839" fill="none" stroke="none" display="none"></path><path id="kity_path_1841" fill="none" stroke="none" display="none"></path><path id="kity_path_1843" fill="none" stroke="none" display="none"></path><path id="kity_path_1845" fill="none" stroke="none" display="none"></path><path id="kity_path_1847" fill="none" stroke="none" display="none"></path><path id="kity_path_1849" fill="none" stroke="none" display="none"></path><path id="kity_path_1851" fill="none" stroke="none" display="none"></path><path id="kity_path_1853" fill="none" stroke="none" display="none"></path><path id="kity_path_1855" fill="none" stroke="none" display="none"></path><path id="kity_path_1857" fill="none" stroke="none" display="none"></path><path id="kity_path_1859" fill="none" stroke="none" display="none"></path><path id="kity_path_1861" fill="none" stroke="none" display="none"></path><path id="kity_path_1863" fill="none" stroke="none" display="none"></path><path id="kity_path_1865" fill="none" stroke="none" display="none"></path><path id="kity_path_1867" fill="none" stroke="none" display="none"></path><path id="kity_path_1869" fill="none" stroke="none" display="none"></path><path id="kity_path_1871" fill="none" stroke="none" display="none"></path><path id="kity_path_1873" fill="none" stroke="none" display="none"></path><path id="kity_path_1875" fill="none" stroke="none" display="none"></path><path id="kity_path_1877" fill="none" stroke="none" display="none"></path><path id="kity_path_1879" fill="none" stroke="none" display="none"></path><path id="kity_path_1881" fill="none" stroke="none" display="none"></path><path id="kity_path_1883" fill="none" stroke="none" display="none"></path><path id="kity_path_1885" fill="none" stroke="none" display="none"></path><path id="kity_path_1887" fill="none" stroke="none" display="none"></path><path id="kity_path_1889" fill="none" stroke="none" display="none"></path><path id="kity_path_1891" fill="none" stroke="none" display="none"></path><path id="kity_path_1893" fill="none" stroke="none" display="none"></path><path id="kity_path_1895" fill="none" stroke="none" display="none"></path><path id="kity_path_1897" fill="none" stroke="none" display="none"></path><path id="kity_path_1899" fill="none" stroke="none" display="none"></path><path id="kity_path_1901" fill="none" stroke="none" display="none"></path><path id="kity_path_1903" fill="none" stroke="none" display="none"></path><path id="kity_path_1905" fill="none" stroke="none" display="none"></path><path id="kity_path_1907" fill="none" stroke="none" display="none"></path><path id="kity_path_1909" fill="none" stroke="none" display="none"></path><path id="kity_path_1911" fill="none" stroke="none" display="none"></path><path id="kity_path_1913" fill="none" stroke="none" display="none"></path><path id="kity_path_1915" fill="none" stroke="none" display="none"></path><path id="kity_path_1917" fill="none" stroke="none" display="none"></path><path id="kity_path_1919" fill="none" stroke="none" display="none"></path><path id="kity_path_1921" fill="none" stroke="none" display="none"></path><path id="kity_path_1923" fill="none" stroke="none" display="none"></path><path id="kity_path_1925" fill="none" stroke="none" display="none"></path><path id="kity_path_1927" fill="none" stroke="none" display="none"></path><path id="kity_path_1929" fill="none" stroke="none" display="none"></path><path id="kity_path_1931" fill="none" stroke="none" display="none"></path><path id="kity_path_1933" fill="none" stroke="none" display="none"></path><path id="kity_path_1935" fill="none" stroke="none" display="none"></path><path id="kity_path_1937" fill="none" stroke="none" display="none"></path><path id="kity_path_1939" fill="none" stroke="none" display="none"></path><path id="kity_path_1941" fill="none" stroke="none" display="none"></path><path id="kity_path_1943" fill="none" stroke="none" display="none"></path><path id="kity_path_1945" fill="none" stroke="none" display="none"></path><path id="kity_path_1947" fill="none" stroke="none" display="none"></path><path id="kity_path_1949" fill="none" stroke="none" display="none"></path><path id="kity_path_1951" fill="none" stroke="none" display="none"></path><path id="kity_path_1953" fill="none" stroke="none" display="none"></path><path id="kity_path_1955" fill="none" stroke="none" display="none"></path><path id="kity_path_1957" fill="none" stroke="none" display="none"></path><path id="kity_path_1959" fill="none" stroke="none" display="none"></path><path id="kity_path_1961" fill="none" stroke="none" display="none"></path><path id="kity_path_1963" fill="none" stroke="none" display="none"></path><path id="kity_path_1965" fill="none" stroke="none" display="none"></path><path id="kity_path_1967" fill="none" stroke="none" display="none"></path><path id="kity_path_1969" fill="none" stroke="none" display="none"></path><path id="kity_path_1971" fill="none" stroke="none" display="none"></path><path id="kity_path_1973" fill="none" stroke="none" display="none"></path><path id="kity_path_1975" fill="none" stroke="none" display="none"></path><path id="kity_path_1977" fill="none" stroke="none" display="none"></path><path id="kity_path_1979" fill="none" stroke="none" display="none"></path><path id="kity_path_1981" fill="none" stroke="none" display="none"></path><path id="kity_path_1983" fill="none" stroke="none" display="none"></path><path id="kity_path_1985" fill="none" stroke="none" display="none"></path><path id="kity_path_1987" fill="none" stroke="none" display="none"></path><path id="kity_path_1989" fill="none" stroke="none" display="none"></path><path id="kity_path_1991" fill="none" stroke="none" display="none"></path><path id="kity_path_1993" fill="none" stroke="none" display="none"></path><path id="kity_path_1995" fill="none" stroke="none" display="none"></path><path id="kity_path_1997" fill="none" stroke="none" display="none"></path><path id="kity_path_1999" fill="none" stroke="none" display="none"></path><path id="kity_path_2001" fill="none" stroke="none" display="none"></path><path id="kity_path_2003" fill="none" stroke="none" display="none"></path><path id="kity_path_2005" fill="none" stroke="none" display="none"></path><path id="kity_path_2007" fill="none" stroke="none" display="none"></path><path id="kity_path_2009" fill="none" stroke="none" display="none"></path><path id="kity_path_2011" fill="none" stroke="none" display="none"></path><path id="kity_path_2013" fill="none" stroke="none" display="none"></path><path id="kity_path_2015" fill="none" stroke="none" display="none"></path><path id="kity_path_2017" fill="none" stroke="none" display="none"></path><path id="kity_path_2019" fill="none" stroke="none" display="none"></path><path id="kity_path_2021" fill="none" stroke="none" display="none"></path><path id="kity_path_2023" fill="none" stroke="none" display="none"></path><path id="kity_path_2025" fill="none" stroke="none" display="none"></path><path id="kity_path_2027" fill="none" stroke="none" display="none"></path><path id="kity_path_2029" fill="none" stroke="none" display="none"></path><path id="kity_path_2031" fill="none" stroke="none" display="none"></path><path id="kity_path_2033" fill="none" stroke="none" display="none"></path><path id="kity_path_2035" fill="none" stroke="none" display="none"></path><path id="kity_path_2037" fill="none" stroke="none" display="none"></path><path id="kity_path_2039" fill="none" stroke="none" display="none"></path><path id="kity_path_2041" fill="none" stroke="none" display="none"></path><path id="kity_path_2043" fill="none" stroke="none" display="none"></path><path id="kity_path_2045" fill="none" stroke="none" display="none"></path><path id="kity_path_2047" fill="none" stroke="none" display="none"></path><path id="kity_path_2049" fill="none" stroke="none" display="none"></path><path id="kity_path_2051" fill="none" stroke="none" display="none"></path><path id="kity_path_2053" fill="none" stroke="none" display="none"></path><path id="kity_path_2055" fill="none" stroke="none" display="none"></path><path id="kity_path_2057" fill="none" stroke="none" display="none"></path><path id="kity_path_2059" fill="none" stroke="none" display="none"></path><path id="kity_path_2061" fill="none" stroke="none" display="none"></path><path id="kity_path_2063" fill="none" stroke="none" display="none"></path><path id="kity_path_2065" fill="none" stroke="none" display="none"></path><path id="kity_path_2067" fill="none" stroke="none" display="none"></path><path id="kity_path_2069" fill="none" stroke="none" display="none"></path><path id="kity_path_2071" fill="none" stroke="none" display="none"></path><path id="kity_path_2073" fill="none" stroke="none" display="none"></path><path id="kity_path_2075" fill="none" stroke="none" display="none"></path><path id="kity_path_2077" fill="none" stroke="none" display="none"></path><path id="kity_path_2079" fill="none" stroke="none" display="none"></path><path id="kity_path_2081" fill="none" stroke="none" display="none"></path><path id="kity_path_2083" fill="none" stroke="none" display="none"></path><path id="kity_path_2085" fill="none" stroke="none" display="none"></path><path id="kity_path_2087" fill="none" stroke="none" display="none"></path><path id="kity_path_2089" fill="none" stroke="none" display="none"></path><path id="kity_path_2091" fill="none" stroke="none" display="none"></path><path id="kity_path_2093" fill="none" stroke="none" display="none"></path><path id="kity_path_2095" fill="none" stroke="none" display="none"></path><path id="kity_path_2097" fill="none" stroke="none" display="none"></path><path id="kity_path_2099" fill="none" stroke="none" display="none"></path><path id="kity_path_2101" fill="none" stroke="none" display="none"></path><path id="kity_path_2103" fill="none" stroke="none" display="none"></path><path id="kity_path_2105" fill="none" stroke="none" display="none"></path><path id="kity_path_2107" fill="none" stroke="none" display="none"></path><path id="kity_path_2109" fill="none" stroke="none" display="none"></path><path id="kity_path_2111" fill="none" stroke="none" display="none"></path><path id="kity_path_2113" fill="none" stroke="none" display="none"></path><path id="kity_path_2115" fill="none" stroke="none" display="none"></path><path id="kity_path_2117" fill="none" stroke="none" display="none"></path><path id="kity_path_2119" fill="none" stroke="none" display="none"></path><path id="kity_path_2121" fill="none" stroke="none" display="none"></path><path id="kity_path_2123" fill="none" stroke="none" display="none"></path><path id="kity_path_2125" fill="none" stroke="none" display="none"></path><path id="kity_path_2127" fill="none" stroke="none" display="none"></path><path id="kity_path_2129" fill="none" stroke="none" display="none"></path><path id="kity_path_2131" fill="none" stroke="none" display="none"></path><path id="kity_path_2133" fill="none" stroke="none" display="none"></path><path id="kity_path_2135" fill="none" stroke="none" display="none"></path><path id="kity_path_2137" fill="none" stroke="none" display="none"></path><path id="kity_path_2139" fill="none" stroke="none" display="none"></path><path id="kity_path_2141" fill="none" stroke="none" display="none"></path><path id="kity_path_2143" fill="none" stroke="none" display="none"></path><path id="kity_path_2145" fill="none" stroke="none" display="none"></path><path id="kity_path_2147" fill="none" stroke="none" display="none"></path><path id="kity_path_2149" fill="none" stroke="none" display="none"></path><path id="kity_path_2151" fill="none" stroke="none" display="none"></path><path id="kity_path_2153" fill="none" stroke="none" display="none"></path><path id="kity_path_2155" fill="none" stroke="none" display="none"></path><path id="kity_path_2157" fill="none" stroke="none" display="none"></path><path id="kity_path_2159" fill="none" stroke="none" display="none"></path><path id="kity_path_2161" fill="none" stroke="none" display="none"></path><path id="kity_path_2163" fill="none" stroke="none" display="none"></path><path id="kity_path_2165" fill="none" stroke="none" display="none"></path><path id="kity_path_2167" fill="none" stroke="none" display="none"></path><path id="kity_path_2169" fill="none" stroke="none" display="none"></path><path id="kity_path_2171" fill="none" stroke="none" display="none"></path><path id="kity_path_2173" fill="none" stroke="none" display="none"></path><path id="kity_path_2175" fill="none" stroke="none" display="none"></path><path id="kity_path_2177" fill="none" stroke="none" display="none"></path><path id="kity_path_2179" fill="none" stroke="none" display="none"></path><path id="kity_path_2181" fill="none" stroke="none" display="none"></path><path id="kity_path_2183" fill="none" stroke="none" display="none"></path><path id="kity_path_2185" fill="none" stroke="none" display="none"></path><path id="kity_path_2187" fill="none" stroke="none" display="none"></path><path id="kity_path_2189" fill="none" stroke="none" display="none"></path><path id="kity_path_2191" fill="none" stroke="none" display="none"></path><path id="kity_path_2193" fill="none" stroke="none" display="none"></path><path id="kity_path_2195" fill="none" stroke="none" display="none"></path><path id="kity_path_2197" fill="none" stroke="none" display="none"></path><path id="kity_path_2199" fill="none" stroke="none" display="none"></path><path id="kity_path_2201" fill="none" stroke="none" display="none"></path><path id="kity_path_2203" fill="none" stroke="none" display="none"></path><path id="kity_path_2205" fill="none" stroke="none" display="none"></path><path id="kity_path_2207" fill="none" stroke="none" display="none"></path><path id="kity_path_2209" fill="none" stroke="none" display="none"></path><path id="kity_path_2211" fill="none" stroke="none" display="none"></path><path id="kity_path_2213" fill="none" stroke="none" display="none"></path><path id="kity_path_2215" fill="none" stroke="none" display="none"></path><path id="kity_path_2217" fill="none" stroke="none" display="none"></path><path id="kity_path_2219" fill="none" stroke="none" display="none"></path><path id="kity_path_2221" fill="none" stroke="none" display="none"></path><path id="kity_path_2223" fill="none" stroke="none" display="none"></path><path id="kity_path_2225" fill="none" stroke="none" display="none"></path><path id="kity_path_2227" fill="none" stroke="none" display="none"></path><path id="kity_path_2229" fill="none" stroke="none" display="none"></path><path id="kity_path_2231" fill="none" stroke="none" display="none"></path><path id="kity_path_2233" fill="none" stroke="none" display="none"></path><path id="kity_path_2235" fill="none" stroke="none" display="none"></path><path id="kity_path_2237" fill="none" stroke="none" display="none"></path><path id="kity_path_2239" fill="none" stroke="none" display="none"></path><path id="kity_path_2241" fill="none" stroke="none" display="none"></path><path id="kity_path_2243" fill="none" stroke="none" display="none"></path><path id="kity_path_2245" fill="none" stroke="none" display="none"></path><path id="kity_path_2247" fill="none" stroke="none" display="none"></path><path id="kity_path_2249" fill="none" stroke="none" display="none"></path><path id="kity_path_2251" fill="none" stroke="none" display="none"></path><path id="kity_path_2253" fill="none" stroke="none" display="none"></path><path id="kity_path_2255" fill="none" stroke="none" display="none"></path><path id="kity_path_2257" fill="none" stroke="none" display="none"></path><path id="kity_path_2259" fill="none" stroke="none" display="none"></path><path id="kity_path_2261" fill="none" stroke="none" display="none"></path><path id="kity_path_2263" fill="none" stroke="none" display="none"></path><path id="kity_path_2265" fill="none" stroke="none" display="none"></path><path id="kity_path_2267" fill="none" stroke="none" display="none"></path><path id="kity_path_2269" fill="none" stroke="none" display="none"></path><path id="kity_path_2271" fill="none" stroke="none" display="none"></path><path id="kity_path_2273" fill="none" stroke="none" display="none"></path><path id="kity_path_2275" fill="none" stroke="none" display="none"></path><path id="kity_path_2277" fill="none" stroke="none" display="none"></path><path id="kity_path_2279" fill="none" stroke="none" display="none"></path><path id="kity_path_2281" fill="none" stroke="none" display="none"></path><path id="kity_path_2283" fill="none" stroke="none" display="none"></path><path id="kity_path_2285" fill="none" stroke="none" display="none"></path><path id="kity_path_2287" fill="none" stroke="none" display="none"></path><path id="kity_path_2289" fill="none" stroke="none" display="none"></path><path id="kity_path_2291" fill="none" stroke="none" display="none"></path><path id="kity_path_2293" fill="none" stroke="none" display="none"></path><path id="kity_path_2295" fill="none" stroke="none" display="none"></path><path id="kity_path_2297" fill="none" stroke="none" display="none"></path><path id="kity_path_2299" fill="none" stroke="none" display="none"></path><path id="kity_path_2301" fill="none" stroke="none" display="none"></path><path id="kity_path_2303" fill="none" stroke="none" display="none"></path><path id="kity_path_2305" fill="none" stroke="none" display="none"></path><path id="kity_path_2307" fill="none" stroke="none" display="none"></path><path id="kity_path_2309" fill="none" stroke="none" display="none"></path><path id="kity_path_2311" fill="none" stroke="none" display="none"></path><path id="kity_path_2313" fill="none" stroke="none" display="none"></path><path id="kity_path_2315" fill="none" stroke="none" display="none"></path><path id="kity_path_2317" fill="none" stroke="none" display="none"></path><path id="kity_path_2319" fill="none" stroke="none" display="none"></path><path id="kity_path_2321" fill="none" stroke="none" display="none"></path><path id="kity_path_2323" fill="none" stroke="none" display="none"></path><path id="kity_path_2325" fill="none" stroke="none" display="none"></path><path id="kity_path_2327" fill="none" stroke="none" display="none"></path><path id="kity_path_2329" fill="none" stroke="none" display="none"></path><path id="kity_path_2331" fill="none" stroke="none" display="none"></path><path id="kity_path_2333" fill="none" stroke="none" display="none"></path><path id="kity_path_2335" fill="none" stroke="none" display="none"></path><path id="kity_path_2337" fill="none" stroke="none" display="none"></path><path id="kity_path_2339" fill="none" stroke="none" display="none"></path><path id="kity_path_2341" fill="none" stroke="none" display="none"></path><path id="kity_path_2343" fill="none" stroke="none" display="none"></path><path id="kity_path_2345" fill="none" stroke="none" display="none"></path><path id="kity_path_2347" fill="none" stroke="none" display="none"></path><path id="kity_path_2349" fill="none" stroke="none" display="none"></path><path id="kity_path_2351" fill="none" stroke="none" display="none"></path><path id="kity_path_2353" fill="none" stroke="none" display="none"></path><path id="kity_path_2355" fill="none" stroke="none" display="none"></path><path id="kity_path_2357" fill="none" stroke="none" display="none"></path><path id="kity_path_2359" fill="none" stroke="none" display="none"></path><path id="kity_path_2361" fill="none" stroke="none" display="none"></path><path id="kity_path_2363" fill="none" stroke="none" display="none"></path><path id="kity_path_2365" fill="none" stroke="none" display="none"></path><path id="kity_path_2367" fill="none" stroke="none" display="none"></path><path id="kity_path_2369" fill="none" stroke="none" display="none"></path><path id="kity_path_2371" fill="none" stroke="none" display="none"></path><path id="kity_path_2373" fill="none" stroke="none" display="none"></path><path id="kity_path_2375" fill="none" stroke="none" display="none"></path><path id="kity_path_2377" fill="none" stroke="none" display="none"></path><path id="kity_path_2379" fill="none" stroke="none" display="none"></path><path id="kity_path_2381" fill="none" stroke="none" display="none"></path><path id="kity_path_2383" fill="none" stroke="none" display="none"></path><path id="kity_path_2385" fill="none" stroke="none" display="none"></path><path id="kity_path_2387" fill="none" stroke="none" display="none"></path><path id="kity_path_2389" fill="none" stroke="none" display="none"></path><path id="kity_path_2391" fill="none" stroke="none" display="none"></path><path id="kity_path_2393" fill="none" stroke="none" display="none"></path><path id="kity_path_2395" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M351.5,15577.5A45,562,0,0,0,396.5,16139.5"></path><path id="kity_path_2397" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M476.5,16139.5C479.5,16139.5,479.5,1416.5,482.5,1416.5L527.5,1416.5"></path><path id="kity_path_2399" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,251.5,533.5,251.5L778.5,251.5"></path><path id="kity_path_2401" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M778.5,251.5C781.5,251.5,781.5,251.5,784.5,251.5L1067.5,251.5"></path><path id="kity_path_2403" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,391.5,533.5,391.5L635.5,391.5"></path><path id="kity_path_2405" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M635.5,391.5C638.5,391.5,638.5,295.5,641.5,295.5L756.5,295.5"></path><path id="kity_path_2407" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M756.5,295.5C759.5,295.5,759.5,313.5,762.5,313.5L1247.5,313.5"></path><path id="kity_path_2409" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M635.5,391.5C638.5,391.5,638.5,339.5,641.5,339.5L922.5,339.5"></path><path id="kity_path_2411" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M922.5,339.5C925.5,339.5,925.5,339.5,928.5,339.5L1475.5,339.5"></path><path id="kity_path_2413" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M635.5,391.5C638.5,391.5,638.5,365.5,641.5,365.5L778.5,365.5"></path><path id="kity_path_2415" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M778.5,365.5C781.5,365.5,781.5,365.5,784.5,365.5L1545.5,365.5"></path><path id="kity_path_2417" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M635.5,391.5C638.5,391.5,638.5,391.5,641.5,391.5L745.5,391.5"></path><path id="kity_path_2419" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M745.5,391.5C748.5,391.5,748.5,391.5,751.5,391.5L1542.5,391.5"></path><path id="kity_path_2421" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M635.5,391.5C638.5,391.5,638.5,417.5,641.5,417.5L920.5,417.5"></path><path id="kity_path_2423" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M920.5,417.5C923.5,417.5,923.5,417.5,926.5,417.5L1430.5,417.5"></path><path id="kity_path_2425" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M635.5,391.5C638.5,391.5,638.5,443.5,641.5,443.5L766.5,443.5"></path><path id="kity_path_2427" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M766.5,443.5C769.5,443.5,769.5,443.5,772.5,443.5L1229.5,443.5"></path><path id="kity_path_2429" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M635.5,391.5C638.5,391.5,638.5,487.5,641.5,487.5L866.5,487.5"></path><path id="kity_path_2431" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M866.5,487.5C869.5,487.5,869.5,505.5,872.5,505.5L1586.5,505.5"></path><path id="kity_path_2433" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,540.5,533.5,540.5L841.5,540.5"></path><path id="kity_path_2435" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M841.5,540.5C844.5,540.5,844.5,549.5,847.5,549.5L1467.5,549.5"></path><path id="kity_path_2437" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,584.5,533.5,584.5L790.5,584.5"></path><path id="kity_path_2439" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M790.5,584.5C793.5,584.5,793.5,593.5,796.5,593.5L1765.5,593.5"></path><path id="kity_path_2441" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,646.5,533.5,646.5L812.5,646.5"></path><path id="kity_path_2443" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M812.5,646.5C815.5,646.5,815.5,673.5,818.5,673.5L1053.5,673.5"></path><path id="kity_path_2445" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,699.5,533.5,699.5L770.5,699.5"></path><path id="kity_path_2447" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M770.5,699.5C773.5,699.5,773.5,699.5,776.5,699.5L1290.5,699.5"></path><path id="kity_path_2449" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,734.5,533.5,734.5L781.5,734.5"></path><path id="kity_path_2451" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M781.5,734.5C784.5,734.5,784.5,743.5,787.5,743.5L1746.5,743.5"></path><path id="kity_path_2453" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,787.5,533.5,787.5L771.5,787.5"></path><path id="kity_path_2455" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M771.5,787.5C774.5,787.5,774.5,787.5,777.5,787.5L1658.5,787.5"></path><path id="kity_path_2457" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,813.5,533.5,813.5L687.5,813.5"></path><path id="kity_path_2459" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M687.5,813.5C690.5,813.5,690.5,813.5,693.5,813.5L1051.5,813.5"></path><path id="kity_path_2461" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,839.5,533.5,839.5L642.5,839.5"></path><path id="kity_path_2463" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M642.5,839.5C645.5,839.5,645.5,839.5,648.5,839.5L1840.5,839.5"></path><path id="kity_path_2465" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,865.5,533.5,865.5L663.5,865.5"></path><path id="kity_path_2467" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M663.5,865.5C666.5,865.5,666.5,865.5,669.5,865.5L1437.5,865.5"></path><path id="kity_path_2469" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,891.5,533.5,891.5L646.5,891.5"></path><path id="kity_path_2471" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M646.5,891.5C649.5,891.5,649.5,891.5,652.5,891.5L1357.5,891.5"></path><path id="kity_path_2473" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,926.5,533.5,926.5L662.5,926.5"></path><path id="kity_path_2475" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M662.5,926.5C665.5,926.5,665.5,935.5,668.5,935.5L1670.5,935.5"></path><path id="kity_path_2477" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,961.5,533.5,961.5L626.5,961.5"></path><path id="kity_path_2479" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M626.5,961.5C629.5,961.5,629.5,961.5,632.5,961.5L1883.5,961.5"></path><path id="kity_path_2481" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,996.5,533.5,996.5L686.5,996.5"></path><path id="kity_path_2483" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M686.5,996.5C689.5,996.5,689.5,1005.5,692.5,1005.5L1450.5,1005.5"></path><path id="kity_path_2485" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,1031.5,533.5,1031.5L870.5,1031.5"></path><path id="kity_path_2487" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M870.5,1031.5C873.5,1031.5,873.5,1031.5,876.5,1031.5L1948.5,1031.5"></path><path id="kity_path_2489" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,1075.5,533.5,1075.5L698.5,1075.5"></path><path id="kity_path_2491" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M698.5,1075.5C701.5,1075.5,701.5,1093.5,704.5,1093.5L1476.5,1093.5"></path><path id="kity_path_2493" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,1164.5,533.5,1164.5L686.5,1164.5"></path><path id="kity_path_2495" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M686.5,1164.5C689.5,1164.5,689.5,1209.5,692.5,1209.5L1830.5,1209.5"></path><path id="kity_path_2497" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,1235.5,533.5,1235.5L674.5,1235.5"></path><path id="kity_path_2499" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M674.5,1235.5C677.5,1235.5,677.5,1235.5,680.5,1235.5L1178.5,1235.5"></path><path id="kity_path_2501" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,1261.5,533.5,1261.5L686.5,1261.5"></path><path id="kity_path_2503" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M686.5,1261.5C689.5,1261.5,689.5,1261.5,692.5,1261.5L1489.5,1261.5"></path><path id="kity_path_2505" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,1287.5,533.5,1287.5L746.5,1287.5"></path><path id="kity_path_2507" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M746.5,1287.5C749.5,1287.5,749.5,1287.5,752.5,1287.5L942.5,1287.5"></path><path id="kity_path_2509" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,1322.5,533.5,1322.5L676.5,1322.5"></path><path id="kity_path_2511" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M676.5,1322.5C679.5,1322.5,679.5,1331.5,682.5,1331.5L1220.5,1331.5"></path><path id="kity_path_2513" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,1384.5,533.5,1384.5L680.5,1384.5"></path><path id="kity_path_2515" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M680.5,1384.5C683.5,1384.5,683.5,1411.5,686.5,1411.5L1386.5,1411.5"></path><path id="kity_path_2517" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,1491.5,533.5,1491.5L698.5,1491.5"></path><path id="kity_path_2519" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M698.5,1491.5C701.5,1491.5,701.5,1545.5,704.5,1545.5L1815.5,1545.5"></path><path id="kity_path_2521" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,1598.5,533.5,1598.5L625.5,1598.5"></path><path id="kity_path_2523" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M625.5,1598.5C628.5,1598.5,628.5,1625.5,631.5,1625.5L1370.5,1625.5"></path><path id="kity_path_2525" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,1660.5,533.5,1660.5L674.5,1660.5"></path><path id="kity_path_2527" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M674.5,1660.5C677.5,1660.5,677.5,1669.5,680.5,1669.5L1209.5,1669.5"></path><path id="kity_path_2529" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,1704.5,533.5,1704.5L757.5,1704.5"></path><path id="kity_path_2531" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M757.5,1704.5C760.5,1704.5,760.5,1713.5,763.5,1713.5L1465.5,1713.5"></path><path id="kity_path_2533" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,1748.5,533.5,1748.5L685.5,1748.5"></path><path id="kity_path_2535" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M685.5,1748.5C688.5,1748.5,688.5,1757.5,691.5,1757.5L2417.5,1757.5"></path><path id="kity_path_2537" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,1837.5,533.5,1837.5L710.5,1837.5"></path><path id="kity_path_2539" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M710.5,1837.5C713.5,1837.5,713.5,1891.5,716.5,1891.5L1764.5,1891.5"></path><path id="kity_path_2541" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,1993.5,533.5,1993.5L601.5,1993.5"></path><path id="kity_path_2543" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M601.5,1993.5C604.5,1993.5,604.5,1953.5,607.5,1953.5L881.5,1953.5"></path><path id="kity_path_2545" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M881.5,1953.5C884.5,1953.5,884.5,1989.5,887.5,1989.5L1781.5,1989.5"></path><path id="kity_path_2547" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M601.5,1993.5C604.5,1993.5,604.5,2033.5,607.5,2033.5L803.5,2033.5"></path><path id="kity_path_2549" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M803.5,2033.5C806.5,2033.5,806.5,2051.5,809.5,2051.5L1672.5,2051.5"></path><path id="kity_path_2551" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,2095.5,533.5,2095.5L807.5,2095.5"></path><path id="kity_path_2553" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M807.5,2095.5C810.5,2095.5,810.5,2113.5,813.5,2113.5L1623.5,2113.5"></path><path id="kity_path_2555" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,2157.5,533.5,2157.5L663.5,2157.5"></path><path id="kity_path_2557" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M663.5,2157.5C666.5,2157.5,666.5,2175.5,669.5,2175.5L2194.5,2175.5"></path><path id="kity_path_2559" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,2210.5,533.5,2210.5L687.5,2210.5"></path><path id="kity_path_2561" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M687.5,2210.5C690.5,2210.5,690.5,2219.5,693.5,2219.5L1268.5,2219.5"></path><path id="kity_path_2563" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,2272.5,533.5,2272.5L709.5,2272.5"></path><path id="kity_path_2565" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M709.5,2272.5C712.5,2272.5,712.5,2299.5,715.5,2299.5L1419.5,2299.5"></path><path id="kity_path_2567" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,2334.5,533.5,2334.5L807.5,2334.5"></path><path id="kity_path_2569" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M807.5,2334.5C810.5,2334.5,810.5,2343.5,813.5,2343.5L1035.5,2343.5"></path><path id="kity_path_2571" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,2387.5,533.5,2387.5L680.5,2387.5"></path><path id="kity_path_2573" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M680.5,2387.5C683.5,2387.5,683.5,2405.5,686.5,2405.5L1493.5,2405.5"></path><path id="kity_path_2575" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,2449.5,533.5,2449.5L734.5,2449.5"></path><path id="kity_path_2577" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M734.5,2449.5C737.5,2449.5,737.5,2467.5,740.5,2467.5L1410.5,2467.5"></path><path id="kity_path_2579" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1410.5,2467.5C1413.5,2467.5,1413.5,2449.5,1416.5,2449.5L1794.5,2449.5"></path><path id="kity_path_2581" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,2511.5,533.5,2511.5L815.5,2511.5"></path><path id="kity_path_2583" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M815.5,2511.5C818.5,2511.5,818.5,2529.5,821.5,2529.5L2038.5,2529.5"></path><path id="kity_path_2585" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,2555.5,533.5,2555.5L678.5,2555.5"></path><path id="kity_path_2587" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M678.5,2555.5C681.5,2555.5,681.5,2555.5,684.5,2555.5L1237.5,2555.5"></path><path id="kity_path_2589" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M527.5,1416.5C530.5,1416.5,530.5,2581.5,533.5,2581.5L724.5,2581.5"></path><path id="kity_path_2591" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M724.5,2581.5C727.5,2581.5,727.5,2581.5,730.5,2581.5L1319.5,2581.5"></path><path id="kity_path_2593" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1319.5,2581.5C1322.5,2581.5,1322.5,2581.5,1325.5,2581.5L1698.5,2581.5"></path><path id="kity_path_2595" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M476.5,16139.5C479.5,16139.5,479.5,3312.5,482.5,3312.5L528.5,3312.5"></path><path id="kity_path_2597" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,3312.5C531.5,3312.5,531.5,2740.5,534.5,2740.5L693.5,2740.5"></path><path id="kity_path_2599" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M693.5,2740.5C696.5,2740.5,696.5,2626.5,699.5,2626.5L949.5,2626.5"></path><path id="kity_path_2601" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M949.5,2626.5C952.5,2626.5,952.5,2644.5,955.5,2644.5L1496.5,2644.5"></path><path id="kity_path_2603" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M693.5,2740.5C696.5,2740.5,696.5,2670.5,699.5,2670.5L894.5,2670.5"></path><path id="kity_path_2605" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M894.5,2670.5C897.5,2670.5,897.5,2670.5,900.5,2670.5L1897.5,2670.5"></path><path id="kity_path_2607" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M693.5,2740.5C696.5,2740.5,696.5,2696.5,699.5,2696.5L823.5,2696.5"></path><path id="kity_path_2609" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M823.5,2696.5C826.5,2696.5,826.5,2696.5,829.5,2696.5L1353.5,2696.5"></path><path id="kity_path_2611" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M693.5,2740.5C696.5,2740.5,696.5,2722.5,699.5,2722.5L832.5,2722.5"></path><path id="kity_path_2613" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M832.5,2722.5C835.5,2722.5,835.5,2722.5,838.5,2722.5L1850.5,2722.5"></path><path id="kity_path_2615" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M693.5,2740.5C696.5,2740.5,696.5,2748.5,699.5,2748.5L819.5,2748.5"></path><path id="kity_path_2617" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M819.5,2748.5C822.5,2748.5,822.5,2748.5,825.5,2748.5L1480.5,2748.5"></path><path id="kity_path_2619" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M693.5,2740.5C696.5,2740.5,696.5,2774.5,699.5,2774.5L862.5,2774.5"></path><path id="kity_path_2621" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M862.5,2774.5C865.5,2774.5,865.5,2774.5,868.5,2774.5L2083.5,2774.5"></path><path id="kity_path_2623" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M693.5,2740.5C696.5,2740.5,696.5,2854.5,699.5,2854.5L876.5,2854.5"></path><path id="kity_path_2625" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M876.5,2854.5C879.5,2854.5,879.5,2908.5,882.5,2908.5L2403.5,2908.5"></path><path id="kity_path_2627" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M2403.5,2908.5C2406.5,2908.5,2406.5,2859.5,2409.5,2859.5L2696.5,2859.5"></path><path id="kity_path_2629" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,3312.5C531.5,3312.5,531.5,3298.5,534.5,3298.5L580.5,3298.5"></path><path id="kity_path_2631" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M580.5,3298.5C583.5,3298.5,583.5,2934.5,586.5,2934.5L703.5,2934.5"></path><path id="kity_path_2633" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M703.5,2934.5C706.5,2934.5,706.5,2934.5,709.5,2934.5L1753.5,2934.5"></path><path id="kity_path_2635" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M580.5,3298.5C583.5,3298.5,583.5,2996.5,586.5,2996.5L822.5,2996.5"></path><path id="kity_path_2637" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M822.5,2996.5C825.5,2996.5,825.5,3032.5,828.5,3032.5L2233.5,3032.5"></path><path id="kity_path_2639" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M580.5,3298.5C583.5,3298.5,583.5,3112.5,586.5,3112.5L859.5,3112.5"></path><path id="kity_path_2641" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M859.5,3112.5C862.5,3112.5,862.5,3166.5,865.5,3166.5L1471.5,3166.5"></path><path id="kity_path_2643" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M580.5,3298.5C583.5,3298.5,583.5,3228.5,586.5,3228.5L787.5,3228.5"></path><path id="kity_path_2645" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M787.5,3228.5C790.5,3228.5,790.5,3264.5,793.5,3264.5L1675.5,3264.5"></path><path id="kity_path_2647" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M580.5,3298.5C583.5,3298.5,583.5,3344.5,586.5,3344.5L800.5,3344.5"></path><path id="kity_path_2649" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M800.5,3344.5C803.5,3344.5,803.5,3398.5,806.5,3398.5L1607.5,3398.5"></path><path id="kity_path_2651" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M580.5,3298.5C583.5,3298.5,583.5,3451.5,586.5,3451.5L727.5,3451.5"></path><path id="kity_path_2653" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M727.5,3451.5C730.5,3451.5,730.5,3478.5,733.5,3478.5L1711.5,3478.5"></path><path id="kity_path_2655" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M580.5,3298.5C583.5,3298.5,583.5,3513.5,586.5,3513.5L788.5,3513.5"></path><path id="kity_path_2657" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M788.5,3513.5C791.5,3513.5,791.5,3522.5,794.5,3522.5L1437.5,3522.5"></path><path id="kity_path_2659" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M580.5,3298.5C583.5,3298.5,583.5,3548.5,586.5,3548.5L776.5,3548.5"></path><path id="kity_path_2661" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M776.5,3548.5C779.5,3548.5,779.5,3548.5,782.5,3548.5L991.5,3548.5"></path><path id="kity_path_2663" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M580.5,3298.5C583.5,3298.5,583.5,3601.5,586.5,3601.5L763.5,3601.5"></path><path id="kity_path_2665" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M763.5,3601.5C766.5,3601.5,766.5,3628.5,769.5,3628.5L1431.5,3628.5"></path><path id="kity_path_2667" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M580.5,3298.5C583.5,3298.5,583.5,3663.5,586.5,3663.5L812.5,3663.5"></path><path id="kity_path_2669" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M812.5,3663.5C815.5,3663.5,815.5,3672.5,818.5,3672.5L1516.5,3672.5"></path><path id="kity_path_2671" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1516.5,3672.5C1519.5,3672.5,1519.5,3663.5,1522.5,3663.5L1783.5,3663.5"></path><path id="kity_path_2673" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,3312.5C531.5,3312.5,531.5,3743.5,534.5,3743.5L711.5,3743.5"></path><path id="kity_path_2675" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M711.5,3743.5C714.5,3743.5,714.5,3788.5,717.5,3788.5L1757.5,3788.5"></path><path id="kity_path_2677" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,3312.5C531.5,3312.5,531.5,3832.5,534.5,3832.5L769.5,3832.5"></path><path id="kity_path_2679" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M769.5,3832.5C772.5,3832.5,772.5,3850.5,775.5,3850.5L1970.5,3850.5"></path><path id="kity_path_2681" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,3312.5C531.5,3312.5,531.5,3885.5,534.5,3885.5L580.5,3885.5"></path><path id="kity_path_2683" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M580.5,3885.5C583.5,3885.5,583.5,3885.5,586.5,3885.5L787.5,3885.5"></path><path id="kity_path_2685" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M787.5,3885.5C790.5,3885.5,790.5,3894.5,793.5,3894.5L1641.5,3894.5"></path><path id="kity_path_2687" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M476.5,16139.5C479.5,16139.5,479.5,3919.5,482.5,3919.5L513.5,3919.5"></path><path id="kity_path_2689" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M513.5,17365.5C516.5,17365.5,516.5,17365.5,519.5,17365.5L606.5,17365.5" display="none"></path><path id="kity_path_2691" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M606.5,17365.5C609.5,17365.5,609.5,17317.5,612.5,17317.5L657.5,17317.5" display="none"></path><path id="kity_path_2693" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M657.5,17317.5C660.5,17317.5,660.5,17273.5,663.5,17273.5L828.5,17273.5" display="none"></path><path id="kity_path_2695" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M828.5,17273.5C831.5,17273.5,831.5,17309.5,834.5,17309.5L2048.5,17309.5" display="none"></path><path id="kity_path_2697" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M657.5,17317.5C660.5,17317.5,660.5,17335.5,663.5,17335.5L791.5,17335.5" display="none"></path><path id="kity_path_2699" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M657.5,17317.5C660.5,17317.5,660.5,17361.5,663.5,17361.5L959.5,17361.5" display="none"></path><path id="kity_path_2701" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M606.5,17365.5C609.5,17365.5,609.5,17387.5,612.5,17387.5L658.5,17387.5" display="none"></path><path id="kity_path_2703" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M606.5,17365.5C609.5,17365.5,609.5,17413.5,612.5,17413.5L657.5,17413.5" display="none"></path><path id="kity_path_2705" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M476.5,16139.5C479.5,16139.5,479.5,10497.5,482.5,10497.5L528.5,10497.5"></path><path id="kity_path_2707" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,10497.5C531.5,10497.5,531.5,4894.5,534.5,4894.5L626.5,4894.5"></path><path id="kity_path_2709" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M626.5,4894.5C629.5,4894.5,629.5,3973.5,632.5,3973.5L750.5,3973.5"></path><path id="kity_path_2711" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M750.5,3973.5C753.5,3973.5,753.5,4000.5,756.5,4000.5L1474.5,4000.5"></path><path id="kity_path_2713" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M626.5,4894.5C629.5,4894.5,629.5,4035.5,632.5,4035.5L880.5,4035.5"></path><path id="kity_path_2715" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M880.5,4035.5C883.5,4035.5,883.5,4044.5,886.5,4044.5L1305.5,4044.5"></path><path id="kity_path_2717" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M626.5,4894.5C629.5,4894.5,629.5,4143.5,632.5,4143.5L844.5,4143.5"></path><path id="kity_path_2719" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M844.5,4143.5C847.5,4143.5,847.5,4188.5,850.5,4188.5L1741.5,4188.5"></path><path id="kity_path_2721" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1741.5,4188.5C1744.5,4188.5,1744.5,4216.5,1747.5,4216.5L1967.5,4216.5"></path><path id="kity_path_2723" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M626.5,4894.5C629.5,4894.5,629.5,4260.5,632.5,4260.5L749.5,4260.5"></path><path id="kity_path_2725" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M749.5,4260.5C752.5,4260.5,752.5,4278.5,755.5,4278.5L1616.5,4278.5"></path><path id="kity_path_2727" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M626.5,4894.5C629.5,4894.5,629.5,4331.5,632.5,4331.5L726.5,4331.5"></path><path id="kity_path_2729" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M726.5,4331.5C729.5,4331.5,729.5,4358.5,732.5,4358.5L1376.5,4358.5"></path><path id="kity_path_2731" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M626.5,4894.5C629.5,4894.5,629.5,4429.5,632.5,4429.5L940.5,4429.5"></path><path id="kity_path_2733" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M940.5,4429.5C943.5,4429.5,943.5,4474.5,946.5,4474.5L1827.5,4474.5"></path><path id="kity_path_2735" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M626.5,4894.5C629.5,4894.5,629.5,4536.5,632.5,4536.5L776.5,4536.5"></path><path id="kity_path_2737" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M776.5,4536.5C779.5,4536.5,779.5,4572.5,782.5,4572.5L1594.5,4572.5"></path><path id="kity_path_2739" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M626.5,4894.5C629.5,4894.5,629.5,4634.5,632.5,4634.5L966.5,4634.5"></path><path id="kity_path_2741" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M966.5,4634.5C969.5,4634.5,969.5,4670.5,972.5,4670.5L1948.5,4670.5"></path><path id="kity_path_2743" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M626.5,4894.5C629.5,4894.5,629.5,4777.5,632.5,4777.5L798.5,4777.5"></path><path id="kity_path_2745" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M798.5,4777.5C801.5,4777.5,801.5,4858.5,804.5,4858.5L2084.5,4858.5"></path><path id="kity_path_2747" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M626.5,4894.5C629.5,4894.5,629.5,4893.5,632.5,4893.5L814.5,4893.5"></path><path id="kity_path_2749" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M814.5,4893.5C817.5,4893.5,817.5,4902.5,820.5,4902.5L1611.5,4902.5"></path><path id="kity_path_2751" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M626.5,4894.5C629.5,4894.5,629.5,4955.5,632.5,4955.5L827.5,4955.5"></path><path id="kity_path_2753" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M827.5,4955.5C830.5,4955.5,830.5,4982.5,833.5,4982.5L1560.5,4982.5"></path><path id="kity_path_2755" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M626.5,4894.5C629.5,4894.5,629.5,5026.5,632.5,5026.5L766.5,5026.5"></path><path id="kity_path_2757" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M766.5,5026.5C769.5,5026.5,769.5,5044.5,772.5,5044.5L1438.5,5044.5"></path><path id="kity_path_2759" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M626.5,4894.5C629.5,4894.5,629.5,5088.5,632.5,5088.5L745.5,5088.5"></path><path id="kity_path_2761" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M745.5,5088.5C748.5,5088.5,748.5,5106.5,751.5,5106.5L1356.5,5106.5"></path><path id="kity_path_2763" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M626.5,4894.5C629.5,4894.5,629.5,5168.5,632.5,5168.5L882.5,5168.5"></path><path id="kity_path_2765" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M882.5,5168.5C885.5,5168.5,885.5,5204.5,888.5,5204.5L2564.5,5204.5"></path><path id="kity_path_2767" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M626.5,4894.5C629.5,4894.5,629.5,5230.5,632.5,5230.5L786.5,5230.5"></path><path id="kity_path_2769" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M786.5,5230.5C789.5,5230.5,789.5,5230.5,792.5,5230.5L2078.5,5230.5"></path><path id="kity_path_2771" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M626.5,4894.5C629.5,4894.5,629.5,5283.5,632.5,5283.5L785.5,5283.5"></path><path id="kity_path_2773" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M785.5,5283.5C788.5,5283.5,788.5,5310.5,791.5,5310.5L1824.5,5310.5"></path><path id="kity_path_2775" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M626.5,4894.5C629.5,4894.5,629.5,5363.5,632.5,5363.5L892.5,5363.5"></path><path id="kity_path_2777" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M892.5,5363.5C895.5,5363.5,895.5,5390.5,898.5,5390.5L2392.5,5390.5"></path><path id="kity_path_2779" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M2392.5,5390.5C2395.5,5390.5,2395.5,5363.5,2398.5,5363.5L2649.5,5363.5"></path><path id="kity_path_2781" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M626.5,4894.5C629.5,4894.5,629.5,5816.5,632.5,5816.5L723.5,5816.5"></path><path id="kity_path_2783" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M723.5,5816.5C726.5,5816.5,726.5,5452.5,729.5,5452.5L941.5,5452.5"></path><path id="kity_path_2785" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M941.5,5452.5C944.5,5452.5,944.5,5488.5,947.5,5488.5L2633.5,5488.5"></path><path id="kity_path_2787" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M723.5,5816.5C726.5,5816.5,726.5,5541.5,729.5,5541.5L895.5,5541.5"></path><path id="kity_path_2789" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M895.5,5541.5C898.5,5541.5,898.5,5568.5,901.5,5568.5L2539.5,5568.5"></path><path id="kity_path_2791" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M723.5,5816.5C726.5,5816.5,726.5,5603.5,729.5,5603.5L904.5,5603.5"></path><path id="kity_path_2793" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M904.5,5603.5C907.5,5603.5,907.5,5612.5,910.5,5612.5L2577.5,5612.5"></path><path id="kity_path_2795" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M723.5,5816.5C726.5,5816.5,726.5,5697.5,729.5,5697.5L1042.5,5697.5"></path><path id="kity_path_2797" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1042.5,5697.5C1045.5,5697.5,1045.5,5724.5,1048.5,5724.5L2366.5,5724.5"></path><path id="kity_path_2799" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M2366.5,5724.5C2369.5,5724.5,2369.5,5756.5,2372.5,5756.5L2592.5,5756.5"></path><path id="kity_path_2801" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M723.5,5816.5C726.5,5816.5,726.5,5808.5,729.5,5808.5L857.5,5808.5"></path><path id="kity_path_2803" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M857.5,5808.5C860.5,5808.5,860.5,5835.5,863.5,5835.5L1676.5,5835.5"></path><path id="kity_path_2805" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M723.5,5816.5C726.5,5816.5,726.5,5906.5,729.5,5906.5L810.5,5906.5"></path><path id="kity_path_2807" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M810.5,5906.5C813.5,5906.5,813.5,5951.5,816.5,5951.5L1557.5,5951.5"></path><path id="kity_path_2809" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1557.5,5951.5C1560.5,5951.5,1560.5,5906.5,1563.5,5906.5L2385.5,5906.5"></path><path id="kity_path_2811" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M723.5,5816.5C726.5,5816.5,726.5,6013.5,729.5,6013.5L936.5,6013.5"></path><path id="kity_path_2813" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M936.5,6013.5C939.5,6013.5,939.5,6049.5,942.5,6049.5L2398.5,6049.5"></path><path id="kity_path_2815" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M723.5,5816.5C726.5,5816.5,726.5,6084.5,729.5,6084.5L909.5,6084.5"></path><path id="kity_path_2817" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M909.5,6084.5C912.5,6084.5,912.5,6093.5,915.5,6093.5L1727.5,6093.5"></path><path id="kity_path_2819" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M723.5,5816.5C726.5,5816.5,726.5,6119.5,729.5,6119.5L916.5,6119.5"></path><path id="kity_path_2821" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M723.5,5816.5C726.5,5816.5,726.5,6145.5,729.5,6145.5L898.5,6145.5"></path><path id="kity_path_2823" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M723.5,5816.5C726.5,5816.5,726.5,6180.5,729.5,6180.5L1063.5,6180.5"></path><path id="kity_path_2825" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1063.5,6180.5C1066.5,6180.5,1066.5,6189.5,1069.5,6189.5L2102.5,6189.5"></path><path id="kity_path_2827" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,10497.5C531.5,10497.5,531.5,6485.5,534.5,6485.5L616.5,6485.5"></path><path id="kity_path_2829" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M616.5,6485.5C619.5,6485.5,619.5,6485.5,622.5,6485.5L757.5,6485.5"></path><path id="kity_path_2831" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M757.5,6485.5C760.5,6485.5,760.5,6232.5,763.5,6232.5L861.5,6232.5"></path><path id="kity_path_2833" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M861.5,6232.5C864.5,6232.5,864.5,6250.5,867.5,6250.5L1673.5,6250.5"></path><path id="kity_path_2835" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M757.5,6485.5C760.5,6485.5,760.5,6303.5,763.5,6303.5L897.5,6303.5"></path><path id="kity_path_2837" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M897.5,6303.5C900.5,6303.5,900.5,6330.5,903.5,6330.5L2203.5,6330.5"></path><path id="kity_path_2839" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M757.5,6485.5C760.5,6485.5,760.5,6356.5,763.5,6356.5L969.5,6356.5"></path><path id="kity_path_2841" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M969.5,6356.5C972.5,6356.5,972.5,6356.5,975.5,6356.5L1330.5,6356.5"></path><path id="kity_path_2843" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M757.5,6485.5C760.5,6485.5,760.5,6463.5,763.5,6463.5L892.5,6463.5"></path><path id="kity_path_2845" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M892.5,6463.5C895.5,6463.5,895.5,6544.5,898.5,6544.5L2331.5,6544.5"></path><path id="kity_path_2847" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M757.5,6485.5C760.5,6485.5,760.5,6579.5,763.5,6579.5L922.5,6579.5"></path><path id="kity_path_2849" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M922.5,6579.5C925.5,6579.5,925.5,6588.5,928.5,6588.5L1920.5,6588.5"></path><path id="kity_path_2851" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M757.5,6485.5C760.5,6485.5,760.5,6614.5,763.5,6614.5L1143.5,6614.5"></path><path id="kity_path_2853" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1143.5,6614.5C1146.5,6614.5,1146.5,6614.5,1149.5,6614.5L2368.5,6614.5"></path><path id="kity_path_2855" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M757.5,6485.5C760.5,6485.5,760.5,6649.5,763.5,6649.5L1031.5,6649.5"></path><path id="kity_path_2857" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1031.5,6649.5C1034.5,6649.5,1034.5,6658.5,1037.5,6658.5L2022.5,6658.5"></path><path id="kity_path_2859" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M2022.5,6658.5C2025.5,6658.5,2025.5,6649.5,2028.5,6649.5L2343.5,6649.5"></path><path id="kity_path_2861" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M757.5,6485.5C760.5,6485.5,760.5,6738.5,763.5,6738.5L961.5,6738.5"></path><path id="kity_path_2863" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M961.5,6738.5C964.5,6738.5,964.5,6792.5,967.5,6792.5L2167.5,6792.5"></path><path id="kity_path_2865" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,10497.5C531.5,10497.5,531.5,7969.5,534.5,7969.5L568.5,7969.5"></path><path id="kity_path_2867" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M568.5,7969.5C571.5,7969.5,571.5,7438.5,574.5,7438.5L743.5,7438.5"></path><path id="kity_path_2869" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M743.5,7438.5C746.5,7438.5,746.5,6846.5,749.5,6846.5L1057.5,6846.5"></path><path id="kity_path_2871" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1057.5,6846.5C1060.5,6846.5,1060.5,6873.5,1063.5,6873.5L1859.5,6873.5"></path><path id="kity_path_2873" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M743.5,7438.5C746.5,7438.5,746.5,6998.5,749.5,6998.5L1151.5,6998.5"></path><path id="kity_path_2875" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1151.5,6998.5C1154.5,6998.5,1154.5,7097.5,1157.5,7097.5L2748.5,7097.5"></path><path id="kity_path_2877" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M743.5,7438.5C746.5,7438.5,746.5,7150.5,749.5,7150.5L934.5,7150.5"></path><path id="kity_path_2879" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M934.5,7150.5C937.5,7150.5,937.5,7177.5,940.5,7177.5L1437.5,7177.5"></path><path id="kity_path_2881" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1437.5,7177.5C1440.5,7177.5,1440.5,7150.5,1443.5,7150.5L1828.5,7150.5"></path><path id="kity_path_2883" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M743.5,7438.5C746.5,7438.5,746.5,7212.5,749.5,7212.5L926.5,7212.5"></path><path id="kity_path_2885" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M926.5,7212.5C929.5,7212.5,929.5,7221.5,932.5,7221.5L2220.5,7221.5"></path><path id="kity_path_2887" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M743.5,7438.5C746.5,7438.5,746.5,7409.5,749.5,7409.5L979.5,7409.5"></path><path id="kity_path_2889" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M979.5,7409.5C982.5,7409.5,982.5,7571.5,985.5,7571.5L2695.5,7571.5"></path><path id="kity_path_2891" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M2695.5,7571.5C2698.5,7571.5,2698.5,7348.5,2701.5,7348.5L3047.5,7348.5"></path><path id="kity_path_2893" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M2695.5,7571.5C2698.5,7571.5,2698.5,7507.5,2701.5,7507.5L2921.5,7507.5"></path><path id="kity_path_2895" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M743.5,7438.5C746.5,7438.5,746.5,7597.5,749.5,7597.5L891.5,7597.5"></path><path id="kity_path_2897" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M891.5,7597.5C894.5,7597.5,894.5,7597.5,897.5,7597.5L954.5,7597.5"></path><path id="kity_path_2899" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M743.5,7438.5C746.5,7438.5,746.5,7623.5,749.5,7623.5L1010.5,7623.5"></path><path id="kity_path_2901" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1010.5,7623.5C1013.5,7623.5,1013.5,7623.5,1016.5,7623.5L1626.5,7623.5"></path><path id="kity_path_2903" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M743.5,7438.5C746.5,7438.5,746.5,7734.5,749.5,7734.5L890.5,7734.5"></path><path id="kity_path_2905" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M890.5,7734.5C893.5,7734.5,893.5,7703.5,896.5,7703.5L1116.5,7703.5"></path><path id="kity_path_2907" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M890.5,7734.5C893.5,7734.5,893.5,7819.5,896.5,7819.5L1648.5,7819.5"></path><path id="kity_path_2909" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M743.5,7438.5C746.5,7438.5,746.5,7853.5,749.5,7853.5L1023.5,7853.5"></path><path id="kity_path_2911" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1023.5,7853.5C1026.5,7853.5,1026.5,7862.5,1029.5,7862.5L1492.5,7862.5"></path><path id="kity_path_2913" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M743.5,7438.5C746.5,7438.5,746.5,7906.5,749.5,7906.5L1138.5,7906.5"></path><path id="kity_path_2915" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1138.5,7906.5C1141.5,7906.5,1141.5,7924.5,1144.5,7924.5L2269.5,7924.5"></path><path id="kity_path_2917" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M743.5,7438.5C746.5,7438.5,746.5,7959.5,749.5,7959.5L977.5,7959.5"></path><path id="kity_path_2919" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M977.5,7959.5C980.5,7959.5,980.5,7968.5,983.5,7968.5L1421.5,7968.5"></path><path id="kity_path_2921" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M743.5,7438.5C746.5,7438.5,746.5,8030.5,749.5,8030.5L1145.5,8030.5"></path><path id="kity_path_2923" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1145.5,8030.5C1148.5,8030.5,1148.5,8066.5,1151.5,8066.5L1603.5,8066.5"></path><path id="kity_path_2925" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M568.5,7969.5C571.5,7969.5,571.5,8110.5,574.5,8110.5L715.5,8110.5"></path><path id="kity_path_2927" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M715.5,8110.5C718.5,8110.5,718.5,8128.5,721.5,8128.5L1434.5,8128.5"></path><path id="kity_path_2929" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M568.5,7969.5C571.5,7969.5,571.5,8172.5,574.5,8172.5L740.5,8172.5"></path><path id="kity_path_2931" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M740.5,8172.5C743.5,8172.5,743.5,8190.5,746.5,8190.5L2228.5,8190.5"></path><path id="kity_path_2933" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M568.5,7969.5C571.5,7969.5,571.5,8225.5,574.5,8225.5L769.5,8225.5"></path><path id="kity_path_2935" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M769.5,8225.5C772.5,8225.5,772.5,8234.5,775.5,8234.5L1886.5,8234.5"></path><path id="kity_path_2937" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M568.5,7969.5C571.5,7969.5,571.5,8323.5,574.5,8323.5L727.5,8323.5"></path><path id="kity_path_2939" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M727.5,8323.5C730.5,8323.5,730.5,8386.5,733.5,8386.5L1889.5,8386.5"></path><path id="kity_path_2941" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M568.5,7969.5C571.5,7969.5,571.5,8421.5,574.5,8421.5L678.5,8421.5"></path><path id="kity_path_2943" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M678.5,8421.5C681.5,8421.5,681.5,8430.5,684.5,8430.5L1341.5,8430.5"></path><path id="kity_path_2945" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M568.5,7969.5C571.5,7969.5,571.5,8501.5,574.5,8501.5L847.5,8501.5"></path><path id="kity_path_2947" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M847.5,8501.5C850.5,8501.5,850.5,8546.5,853.5,8546.5L2233.5,8546.5"></path><path id="kity_path_2949" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,10497.5C531.5,10497.5,531.5,8984.5,534.5,8984.5L580.5,8984.5"></path><path id="kity_path_2951" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M580.5,8984.5C583.5,8984.5,583.5,8660.5,586.5,8660.5L729.5,8660.5"></path><path id="kity_path_2953" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M729.5,8660.5C732.5,8660.5,732.5,8705.5,735.5,8705.5L2263.5,8705.5"></path><path id="kity_path_2955" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M2263.5,8705.5C2266.5,8705.5,2266.5,8750.5,2269.5,8750.5L2489.5,8750.5"></path><path id="kity_path_2957" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M580.5,8984.5C583.5,8984.5,583.5,8945.5,586.5,8945.5L776.5,8945.5"></path><path id="kity_path_2959" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M776.5,8945.5C779.5,8945.5,779.5,8945.5,782.5,8945.5L1525.5,8945.5"></path><path id="kity_path_2961" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1525.5,8945.5C1528.5,8945.5,1528.5,8930.5,1531.5,8930.5L1751.5,8930.5"></path><path id="kity_path_2963" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1525.5,8945.5C1528.5,8945.5,1528.5,9114.5,1531.5,9114.5L1751.5,9114.5"></path><path id="kity_path_2965" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M580.5,8984.5C583.5,8984.5,583.5,9149.5,586.5,9149.5L667.5,9149.5"></path><path id="kity_path_2967" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M667.5,9149.5C670.5,9149.5,670.5,9158.5,673.5,9158.5L1882.5,9158.5"></path><path id="kity_path_2969" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1882.5,9158.5C1885.5,9158.5,1885.5,9149.5,1888.5,9149.5L2244.5,9149.5"></path><path id="kity_path_2971" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M580.5,8984.5C583.5,8984.5,583.5,9193.5,586.5,9193.5L836.5,9193.5"></path><path id="kity_path_2973" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M836.5,9193.5C839.5,9193.5,839.5,9202.5,842.5,9202.5L1537.5,9202.5"></path><path id="kity_path_2975" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M580.5,8984.5C583.5,8984.5,583.5,9246.5,586.5,9246.5L728.5,9246.5"></path><path id="kity_path_2977" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M728.5,9246.5C731.5,9246.5,731.5,9264.5,734.5,9264.5L1938.5,9264.5"></path><path id="kity_path_2979" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1938.5,9264.5C1941.5,9264.5,1941.5,9246.5,1944.5,9246.5L2298.5,9246.5"></path><path id="kity_path_2981" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M580.5,8984.5C583.5,8984.5,583.5,9308.5,586.5,9308.5L717.5,9308.5"></path><path id="kity_path_2983" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M717.5,9308.5C720.5,9308.5,720.5,9326.5,723.5,9326.5L2293.5,9326.5"></path><path id="kity_path_2985" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,10497.5C531.5,10497.5,531.5,9802.5,534.5,9802.5L591.5,9802.5"></path><path id="kity_path_2987" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M591.5,9802.5C594.5,9802.5,594.5,9361.5,597.5,9361.5L708.5,9361.5"></path><path id="kity_path_2989" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M708.5,9361.5C711.5,9361.5,711.5,9370.5,714.5,9370.5L1727.5,9370.5"></path><path id="kity_path_2991" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M591.5,9802.5C594.5,9802.5,594.5,9522.5,597.5,9522.5L859.5,9522.5"></path><path id="kity_path_2993" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M859.5,9522.5C862.5,9522.5,862.5,9648.5,865.5,9648.5L1928.5,9648.5"></path><path id="kity_path_2995" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M591.5,9802.5C594.5,9802.5,594.5,9700.5,597.5,9700.5L732.5,9700.5"></path><path id="kity_path_2997" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M732.5,9700.5C735.5,9700.5,735.5,9718.5,738.5,9718.5L1955.5,9718.5"></path><path id="kity_path_2999" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1955.5,9718.5C1958.5,9718.5,1958.5,9726.5,1961.5,9726.5L2181.5,9726.5"></path><path id="kity_path_3001" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M591.5,9802.5C594.5,9802.5,594.5,9870.5,597.5,9870.5L775.5,9870.5"></path><path id="kity_path_3003" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M775.5,9870.5C778.5,9870.5,778.5,9888.5,781.5,9888.5L1733.5,9888.5"></path><path id="kity_path_3005" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1733.5,9888.5C1736.5,9888.5,1736.5,9855.5,1739.5,9855.5L1959.5,9855.5"></path><path id="kity_path_3007" fill="none" stroke="none" display="none"></path><path id="kity_path_3009" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1733.5,9888.5C1736.5,9888.5,1736.5,9988.5,1739.5,9988.5L1959.5,9988.5"></path><path id="kity_path_3011" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M591.5,9802.5C594.5,9802.5,594.5,10022.5,597.5,10022.5L719.5,10022.5"></path><path id="kity_path_3013" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M719.5,10022.5C722.5,10022.5,722.5,10031.5,725.5,10031.5L1455.5,10031.5"></path><path id="kity_path_3015" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M591.5,9802.5C594.5,9802.5,594.5,10057.5,597.5,10057.5L763.5,10057.5"></path><path id="kity_path_3017" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M763.5,10057.5C766.5,10057.5,766.5,10057.5,769.5,10057.5L1282.5,10057.5"></path><path id="kity_path_3019" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M591.5,9802.5C594.5,9802.5,594.5,10101.5,597.5,10101.5L750.5,10101.5"></path><path id="kity_path_3021" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M750.5,10101.5C753.5,10101.5,753.5,10119.5,756.5,10119.5L1507.5,10119.5"></path><path id="kity_path_3023" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1507.5,10119.5C1510.5,10119.5,1510.5,10101.5,1513.5,10101.5L1859.5,10101.5"></path><path id="kity_path_3025" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M591.5,9802.5C594.5,9802.5,594.5,10243.5,597.5,10243.5L898.5,10243.5"></path><path id="kity_path_3027" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M898.5,10243.5C901.5,10243.5,901.5,10252.5,904.5,10252.5L1612.5,10252.5"></path><path id="kity_path_3029" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1612.5,10252.5C1615.5,10252.5,1615.5,10341.5,1618.5,10341.5L1838.5,10341.5"></path><path id="kity_path_3031" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,10497.5C531.5,10497.5,531.5,10924.5,534.5,10924.5L604.5,10924.5"></path><path id="kity_path_3033" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M604.5,10924.5C607.5,10924.5,607.5,10652.5,610.5,10652.5L786.5,10652.5"></path><path id="kity_path_3035" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M786.5,10652.5C789.5,10652.5,789.5,10457.5,792.5,10457.5L969.5,10457.5"></path><path id="kity_path_3037" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M969.5,10457.5C972.5,10457.5,972.5,10547.5,975.5,10547.5L2946.5,10547.5"></path><path id="kity_path_3039" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M2946.5,10547.5C2949.5,10547.5,2949.5,10457.5,2952.5,10457.5L3298.5,10457.5"></path><path id="kity_path_3041" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M786.5,10652.5C789.5,10652.5,789.5,10618.5,792.5,10618.5L1151.5,10618.5"></path><path id="kity_path_3043" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1151.5,10618.5C1154.5,10618.5,1154.5,10663.5,1157.5,10663.5L2114.5,10663.5"></path><path id="kity_path_3045" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M786.5,10652.5C789.5,10652.5,789.5,10707.5,792.5,10707.5L1111.5,10707.5"></path><path id="kity_path_3047" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1111.5,10707.5C1114.5,10707.5,1114.5,10725.5,1117.5,10725.5L1750.5,10725.5"></path><path id="kity_path_3049" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M786.5,10652.5C789.5,10652.5,789.5,10760.5,792.5,10760.5L1029.5,10760.5"></path><path id="kity_path_3051" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1029.5,10760.5C1032.5,10760.5,1032.5,10769.5,1035.5,10769.5L1837.5,10769.5"></path><path id="kity_path_3053" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M786.5,10652.5C789.5,10652.5,789.5,10804.5,792.5,10804.5L933.5,10804.5"></path><path id="kity_path_3055" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M933.5,10804.5C936.5,10804.5,936.5,10813.5,939.5,10813.5L1920.5,10813.5"></path><path id="kity_path_3057" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M786.5,10652.5C789.5,10652.5,789.5,10848.5,792.5,10848.5L992.5,10848.5"></path><path id="kity_path_3059" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M992.5,10848.5C995.5,10848.5,995.5,10857.5,998.5,10857.5L1584.5,10857.5"></path><path id="kity_path_3061" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M604.5,10924.5C607.5,10924.5,607.5,10901.5,610.5,10901.5L715.5,10901.5"></path><path id="kity_path_3063" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M715.5,10901.5C718.5,10901.5,718.5,10919.5,721.5,10919.5L1306.5,10919.5"></path><path id="kity_path_3065" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M604.5,10924.5C607.5,10924.5,607.5,11044.5,610.5,11044.5L728.5,11044.5"></path><path id="kity_path_3067" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M728.5,11044.5C731.5,11044.5,731.5,11143.5,734.5,11143.5L2079.5,11143.5"></path><path id="kity_path_3069" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M604.5,10924.5C607.5,10924.5,607.5,11196.5,610.5,11196.5L715.5,11196.5"></path><path id="kity_path_3071" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M715.5,11196.5C718.5,11196.5,718.5,11223.5,721.5,11223.5L1612.5,11223.5"></path><path id="kity_path_3073" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,10497.5C531.5,10497.5,531.5,11417.5,534.5,11417.5L577.5,11417.5"></path><path id="kity_path_3075" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M577.5,11417.5C580.5,11417.5,580.5,11259.5,583.5,11259.5L698.5,11259.5"></path><path id="kity_path_3077" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M698.5,11259.5C701.5,11259.5,701.5,11268.5,704.5,11268.5L1833.5,11268.5"></path><path id="kity_path_3079" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M577.5,11417.5C580.5,11417.5,580.5,11321.5,583.5,11321.5L795.5,11321.5"></path><path id="kity_path_3081" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M795.5,11321.5C798.5,11321.5,798.5,11348.5,801.5,11348.5L2320.5,11348.5"></path><path id="kity_path_3083" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M577.5,11417.5C580.5,11417.5,580.5,11392.5,583.5,11392.5L746.5,11392.5"></path><path id="kity_path_3085" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M746.5,11392.5C749.5,11392.5,749.5,11410.5,752.5,11410.5L2405.5,11410.5"></path><path id="kity_path_3087" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M2405.5,11410.5C2408.5,11410.5,2408.5,11392.5,2411.5,11392.5L2691.5,11392.5"></path><path id="kity_path_3089" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M577.5,11417.5C580.5,11417.5,580.5,11445.5,583.5,11445.5L688.5,11445.5"></path><path id="kity_path_3091" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M688.5,11445.5C691.5,11445.5,691.5,11454.5,694.5,11454.5L1903.5,11454.5"></path><path id="kity_path_3093" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M577.5,11417.5C580.5,11417.5,580.5,11480.5,583.5,11480.5L711.5,11480.5"></path><path id="kity_path_3095" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M711.5,11480.5C714.5,11480.5,714.5,11480.5,717.5,11480.5L1018.5,11480.5"></path><path id="kity_path_3097" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M577.5,11417.5C580.5,11417.5,580.5,11515.5,583.5,11515.5L760.5,11515.5"></path><path id="kity_path_3099" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M760.5,11515.5C763.5,11515.5,763.5,11524.5,766.5,11524.5L1816.5,11524.5"></path><path id="kity_path_3101" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1816.5,11524.5C1819.5,11524.5,1819.5,11515.5,1822.5,11515.5L2160.5,11515.5"></path><path id="kity_path_3103" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M577.5,11417.5C580.5,11417.5,580.5,11550.5,583.5,11550.5L674.5,11550.5"></path><path id="kity_path_3105" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M674.5,11550.5C677.5,11550.5,677.5,11550.5,680.5,11550.5L792.5,11550.5"></path><path id="kity_path_3107" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M577.5,11417.5C580.5,11417.5,580.5,11576.5,583.5,11576.5L842.5,11576.5"></path><path id="kity_path_3109" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M842.5,11576.5C845.5,11576.5,845.5,11576.5,848.5,11576.5L926.5,11576.5"></path><path id="kity_path_3111" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,10497.5C531.5,10497.5,531.5,11850.5,534.5,11850.5L604.5,11850.5"></path><path id="kity_path_3113" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M604.5,11850.5C607.5,11850.5,607.5,11647.5,610.5,11647.5L739.5,11647.5"></path><path id="kity_path_3115" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M739.5,11647.5C742.5,11647.5,742.5,11692.5,745.5,11692.5L1353.5,11692.5"></path><path id="kity_path_3117" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1353.5,11692.5C1356.5,11692.5,1356.5,11647.5,1359.5,11647.5L1701.5,11647.5"></path><path id="kity_path_3119" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M604.5,11850.5C607.5,11850.5,607.5,11736.5,610.5,11736.5L774.5,11736.5"></path><path id="kity_path_3121" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M774.5,11736.5C777.5,11736.5,777.5,11754.5,780.5,11754.5L2583.5,11754.5"></path><path id="kity_path_3123" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M604.5,11850.5C607.5,11850.5,607.5,11798.5,610.5,11798.5L832.5,11798.5"></path><path id="kity_path_3125" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M832.5,11798.5C835.5,11798.5,835.5,11816.5,838.5,11816.5L2191.5,11816.5"></path><path id="kity_path_3127" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M604.5,11850.5C607.5,11850.5,607.5,11842.5,610.5,11842.5L792.5,11842.5"></path><path id="kity_path_3129" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M792.5,11842.5C795.5,11842.5,795.5,11842.5,798.5,11842.5L1049.5,11842.5"></path><path id="kity_path_3131" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M604.5,11850.5C607.5,11850.5,607.5,11895.5,610.5,11895.5L811.5,11895.5"></path><path id="kity_path_3133" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M811.5,11895.5C814.5,11895.5,814.5,11922.5,817.5,11922.5L1559.5,11922.5"></path><path id="kity_path_3135" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M604.5,11850.5C607.5,11850.5,607.5,11975.5,610.5,11975.5L883.5,11975.5"></path><path id="kity_path_3137" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M883.5,11975.5C886.5,11975.5,886.5,12002.5,889.5,12002.5L2435.5,12002.5"></path><path id="kity_path_3139" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M2435.5,12002.5C2438.5,12002.5,2438.5,11975.5,2441.5,11975.5L2783.5,11975.5"></path><path id="kity_path_3141" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M604.5,11850.5C607.5,11850.5,607.5,12028.5,610.5,12028.5L827.5,12028.5"></path><path id="kity_path_3143" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M827.5,12028.5C830.5,12028.5,830.5,12028.5,833.5,12028.5L2555.5,12028.5"></path><path id="kity_path_3145" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M604.5,11850.5C607.5,11850.5,607.5,12054.5,610.5,12054.5L739.5,12054.5"></path><path id="kity_path_3147" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M739.5,12054.5C742.5,12054.5,742.5,12054.5,745.5,12054.5L1051.5,12054.5"></path><path id="kity_path_3149" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,10497.5C531.5,10497.5,531.5,13397.5,534.5,13397.5L592.5,13397.5"></path><path id="kity_path_3151" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M592.5,13397.5C595.5,13397.5,595.5,12633.5,598.5,12633.5L643.5,12633.5"></path><path id="kity_path_3153" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M643.5,12633.5C646.5,12633.5,646.5,12080.5,649.5,12080.5L862.5,12080.5"></path><path id="kity_path_3155" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M862.5,12080.5C865.5,12080.5,865.5,12080.5,868.5,12080.5L1164.5,12080.5"></path><path id="kity_path_3157" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M643.5,12633.5C646.5,12633.5,646.5,12142.5,649.5,12142.5L791.5,12142.5"></path><path id="kity_path_3159" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M791.5,12142.5C794.5,12142.5,794.5,12178.5,797.5,12178.5L1323.5,12178.5"></path><path id="kity_path_3161" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M643.5,12633.5C646.5,12633.5,646.5,12339.5,649.5,12339.5L983.5,12339.5"></path><path id="kity_path_3163" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M983.5,12339.5C986.5,12339.5,986.5,12474.5,989.5,12474.5L2516.5,12474.5"></path><path id="kity_path_3165" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M2516.5,12474.5C2519.5,12474.5,2519.5,12339.5,2522.5,12339.5L2875.5,12339.5"></path><path id="kity_path_3167" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M643.5,12633.5C646.5,12633.5,646.5,12536.5,649.5,12536.5L837.5,12536.5"></path><path id="kity_path_3169" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M837.5,12536.5C840.5,12536.5,840.5,12572.5,843.5,12572.5L2334.5,12572.5"></path><path id="kity_path_3171" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M643.5,12633.5C646.5,12633.5,646.5,12652.5,649.5,12652.5L779.5,12652.5"></path><path id="kity_path_3173" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M779.5,12652.5C782.5,12652.5,782.5,12706.5,785.5,12706.5L1687.5,12706.5"></path><path id="kity_path_3175" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M643.5,12633.5C646.5,12633.5,646.5,12768.5,649.5,12768.5L791.5,12768.5"></path><path id="kity_path_3177" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M791.5,12768.5C794.5,12768.5,794.5,12804.5,797.5,12804.5L1440.5,12804.5"></path><path id="kity_path_3179" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M643.5,12633.5C646.5,12633.5,646.5,12857.5,649.5,12857.5L815.5,12857.5"></path><path id="kity_path_3181" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M815.5,12857.5C818.5,12857.5,818.5,12884.5,821.5,12884.5L1349.5,12884.5"></path><path id="kity_path_3183" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M643.5,12633.5C646.5,12633.5,646.5,13000.5,649.5,13000.5L815.5,13000.5"></path><path id="kity_path_3185" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M815.5,13000.5C818.5,13000.5,818.5,13090.5,821.5,13090.5L2630.5,13090.5"></path><path id="kity_path_3187" fill="none" stroke="none" display="none"></path><path id="kity_path_3189" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M643.5,12633.5C646.5,12633.5,646.5,13134.5,649.5,13134.5L874.5,13134.5"></path><path id="kity_path_3191" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M874.5,13134.5C877.5,13134.5,877.5,13152.5,880.5,13152.5L1545.5,13152.5"></path><path id="kity_path_3193" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M643.5,12633.5C646.5,12633.5,646.5,13187.5,649.5,13187.5L932.5,13187.5"></path><path id="kity_path_3195" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M932.5,13187.5C935.5,13187.5,935.5,13196.5,938.5,13196.5L2432.5,13196.5"></path><path id="kity_path_3197" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M592.5,13397.5C595.5,13397.5,595.5,13240.5,598.5,13240.5L644.5,13240.5"></path><path id="kity_path_3199" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M644.5,13240.5C647.5,13240.5,647.5,13240.5,650.5,13240.5L779.5,13240.5"></path><path id="kity_path_3201" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M779.5,13240.5C782.5,13240.5,782.5,13258.5,785.5,13258.5L1187.5,13258.5"></path><path id="kity_path_3203" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M592.5,13397.5C595.5,13397.5,595.5,13403.5,598.5,13403.5L726.5,13403.5"></path><path id="kity_path_3205" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M726.5,13403.5C729.5,13403.5,729.5,13284.5,732.5,13284.5L993.5,13284.5"></path><path id="kity_path_3207" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M993.5,13284.5C996.5,13284.5,996.5,13284.5,999.5,13284.5L1294.5,13284.5"></path><path id="kity_path_3209" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M726.5,13403.5C729.5,13403.5,729.5,13319.5,732.5,13319.5L1133.5,13319.5"></path><path id="kity_path_3211" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1133.5,13319.5C1136.5,13319.5,1136.5,13328.5,1139.5,13328.5L2036.5,13328.5"></path><path id="kity_path_3213" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M726.5,13403.5C729.5,13403.5,729.5,13354.5,732.5,13354.5L993.5,13354.5"></path><path id="kity_path_3215" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M993.5,13354.5C996.5,13354.5,996.5,13354.5,999.5,13354.5L1603.5,13354.5"></path><path id="kity_path_3217" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M726.5,13403.5C729.5,13403.5,729.5,13416.5,732.5,13416.5L970.5,13416.5"></path><path id="kity_path_3219" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M970.5,13416.5C973.5,13416.5,973.5,13452.5,976.5,13452.5L1886.5,13452.5"></path><path id="kity_path_3221" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M726.5,13403.5C729.5,13403.5,729.5,13523.5,732.5,13523.5L873.5,13523.5"></path><path id="kity_path_3223" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M873.5,13523.5C876.5,13523.5,876.5,13568.5,879.5,13568.5L2099.5,13568.5"></path><path id="kity_path_3225" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M592.5,13397.5C595.5,13397.5,595.5,13804.5,598.5,13804.5L729.5,13804.5"></path><path id="kity_path_3227" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M729.5,13804.5C732.5,13804.5,732.5,13630.5,735.5,13630.5L921.5,13630.5"></path><path id="kity_path_3229" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M921.5,13630.5C924.5,13630.5,924.5,13666.5,927.5,13666.5L2026.5,13666.5"></path><path id="kity_path_3231" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M729.5,13804.5C732.5,13804.5,732.5,13710.5,735.5,13710.5L858.5,13710.5"></path><path id="kity_path_3233" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M858.5,13710.5C861.5,13710.5,861.5,13728.5,864.5,13728.5L1926.5,13728.5"></path><path id="kity_path_3235" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1926.5,13728.5C1929.5,13728.5,1929.5,13719.5,1932.5,13719.5L2285.5,13719.5"></path><path id="kity_path_3237" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M729.5,13804.5C732.5,13804.5,732.5,13772.5,735.5,13772.5L904.5,13772.5"></path><path id="kity_path_3239" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M904.5,13772.5C907.5,13772.5,907.5,13790.5,910.5,13790.5L1433.5,13790.5"></path><path id="kity_path_3241" fill="none" stroke="none" display="none"></path><path id="kity_path_3243" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M729.5,13804.5C732.5,13804.5,732.5,13875.5,735.5,13875.5L927.5,13875.5"></path><path id="kity_path_3245" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M927.5,13875.5C930.5,13875.5,930.5,13911.5,933.5,13911.5L1683.5,13911.5"></path><path id="kity_path_3247" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1683.5,13911.5C1686.5,13911.5,1686.5,13935.5,1689.5,13935.5L1909.5,13935.5"></path><path id="kity_path_3249" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M729.5,13804.5C732.5,13804.5,732.5,13979.5,735.5,13979.5L879.5,13979.5"></path><path id="kity_path_3251" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M879.5,13979.5C882.5,13979.5,882.5,13997.5,885.5,13997.5L1517.5,13997.5"></path><path id="kity_path_3253" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M592.5,13397.5C595.5,13397.5,595.5,14161.5,598.5,14161.5L671.5,14161.5"></path><path id="kity_path_3255" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M671.5,14161.5C674.5,14161.5,674.5,14068.5,677.5,14068.5L1006.5,14068.5"></path><path id="kity_path_3257" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1006.5,14068.5C1009.5,14068.5,1009.5,14113.5,1012.5,14113.5L1953.5,14113.5"></path><path id="kity_path_3259" fill="none" stroke="none" display="none"></path><path id="kity_path_3261" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M671.5,14161.5C674.5,14161.5,674.5,14184.5,677.5,14184.5L769.5,14184.5"></path><path id="kity_path_3263" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M769.5,14184.5C772.5,14184.5,772.5,14229.5,775.5,14229.5L2448.5,14229.5"></path><path id="kity_path_3265" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M671.5,14161.5C674.5,14161.5,674.5,14255.5,677.5,14255.5L842.5,14255.5"></path><path id="kity_path_3267" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M842.5,14255.5C845.5,14255.5,845.5,14255.5,848.5,14255.5L1934.5,14255.5"></path><path id="kity_path_3269" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,10497.5C531.5,10497.5,531.5,14477.5,534.5,14477.5L593.5,14477.5"></path><path id="kity_path_3271" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M593.5,14477.5C596.5,14477.5,596.5,14302.5,599.5,14302.5L657.5,14302.5"></path><path id="kity_path_3273" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M657.5,14302.5C660.5,14302.5,660.5,14280.5,663.5,14280.5L817.5,14280.5"></path><path id="kity_path_3275" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M817.5,14280.5C820.5,14280.5,820.5,14280.5,823.5,14280.5L1352.5,14280.5"></path><path id="kity_path_3277" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M657.5,14302.5C660.5,14302.5,660.5,14324.5,663.5,14324.5L864.5,14324.5"></path><path id="kity_path_3279" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M864.5,14324.5C867.5,14324.5,867.5,14342.5,870.5,14342.5L1568.5,14342.5"></path><path id="kity_path_3281" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M593.5,14477.5C596.5,14477.5,596.5,14395.5,599.5,14395.5L703.5,14395.5"></path><path id="kity_path_3283" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M703.5,14395.5C706.5,14395.5,706.5,14378.5,709.5,14378.5L911.5,14378.5"></path><path id="kity_path_3285" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M911.5,14378.5C914.5,14378.5,914.5,14387.5,917.5,14387.5L1739.5,14387.5"></path><path id="kity_path_3287" fill="none" stroke="none" display="none"></path><path id="kity_path_3289" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M703.5,14395.5C706.5,14395.5,706.5,14413.5,709.5,14413.5L884.5,14413.5"></path><path id="kity_path_3291" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M884.5,14413.5C887.5,14413.5,887.5,14413.5,890.5,14413.5L1280.5,14413.5"></path><path id="kity_path_3293" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M593.5,14477.5C596.5,14477.5,596.5,14652.5,599.5,14652.5L683.5,14652.5"></path><path id="kity_path_3295" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M683.5,14652.5C686.5,14652.5,686.5,14448.5,689.5,14448.5L945.5,14448.5"></path><path id="kity_path_3297" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M945.5,14448.5C948.5,14448.5,948.5,14457.5,951.5,14457.5L1877.5,14457.5"></path><path id="kity_path_3299" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M683.5,14652.5C686.5,14652.5,686.5,14501.5,689.5,14501.5L821.5,14501.5"></path><path id="kity_path_3301" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M821.5,14501.5C824.5,14501.5,824.5,14519.5,827.5,14519.5L1553.5,14519.5"></path><path id="kity_path_3303" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M683.5,14652.5C686.5,14652.5,686.5,14644.5,689.5,14644.5L1057.5,14644.5"></path><path id="kity_path_3305" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1057.5,14644.5C1060.5,14644.5,1060.5,14743.5,1063.5,14743.5L2911.5,14743.5"></path><path id="kity_path_3307" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M2911.5,14743.5C2914.5,14743.5,2914.5,14671.5,2917.5,14671.5L3284.5,14671.5"></path><path id="kity_path_3309" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M683.5,14652.5C686.5,14652.5,686.5,14778.5,689.5,14778.5L921.5,14778.5"></path><path id="kity_path_3311" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M921.5,14778.5C924.5,14778.5,924.5,14787.5,927.5,14787.5L2021.5,14787.5"></path><path id="kity_path_3313" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M683.5,14652.5C686.5,14652.5,686.5,14822.5,689.5,14822.5L934.5,14822.5"></path><path id="kity_path_3315" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M934.5,14822.5C937.5,14822.5,937.5,14831.5,940.5,14831.5L1594.5,14831.5"></path><path id="kity_path_3317" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1594.5,14831.5C1597.5,14831.5,1597.5,14827.5,1600.5,14827.5L1699.5,14827.5"></path><path id="kity_path_3319" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M683.5,14652.5C686.5,14652.5,686.5,14857.5,689.5,14857.5L845.5,14857.5"></path><path id="kity_path_3321" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M845.5,14857.5C848.5,14857.5,848.5,14857.5,851.5,14857.5L2566.5,14857.5"></path><path id="kity_path_3323" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,10497.5C531.5,10497.5,531.5,15214.5,534.5,15214.5L604.5,15214.5"></path><path id="kity_path_3325" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M604.5,15214.5C607.5,15214.5,607.5,14984.5,610.5,14984.5L735.5,14984.5"></path><path id="kity_path_3327" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M735.5,14984.5C738.5,14984.5,738.5,14918.5,741.5,14918.5L897.5,14918.5"></path><path id="kity_path_3329" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M897.5,14918.5C900.5,14918.5,900.5,14954.5,903.5,14954.5L2089.5,14954.5"></path><path id="kity_path_3331" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M735.5,14984.5C738.5,14984.5,738.5,14989.5,741.5,14989.5L956.5,14989.5"></path><path id="kity_path_3333" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M956.5,14989.5C959.5,14989.5,959.5,14998.5,962.5,14998.5L1763.5,14998.5"></path><path id="kity_path_3335" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M735.5,14984.5C738.5,14984.5,738.5,15051.5,741.5,15051.5L1014.5,15051.5"></path><path id="kity_path_3337" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1014.5,15051.5C1017.5,15051.5,1017.5,15078.5,1020.5,15078.5L2433.5,15078.5"></path><path id="kity_path_3339" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M604.5,15214.5C607.5,15214.5,607.5,15149.5,610.5,15149.5L701.5,15149.5"></path><path id="kity_path_3341" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M701.5,15149.5C704.5,15149.5,704.5,15149.5,707.5,15149.5L895.5,15149.5"></path><path id="kity_path_3343" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M895.5,15149.5C898.5,15149.5,898.5,15194.5,901.5,15194.5L1800.5,15194.5"></path><path id="kity_path_3345" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M604.5,15214.5C607.5,15214.5,607.5,15301.5,610.5,15301.5L696.5,15301.5"></path><path id="kity_path_3347" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M696.5,15301.5C699.5,15301.5,699.5,15301.5,702.5,15301.5L861.5,15301.5"></path><path id="kity_path_3349" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M861.5,15301.5C864.5,15301.5,864.5,15382.5,867.5,15382.5L1697.5,15382.5"></path><path id="kity_path_3351" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M604.5,15214.5C607.5,15214.5,607.5,15444.5,610.5,15444.5L690.5,15444.5"></path><path id="kity_path_3353" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M690.5,15444.5C693.5,15444.5,693.5,15444.5,696.5,15444.5L860.5,15444.5"></path><path id="kity_path_3355" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M860.5,15444.5C863.5,15444.5,863.5,15480.5,866.5,15480.5L2243.5,15480.5"></path><path id="kity_path_3357" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,10497.5C531.5,10497.5,531.5,15676.5,534.5,15676.5L603.5,15676.5"></path><path id="kity_path_3359" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M603.5,15676.5C606.5,15676.5,606.5,15676.5,609.5,15676.5L740.5,15676.5"></path><path id="kity_path_3361" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M740.5,15676.5C743.5,15676.5,743.5,15590.5,746.5,15590.5L791.5,15590.5"></path><path id="kity_path_3363" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M791.5,15590.5C794.5,15590.5,794.5,15524.5,797.5,15524.5L975.5,15524.5"></path><path id="kity_path_3365" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M975.5,15524.5C978.5,15524.5,978.5,15542.5,981.5,15542.5L2014.5,15542.5"></path><path id="kity_path_3367" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M791.5,15590.5C794.5,15590.5,794.5,15586.5,797.5,15586.5L950.5,15586.5"></path><path id="kity_path_3369" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M950.5,15586.5C953.5,15586.5,953.5,15604.5,956.5,15604.5L1818.5,15604.5"></path><path id="kity_path_3371" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M791.5,15590.5C794.5,15590.5,794.5,15657.5,797.5,15657.5L1020.5,15657.5"></path><path id="kity_path_3373" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1020.5,15657.5C1023.5,15657.5,1023.5,15684.5,1026.5,15684.5L2385.5,15684.5"></path><path id="kity_path_3375" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M2385.5,15684.5C2388.5,15684.5,2388.5,15657.5,2391.5,15657.5L3009.5,15657.5"></path><path id="kity_path_3377" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M740.5,15676.5C743.5,15676.5,743.5,15710.5,746.5,15710.5L792.5,15710.5"></path><path id="kity_path_3379" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M740.5,15676.5C743.5,15676.5,743.5,15736.5,746.5,15736.5L791.5,15736.5"></path><path id="kity_path_3381" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M791.5,15736.5C794.5,15736.5,794.5,15736.5,797.5,15736.5L914.5,15736.5"></path><path id="kity_path_3383" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M914.5,15736.5C917.5,15736.5,917.5,15736.5,920.5,15736.5L1011.5,15736.5"></path><path id="kity_path_3385" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M740.5,15676.5C743.5,15676.5,743.5,15762.5,746.5,15762.5L852.5,15762.5"></path><path id="kity_path_3387" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,10497.5C531.5,10497.5,531.5,16101.5,534.5,16101.5L688.5,16101.5"></path><path id="kity_path_3389" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M688.5,16101.5C691.5,16101.5,691.5,15870.5,694.5,15870.5L1003.5,15870.5"></path><path id="kity_path_3391" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1003.5,15870.5C1006.5,15870.5,1006.5,15951.5,1009.5,15951.5L2388.5,15951.5"></path><path id="kity_path_3393" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M688.5,16101.5C691.5,16101.5,691.5,15979.5,694.5,15979.5L786.5,15979.5"></path><path id="kity_path_3395" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M786.5,15979.5C789.5,15979.5,789.5,15982.5,792.5,15982.5L1047.5,15982.5"></path><path id="kity_path_3397" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M688.5,16101.5C691.5,16101.5,691.5,16008.5,694.5,16008.5L833.5,16008.5"></path><path id="kity_path_3399" fill="none" stroke="none" display="none"></path><path id="kity_path_3401" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M688.5,16101.5C691.5,16101.5,691.5,16034.5,694.5,16034.5L836.5,16034.5"></path><path id="kity_path_3403" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M836.5,16034.5C839.5,16034.5,839.5,16034.5,842.5,16034.5L1438.5,16034.5"></path><path id="kity_path_3405" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M688.5,16101.5C691.5,16101.5,691.5,16060.5,694.5,16060.5L852.5,16060.5"></path><path id="kity_path_3407" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M688.5,16101.5C691.5,16101.5,691.5,16086.5,694.5,16086.5L883.5,16086.5"></path><path id="kity_path_3409" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M688.5,16101.5C691.5,16101.5,691.5,16112.5,694.5,16112.5L848.5,16112.5"></path><path id="kity_path_3411" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M688.5,16101.5C691.5,16101.5,691.5,16138.5,694.5,16138.5L1105.5,16138.5"></path><path id="kity_path_3413" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1105.5,16138.5C1108.5,16138.5,1108.5,16138.5,1111.5,16138.5L1418.5,16138.5"></path><path id="kity_path_3415" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M688.5,16101.5C691.5,16101.5,691.5,16164.5,694.5,16164.5L883.5,16164.5"></path><path id="kity_path_3417" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M883.5,16164.5C886.5,16164.5,886.5,16164.5,889.5,16164.5L1142.5,16164.5"></path><path id="kity_path_3419" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M688.5,16101.5C691.5,16101.5,691.5,16190.5,694.5,16190.5L1207.5,16190.5"></path><path id="kity_path_3421" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1207.5,16190.5C1210.5,16190.5,1210.5,16190.5,1213.5,16190.5L1711.5,16190.5"></path><path id="kity_path_3423" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M688.5,16101.5C691.5,16101.5,691.5,16333.5,694.5,16333.5L788.5,16333.5"></path><path id="kity_path_3425" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M788.5,16333.5C791.5,16333.5,791.5,16450.5,794.5,16450.5L2170.5,16450.5"></path><path id="kity_path_3427" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M476.5,16139.5C479.5,16139.5,479.5,21059.5,482.5,21059.5L528.5,21059.5"></path><path id="kity_path_3429" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,21059.5C531.5,21059.5,531.5,16609.5,534.5,16609.5L579.5,16609.5"></path><path id="kity_path_3431" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M579.5,16609.5C582.5,16609.5,582.5,16521.5,585.5,16521.5L811.5,16521.5"></path><path id="kity_path_3433" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M811.5,16521.5C814.5,16521.5,814.5,16566.5,817.5,16566.5L1783.5,16566.5"></path><path id="kity_path_3435" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M579.5,16609.5C582.5,16609.5,582.5,16601.5,585.5,16601.5L725.5,16601.5"></path><path id="kity_path_3437" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M725.5,16601.5C728.5,16601.5,728.5,16610.5,731.5,16610.5L1392.5,16610.5"></path><path id="kity_path_3439" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M579.5,16609.5C582.5,16609.5,582.5,16654.5,585.5,16654.5L698.5,16654.5"></path><path id="kity_path_3441" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M698.5,16654.5C701.5,16654.5,701.5,16672.5,704.5,16672.5L1727.5,16672.5"></path><path id="kity_path_3443" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M579.5,16609.5C582.5,16609.5,582.5,16698.5,585.5,16698.5L831.5,16698.5"></path><path id="kity_path_3445" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M831.5,16698.5C834.5,16698.5,834.5,16698.5,837.5,16698.5L1634.5,16698.5"></path><path id="kity_path_3447" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,21059.5C531.5,21059.5,531.5,18029.5,534.5,18029.5L583.5,18029.5"></path><path id="kity_path_3449" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M583.5,18029.5C586.5,18029.5,586.5,16849.5,589.5,16849.5L708.5,16849.5"></path><path id="kity_path_3451" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M708.5,16849.5C711.5,16849.5,711.5,16975.5,714.5,16975.5L3332.5,16975.5"></path><path id="kity_path_3453" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M3332.5,16975.5C3335.5,16975.5,3335.5,16924.5,3338.5,16924.5L3558.5,16924.5"></path><path id="kity_path_3455" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M583.5,18029.5C586.5,18029.5,586.5,17064.5,589.5,17064.5L765.5,17064.5"></path><path id="kity_path_3457" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M765.5,17064.5C768.5,17064.5,768.5,17127.5,771.5,17127.5L2141.5,17127.5"></path><path id="kity_path_3459" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M2141.5,17127.5C2144.5,17127.5,2144.5,17064.5,2147.5,17064.5L2520.5,17064.5"></path><path id="kity_path_3461" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M583.5,18029.5C586.5,18029.5,586.5,17207.5,589.5,17207.5L697.5,17207.5"></path><path id="kity_path_3463" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M697.5,17207.5C700.5,17207.5,700.5,17261.5,703.5,17261.5L2299.5,17261.5"></path><path id="kity_path_3465" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M2299.5,17261.5C2302.5,17261.5,2302.5,17216.5,2305.5,17216.5L2688.5,17216.5"></path><path id="kity_path_3467" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M583.5,18029.5C586.5,18029.5,586.5,17287.5,589.5,17287.5L731.5,17287.5"></path><path id="kity_path_3469" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M731.5,17287.5C734.5,17287.5,734.5,17287.5,737.5,17287.5L947.5,17287.5"></path><path id="kity_path_3471" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M583.5,18029.5C586.5,18029.5,586.5,17389.5,589.5,17389.5L871.5,17389.5"></path><path id="kity_path_3473" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M871.5,17389.5C874.5,17389.5,874.5,17349.5,877.5,17349.5L1080.5,17349.5"></path><path id="kity_path_3475" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1080.5,17349.5C1083.5,17349.5,1083.5,17385.5,1086.5,17385.5L1997.5,17385.5"></path><path id="kity_path_3477" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M871.5,17389.5C874.5,17389.5,874.5,17429.5,877.5,17429.5L1162.5,17429.5"></path><path id="kity_path_3479" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1162.5,17429.5C1165.5,17429.5,1165.5,17447.5,1168.5,17447.5L2180.5,17447.5"></path><path id="kity_path_3481" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M583.5,18029.5C586.5,18029.5,586.5,17500.5,589.5,17500.5L766.5,17500.5"></path><path id="kity_path_3483" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M766.5,17500.5C769.5,17500.5,769.5,17527.5,772.5,17527.5L1903.5,17527.5"></path><path id="kity_path_3485" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M583.5,18029.5C586.5,18029.5,586.5,17936.5,589.5,17936.5L779.5,17936.5"></path><path id="kity_path_3487" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M779.5,17936.5C782.5,17936.5,782.5,17571.5,785.5,17571.5L1572.5,17571.5"></path><path id="kity_path_3489" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M779.5,17936.5C782.5,17936.5,782.5,17615.5,785.5,17615.5L1033.5,17615.5"></path><path id="kity_path_3491" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1033.5,17615.5C1036.5,17615.5,1036.5,17633.5,1039.5,17633.5L1753.5,17633.5"></path><path id="kity_path_3493" fill="none" stroke="none" display="none"></path><path id="kity_path_3495" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M779.5,17936.5C782.5,17936.5,782.5,17677.5,785.5,17677.5L1118.5,17677.5"></path><path id="kity_path_3497" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1118.5,17677.5C1121.5,17677.5,1121.5,17695.5,1124.5,17695.5L1797.5,17695.5"></path><path id="kity_path_3499" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M779.5,17936.5C782.5,17936.5,782.5,17730.5,785.5,17730.5L903.5,17730.5"></path><path id="kity_path_3501" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M903.5,17730.5C906.5,17730.5,906.5,17739.5,909.5,17739.5L2115.5,17739.5"></path><path id="kity_path_3503" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M779.5,17936.5C782.5,17936.5,782.5,17783.5,785.5,17783.5L962.5,17783.5"></path><path id="kity_path_3505" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M962.5,17783.5C965.5,17783.5,965.5,17801.5,968.5,17801.5L1742.5,17801.5"></path><path id="kity_path_3507" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M779.5,17936.5C782.5,17936.5,782.5,17872.5,785.5,17872.5L914.5,17872.5"></path><path id="kity_path_3509" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M914.5,17872.5C917.5,17872.5,917.5,17917.5,920.5,17917.5L2173.5,17917.5"></path><path id="kity_path_3511" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M779.5,17936.5C782.5,17936.5,782.5,17943.5,785.5,17943.5L903.5,17943.5"></path><path id="kity_path_3513" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M903.5,17943.5C906.5,17943.5,906.5,17943.5,909.5,17943.5L1246.5,17943.5"></path><path id="kity_path_3515" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M779.5,17936.5C782.5,17936.5,782.5,18014.5,785.5,18014.5L1083.5,18014.5"></path><path id="kity_path_3517" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1083.5,18014.5C1086.5,18014.5,1086.5,18059.5,1089.5,18059.5L1733.5,18059.5"></path><path id="kity_path_3519" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M779.5,17936.5C782.5,17936.5,782.5,18301.5,785.5,18301.5L1068.5,18301.5"></path><path id="kity_path_3521" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1068.5,18301.5C1071.5,18301.5,1071.5,18355.5,1074.5,18355.5L2457.5,18355.5"></path><path id="kity_path_3523" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M2457.5,18355.5C2460.5,18355.5,2460.5,18145.5,2463.5,18145.5L2857.5,18145.5"></path><path id="kity_path_3525" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M2457.5,18355.5C2460.5,18355.5,2460.5,18286.5,2463.5,18286.5L2683.5,18286.5"></path><path id="kity_path_3527" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M2457.5,18355.5C2460.5,18355.5,2460.5,18517.5,2463.5,18517.5L2634.5,18517.5"></path><path id="kity_path_3529" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M583.5,18029.5C586.5,18029.5,586.5,18587.5,589.5,18587.5L730.5,18587.5"></path><path id="kity_path_3531" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M730.5,18587.5C733.5,18587.5,733.5,18632.5,736.5,18632.5L2005.5,18632.5"></path><path id="kity_path_3533" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M2005.5,18632.5C2008.5,18632.5,2008.5,18592.5,2011.5,18592.5L2110.5,18592.5"></path><path id="kity_path_3535" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M583.5,18029.5C586.5,18029.5,586.5,18694.5,589.5,18694.5L789.5,18694.5"></path><path id="kity_path_3537" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M789.5,18694.5C792.5,18694.5,792.5,18730.5,795.5,18730.5L2136.5,18730.5"></path><path id="kity_path_3539" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M2136.5,18730.5C2139.5,18730.5,2139.5,18703.5,2142.5,18703.5L2537.5,18703.5"></path><path id="kity_path_3541" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M583.5,18029.5C586.5,18029.5,586.5,18792.5,589.5,18792.5L735.5,18792.5"></path><path id="kity_path_3543" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M735.5,18792.5C738.5,18792.5,738.5,18828.5,741.5,18828.5L2623.5,18828.5"></path><path id="kity_path_3545" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M583.5,18029.5C586.5,18029.5,586.5,18863.5,589.5,18863.5L779.5,18863.5"></path><path id="kity_path_3547" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M779.5,18863.5C782.5,18863.5,782.5,18872.5,785.5,18872.5L1506.5,18872.5"></path><path id="kity_path_3549" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M583.5,18029.5C586.5,18029.5,586.5,18907.5,589.5,18907.5L695.5,18907.5"></path><path id="kity_path_3551" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M695.5,18907.5C698.5,18907.5,698.5,18916.5,701.5,18916.5L1683.5,18916.5"></path><path id="kity_path_3553" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M583.5,18029.5C586.5,18029.5,586.5,18960.5,589.5,18960.5L694.5,18960.5"></path><path id="kity_path_3555" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M694.5,18960.5C697.5,18960.5,697.5,18978.5,700.5,18978.5L2194.5,18978.5"></path><path id="kity_path_3557" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M583.5,18029.5C586.5,18029.5,586.5,19040.5,589.5,19040.5L741.5,19040.5"></path><path id="kity_path_3559" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M741.5,19040.5C744.5,19040.5,744.5,19076.5,747.5,19076.5L1997.5,19076.5"></path><path id="kity_path_3561" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M583.5,18029.5C586.5,18029.5,586.5,19138.5,589.5,19138.5L730.5,19138.5"></path><path id="kity_path_3563" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M730.5,19138.5C733.5,19138.5,733.5,19174.5,736.5,19174.5L2082.5,19174.5"></path><path id="kity_path_3565" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M2082.5,19174.5C2085.5,19174.5,2085.5,19138.5,2088.5,19138.5L2355.5,19138.5"></path><path id="kity_path_3567" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M583.5,18029.5C586.5,18029.5,586.5,19209.5,589.5,19209.5L754.5,19209.5"></path><path id="kity_path_3569" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M754.5,19209.5C757.5,19209.5,757.5,19218.5,760.5,19218.5L1198.5,19218.5"></path><path id="kity_path_3571" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1198.5,19218.5C1201.5,19218.5,1201.5,19218.5,1204.5,19218.5L1513.5,19218.5"></path><path id="kity_path_3573" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,21059.5C531.5,21059.5,531.5,19582.5,534.5,19582.5L603.5,19582.5"></path><path id="kity_path_3575" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M603.5,19582.5C606.5,19582.5,606.5,19280.5,609.5,19280.5L739.5,19280.5"></path><path id="kity_path_3577" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M739.5,19280.5C742.5,19280.5,742.5,19316.5,745.5,19316.5L2499.5,19316.5"></path><path id="kity_path_3579" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M603.5,19582.5C606.5,19582.5,606.5,19378.5,609.5,19378.5L810.5,19378.5"></path><path id="kity_path_3581" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M810.5,19378.5C813.5,19378.5,813.5,19414.5,816.5,19414.5L1745.5,19414.5"></path><path id="kity_path_3583" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M603.5,19582.5C606.5,19582.5,606.5,19503.5,609.5,19503.5L846.5,19503.5"></path><path id="kity_path_3585" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M846.5,19503.5C849.5,19503.5,849.5,19566.5,852.5,19566.5L1809.5,19566.5"></path><path id="kity_path_3587" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1809.5,19566.5C1812.5,19566.5,1812.5,19506.5,1815.5,19506.5L1952.5,19506.5"></path><path id="kity_path_3589" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M603.5,19582.5C606.5,19582.5,606.5,19619.5,609.5,19619.5L787.5,19619.5"></path><path id="kity_path_3591" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M787.5,19619.5C790.5,19619.5,790.5,19646.5,793.5,19646.5L2106.5,19646.5"></path><path id="kity_path_3593" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M603.5,19582.5C606.5,19582.5,606.5,19699.5,609.5,19699.5L738.5,19699.5"></path><path id="kity_path_3595" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M738.5,19699.5C741.5,19699.5,741.5,19726.5,744.5,19726.5L1624.5,19726.5"></path><path id="kity_path_3597" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M603.5,19582.5C606.5,19582.5,606.5,19770.5,609.5,19770.5L823.5,19770.5"></path><path id="kity_path_3599" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M823.5,19770.5C826.5,19770.5,826.5,19788.5,829.5,19788.5L2212.5,19788.5"></path><path id="kity_path_3601" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M603.5,19582.5C606.5,19582.5,606.5,19814.5,609.5,19814.5L828.5,19814.5"></path><path id="kity_path_3603" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M828.5,19814.5C831.5,19814.5,831.5,19814.5,834.5,19814.5L889.5,19814.5"></path><path id="kity_path_3605" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M603.5,19582.5C606.5,19582.5,606.5,19840.5,609.5,19840.5L738.5,19840.5"></path><path id="kity_path_3607" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M738.5,19840.5C741.5,19840.5,741.5,19840.5,744.5,19840.5L1143.5,19840.5"></path><path id="kity_path_3609" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M603.5,19582.5C606.5,19582.5,606.5,19884.5,609.5,19884.5L762.5,19884.5"></path><path id="kity_path_3611" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M762.5,19884.5C765.5,19884.5,765.5,19902.5,768.5,19902.5L1248.5,19902.5"></path><path id="kity_path_3613" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1248.5,19902.5C1251.5,19902.5,1251.5,19884.5,1254.5,19884.5L1558.5,19884.5"></path><path id="kity_path_3615" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,21059.5C531.5,21059.5,531.5,21136.5,534.5,21136.5L571.5,21136.5"></path><path id="kity_path_3617" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M571.5,21136.5C574.5,21136.5,574.5,19928.5,577.5,19928.5L685.5,19928.5"></path><path id="kity_path_3619" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M685.5,19928.5C688.5,19928.5,688.5,19928.5,691.5,19928.5L2156.5,19928.5"></path><path id="kity_path_3621" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M571.5,21136.5C574.5,21136.5,574.5,19990.5,577.5,19990.5L826.5,19990.5"></path><path id="kity_path_3623" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M826.5,19990.5C829.5,19990.5,829.5,20026.5,832.5,20026.5L1818.5,20026.5"></path><path id="kity_path_3625" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1818.5,20026.5C1821.5,20026.5,1821.5,19990.5,1824.5,19990.5L2171.5,19990.5"></path><path id="kity_path_3627" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M571.5,21136.5C574.5,21136.5,574.5,20106.5,577.5,20106.5L862.5,20106.5"></path><path id="kity_path_3629" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M862.5,20106.5C865.5,20106.5,865.5,20160.5,868.5,20160.5L2508.5,20160.5"></path><path id="kity_path_3631" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M2508.5,20160.5C2511.5,20160.5,2511.5,20115.5,2514.5,20115.5L2862.5,20115.5"></path><path id="kity_path_3633" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M571.5,21136.5C574.5,21136.5,574.5,20222.5,577.5,20222.5L754.5,20222.5"></path><path id="kity_path_3635" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M754.5,20222.5C757.5,20222.5,757.5,20258.5,760.5,20258.5L1570.5,20258.5"></path><path id="kity_path_3637" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M571.5,21136.5C574.5,21136.5,574.5,20347.5,577.5,20347.5L742.5,20347.5"></path><path id="kity_path_3639" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M742.5,20347.5C745.5,20347.5,745.5,20410.5,748.5,20410.5L1660.5,20410.5"></path><path id="kity_path_3641" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M571.5,21136.5C574.5,21136.5,574.5,20481.5,577.5,20481.5L696.5,20481.5"></path><path id="kity_path_3643" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M696.5,20481.5C699.5,20481.5,699.5,20526.5,702.5,20526.5L1614.5,20526.5"></path><path id="kity_path_3645" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M571.5,21136.5C574.5,21136.5,574.5,20588.5,577.5,20588.5L767.5,20588.5"></path><path id="kity_path_3647" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M767.5,20588.5C770.5,20588.5,770.5,20624.5,773.5,20624.5L2099.5,20624.5"></path><path id="kity_path_3649" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M571.5,21136.5C574.5,21136.5,574.5,20659.5,577.5,20659.5L718.5,20659.5"></path><path id="kity_path_3651" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M718.5,20659.5C721.5,20659.5,721.5,20668.5,724.5,20668.5L1549.5,20668.5"></path><path id="kity_path_3653" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M571.5,21136.5C574.5,21136.5,574.5,20820.5,577.5,20820.5L660.5,20820.5"></path><path id="kity_path_3655" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M660.5,20820.5C663.5,20820.5,663.5,20767.5,666.5,20767.5L798.5,20767.5"></path><path id="kity_path_3657" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M798.5,20767.5C801.5,20767.5,801.5,20839.5,804.5,20839.5L1801.5,20839.5"></path><path id="kity_path_3659" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M660.5,20820.5C663.5,20820.5,663.5,20874.5,666.5,20874.5L907.5,20874.5"></path><path id="kity_path_3661" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M907.5,20874.5C910.5,20874.5,910.5,20883.5,913.5,20883.5L1753.5,20883.5"></path><path id="kity_path_3663" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M571.5,21136.5C574.5,21136.5,574.5,21435.5,577.5,21435.5L694.5,21435.5"></path><path id="kity_path_3665" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M694.5,21435.5C697.5,21435.5,697.5,20989.5,700.5,20989.5L816.5,20989.5"></path><path id="kity_path_3667" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M816.5,20989.5C819.5,20989.5,819.5,21070.5,822.5,21070.5L1492.5,21070.5"></path><path id="kity_path_3669" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M694.5,21435.5C697.5,21435.5,697.5,21114.5,700.5,21114.5L797.5,21114.5"></path><path id="kity_path_3671" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M797.5,21114.5C800.5,21114.5,800.5,21132.5,803.5,21132.5L2538.5,21132.5"></path><path id="kity_path_3673" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M694.5,21435.5C697.5,21435.5,697.5,21185.5,700.5,21185.5L845.5,21185.5"></path><path id="kity_path_3675" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M845.5,21185.5C848.5,21185.5,848.5,21212.5,851.5,21212.5L2226.5,21212.5"></path><path id="kity_path_3677" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M2226.5,21212.5C2229.5,21212.5,2229.5,21185.5,2232.5,21185.5L2483.5,21185.5"></path><path id="kity_path_3679" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M694.5,21435.5C697.5,21435.5,697.5,21292.5,700.5,21292.5L817.5,21292.5"></path><path id="kity_path_3681" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M817.5,21292.5C820.5,21292.5,820.5,21346.5,823.5,21346.5L2100.5,21346.5"></path><path id="kity_path_3683" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M694.5,21435.5C697.5,21435.5,697.5,21408.5,700.5,21408.5L856.5,21408.5"></path><path id="kity_path_3685" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M856.5,21408.5C859.5,21408.5,859.5,21444.5,862.5,21444.5L1944.5,21444.5"></path><path id="kity_path_3687" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M694.5,21435.5C697.5,21435.5,697.5,21479.5,700.5,21479.5L868.5,21479.5"></path><path id="kity_path_3689" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M868.5,21479.5C871.5,21479.5,871.5,21488.5,874.5,21488.5L1424.5,21488.5"></path><path id="kity_path_3691" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M694.5,21435.5C697.5,21435.5,697.5,21622.5,700.5,21622.5L909.5,21622.5"></path><path id="kity_path_3693" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M909.5,21622.5C912.5,21622.5,912.5,21730.5,915.5,21730.5L2308.5,21730.5"></path><path id="kity_path_3695" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M694.5,21435.5C697.5,21435.5,697.5,21801.5,700.5,21801.5L890.5,21801.5"></path><path id="kity_path_3697" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M890.5,21801.5C893.5,21801.5,893.5,21846.5,896.5,21846.5L1339.5,21846.5"></path><path id="kity_path_3699" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M694.5,21435.5C697.5,21435.5,697.5,21881.5,700.5,21881.5L885.5,21881.5"></path><path id="kity_path_3701" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M885.5,21881.5C888.5,21881.5,888.5,21890.5,891.5,21890.5L2427.5,21890.5"></path><path id="kity_path_3703" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M2427.5,21890.5C2430.5,21890.5,2430.5,21881.5,2433.5,21881.5L2829.5,21881.5"></path><path id="kity_path_3705" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M571.5,21136.5C574.5,21136.5,574.5,21997.5,577.5,21997.5L647.5,21997.5"></path><path id="kity_path_3707" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M647.5,21997.5C650.5,21997.5,650.5,22078.5,653.5,22078.5L1695.5,22078.5"></path><path id="kity_path_3709" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M571.5,21136.5C574.5,21136.5,574.5,22122.5,577.5,22122.5L940.5,22122.5"></path><path id="kity_path_3711" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M940.5,22122.5C943.5,22122.5,943.5,22140.5,946.5,22140.5L1594.5,22140.5"></path><path id="kity_path_3713" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1594.5,22140.5C1597.5,22140.5,1597.5,22131.5,1600.5,22131.5L1904.5,22131.5"></path><path id="kity_path_3715" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M571.5,21136.5C574.5,21136.5,574.5,22224.5,577.5,22224.5L670.5,22224.5"></path><path id="kity_path_3717" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M670.5,22224.5C673.5,22224.5,673.5,22193.5,676.5,22193.5L816.5,22193.5"></path><path id="kity_path_3719" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M816.5,22193.5C819.5,22193.5,819.5,22220.5,822.5,22220.5L1596.5,22220.5"></path><path id="kity_path_3721" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M670.5,22224.5C673.5,22224.5,673.5,22255.5,676.5,22255.5L847.5,22255.5"></path><path id="kity_path_3723" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M847.5,22255.5C850.5,22255.5,850.5,22264.5,853.5,22264.5L1220.5,22264.5"></path><path id="kity_path_3725" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M571.5,21136.5C574.5,21136.5,574.5,22344.5,577.5,22344.5L790.5,22344.5"></path><path id="kity_path_3727" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M790.5,22344.5C793.5,22344.5,793.5,22398.5,796.5,22398.5L1329.5,22398.5"></path><path id="kity_path_3729" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1329.5,22398.5C1332.5,22398.5,1332.5,22344.5,1335.5,22344.5L1681.5,22344.5"></path><path id="kity_path_3731" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,21059.5C531.5,21059.5,531.5,22621.5,534.5,22621.5L605.5,22621.5"></path><path id="kity_path_3733" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M605.5,22621.5C608.5,22621.5,608.5,22496.5,611.5,22496.5L703.5,22496.5"></path><path id="kity_path_3735" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M703.5,22496.5C706.5,22496.5,706.5,22496.5,709.5,22496.5L848.5,22496.5"></path><path id="kity_path_3737" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M848.5,22496.5C851.5,22496.5,851.5,22568.5,854.5,22568.5L2177.5,22568.5"></path><path id="kity_path_3739" fill="none" stroke="none" display="none"></path><path id="kity_path_3741" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M605.5,22621.5C608.5,22621.5,608.5,22639.5,611.5,22639.5L670.5,22639.5"></path><path id="kity_path_3743" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M670.5,22639.5C673.5,22639.5,673.5,22639.5,676.5,22639.5L816.5,22639.5"></path><path id="kity_path_3745" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M816.5,22639.5C819.5,22639.5,819.5,22684.5,822.5,22684.5L1604.5,22684.5"></path><path id="kity_path_3747" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M605.5,22621.5C608.5,22621.5,608.5,22746.5,611.5,22746.5L703.5,22746.5"></path><path id="kity_path_3749" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M703.5,22746.5C706.5,22746.5,706.5,22746.5,709.5,22746.5L871.5,22746.5"></path><path id="kity_path_3751" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M871.5,22746.5C874.5,22746.5,874.5,22782.5,877.5,22782.5L1815.5,22782.5"></path><path id="kity_path_3753" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,21059.5C531.5,21059.5,531.5,23627.5,534.5,23627.5L592.5,23627.5"></path><path id="kity_path_3755" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M592.5,23627.5C595.5,23627.5,595.5,22817.5,598.5,22817.5L739.5,22817.5"></path><path id="kity_path_3757" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M739.5,22817.5C742.5,22817.5,742.5,22826.5,745.5,22826.5L1537.5,22826.5"></path><path id="kity_path_3759" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M592.5,23627.5C595.5,23627.5,595.5,22897.5,598.5,22897.5L727.5,22897.5"></path><path id="kity_path_3761" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M727.5,22897.5C730.5,22897.5,730.5,22942.5,733.5,22942.5L1427.5,22942.5"></path><path id="kity_path_3763" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M592.5,23627.5C595.5,23627.5,595.5,23022.5,598.5,23022.5L715.5,23022.5"></path><path id="kity_path_3765" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M715.5,23022.5C718.5,23022.5,718.5,23076.5,721.5,23076.5L1648.5,23076.5"></path><path id="kity_path_3767" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1648.5,23076.5C1651.5,23076.5,1651.5,23027.5,1654.5,23027.5L1727.5,23027.5"></path><path id="kity_path_3769" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M592.5,23627.5C595.5,23627.5,595.5,23156.5,598.5,23156.5L715.5,23156.5"></path><path id="kity_path_3771" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M715.5,23156.5C718.5,23156.5,718.5,23210.5,721.5,23210.5L1030.5,23210.5"></path><path id="kity_path_3773" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M592.5,23627.5C595.5,23627.5,595.5,23272.5,598.5,23272.5L764.5,23272.5"></path><path id="kity_path_3775" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M764.5,23272.5C767.5,23272.5,767.5,23308.5,770.5,23308.5L1397.5,23308.5"></path><path id="kity_path_3777" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M592.5,23627.5C595.5,23627.5,595.5,23352.5,598.5,23352.5L835.5,23352.5"></path><path id="kity_path_3779" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M835.5,23352.5C838.5,23352.5,838.5,23370.5,841.5,23370.5L1673.5,23370.5"></path><path id="kity_path_3781" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M592.5,23627.5C595.5,23627.5,595.5,23396.5,598.5,23396.5L703.5,23396.5"></path><path id="kity_path_3783" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M703.5,23396.5C706.5,23396.5,706.5,23396.5,709.5,23396.5L1085.5,23396.5"></path><path id="kity_path_3785" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M592.5,23627.5C595.5,23627.5,595.5,23512.5,598.5,23512.5L752.5,23512.5"></path><path id="kity_path_3787" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M752.5,23512.5C755.5,23512.5,755.5,23602.5,758.5,23602.5L1666.5,23602.5"></path><path id="kity_path_3789" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1666.5,23602.5C1669.5,23602.5,1669.5,23530.5,1672.5,23530.5L2153.5,23530.5"></path><path id="kity_path_3791" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M592.5,23627.5C595.5,23627.5,595.5,23628.5,598.5,23628.5L727.5,23628.5"></path><path id="kity_path_3793" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M727.5,23628.5C730.5,23628.5,730.5,23628.5,733.5,23628.5L1715.5,23628.5"></path><path id="kity_path_3795" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M592.5,23627.5C595.5,23627.5,595.5,23943.5,598.5,23943.5L740.5,23943.5"></path><path id="kity_path_3797" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M740.5,23943.5C743.5,23943.5,743.5,23663.5,746.5,23663.5L912.5,23663.5"></path><path id="kity_path_3799" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M912.5,23663.5C915.5,23663.5,915.5,23672.5,918.5,23672.5L1794.5,23672.5"></path><path id="kity_path_3801" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M740.5,23943.5C743.5,23943.5,743.5,23725.5,746.5,23725.5L912.5,23725.5"></path><path id="kity_path_3803" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M912.5,23725.5C915.5,23725.5,915.5,23752.5,918.5,23752.5L2206.5,23752.5"></path><path id="kity_path_3805" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M740.5,23943.5C743.5,23943.5,743.5,23823.5,746.5,23823.5L938.5,23823.5"></path><path id="kity_path_3807" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M938.5,23823.5C941.5,23823.5,941.5,23868.5,944.5,23868.5L2056.5,23868.5"></path><path id="kity_path_3809" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M2056.5,23868.5C2059.5,23868.5,2059.5,23832.5,2062.5,23832.5L2548.5,23832.5"></path><path id="kity_path_3811" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M740.5,23943.5C743.5,23943.5,743.5,23894.5,746.5,23894.5L891.5,23894.5"></path><path id="kity_path_3813" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M891.5,23894.5C894.5,23894.5,894.5,23894.5,897.5,23894.5L2442.5,23894.5"></path><path id="kity_path_3815" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M740.5,23943.5C743.5,23943.5,743.5,23965.5,746.5,23965.5L900.5,23965.5"></path><path id="kity_path_3817" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M900.5,23965.5C903.5,23965.5,903.5,24010.5,906.5,24010.5L1827.5,24010.5"></path><path id="kity_path_3819" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1827.5,24010.5C1830.5,24010.5,1830.5,24001.5,1833.5,24001.5L2205.5,24001.5"></path><path id="kity_path_3821" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M740.5,23943.5C743.5,23943.5,743.5,24081.5,746.5,24081.5L984.5,24081.5"></path><path id="kity_path_3823" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M984.5,24081.5C987.5,24081.5,987.5,24126.5,990.5,24126.5L2091.5,24126.5"></path><path id="kity_path_3825" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M740.5,23943.5C743.5,23943.5,743.5,24224.5,746.5,24224.5L1007.5,24224.5"></path><path id="kity_path_3827" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1007.5,24224.5C1010.5,24224.5,1010.5,24296.5,1013.5,24296.5L2010.5,24296.5"></path><path id="kity_path_3829" fill="none" stroke="none" display="none"></path><path id="kity_path_3831" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M592.5,23627.5C595.5,23627.5,595.5,24437.5,598.5,24437.5L683.5,24437.5"></path><path id="kity_path_3833" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M683.5,24437.5C686.5,24437.5,686.5,24437.5,689.5,24437.5L737.5,24437.5"></path><path id="kity_path_3835" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M737.5,24437.5C740.5,24437.5,740.5,24437.5,743.5,24437.5L1675.5,24437.5"></path><path id="kity_path_3837" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1675.5,24437.5C1678.5,24437.5,1678.5,24322.5,1681.5,24322.5L1999.5,24322.5"></path><path id="kity_path_3839" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1675.5,24437.5C1678.5,24437.5,1678.5,24553.5,1681.5,24553.5L1823.5,24553.5"></path><path id="kity_path_3841" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,21059.5C531.5,21059.5,531.5,25509.5,534.5,25509.5L664.5,25509.5"></path><path id="kity_path_3843" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M664.5,25509.5C667.5,25509.5,667.5,24636.5,670.5,24636.5L737.5,24636.5"></path><path id="kity_path_3845" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M737.5,24636.5C740.5,24636.5,740.5,24588.5,743.5,24588.5L907.5,24588.5"></path><path id="kity_path_3847" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M907.5,24588.5C910.5,24588.5,910.5,24597.5,913.5,24597.5L1203.5,24597.5"></path><path id="kity_path_3849" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M737.5,24636.5C740.5,24636.5,740.5,24641.5,743.5,24641.5L907.5,24641.5"></path><path id="kity_path_3851" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M907.5,24641.5C910.5,24641.5,910.5,24659.5,913.5,24659.5L1576.5,24659.5"></path><path id="kity_path_3853" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M737.5,24636.5C740.5,24636.5,740.5,24685.5,743.5,24685.5L870.5,24685.5"></path><path id="kity_path_3855" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M870.5,24685.5C873.5,24685.5,873.5,24685.5,876.5,24685.5L1241.5,24685.5"></path><path id="kity_path_3857" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M664.5,25509.5C667.5,25509.5,667.5,24876.5,670.5,24876.5L725.5,24876.5"></path><path id="kity_path_3859" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M725.5,24876.5C728.5,24876.5,728.5,24756.5,731.5,24756.5L884.5,24756.5"></path><path id="kity_path_3861" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M884.5,24756.5C887.5,24756.5,887.5,24801.5,890.5,24801.5L1993.5,24801.5"></path><path id="kity_path_3863" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1993.5,24801.5C1996.5,24801.5,1996.5,24756.5,1999.5,24756.5L2345.5,24756.5"></path><path id="kity_path_3865" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M725.5,24876.5C728.5,24876.5,728.5,24863.5,731.5,24863.5L884.5,24863.5"></path><path id="kity_path_3867" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M884.5,24863.5C887.5,24863.5,887.5,24899.5,890.5,24899.5L2323.5,24899.5"></path><path id="kity_path_3869" fill="none" stroke="none" display="none"></path><path id="kity_path_3871" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M725.5,24876.5C728.5,24876.5,728.5,24997.5,731.5,24997.5L872.5,24997.5"></path><path id="kity_path_3873" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M872.5,24997.5C875.5,24997.5,875.5,25069.5,878.5,25069.5L2268.5,25069.5"></path><path id="kity_path_3875" fill="none" stroke="none" display="none"></path><path id="kity_path_3877" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M664.5,25509.5C667.5,25509.5,667.5,25095.5,670.5,25095.5L798.5,25095.5"></path><path id="kity_path_3879" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M798.5,25095.5C801.5,25095.5,801.5,25095.5,804.5,25095.5L1428.5,25095.5"></path><path id="kity_path_3881" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M664.5,25509.5C667.5,25509.5,667.5,25121.5,670.5,25121.5L844.5,25121.5"></path><path id="kity_path_3883" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M664.5,25509.5C667.5,25509.5,667.5,25210.5,670.5,25210.5L807.5,25210.5"></path><path id="kity_path_3885" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M807.5,25210.5C810.5,25210.5,810.5,25273.5,813.5,25273.5L2450.5,25273.5"></path><path id="kity_path_3887" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M664.5,25509.5C667.5,25509.5,667.5,25317.5,670.5,25317.5L806.5,25317.5"></path><path id="kity_path_3889" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M806.5,25317.5C809.5,25317.5,809.5,25335.5,812.5,25335.5L1111.5,25335.5"></path><path id="kity_path_3891" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1111.5,25335.5C1114.5,25335.5,1114.5,25317.5,1117.5,25317.5L1467.5,25317.5"></path><path id="kity_path_3893" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M664.5,25509.5C667.5,25509.5,667.5,25361.5,670.5,25361.5L931.5,25361.5"></path><path id="kity_path_3895" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M931.5,25361.5C934.5,25361.5,934.5,25361.5,937.5,25361.5L1731.5,25361.5"></path><path id="kity_path_3897" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M664.5,25509.5C667.5,25509.5,667.5,25493.5,670.5,25493.5L835.5,25493.5"></path><path id="kity_path_3899" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M835.5,25493.5C838.5,25493.5,838.5,25423.5,841.5,25423.5L1030.5,25423.5"></path><path id="kity_path_3901" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1030.5,25423.5C1033.5,25423.5,1033.5,25459.5,1036.5,25459.5L1623.5,25459.5"></path><path id="kity_path_3903" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M835.5,25493.5C838.5,25493.5,838.5,25485.5,841.5,25485.5L934.5,25485.5"></path><path id="kity_path_3905" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M835.5,25493.5C838.5,25493.5,838.5,25511.5,841.5,25511.5L1042.5,25511.5"></path><path id="kity_path_3907" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M835.5,25493.5C838.5,25493.5,838.5,25537.5,841.5,25537.5L946.5,25537.5"></path><path id="kity_path_3909" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M835.5,25493.5C838.5,25493.5,838.5,25563.5,841.5,25563.5L1042.5,25563.5"></path><path id="kity_path_3911" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M664.5,25509.5C667.5,25509.5,667.5,25670.5,670.5,25670.5L808.5,25670.5"></path><path id="kity_path_3913" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M808.5,25670.5C811.5,25670.5,811.5,25751.5,814.5,25751.5L1700.5,25751.5"></path><path id="kity_path_3915" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M664.5,25509.5C667.5,25509.5,667.5,26019.5,670.5,26019.5L797.5,26019.5"></path><path id="kity_path_3917" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M797.5,26019.5C800.5,26019.5,800.5,26002.5,803.5,26002.5L1559.5,26002.5"></path><path id="kity_path_3919" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1559.5,26002.5C1562.5,26002.5,1562.5,26119.5,1565.5,26119.5L3363.5,26119.5"></path><path id="kity_path_3921" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M797.5,26019.5C800.5,26019.5,800.5,26145.5,803.5,26145.5L1127.5,26145.5"></path><path id="kity_path_3923" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M664.5,25509.5C667.5,25509.5,667.5,26198.5,670.5,26198.5L880.5,26198.5"></path><path id="kity_path_3925" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M880.5,26198.5C883.5,26198.5,883.5,26225.5,886.5,26225.5L2218.5,26225.5"></path><path id="kity_path_3927" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M2218.5,26225.5C2221.5,26225.5,2221.5,26216.5,2224.5,26216.5L2748.5,26216.5"></path><path id="kity_path_3929" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M664.5,25509.5C667.5,25509.5,667.5,26251.5,670.5,26251.5L1076.5,26251.5"></path><path id="kity_path_3931" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M664.5,25509.5C667.5,25509.5,667.5,26277.5,670.5,26277.5L871.5,26277.5"></path><path id="kity_path_3933" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M871.5,26277.5C874.5,26277.5,874.5,26277.5,877.5,26277.5L946.5,26277.5"></path><path id="kity_path_3935" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M664.5,25509.5C667.5,25509.5,667.5,26303.5,670.5,26303.5L812.5,26303.5"></path><path id="kity_path_3937" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M812.5,26303.5C815.5,26303.5,815.5,26303.5,818.5,26303.5L1120.5,26303.5"></path><path id="kity_path_3939" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M664.5,25509.5C667.5,25509.5,667.5,26347.5,670.5,26347.5L949.5,26347.5"></path><path id="kity_path_3941" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M949.5,26347.5C952.5,26347.5,952.5,26338.5,955.5,26338.5L1327.5,26338.5"></path><path id="kity_path_3943" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M664.5,25509.5C667.5,25509.5,667.5,26382.5,670.5,26382.5L765.5,26382.5"></path><path id="kity_path_3945" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M765.5,26382.5C768.5,26382.5,768.5,26391.5,771.5,26391.5L1308.5,26391.5"></path><path id="kity_path_3947" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M476.5,16139.5C479.5,16139.5,479.5,28237.5,482.5,28237.5L528.5,28237.5"></path><path id="kity_path_3949" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,28237.5C531.5,28237.5,531.5,26901.5,534.5,26901.5L574.5,26901.5"></path><path id="kity_path_3951" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M574.5,26901.5C577.5,26901.5,577.5,26561.5,580.5,26561.5L652.5,26561.5"></path><path id="kity_path_3953" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M652.5,26561.5C655.5,26561.5,655.5,26418.5,658.5,26418.5L810.5,26418.5"></path><path id="kity_path_3955" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M810.5,26418.5C813.5,26418.5,813.5,26418.5,816.5,26418.5L1441.5,26418.5"></path><path id="kity_path_3957" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M652.5,26561.5C655.5,26561.5,655.5,26444.5,658.5,26444.5L789.5,26444.5"></path><path id="kity_path_3959" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M789.5,26444.5C792.5,26444.5,792.5,26444.5,795.5,26444.5L2183.5,26444.5"></path><path id="kity_path_3961" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M652.5,26561.5C655.5,26561.5,655.5,26470.5,658.5,26470.5L777.5,26470.5"></path><path id="kity_path_3963" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M777.5,26470.5C780.5,26470.5,780.5,26470.5,783.5,26470.5L1483.5,26470.5"></path><path id="kity_path_3965" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M652.5,26561.5C655.5,26561.5,655.5,26496.5,658.5,26496.5L812.5,26496.5"></path><path id="kity_path_3967" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M812.5,26496.5C815.5,26496.5,815.5,26496.5,818.5,26496.5L1698.5,26496.5"></path><path id="kity_path_3969" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M652.5,26561.5C655.5,26561.5,655.5,26522.5,658.5,26522.5L809.5,26522.5"></path><path id="kity_path_3971" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M809.5,26522.5C812.5,26522.5,812.5,26522.5,815.5,26522.5L1029.5,26522.5"></path><path id="kity_path_3973" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M652.5,26561.5C655.5,26561.5,655.5,26548.5,658.5,26548.5L833.5,26548.5"></path><path id="kity_path_3975" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M833.5,26548.5C836.5,26548.5,836.5,26548.5,839.5,26548.5L1855.5,26548.5"></path><path id="kity_path_3977" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M652.5,26561.5C655.5,26561.5,655.5,26574.5,658.5,26574.5L960.5,26574.5"></path><path id="kity_path_3979" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M960.5,26574.5C963.5,26574.5,963.5,26574.5,966.5,26574.5L1931.5,26574.5"></path><path id="kity_path_3981" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M652.5,26561.5C655.5,26561.5,655.5,26600.5,658.5,26600.5L946.5,26600.5"></path><path id="kity_path_3983" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M946.5,26600.5C949.5,26600.5,949.5,26600.5,952.5,26600.5L1785.5,26600.5"></path><path id="kity_path_3985" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M652.5,26561.5C655.5,26561.5,655.5,26626.5,658.5,26626.5L801.5,26626.5"></path><path id="kity_path_3987" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M801.5,26626.5C804.5,26626.5,804.5,26626.5,807.5,26626.5L1552.5,26626.5"></path><path id="kity_path_3989" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M652.5,26561.5C655.5,26561.5,655.5,26652.5,658.5,26652.5L826.5,26652.5"></path><path id="kity_path_3991" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M826.5,26652.5C829.5,26652.5,829.5,26652.5,832.5,26652.5L1129.5,26652.5"></path><path id="kity_path_3993" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M652.5,26561.5C655.5,26561.5,655.5,26678.5,658.5,26678.5L825.5,26678.5"></path><path id="kity_path_3995" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M825.5,26678.5C828.5,26678.5,828.5,26678.5,831.5,26678.5L1080.5,26678.5"></path><path id="kity_path_3997" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M652.5,26561.5C655.5,26561.5,655.5,26704.5,658.5,26704.5L974.5,26704.5"></path><path id="kity_path_3999" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M974.5,26704.5C977.5,26704.5,977.5,26704.5,980.5,26704.5L1472.5,26704.5"></path><path id="kity_path_4001" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M574.5,26901.5C577.5,26901.5,577.5,26756.5,580.5,26756.5L658.5,26756.5"></path><path id="kity_path_4003" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M658.5,26756.5C661.5,26756.5,661.5,26730.5,664.5,26730.5L826.5,26730.5"></path><path id="kity_path_4005" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M826.5,26730.5C829.5,26730.5,829.5,26730.5,832.5,26730.5L1615.5,26730.5"></path><path id="kity_path_4007" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M658.5,26756.5C661.5,26756.5,661.5,26756.5,664.5,26756.5L789.5,26756.5"></path><path id="kity_path_4009" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M789.5,26756.5C792.5,26756.5,792.5,26756.5,795.5,26756.5L1455.5,26756.5"></path><path id="kity_path_4011" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M658.5,26756.5C661.5,26756.5,661.5,26782.5,664.5,26782.5L836.5,26782.5"></path><path id="kity_path_4013" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M836.5,26782.5C839.5,26782.5,839.5,26782.5,842.5,26782.5L1310.5,26782.5"></path><path id="kity_path_4015" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M574.5,26901.5C577.5,26901.5,577.5,26986.5,580.5,26986.5L617.5,26986.5"></path><path id="kity_path_4017" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M617.5,26986.5C620.5,26986.5,620.5,26808.5,623.5,26808.5L720.5,26808.5"></path><path id="kity_path_4019" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M720.5,26808.5C723.5,26808.5,723.5,26808.5,726.5,26808.5L1076.5,26808.5"></path><path id="kity_path_4021" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M617.5,26986.5C620.5,26986.5,620.5,26834.5,623.5,26834.5L756.5,26834.5"></path><path id="kity_path_4023" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M756.5,26834.5C759.5,26834.5,759.5,26834.5,762.5,26834.5L1261.5,26834.5"></path><path id="kity_path_4025" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M617.5,26986.5C620.5,26986.5,620.5,26860.5,623.5,26860.5L932.5,26860.5"></path><path id="kity_path_4027" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M932.5,26860.5C935.5,26860.5,935.5,26860.5,938.5,26860.5L1247.5,26860.5"></path><path id="kity_path_4029" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M617.5,26986.5C620.5,26986.5,620.5,26886.5,623.5,26886.5L861.5,26886.5"></path><path id="kity_path_4031" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M861.5,26886.5C864.5,26886.5,864.5,26886.5,867.5,26886.5L2033.5,26886.5"></path><path id="kity_path_4033" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M617.5,26986.5C620.5,26986.5,620.5,26921.5,623.5,26921.5L740.5,26921.5"></path><path id="kity_path_4035" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M740.5,26921.5C743.5,26921.5,743.5,26930.5,746.5,26930.5L1899.5,26930.5"></path><path id="kity_path_4037" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M617.5,26986.5C620.5,26986.5,620.5,26956.5,623.5,26956.5L763.5,26956.5"></path><path id="kity_path_4039" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M763.5,26956.5C766.5,26956.5,766.5,26956.5,769.5,26956.5L1090.5,26956.5"></path><path id="kity_path_4041" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M617.5,26986.5C620.5,26986.5,620.5,26982.5,623.5,26982.5L872.5,26982.5"></path><path id="kity_path_4043" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M872.5,26982.5C875.5,26982.5,875.5,26982.5,878.5,26982.5L1175.5,26982.5"></path><path id="kity_path_4045" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M617.5,26986.5C620.5,26986.5,620.5,27008.5,623.5,27008.5L800.5,27008.5"></path><path id="kity_path_4047" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M800.5,27008.5C803.5,27008.5,803.5,27008.5,806.5,27008.5L1762.5,27008.5"></path><path id="kity_path_4049" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M617.5,26986.5C620.5,26986.5,620.5,27034.5,623.5,27034.5L917.5,27034.5"></path><path id="kity_path_4051" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M917.5,27034.5C920.5,27034.5,920.5,27034.5,923.5,27034.5L1741.5,27034.5"></path><path id="kity_path_4053" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M617.5,26986.5C620.5,26986.5,620.5,27060.5,623.5,27060.5L994.5,27060.5"></path><path id="kity_path_4055" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M994.5,27060.5C997.5,27060.5,997.5,27060.5,1000.5,27060.5L1690.5,27060.5"></path><path id="kity_path_4057" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M617.5,26986.5C620.5,26986.5,620.5,27086.5,623.5,27086.5L744.5,27086.5"></path><path id="kity_path_4059" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M744.5,27086.5C747.5,27086.5,747.5,27086.5,750.5,27086.5L1783.5,27086.5"></path><path id="kity_path_4061" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M617.5,26986.5C620.5,26986.5,620.5,27112.5,623.5,27112.5L812.5,27112.5"></path><path id="kity_path_4063" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M812.5,27112.5C815.5,27112.5,815.5,27112.5,818.5,27112.5L1289.5,27112.5"></path><path id="kity_path_4065" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M617.5,26986.5C620.5,26986.5,620.5,27138.5,623.5,27138.5L786.5,27138.5"></path><path id="kity_path_4067" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M786.5,27138.5C789.5,27138.5,789.5,27138.5,792.5,27138.5L1498.5,27138.5"></path><path id="kity_path_4069" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M617.5,26986.5C620.5,26986.5,620.5,27164.5,623.5,27164.5L748.5,27164.5"></path><path id="kity_path_4071" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M748.5,27164.5C751.5,27164.5,751.5,27164.5,754.5,27164.5L1437.5,27164.5"></path><path id="kity_path_4073" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M574.5,26901.5C577.5,26901.5,577.5,27242.5,580.5,27242.5L729.5,27242.5"></path><path id="kity_path_4075" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M729.5,27242.5C732.5,27242.5,732.5,27190.5,735.5,27190.5L957.5,27190.5"></path><path id="kity_path_4077" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M957.5,27190.5C960.5,27190.5,960.5,27190.5,963.5,27190.5L2268.5,27190.5"></path><path id="kity_path_4079" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M729.5,27242.5C732.5,27242.5,732.5,27216.5,735.5,27216.5L969.5,27216.5"></path><path id="kity_path_4081" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M969.5,27216.5C972.5,27216.5,972.5,27216.5,975.5,27216.5L1651.5,27216.5"></path><path id="kity_path_4083" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M729.5,27242.5C732.5,27242.5,732.5,27242.5,735.5,27242.5L968.5,27242.5"></path><path id="kity_path_4085" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M968.5,27242.5C971.5,27242.5,971.5,27242.5,974.5,27242.5L1283.5,27242.5"></path><path id="kity_path_4087" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M729.5,27242.5C732.5,27242.5,732.5,27268.5,735.5,27268.5L853.5,27268.5"></path><path id="kity_path_4089" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M853.5,27268.5C856.5,27268.5,856.5,27268.5,859.5,27268.5L1397.5,27268.5"></path><path id="kity_path_4091" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M729.5,27242.5C732.5,27242.5,732.5,27294.5,735.5,27294.5L915.5,27294.5"></path><path id="kity_path_4093" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M915.5,27294.5C918.5,27294.5,918.5,27294.5,921.5,27294.5L1368.5,27294.5"></path><path id="kity_path_4095" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,28237.5C531.5,28237.5,531.5,28635.5,534.5,28635.5L580.5,28635.5"></path><path id="kity_path_4097" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M580.5,28635.5C583.5,28635.5,583.5,27931.5,586.5,27931.5L659.5,27931.5"></path><path id="kity_path_4099" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,27329.5,665.5,27329.5L811.5,27329.5"></path><path id="kity_path_4101" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M811.5,27329.5C814.5,27329.5,814.5,27338.5,817.5,27338.5L1251.5,27338.5"></path><path id="kity_path_4103" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,27364.5,665.5,27364.5L884.5,27364.5"></path><path id="kity_path_4105" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M884.5,27364.5C887.5,27364.5,887.5,27364.5,890.5,27364.5L1580.5,27364.5"></path><path id="kity_path_4107" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,27417.5,665.5,27417.5L860.5,27417.5"></path><path id="kity_path_4109" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M860.5,27417.5C863.5,27417.5,863.5,27435.5,866.5,27435.5L1791.5,27435.5"></path><path id="kity_path_4111" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1791.5,27435.5C1794.5,27435.5,1794.5,27444.5,1797.5,27444.5L2461.5,27444.5"></path><path id="kity_path_4113" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,27470.5,665.5,27470.5L823.5,27470.5"></path><path id="kity_path_4115" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M823.5,27470.5C826.5,27470.5,826.5,27470.5,829.5,27470.5L1900.5,27470.5"></path><path id="kity_path_4117" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,27496.5,665.5,27496.5L912.5,27496.5"></path><path id="kity_path_4119" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M912.5,27496.5C915.5,27496.5,915.5,27496.5,918.5,27496.5L1118.5,27496.5"></path><path id="kity_path_4121" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,27531.5,665.5,27531.5L746.5,27531.5"></path><path id="kity_path_4123" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M746.5,27531.5C749.5,27531.5,749.5,27540.5,752.5,27540.5L1723.5,27540.5"></path><path id="kity_path_4125" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,27566.5,665.5,27566.5L862.5,27566.5"></path><path id="kity_path_4127" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M862.5,27566.5C865.5,27566.5,865.5,27566.5,868.5,27566.5L1748.5,27566.5"></path><path id="kity_path_4129" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,27592.5,665.5,27592.5L821.5,27592.5"></path><path id="kity_path_4131" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M821.5,27592.5C824.5,27592.5,824.5,27592.5,827.5,27592.5L2074.5,27592.5"></path><path id="kity_path_4133" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,27636.5,665.5,27636.5L832.5,27636.5"></path><path id="kity_path_4135" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M832.5,27636.5C835.5,27636.5,835.5,27654.5,838.5,27654.5L1642.5,27654.5"></path><path id="kity_path_4137" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,27698.5,665.5,27698.5L825.5,27698.5"></path><path id="kity_path_4139" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M825.5,27698.5C828.5,27698.5,828.5,27716.5,831.5,27716.5L1401.5,27716.5"></path><path id="kity_path_4141" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,27742.5,665.5,27742.5L836.5,27742.5"></path><path id="kity_path_4143" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M836.5,27742.5C839.5,27742.5,839.5,27742.5,842.5,27742.5L1789.5,27742.5"></path><path id="kity_path_4145" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,27777.5,665.5,27777.5L925.5,27777.5"></path><path id="kity_path_4147" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M925.5,27777.5C928.5,27777.5,928.5,27786.5,931.5,27786.5L1776.5,27786.5"></path><path id="kity_path_4149" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,27812.5,665.5,27812.5L879.5,27812.5"></path><path id="kity_path_4151" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M879.5,27812.5C882.5,27812.5,882.5,27812.5,885.5,27812.5L1859.5,27812.5"></path><path id="kity_path_4153" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,27838.5,665.5,27838.5L1002.5,27838.5"></path><path id="kity_path_4155" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1002.5,27838.5C1005.5,27838.5,1005.5,27838.5,1008.5,27838.5L1527.5,27838.5"></path><path id="kity_path_4157" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,27864.5,665.5,27864.5L884.5,27864.5"></path><path id="kity_path_4159" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M884.5,27864.5C887.5,27864.5,887.5,27864.5,890.5,27864.5L1116.5,27864.5"></path><path id="kity_path_4161" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,27890.5,665.5,27890.5L1008.5,27890.5"></path><path id="kity_path_4163" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1008.5,27890.5C1011.5,27890.5,1011.5,27890.5,1014.5,27890.5L1834.5,27890.5"></path><path id="kity_path_4165" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,27952.5,665.5,27952.5L890.5,27952.5"></path><path id="kity_path_4167" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M890.5,27952.5C893.5,27952.5,893.5,27988.5,896.5,27988.5L1461.5,27988.5"></path><path id="kity_path_4169" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,28014.5,665.5,28014.5L829.5,28014.5"></path><path id="kity_path_4171" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M829.5,28014.5C832.5,28014.5,832.5,28014.5,835.5,28014.5L1668.5,28014.5"></path><path id="kity_path_4173" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,28067.5,665.5,28067.5L890.5,28067.5"></path><path id="kity_path_4175" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M890.5,28067.5C893.5,28067.5,893.5,28094.5,896.5,28094.5L1361.5,28094.5"></path><path id="kity_path_4177" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,28120.5,665.5,28120.5L853.5,28120.5"></path><path id="kity_path_4179" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,28146.5,665.5,28146.5L856.5,28146.5"></path><path id="kity_path_4181" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M856.5,28146.5C859.5,28146.5,859.5,28146.5,862.5,28146.5L1308.5,28146.5"></path><path id="kity_path_4183" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,28172.5,665.5,28172.5L907.5,28172.5"></path><path id="kity_path_4185" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M907.5,28172.5C910.5,28172.5,910.5,28172.5,913.5,28172.5L1089.5,28172.5"></path><path id="kity_path_4187" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,28198.5,665.5,28198.5L890.5,28198.5"></path><path id="kity_path_4189" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M890.5,28198.5C893.5,28198.5,893.5,28198.5,896.5,28198.5L1376.5,28198.5"></path><path id="kity_path_4191" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,28233.5,665.5,28233.5L889.5,28233.5"></path><path id="kity_path_4193" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M889.5,28233.5C892.5,28233.5,892.5,28242.5,895.5,28242.5L1239.5,28242.5"></path><path id="kity_path_4195" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,28313.5,665.5,28313.5L859.5,28313.5"></path><path id="kity_path_4197" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M859.5,28313.5C862.5,28313.5,862.5,28358.5,865.5,28358.5L2016.5,28358.5"></path><path id="kity_path_4199" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,28420.5,665.5,28420.5L1028.5,28420.5"></path><path id="kity_path_4201" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1028.5,28420.5C1031.5,28420.5,1031.5,28456.5,1034.5,28456.5L2173.5,28456.5"></path><path id="kity_path_4203" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,28482.5,665.5,28482.5L926.5,28482.5"></path><path id="kity_path_4205" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,28508.5,665.5,28508.5L921.5,28508.5"></path><path id="kity_path_4207" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M659.5,27931.5C662.5,27931.5,662.5,28534.5,665.5,28534.5L937.5,28534.5"></path><path id="kity_path_4209" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M937.5,28534.5C940.5,28534.5,940.5,28534.5,943.5,28534.5L1330.5,28534.5"></path><path id="kity_path_4211" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M580.5,28635.5C583.5,28635.5,583.5,28585.5,586.5,28585.5L699.5,28585.5"></path><path id="kity_path_4213" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M699.5,28585.5C702.5,28585.5,702.5,28559.5,705.5,28559.5L897.5,28559.5"></path><path id="kity_path_4215" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M897.5,28559.5C900.5,28559.5,900.5,28559.5,903.5,28559.5L1699.5,28559.5"></path><path id="kity_path_4217" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M699.5,28585.5C702.5,28585.5,702.5,28585.5,705.5,28585.5L982.5,28585.5"></path><path id="kity_path_4219" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M982.5,28585.5C985.5,28585.5,985.5,28585.5,988.5,28585.5L1733.5,28585.5"></path><path id="kity_path_4221" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M699.5,28585.5C702.5,28585.5,702.5,28611.5,705.5,28611.5L878.5,28611.5"></path><path id="kity_path_4223" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M878.5,28611.5C881.5,28611.5,881.5,28611.5,884.5,28611.5L1478.5,28611.5"></path><path id="kity_path_4225" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M580.5,28635.5C583.5,28635.5,583.5,28888.5,586.5,28888.5L724.5,28888.5"></path><path id="kity_path_4227" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M724.5,28888.5C727.5,28888.5,727.5,28637.5,730.5,28637.5L824.5,28637.5"></path><path id="kity_path_4229" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M824.5,28637.5C827.5,28637.5,827.5,28637.5,830.5,28637.5L1590.5,28637.5"></path><path id="kity_path_4231" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M724.5,28888.5C727.5,28888.5,727.5,28663.5,730.5,28663.5L847.5,28663.5"></path><path id="kity_path_4233" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M847.5,28663.5C850.5,28663.5,850.5,28663.5,853.5,28663.5L1048.5,28663.5"></path><path id="kity_path_4235" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M724.5,28888.5C727.5,28888.5,727.5,28689.5,730.5,28689.5L872.5,28689.5"></path><path id="kity_path_4237" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M872.5,28689.5C875.5,28689.5,875.5,28689.5,878.5,28689.5L1730.5,28689.5"></path><path id="kity_path_4239" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M724.5,28888.5C727.5,28888.5,727.5,28715.5,730.5,28715.5L874.5,28715.5"></path><path id="kity_path_4241" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M874.5,28715.5C877.5,28715.5,877.5,28715.5,880.5,28715.5L1643.5,28715.5"></path><path id="kity_path_4243" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M724.5,28888.5C727.5,28888.5,727.5,28759.5,730.5,28759.5L820.5,28759.5"></path><path id="kity_path_4245" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M820.5,28759.5C823.5,28759.5,823.5,28777.5,826.5,28777.5L2042.5,28777.5"></path><path id="kity_path_4247" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M724.5,28888.5C727.5,28888.5,727.5,28857.5,730.5,28857.5L923.5,28857.5"></path><path id="kity_path_4249" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M923.5,28857.5C926.5,28857.5,926.5,28911.5,929.5,28911.5L1607.5,28911.5"></path><path id="kity_path_4251" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M724.5,28888.5C727.5,28888.5,727.5,28964.5,730.5,28964.5L978.5,28964.5"></path><path id="kity_path_4253" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M978.5,28964.5C981.5,28964.5,981.5,28991.5,984.5,28991.5L2609.5,28991.5"></path><path id="kity_path_4255" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M724.5,28888.5C727.5,28888.5,727.5,29026.5,730.5,29026.5L811.5,29026.5"></path><path id="kity_path_4257" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M811.5,29026.5C814.5,29026.5,814.5,29035.5,817.5,29035.5L1583.5,29035.5"></path><path id="kity_path_4259" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M724.5,28888.5C727.5,28888.5,727.5,29061.5,730.5,29061.5L836.5,29061.5"></path><path id="kity_path_4261" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M836.5,29061.5C839.5,29061.5,839.5,29061.5,842.5,29061.5L1402.5,29061.5"></path><path id="kity_path_4263" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M724.5,28888.5C727.5,28888.5,727.5,29087.5,730.5,29087.5L956.5,29087.5"></path><path id="kity_path_4265" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M956.5,29087.5C959.5,29087.5,959.5,29087.5,962.5,29087.5L2215.5,29087.5"></path><path id="kity_path_4267" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M724.5,28888.5C727.5,28888.5,727.5,29113.5,730.5,29113.5L952.5,29113.5"></path><path id="kity_path_4269" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M952.5,29113.5C955.5,29113.5,955.5,29113.5,958.5,29113.5L1127.5,29113.5"></path><path id="kity_path_4271" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M724.5,28888.5C727.5,28888.5,727.5,29139.5,730.5,29139.5L975.5,29139.5"></path><path id="kity_path_4273" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M580.5,28635.5C583.5,28635.5,583.5,29231.5,586.5,29231.5L662.5,29231.5"></path><path id="kity_path_4275" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M662.5,29231.5C665.5,29231.5,665.5,29175.5,668.5,29175.5L813.5,29175.5"></path><path id="kity_path_4277" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M813.5,29175.5C816.5,29175.5,816.5,29184.5,819.5,29184.5L1553.5,29184.5"></path><path id="kity_path_4279" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1553.5,29184.5C1556.5,29184.5,1556.5,29175.5,1559.5,29175.5L1868.5,29175.5"></path><path id="kity_path_4281" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M662.5,29231.5C665.5,29231.5,665.5,29210.5,668.5,29210.5L869.5,29210.5"></path><path id="kity_path_4283" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M869.5,29210.5C872.5,29210.5,872.5,29210.5,875.5,29210.5L1516.5,29210.5"></path><path id="kity_path_4285" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M662.5,29231.5C665.5,29231.5,665.5,29236.5,668.5,29236.5L829.5,29236.5"></path><path id="kity_path_4287" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M829.5,29236.5C832.5,29236.5,832.5,29236.5,835.5,29236.5L951.5,29236.5"></path><path id="kity_path_4289" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M662.5,29231.5C665.5,29231.5,665.5,29262.5,668.5,29262.5L942.5,29262.5"></path><path id="kity_path_4291" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M942.5,29262.5C945.5,29262.5,945.5,29262.5,948.5,29262.5L1336.5,29262.5"></path><path id="kity_path_4293" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M662.5,29231.5C665.5,29231.5,665.5,29288.5,668.5,29288.5L883.5,29288.5"></path><path id="kity_path_4295" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M883.5,29288.5C886.5,29288.5,886.5,29288.5,889.5,29288.5L2002.5,29288.5"></path><path id="kity_path_4297" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M580.5,28635.5C583.5,28635.5,583.5,29339.5,586.5,29339.5L658.5,29339.5"></path><path id="kity_path_4299" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M658.5,29339.5C661.5,29339.5,661.5,29313.5,664.5,29313.5L784.5,29313.5"></path><path id="kity_path_4301" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M784.5,29313.5C787.5,29313.5,787.5,29313.5,790.5,29313.5L1458.5,29313.5"></path><path id="kity_path_4303" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M658.5,29339.5C661.5,29339.5,661.5,29339.5,664.5,29339.5L864.5,29339.5"></path><path id="kity_path_4305" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M864.5,29339.5C867.5,29339.5,867.5,29339.5,870.5,29339.5L1160.5,29339.5"></path><path id="kity_path_4307" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M658.5,29339.5C661.5,29339.5,661.5,29365.5,664.5,29365.5L843.5,29365.5"></path><path id="kity_path_4309" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,28237.5C531.5,28237.5,531.5,29443.5,534.5,29443.5L571.5,29443.5"></path><path id="kity_path_4311" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M571.5,29443.5C574.5,29443.5,574.5,29391.5,577.5,29391.5L639.5,29391.5"></path><path id="kity_path_4313" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M639.5,29391.5C642.5,29391.5,642.5,29391.5,645.5,29391.5L896.5,29391.5"></path><path id="kity_path_4315" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M571.5,29443.5C574.5,29443.5,574.5,29417.5,577.5,29417.5L718.5,29417.5"></path><path id="kity_path_4317" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M718.5,29417.5C721.5,29417.5,721.5,29417.5,724.5,29417.5L1253.5,29417.5"></path><path id="kity_path_4319" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M571.5,29443.5C574.5,29443.5,574.5,29443.5,577.5,29443.5L752.5,29443.5"></path><path id="kity_path_4321" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M752.5,29443.5C755.5,29443.5,755.5,29443.5,758.5,29443.5L1180.5,29443.5"></path><path id="kity_path_4323" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M571.5,29443.5C574.5,29443.5,574.5,29469.5,577.5,29469.5L740.5,29469.5"></path><path id="kity_path_4325" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M740.5,29469.5C743.5,29469.5,743.5,29469.5,746.5,29469.5L891.5,29469.5"></path><path id="kity_path_4327" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M571.5,29443.5C574.5,29443.5,574.5,29495.5,577.5,29495.5L718.5,29495.5"></path><path id="kity_path_4329" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M528.5,28237.5C531.5,28237.5,531.5,29573.5,534.5,29573.5L610.5,29573.5"></path><path id="kity_path_4331" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M610.5,29573.5C613.5,29573.5,613.5,29521.5,616.5,29521.5L825.5,29521.5"></path><path id="kity_path_4333" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M825.5,29521.5C828.5,29521.5,828.5,29521.5,831.5,29521.5L1398.5,29521.5"></path><path id="kity_path_4335" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M610.5,29573.5C613.5,29573.5,613.5,29547.5,616.5,29547.5L881.5,29547.5"></path><path id="kity_path_4337" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M610.5,29573.5C613.5,29573.5,613.5,29573.5,616.5,29573.5L733.5,29573.5"></path><path id="kity_path_4339" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M733.5,29573.5C736.5,29573.5,736.5,29573.5,739.5,29573.5L917.5,29573.5"></path><path id="kity_path_4341" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M610.5,29573.5C613.5,29573.5,613.5,29599.5,616.5,29599.5L734.5,29599.5"></path><path id="kity_path_4343" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M734.5,29599.5C737.5,29599.5,737.5,29599.5,740.5,29599.5L901.5,29599.5"></path><path id="kity_path_4345" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M610.5,29573.5C613.5,29573.5,613.5,29625.5,616.5,29625.5L857.5,29625.5"></path><path id="kity_path_4347" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M476.5,16139.5C479.5,16139.5,479.5,30423.5,482.5,30423.5L551.5,30423.5"></path><path id="kity_path_4349" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M551.5,30423.5C554.5,30423.5,554.5,30423.5,557.5,30423.5L615.5,30423.5"></path><path id="kity_path_4351" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M615.5,30423.5C618.5,30423.5,618.5,30039.5,621.5,30039.5L666.5,30039.5"></path><path id="kity_path_4353" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M666.5,30039.5C669.5,30039.5,669.5,29670.5,672.5,29670.5L791.5,29670.5"></path><path id="kity_path_4355" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M791.5,29670.5C794.5,29670.5,794.5,29688.5,797.5,29688.5L1668.5,29688.5"></path><path id="kity_path_4357" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M666.5,30039.5C669.5,30039.5,669.5,29714.5,672.5,29714.5L873.5,29714.5"></path><path id="kity_path_4359" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M666.5,30039.5C669.5,30039.5,669.5,29740.5,672.5,29740.5L790.5,29740.5"></path><path id="kity_path_4361" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M790.5,29740.5C793.5,29740.5,793.5,29740.5,796.5,29740.5L1385.5,29740.5"></path><path id="kity_path_4363" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M666.5,30039.5C669.5,30039.5,669.5,29766.5,672.5,29766.5L789.5,29766.5"></path><path id="kity_path_4365" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M666.5,30039.5C669.5,30039.5,669.5,29792.5,672.5,29792.5L814.5,29792.5"></path><path id="kity_path_4367" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M666.5,30039.5C669.5,30039.5,669.5,29818.5,672.5,29818.5L866.5,29818.5"></path><path id="kity_path_4369" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M866.5,29818.5C869.5,29818.5,869.5,29818.5,872.5,29818.5L1454.5,29818.5"></path><path id="kity_path_4371" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M666.5,30039.5C669.5,30039.5,669.5,29844.5,672.5,29844.5L837.5,29844.5"></path><path id="kity_path_4373" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M666.5,30039.5C669.5,30039.5,669.5,29870.5,672.5,29870.5L837.5,29870.5"></path><path id="kity_path_4375" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M837.5,29870.5C840.5,29870.5,840.5,29870.5,843.5,29870.5L1750.5,29870.5"></path><path id="kity_path_4377" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M666.5,30039.5C669.5,30039.5,669.5,29932.5,672.5,29932.5L861.5,29932.5"></path><path id="kity_path_4379" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M861.5,29932.5C864.5,29932.5,864.5,29950.5,867.5,29950.5L1159.5,29950.5"></path><path id="kity_path_4381" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1159.5,29950.5C1162.5,29950.5,1162.5,29923.5,1165.5,29923.5L1559.5,29923.5"></path><path id="kity_path_4383" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M666.5,30039.5C669.5,30039.5,669.5,30078.5,672.5,30078.5L898.5,30078.5"></path><path id="kity_path_4385" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M898.5,30078.5C901.5,30078.5,901.5,30078.5,904.5,30078.5L974.5,30078.5"></path><path id="kity_path_4387" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M974.5,30078.5C977.5,30078.5,977.5,30181.5,980.5,30181.5L1196.5,30181.5"></path><path id="kity_path_4389" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1196.5,30181.5C1199.5,30181.5,1199.5,30079.5,1202.5,30079.5L1481.5,30079.5"></path><path id="kity_path_4391" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M666.5,30039.5C669.5,30039.5,669.5,30207.5,672.5,30207.5L896.5,30207.5"></path><path id="kity_path_4393" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M896.5,30207.5C899.5,30207.5,899.5,30207.5,902.5,30207.5L1041.5,30207.5"></path><path id="kity_path_4395" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M666.5,30039.5C669.5,30039.5,669.5,30233.5,672.5,30233.5L1012.5,30233.5"></path><path id="kity_path_4397" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1012.5,30233.5C1015.5,30233.5,1015.5,30233.5,1018.5,30233.5L1239.5,30233.5"></path><path id="kity_path_4399" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M666.5,30039.5C669.5,30039.5,669.5,30277.5,672.5,30277.5L832.5,30277.5"></path><path id="kity_path_4401" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M832.5,30277.5C835.5,30277.5,835.5,30295.5,838.5,30295.5L1655.5,30295.5"></path><path id="kity_path_4403" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M666.5,30039.5C669.5,30039.5,669.5,30321.5,672.5,30321.5L837.5,30321.5"></path><path id="kity_path_4405" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M837.5,30321.5C840.5,30321.5,840.5,30321.5,843.5,30321.5L1240.5,30321.5"></path><path id="kity_path_4407" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1240.5,30321.5C1243.5,30321.5,1243.5,30321.5,1246.5,30321.5L1599.5,30321.5"></path><path id="kity_path_4409" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M666.5,30039.5C669.5,30039.5,669.5,30365.5,672.5,30365.5L871.5,30365.5"></path><path id="kity_path_4411" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M871.5,30365.5C874.5,30365.5,874.5,30383.5,877.5,30383.5L1848.5,30383.5"></path><path id="kity_path_4413" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1848.5,30383.5C1851.5,30383.5,1851.5,30365.5,1854.5,30365.5L2217.5,30365.5"></path><path id="kity_path_4415" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M666.5,30039.5C669.5,30039.5,669.5,30409.5,672.5,30409.5L726.5,30409.5"></path><path id="kity_path_4417" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M726.5,30409.5C729.5,30409.5,729.5,30409.5,732.5,30409.5L1020.5,30409.5"></path><path id="kity_path_4419" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M615.5,30423.5C618.5,30423.5,618.5,30434.5,621.5,30434.5L667.5,30434.5"></path><path id="kity_path_4421" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M615.5,30423.5C618.5,30423.5,618.5,30623.5,621.5,30623.5L725.5,30623.5"></path><path id="kity_path_4423" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M725.5,30623.5C728.5,30623.5,728.5,30501.5,731.5,30501.5L908.5,30501.5"></path><path id="kity_path_4425" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M908.5,30501.5C911.5,30501.5,911.5,30497.5,914.5,30497.5L1275.5,30497.5"></path><path id="kity_path_4427" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M908.5,30501.5C911.5,30501.5,911.5,30541.5,914.5,30541.5L1580.5,30541.5"></path><path id="kity_path_4429" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1580.5,30541.5C1583.5,30541.5,1583.5,30532.5,1586.5,30532.5L1932.5,30532.5"></path><path id="kity_path_4431" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M725.5,30623.5C728.5,30623.5,728.5,30639.5,731.5,30639.5L932.5,30639.5"></path><path id="kity_path_4433" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M932.5,30639.5C935.5,30639.5,935.5,30711.5,938.5,30711.5L1780.5,30711.5"></path><path id="kity_path_4435" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1780.5,30711.5C1783.5,30711.5,1783.5,30657.5,1786.5,30657.5L2173.5,30657.5"></path><path id="kity_path_4437" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M725.5,30623.5C728.5,30623.5,728.5,30746.5,731.5,30746.5L885.5,30746.5"></path><path id="kity_path_4439" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M885.5,30746.5C888.5,30746.5,888.5,30755.5,891.5,30755.5L1478.5,30755.5"></path><path id="kity_path_4441" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M1478.5,30755.5C1481.5,30755.5,1481.5,30746.5,1484.5,30746.5L1830.5,30746.5"></path><path id="kity_path_4443" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M615.5,30423.5C618.5,30423.5,618.5,30807.5,621.5,30807.5L690.5,30807.5"></path><path id="kity_path_4445" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M690.5,30807.5C693.5,30807.5,693.5,30834.5,696.5,30834.5L1062.5,30834.5"></path><path id="kity_path_4447" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M476.5,16139.5C479.5,16139.5,479.5,30860.5,482.5,30860.5L600.5,30860.5"></path><path id="kity_path_4449" fill="none" stroke="none" display="none"></path><path id="kity_path_4451" fill="none" stroke="none" display="none"></path><path id="kity_path_4453" fill="none" stroke="none" display="none"></path><path id="kity_path_4455" fill="none" stroke="none" display="none"></path><path id="kity_path_4457" fill="none" stroke="none" display="none"></path><path id="kity_path_4459" fill="none" stroke="none" display="none"></path><path id="kity_path_4461" fill="none" stroke="none" display="none"></path><path id="kity_path_4463" fill="none" stroke="none" display="none"></path><path id="kity_path_4465" fill="none" stroke="none" display="none"></path><path id="kity_path_4467" fill="none" stroke="none" display="none"></path><path id="kity_path_4469" fill="none" stroke="none" display="none"></path><path id="kity_path_4471" fill="none" stroke="none" display="none"></path><path id="kity_path_4473" fill="none" stroke="none" display="none"></path><path id="kity_path_4475" fill="none" stroke="none" display="none"></path><path id="kity_path_4477" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M476.5,16139.5C479.5,16139.5,479.5,30886.5,482.5,30886.5L534.5,30886.5"></path><path id="kity_path_4479" fill="none" stroke="none" display="none"></path><path id="kity_path_4481" fill="none" stroke="none" display="none"></path><path id="kity_path_4483" fill="none" stroke="none" display="none"></path><path id="kity_path_4485" fill="none" stroke="none" display="none"></path><path id="kity_path_4487" fill="none" stroke="none" display="none"></path><path id="kity_path_4489" fill="none" stroke="none" display="none"></path><path id="kity_path_4491" fill="none" stroke="none" display="none"></path><path id="kity_path_4493" fill="none" stroke="none" display="none"></path><path id="kity_path_4495" fill="none" stroke="none" display="none"></path><path id="kity_path_4497" fill="none" stroke="none" display="none"></path><path id="kity_path_4499" fill="none" stroke="none" display="none"></path><path id="kity_path_4501" fill="none" stroke="none" display="none"></path><path id="kity_path_4503" fill="none" stroke="none" display="none"></path><path id="kity_path_4505" fill="none" stroke="none" display="none"></path><path id="kity_path_4507" fill="none" stroke="none" display="none"></path><path id="kity_path_4509" fill="none" stroke="none" display="none"></path><path id="kity_path_4511" fill="none" stroke="none" display="none"></path><path id="kity_path_4513" fill="none" stroke="none" display="none"></path><path id="kity_path_4515" fill="none" stroke="none" display="none"></path><path id="kity_path_4517" fill="none" stroke="none" display="none"></path><path id="kity_path_4519" fill="none" stroke="none" display="none"></path><path id="kity_path_4521" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M351.5,15577.5A45,15335,0,0,0,396.5,30912.5"></path><path id="kity_path_4523" fill="none" stroke="none" display="none"></path><path id="kity_path_4525" fill="none" stroke="none" display="none"></path><path id="kity_path_4527" fill="none" stroke="none" display="none"></path><path id="kity_path_4529" fill="none" stroke="none" display="none"></path><path id="kity_path_4531" fill="none" stroke="none" display="none"></path><path id="kity_path_4533" fill="none" stroke="none" display="none"></path><path id="kity_path_4535" fill="none" stroke="none" display="none"></path><path id="kity_path_4537" fill="none" stroke="none" display="none"></path><path id="kity_path_4539" fill="none" stroke="none" display="none"></path><path id="kity_path_4541" fill="none" stroke="none" display="none"></path><path id="kity_path_4543" fill="none" stroke="none" display="none"></path><path id="kity_path_4545" fill="none" stroke="none" display="none"></path><path id="kity_path_4547" fill="none" stroke="none" display="none"></path><path id="kity_path_4549" fill="none" stroke="none" display="none"></path><path id="kity_path_4551" fill="none" stroke="none" display="none"></path><path id="kity_path_4553" fill="none" stroke="none" display="none"></path><path id="kity_path_4555" fill="none" stroke="none" display="none"></path><path id="kity_path_4557" fill="none" stroke="none" display="none"></path><path id="kity_path_4559" fill="none" stroke="none" display="none"></path><path id="kity_path_4561" fill="none" stroke="none" display="none"></path><path id="kity_path_4563" fill="none" stroke="none" display="none"></path><path id="kity_path_4565" fill="none" stroke="none" display="none"></path><path id="kity_path_4567" fill="none" stroke="none" display="none"></path><path id="kity_path_4569" fill="none" stroke="none" display="none"></path><path id="kity_path_4571" fill="none" stroke="none" display="none"></path><path id="kity_path_4573" fill="none" stroke="none" display="none"></path><path id="kity_path_4575" fill="none" stroke="none" display="none"></path><path id="kity_path_4577" fill="none" stroke="none" display="none"></path><path id="kity_path_4579" fill="none" stroke="none" display="none"></path><path id="kity_path_4581" fill="none" stroke="none" display="none"></path><path id="kity_path_4583" fill="none" stroke="none" display="none"></path><path id="kity_path_4585" fill="none" stroke="none" display="none"></path><path id="kity_path_4587" fill="none" stroke="none" display="none"></path><path id="kity_path_4589" fill="none" stroke="none" display="none"></path><path id="kity_path_4591" fill="none" stroke="none" display="none"></path><path id="kity_path_4593" fill="none" stroke="none" display="none"></path><path id="kity_path_4595" fill="none" stroke="none" display="none"></path><path id="kity_path_4597" fill="none" stroke="none" display="none"></path><path id="kity_path_4599" fill="none" stroke="none" display="none"></path><path id="kity_path_4601" fill="none" stroke="none" display="none"></path><path id="kity_path_4603" fill="none" stroke="none" display="none"></path><path id="kity_path_4605" fill="none" stroke="none" display="none"></path><path id="kity_path_4607" fill="none" stroke="none" display="none"></path><path id="kity_path_4609" fill="none" stroke="none" display="none"></path><path id="kity_path_4611" fill="none" stroke="none" display="none"></path><path id="kity_path_4613" fill="none" stroke="none" display="none"></path><path id="kity_path_4615" fill="none" stroke="none" display="none"></path><path id="kity_path_4617" fill="none" stroke="none" display="none"></path><path id="kity_path_4619" fill="none" stroke="none" display="none"></path><path id="kity_path_4621" fill="none" stroke="none" display="none"></path><path id="kity_path_4623" fill="none" stroke="none" display="none"></path><path id="kity_path_4625" fill="none" stroke="none" display="none"></path><path id="kity_path_4627" fill="none" stroke="none" display="none"></path><path id="kity_path_4629" fill="none" stroke="none" display="none"></path><path id="kity_path_4631" fill="none" stroke="none" display="none"></path><path id="kity_path_4633" fill="none" stroke="none" display="none"></path><path id="kity_path_4635" fill="none" stroke="none" display="none"></path><path id="kity_path_4637" fill="none" stroke="none" display="none"></path><path id="kity_path_4639" fill="none" stroke="none" display="none"></path><path id="kity_path_4641" fill="none" stroke="none" display="none"></path><path id="kity_path_4643" fill="none" stroke="none" display="none"></path><path id="kity_path_4645" fill="none" stroke="none" display="none"></path><path id="kity_path_4647" fill="none" stroke="none" display="none"></path><path id="kity_path_4649" fill="none" stroke="none" display="none"></path><path id="kity_path_4651" fill="none" stroke="none" display="none"></path><path id="kity_path_4653" fill="none" stroke="none" display="none"></path><path id="kity_path_4655" fill="none" stroke="none" display="none"></path><path id="kity_path_4657" fill="none" stroke="none" display="none"></path><path id="kity_path_4659" fill="none" stroke="none" display="none"></path><path id="kity_path_4661" fill="none" stroke="none" display="none"></path><path id="kity_path_4663" fill="none" stroke="none" display="none"></path><path id="kity_path_4665" fill="none" stroke="none" display="none"></path><path id="kity_path_4667" fill="none" stroke="none" display="none"></path><path id="kity_path_4669" fill="none" stroke="none" display="none"></path><path id="kity_path_4671" fill="none" stroke="none" display="none"></path><path id="kity_path_4673" fill="none" stroke="none" display="none"></path><path id="kity_path_4675" fill="none" stroke="none" display="none"></path><path id="kity_path_4677" fill="none" stroke="none" display="none"></path><path id="kity_path_4679" fill="none" stroke="none" display="none"></path><path id="kity_path_4681" fill="none" stroke="none" display="none"></path><path id="kity_path_4683" fill="none" stroke="none" display="none"></path><path id="kity_path_4685" fill="none" stroke="none" display="none"></path><path id="kity_path_4687" fill="none" stroke="none" display="none"></path><path id="kity_path_4689" fill="none" stroke="none" display="none"></path><path id="kity_path_4691" fill="none" stroke="none" display="none"></path><path id="kity_path_4693" fill="none" stroke="none" display="none"></path><path id="kity_path_4695" fill="none" stroke="none" display="none"></path><path id="kity_path_4697" fill="none" stroke="none" display="none"></path><path id="kity_path_4699" fill="none" stroke="none" display="none"></path><path id="kity_path_4701" fill="none" stroke="none" display="none"></path><path id="kity_path_4703" fill="none" stroke="none" display="none"></path><path id="kity_path_4705" fill="none" stroke="none" display="none"></path><path id="kity_path_4707" fill="none" stroke="none" display="none"></path><path id="kity_path_4709" fill="none" stroke="none" display="none"></path><path id="kity_path_4711" fill="none" stroke="none" display="none"></path><path id="kity_path_4713" fill="none" stroke="none" display="none"></path><path id="kity_path_4715" fill="none" stroke="none" display="none"></path><path id="kity_path_4717" fill="none" stroke="none" display="none"></path><path id="kity_path_4719" fill="none" stroke="none" display="none"></path><path id="kity_path_4721" fill="none" stroke="none" display="none"></path><path id="kity_path_4723" fill="none" stroke="none" display="none"></path><path id="kity_path_4725" fill="none" stroke="none" display="none"></path><path id="kity_path_4727" fill="none" stroke="none" display="none"></path><path id="kity_path_4729" fill="none" stroke="none" display="none"></path><path id="kity_path_4731" fill="none" stroke="none" display="none"></path><path id="kity_path_4733" fill="none" stroke="none" display="none"></path><path id="kity_path_4735" fill="none" stroke="none" display="none"></path><path id="kity_path_4737" fill="none" stroke="none" display="none"></path><path id="kity_path_4739" fill="none" stroke="none" display="none"></path><path id="kity_path_4741" fill="none" stroke="none" display="none"></path><path id="kity_path_4743" fill="none" stroke="none" display="none"></path><path id="kity_path_4745" fill="none" stroke="none" display="none"></path><path id="kity_path_4747" fill="none" stroke="none" display="none"></path><path id="kity_path_4749" fill="none" stroke="none" display="none"></path><path id="kity_path_4751" fill="none" stroke="none" display="none"></path><path id="kity_path_4753" fill="none" stroke="none" display="none"></path><path id="kity_path_4755" fill="none" stroke="none" display="none"></path><path id="kity_path_4757" fill="none" stroke="none" display="none"></path><path id="kity_path_4759" fill="none" stroke="none" display="none"></path><path id="kity_path_4761" fill="none" stroke="none" display="none"></path><path id="kity_path_4763" fill="none" stroke="none" display="none"></path><path id="kity_path_4765" fill="none" stroke="none" display="none"></path><path id="kity_path_4767" fill="none" stroke="none" display="none"></path><path id="kity_path_4769" fill="none" stroke="none" display="none"></path><path id="kity_path_4771" fill="none" stroke="none" display="none"></path><path id="kity_path_4773" fill="none" stroke="none" display="none"></path><path id="kity_path_4775" fill="none" stroke="none" display="none"></path><path id="kity_path_4777" fill="none" stroke="none" display="none"></path><path id="kity_path_4779" fill="none" stroke="none" display="none"></path><path id="kity_path_4781" fill="none" stroke="none" display="none"></path><path id="kity_path_4783" fill="none" stroke="none" display="none"></path><path id="kity_path_4785" fill="none" stroke="none" display="none"></path><path id="kity_path_4787" fill="none" stroke="none" display="none"></path><path id="kity_path_4789" fill="none" stroke="none" display="none"></path><path id="kity_path_4791" fill="none" stroke="none" display="none"></path><path id="kity_path_4793" fill="none" stroke="none" display="none"></path><path id="kity_path_4795" fill="none" stroke="none" display="none"></path><path id="kity_path_4797" fill="none" stroke="none" display="none"></path><path id="kity_path_4799" fill="none" stroke="none" display="none"></path><path id="kity_path_4801" fill="none" stroke="none" display="none"></path><path id="kity_path_4803" fill="none" stroke="none" display="none"></path><path id="kity_path_4805" fill="none" stroke="none" display="none"></path><path id="kity_path_4807" fill="none" stroke="none" display="none"></path><path id="kity_path_4809" fill="none" stroke="none" display="none"></path><path id="kity_path_4811" fill="none" stroke="none" display="none"></path><path id="kity_path_4813" fill="none" stroke="none" display="none"></path><path id="kity_path_4815" fill="none" stroke="none" display="none"></path><path id="kity_path_4817" fill="none" stroke="none" display="none"></path><path id="kity_path_4819" fill="none" stroke="none" display="none"></path><path id="kity_path_4821" fill="none" stroke="none" display="none"></path><path id="kity_path_4823" fill="none" stroke="none" display="none"></path><path id="kity_path_4825" fill="none" stroke="none" display="none"></path><path id="kity_path_4827" fill="none" stroke="none" display="none"></path><path id="kity_path_4829" fill="none" stroke="none" display="none"></path><path id="kity_path_4831" fill="none" stroke="none" display="none"></path><path id="kity_path_4833" fill="none" stroke="none" display="none"></path><path id="kity_path_4835" fill="none" stroke="none" display="none"></path><path id="kity_path_4837" fill="none" stroke="none" display="none"></path><path id="kity_path_4839" fill="none" stroke="none" display="none"></path><path id="kity_path_4841" fill="none" stroke="none" display="none"></path><path id="kity_path_4843" fill="none" stroke="none" display="none"></path><path id="kity_path_4845" fill="none" stroke="none" display="none"></path><path id="kity_path_4847" fill="none" stroke="none" display="none"></path><path id="kity_path_4849" fill="none" stroke="none" display="none"></path><path id="kity_path_4851" fill="none" stroke="none" display="none"></path><path id="kity_path_4853" fill="none" stroke="none" display="none"></path><path id="kity_path_4855" fill="none" stroke="none" display="none"></path><path id="kity_path_4857" fill="none" stroke="none" display="none"></path><path id="kity_path_4859" fill="none" stroke="none" display="none"></path><path id="kity_path_4861" fill="none" stroke="none" display="none"></path><path id="kity_path_4863" fill="none" stroke="none" display="none"></path><path id="kity_path_4865" fill="none" stroke="none" display="none"></path><path id="kity_path_4867" fill="none" stroke="none" display="none"></path><path id="kity_path_4869" fill="none" stroke="none" display="none"></path><path id="kity_path_4871" fill="none" stroke="none" display="none"></path><path id="kity_path_4873" fill="none" stroke="none" display="none"></path><path id="kity_path_4875" fill="none" stroke="none" display="none"></path><path id="kity_path_4877" fill="none" stroke="none" display="none"></path><path id="kity_path_4879" fill="none" stroke="none" display="none"></path><path id="kity_path_4881" fill="none" stroke="none" display="none"></path><path id="kity_path_4883" fill="none" stroke="none" display="none"></path><path id="kity_path_4885" fill="none" stroke="none" display="none"></path><path id="kity_path_4887" fill="none" stroke="none" display="none"></path><path id="kity_path_4889" fill="none" stroke="none" display="none"></path><path id="kity_path_4891" fill="none" stroke="none" display="none"></path><path id="kity_path_4893" fill="none" stroke="none" display="none"></path><path id="kity_path_4895" fill="none" stroke="none" display="none"></path><path id="kity_path_4897" fill="none" stroke="none" display="none"></path><path id="kity_path_4899" fill="none" stroke="none" display="none"></path><path id="kity_path_4901" fill="none" stroke="none" display="none"></path><path id="kity_path_4903" fill="none" stroke="none" display="none"></path><path id="kity_path_4905" fill="none" stroke="none" display="none"></path><path id="kity_path_4907" fill="none" stroke="none" display="none"></path><path id="kity_path_4909" fill="none" stroke="none" display="none"></path><path id="kity_path_4911" fill="none" stroke="none" display="none"></path><path id="kity_path_4913" fill="none" stroke="none" display="none"></path><path id="kity_path_4915" fill="none" stroke="none" display="none"></path><path id="kity_path_4917" fill="none" stroke="none" display="none"></path><path id="kity_path_4919" fill="none" stroke="none" display="none"></path><path id="kity_path_4921" fill="none" stroke="none" display="none"></path><path id="kity_path_4923" fill="none" stroke="none" display="none"></path><path id="kity_path_4925" fill="none" stroke="none" display="none"></path><path id="kity_path_4927" fill="none" stroke="none" display="none"></path><path id="kity_path_4929" fill="none" stroke="none" display="none"></path><path id="kity_path_4931" fill="none" stroke="none" display="none"></path><path id="kity_path_4933" fill="none" stroke="none" display="none"></path><path id="kity_path_4935" fill="none" stroke="none" display="none"></path><path id="kity_path_4937" fill="none" stroke="none" display="none"></path><path id="kity_path_4939" fill="none" stroke="none" display="none"></path><path id="kity_path_4941" fill="none" stroke="none" display="none"></path><path id="kity_path_4943" fill="none" stroke="none" display="none"></path><path id="kity_path_4945" fill="none" stroke="none" display="none"></path><path id="kity_path_4947" fill="none" stroke="none" display="none"></path><path id="kity_path_4949" fill="none" stroke="none" display="none"></path><path id="kity_path_4951" fill="none" stroke="none" display="none"></path><path id="kity_path_4953" fill="none" stroke="none" display="none"></path><path id="kity_path_4955" fill="none" stroke="none" display="none"></path><path id="kity_path_4957" fill="none" stroke="none" display="none"></path><path id="kity_path_4959" fill="none" stroke="none" display="none"></path><path id="kity_path_4961" fill="none" stroke="none" display="none"></path><path id="kity_path_4963" fill="none" stroke="none" display="none"></path><path id="kity_path_4965" fill="none" stroke="none" display="none"></path><path id="kity_path_4967" fill="none" stroke="none" display="none"></path><path id="kity_path_4969" fill="none" stroke="none" display="none"></path><path id="kity_path_4971" fill="none" stroke="none" display="none"></path><path id="kity_path_4973" fill="none" stroke="none" display="none"></path><path id="kity_path_4975" fill="none" stroke="none" display="none"></path><path id="kity_path_4977" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M351.5,15577.5A45,15377,0,0,0,396.5,30954.5"></path><path id="kity_path_4979" fill="none" stroke="none" display="none"></path><path id="kity_path_4981" fill="none" stroke="none" display="none"></path><path id="kity_path_4983" fill="none" stroke="none" display="none"></path><path id="kity_path_4985" fill="none" stroke="none" display="none"></path><path id="kity_path_4987" fill="none" stroke="none" display="none"></path><path id="kity_path_4989" fill="none" stroke="none" display="none"></path><path id="kity_path_4991" fill="none" stroke="none" display="none"></path><path id="kity_path_4993" fill="none" stroke="none" display="none"></path><path id="kity_path_4995" fill="none" stroke="none" display="none"></path><path id="kity_path_4997" fill="none" stroke="none" display="none"></path><path id="kity_path_4999" fill="none" stroke="none" display="none"></path><path id="kity_path_5001" fill="none" stroke="none" display="none"></path><path id="kity_path_5003" fill="none" stroke="none" display="none"></path><path id="kity_path_5005" fill="none" stroke="none" display="none"></path><path id="kity_path_5007" fill="none" stroke="none" display="none"></path><path id="kity_path_5009" fill="none" stroke="none" display="none"></path><path id="kity_path_5011" fill="none" stroke="none" display="none"></path><path id="kity_path_5013" fill="none" stroke="none" display="none"></path><path id="kity_path_5015" fill="none" stroke="none" display="none"></path><path id="kity_path_5017" fill="none" stroke="none" display="none"></path><path id="kity_path_5019" fill="none" stroke="none" display="none"></path><path id="kity_path_5021" fill="none" stroke="none" display="none"></path><path id="kity_path_5023" fill="none" stroke="none" display="none"></path><path id="kity_path_5025" fill="none" stroke="none" display="none"></path><path id="kity_path_5027" fill="none" stroke="none" display="none"></path><path id="kity_path_5029" fill="none" stroke="none" display="none"></path><path id="kity_path_5031" fill="none" stroke="none" display="none"></path><path id="kity_path_5033" fill="none" stroke="none" display="none"></path><path id="kity_path_5035" fill="none" stroke="none" display="none"></path><path id="kity_path_5037" fill="none" stroke="none" display="none"></path><path id="kity_path_5039" fill="none" stroke="none" display="none"></path><path id="kity_path_5041" fill="none" stroke="none" display="none"></path><path id="kity_path_5043" fill="none" stroke="none" display="none"></path><path id="kity_path_5045" fill="none" stroke="none" display="none"></path><path id="kity_path_5047" fill="none" stroke="none" display="none"></path><path id="kity_path_5049" fill="none" stroke="none" display="none"></path><path id="kity_path_5051" fill="none" stroke="none" display="none"></path><path id="kity_path_5053" fill="none" stroke="none" display="none"></path><path id="kity_path_5055" fill="none" stroke="none" display="none"></path><path id="kity_path_5057" fill="none" stroke="none" display="none"></path><path id="kity_path_5059" fill="none" stroke="none" display="none"></path><path id="kity_path_5061" fill="none" stroke="none" display="none"></path><path id="kity_path_5063" fill="none" stroke="none" display="none"></path><path id="kity_path_5065" fill="none" stroke="none" display="none"></path><path id="kity_path_5067" fill="none" stroke="none" display="none"></path><path id="kity_path_5069" fill="none" stroke="none" display="none"></path><path id="kity_path_5071" fill="none" stroke="none" display="none"></path><path id="kity_path_5073" fill="none" stroke="none" display="none"></path><path id="kity_path_5075" fill="none" stroke="none" display="none"></path><path id="kity_path_5077" fill="none" stroke="none" display="none"></path><path id="kity_path_5079" fill="none" stroke="none" display="none"></path><path id="kity_path_5081" fill="none" stroke="none" display="none"></path><path id="kity_path_5083" fill="none" stroke="none" display="none"></path><path id="kity_path_5085" fill="none" stroke="none" display="none"></path><path id="kity_path_5087" fill="none" stroke="none" display="none"></path><path id="kity_path_5089" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M351.5,15577.5A45,15419,0,0,0,396.5,30996.5"></path><path id="kity_path_5091" fill="none" stroke="none" display="none"></path><path id="kity_path_5093" fill="none" stroke="none" display="none"></path><path id="kity_path_5095" fill="none" stroke="none" display="none"></path><path id="kity_path_5097" fill="none" stroke="none" display="none"></path><path id="kity_path_5099" fill="none" stroke="none" display="none"></path><path id="kity_path_5101" fill="none" stroke="none" display="none"></path><path id="kity_path_5103" fill="none" stroke="none" display="none"></path><path id="kity_path_5105" fill="none" stroke="none" display="none"></path><path id="kity_path_5107" fill="none" stroke="none" display="none"></path><path id="kity_path_5109" fill="none" stroke="none" display="none"></path><path id="kity_path_5111" fill="none" stroke="none" display="none"></path><path id="kity_path_5113" fill="none" stroke="none" display="none"></path><path id="kity_path_5115" fill="none" stroke="none" display="none"></path><path id="kity_path_5117" fill="none" stroke="none" display="none"></path><path id="kity_path_5119" fill="none" stroke="none" display="none"></path><path id="kity_path_5121" fill="none" stroke="none" display="none"></path><path id="kity_path_5123" fill="none" stroke="none" display="none"></path><path id="kity_path_5125" fill="none" stroke="none" display="none"></path><path id="kity_path_5127" fill="none" stroke="none" display="none"></path><path id="kity_path_5129" fill="none" stroke="none" display="none"></path><path id="kity_path_5131" fill="none" stroke="none" display="none"></path><path id="kity_path_5133" fill="none" stroke="none" display="none"></path><path id="kity_path_5135" fill="none" stroke="none" display="none"></path><path id="kity_path_5137" fill="none" stroke="none" display="none"></path><path id="kity_path_5139" fill="none" stroke="none" display="none"></path><path id="kity_path_5141" fill="none" stroke="none" display="none"></path><path id="kity_path_5143" fill="none" stroke="none" display="none"></path><path id="kity_path_5145" fill="none" stroke="none" display="none"></path><path id="kity_path_5147" fill="none" stroke="none" display="none"></path><path id="kity_path_5149" fill="none" stroke="none" display="none"></path><path id="kity_path_5151" fill="none" stroke="none" display="none"></path><path id="kity_path_5153" fill="none" stroke="none" display="none"></path><path id="kity_path_5155" fill="none" stroke="none" display="none"></path><path id="kity_path_5157" fill="none" stroke="none" display="none"></path><path id="kity_path_5159" fill="none" stroke="none" display="none"></path><path id="kity_path_5161" fill="none" stroke="none" display="none"></path><path id="kity_path_5163" fill="none" stroke="none" display="none"></path><path id="kity_path_5165" fill="none" stroke="none" display="none"></path><path id="kity_path_5167" fill="none" stroke="none" display="none"></path><path id="kity_path_5169" fill="none" stroke="none" display="none"></path><path id="kity_path_5171" fill="none" stroke="none" display="none"></path><path id="kity_path_5173" fill="none" stroke="none" display="none"></path><path id="kity_path_5175" fill="none" stroke="none" display="none"></path><path id="kity_path_5177" fill="none" stroke="none" display="none"></path><path id="kity_path_5179" fill="none" stroke="none" display="none"></path><path id="kity_path_5181" fill="none" stroke="none" display="none"></path><path id="kity_path_5183" fill="none" stroke="none" display="none"></path><path id="kity_path_5185" fill="none" stroke="none" display="none"></path><path id="kity_path_5187" fill="none" stroke="none" display="none"></path><path id="kity_path_5189" fill="none" stroke="none" display="none"></path><path id="kity_path_5191" fill="none" stroke="none" display="none"></path><path id="kity_path_5193" fill="none" stroke="none" display="none"></path><path id="kity_path_5195" fill="none" stroke="none" display="none"></path><path id="kity_path_5197" fill="none" stroke="none" display="none"></path><path id="kity_path_5199" fill="none" stroke="none" display="none"></path><path id="kity_path_5201" fill="none" stroke="none" display="none"></path><path id="kity_path_5203" fill="none" stroke="none" display="none"></path><path id="kity_path_5205" fill="none" stroke="none" display="none"></path><path id="kity_path_5207" fill="none" stroke="none" display="none"></path><path id="kity_path_5209" fill="none" stroke="none" display="none"></path><path id="kity_path_5211" fill="none" stroke="none" display="none"></path><path id="kity_path_5213" fill="none" stroke="none" display="none"></path><path id="kity_path_5215" fill="none" stroke="none" display="none"></path><path id="kity_path_5217" fill="none" stroke="none" display="none"></path><path id="kity_path_5219" fill="none" stroke="none" display="none"></path><path id="kity_path_5221" fill="none" stroke="none" display="none"></path><path id="kity_path_5223" fill="none" stroke="none" display="none"></path><path id="kity_path_5225" fill="none" stroke="none" display="none"></path><path id="kity_path_5227" fill="none" stroke="none" display="none"></path><path id="kity_path_5229" fill="none" stroke="none" display="none"></path><path id="kity_path_5231" fill="none" stroke="none" display="none"></path><path id="kity_path_5233" fill="none" stroke="none" display="none"></path><path id="kity_path_5235" fill="none" stroke="none" display="none"></path><path id="kity_path_5237" fill="none" stroke="none" display="none"></path><path id="kity_path_5239" fill="none" stroke="none" display="none"></path><path id="kity_path_5241" fill="none" stroke="none" display="none"></path><path id="kity_path_5243" fill="none" stroke="none" display="none"></path><path id="kity_path_5245" fill="none" stroke="none" display="none"></path><path id="kity_path_5247" fill="none" stroke="none" display="none"></path><path id="kity_path_5249" fill="none" stroke="none" display="none"></path><path id="kity_path_5251" fill="none" stroke="none" display="none"></path><path id="kity_path_5253" fill="none" stroke="none" display="none"></path><path id="kity_path_5255" fill="none" stroke="none" display="none"></path><path id="kity_path_5257" fill="none" stroke="none" display="none"></path><path id="kity_path_5259" fill="none" stroke="none" display="none"></path><path id="kity_path_5261" fill="none" stroke="none" display="none"></path><path id="kity_path_5263" fill="none" stroke="none" display="none"></path><path id="kity_path_5265" fill="none" stroke="none" display="none"></path><path id="kity_path_5267" fill="none" stroke="none" display="none"></path><path id="kity_path_5269" fill="none" stroke="none" display="none"></path><path id="kity_path_5271" fill="none" stroke="none" display="none"></path><path id="kity_path_5273" fill="none" stroke="none" display="none"></path><path id="kity_path_5275" fill="none" stroke="none" display="none"></path><path id="kity_path_5277" fill="none" stroke="none" display="none"></path><path id="kity_path_5279" fill="none" stroke="none" display="none"></path><path id="kity_path_5281" fill="none" stroke="none" display="none"></path><path id="kity_path_5283" fill="none" stroke="none" display="none"></path><path id="kity_path_5285" fill="none" stroke="none" display="none"></path><path id="kity_path_5287" fill="none" stroke="none" display="none"></path><path id="kity_path_5289" fill="none" stroke="none" display="none"></path><path id="kity_path_5291" fill="none" stroke="none" display="none"></path><path id="kity_path_5293" fill="none" stroke="none" display="none"></path><path id="kity_path_5295" fill="none" stroke="none" display="none"></path><path id="kity_path_5297" fill="none" stroke="none" display="none"></path><path id="kity_path_5299" fill="none" stroke="none" display="none"></path><path id="kity_path_5301" fill="none" stroke="none" display="none"></path><path id="kity_path_5303" fill="none" stroke="none" display="none"></path><path id="kity_path_5305" fill="none" stroke="none" display="none"></path><path id="kity_path_5307" fill="none" stroke="none" display="none"></path><path id="kity_path_5309" fill="none" stroke="none" display="none"></path><path id="kity_path_5311" fill="none" stroke="none" display="none"></path><path id="kity_path_5313" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M351.5,15577.5A45,15461,0,0,0,396.5,31038.5"></path><path id="kity_path_5315" fill="none" stroke="none" display="none"></path><path id="kity_path_5317" fill="none" stroke="none" display="none"></path><path id="kity_path_5319" fill="none" stroke="none" display="none"></path><path id="kity_path_5321" fill="none" stroke="none" display="none"></path><path id="kity_path_5323" fill="none" stroke="none" display="none"></path><path id="kity_path_5325" fill="none" stroke="none" display="none"></path><path id="kity_path_5327" fill="none" stroke="none" display="none"></path><path id="kity_path_5329" fill="none" stroke="none" display="none"></path><path id="kity_path_5331" fill="none" stroke="none" display="none"></path><path id="kity_path_5333" fill="none" stroke="none" display="none"></path><path id="kity_path_5335" fill="none" stroke="none" display="none"></path><path id="kity_path_5337" fill="none" stroke="none" display="none"></path><path id="kity_path_5339" fill="none" stroke="none" display="none"></path><path id="kity_path_5341" fill="none" stroke="none" display="none"></path><path id="kity_path_5343" fill="none" stroke="none" display="none"></path><path id="kity_path_5345" fill="none" stroke="none" display="none"></path><path id="kity_path_5347" fill="none" stroke="none" display="none"></path><path id="kity_path_5349" fill="none" stroke="none" display="none"></path><path id="kity_path_5351" fill="none" stroke="none" display="none"></path><path id="kity_path_5353" fill="none" stroke="none" display="none"></path><path id="kity_path_5355" fill="none" stroke="none" display="none"></path><path id="kity_path_5357" fill="none" stroke="none" display="none"></path><path id="kity_path_5359" fill="none" stroke="none" display="none"></path><path id="kity_path_5361" fill="none" stroke="none" display="none"></path><path id="kity_path_5363" fill="none" stroke="none" display="none"></path><path id="kity_path_5365" fill="none" stroke="none" display="none"></path><path id="kity_path_5367" fill="none" stroke="none" display="none"></path><path id="kity_path_5369" fill="none" stroke="none" display="none"></path><path id="kity_path_5371" fill="none" stroke="none" display="none"></path><path id="kity_path_5373" fill="none" stroke="none" display="none"></path><path id="kity_path_5375" fill="none" stroke="none" display="none"></path><path id="kity_path_5377" fill="none" stroke="none" display="none"></path><path id="kity_path_5379" fill="none" stroke="none" display="none"></path><path id="kity_path_5381" fill="none" stroke="none" display="none"></path><path id="kity_path_5383" fill="none" stroke="none" display="none"></path><path id="kity_path_5385" fill="none" stroke="none" display="none"></path><path id="kity_path_5387" fill="none" stroke="none" display="none"></path><path id="kity_path_5389" fill="none" stroke="none" display="none"></path><path id="kity_path_5391" fill="none" stroke="none" display="none"></path><path id="kity_path_5393" fill="none" stroke="none" display="none"></path><path id="kity_path_5395" fill="none" stroke="none" display="none"></path><path id="kity_path_5397" fill="none" stroke="none" display="none"></path><path id="kity_path_5399" fill="none" stroke="none" display="none"></path><path id="kity_path_5401" fill="none" stroke="none" display="none"></path><path id="kity_path_5403" fill="none" stroke="none" display="none"></path><path id="kity_path_5405" fill="none" stroke="none" display="none"></path><path id="kity_path_5407" fill="none" stroke="none" display="none"></path><path id="kity_path_5409" fill="none" stroke="none" display="none"></path><path id="kity_path_5411" fill="none" stroke="none" display="none"></path><path id="kity_path_5413" fill="none" stroke="none" display="none"></path><path id="kity_path_5415" fill="none" stroke="none" display="none"></path><path id="kity_path_5417" fill="none" stroke="none" display="none"></path><path id="kity_path_5419" fill="none" stroke="none" display="none"></path><path id="kity_path_5421" fill="none" stroke="none" display="none"></path><path id="kity_path_5423" fill="none" stroke="none" display="none"></path><path id="kity_path_5425" fill="none" stroke="none" display="none"></path><path id="kity_path_5427" fill="none" stroke="none" display="none"></path><path id="kity_path_5429" fill="none" stroke="none" display="none"></path><path id="kity_path_5431" fill="none" stroke="none" display="none"></path><path id="kity_path_5433" fill="none" stroke="none" display="none"></path><path id="kity_path_5435" fill="none" stroke="none" display="none"></path><path id="kity_path_5437" fill="none" stroke="none" display="none"></path><path id="kity_path_5439" fill="none" stroke="none" display="none"></path><path id="kity_path_5441" fill="none" stroke="none" display="none"></path><path id="kity_path_5443" fill="none" stroke="none" display="none"></path><path id="kity_path_5445" fill="none" stroke="none" display="none"></path><path id="kity_path_5447" fill="none" stroke="none" display="none"></path><path id="kity_path_5449" fill="none" stroke="none" display="none"></path><path id="kity_path_5451" fill="none" stroke="none" display="none"></path><path id="kity_path_5453" fill="none" stroke="none" display="none"></path><path id="kity_path_5455" fill="none" stroke="none" display="none"></path><path id="kity_path_5457" fill="none" stroke="none" display="none"></path><path id="kity_path_5459" fill="none" stroke="none" display="none"></path><path id="kity_path_5461" fill="none" stroke="none" display="none"></path><path id="kity_path_5463" fill="none" stroke="none" display="none"></path><path id="kity_path_5465" fill="none" stroke="none" display="none"></path><path id="kity_path_5467" fill="none" stroke="none" display="none"></path><path id="kity_path_5469" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M351.5,15577.5A45,15503,0,0,0,396.5,31080.5"></path><path id="kity_path_5471" fill="none" stroke="none" display="none"></path><path id="kity_path_5473" fill="none" stroke="none" display="none"></path><path id="kity_path_5475" fill="none" stroke="none" display="none"></path><path id="kity_path_5477" fill="none" stroke="none" display="none"></path><path id="kity_path_5479" fill="none" stroke="none" display="none"></path><path id="kity_path_5481" fill="none" stroke="none" display="none"></path><path id="kity_path_5483" fill="none" stroke="none" display="none"></path><path id="kity_path_5485" fill="none" stroke="none" display="none"></path><path id="kity_path_5487" fill="none" stroke="none" display="none"></path><path id="kity_path_5489" fill="none" stroke="none" display="none"></path><path id="kity_path_5491" fill="none" stroke="none" display="none"></path><path id="kity_path_5493" fill="none" stroke="none" display="none"></path><path id="kity_path_5495" fill="none" stroke="none" display="none"></path><path id="kity_path_5497" fill="none" stroke="none" display="none"></path><path id="kity_path_5499" fill="none" stroke="none" display="none"></path><path id="kity_path_5501" fill="none" stroke="none" display="none"></path><path id="kity_path_5503" fill="none" stroke="none" display="none"></path><path id="kity_path_5505" fill="none" stroke="none" display="none"></path><path id="kity_path_5507" fill="none" stroke="none" display="none"></path><path id="kity_path_5509" fill="none" stroke="none" display="none"></path><path id="kity_path_5511" fill="none" stroke="none" display="none"></path><path id="kity_path_5513" fill="none" stroke="none" display="none"></path><path id="kity_path_5515" fill="none" stroke="none" display="none"></path><path id="kity_path_5517" fill="none" stroke="none" display="none"></path><path id="kity_path_5519" fill="none" stroke="none" display="none"></path><path id="kity_path_5521" fill="none" stroke="none" display="none"></path><path id="kity_path_5523" fill="none" stroke="none" display="none"></path><path id="kity_path_5525" fill="none" stroke="none" display="none"></path><path id="kity_path_5527" fill="none" stroke="none" display="none"></path><path id="kity_path_5529" fill="none" stroke="none" display="none"></path><path id="kity_path_5531" fill="none" stroke="none" display="none"></path><path id="kity_path_5533" fill="none" stroke="none" display="none"></path><path id="kity_path_5535" fill="none" stroke="none" display="none"></path><path id="kity_path_5537" fill="none" stroke="none" display="none"></path><path id="kity_path_5539" fill="none" stroke="none" display="none"></path><path id="kity_path_5541" fill="none" stroke="none" display="none"></path><path id="kity_path_5543" fill="none" stroke="none" display="none"></path><path id="kity_path_5545" fill="none" stroke="none" display="none"></path><path id="kity_path_5547" fill="none" stroke="none" display="none"></path><path id="kity_path_5549" fill="none" stroke="none" display="none"></path><path id="kity_path_5551" fill="none" stroke="none" display="none"></path><path id="kity_path_5553" fill="none" stroke="none" display="none"></path><path id="kity_path_5555" fill="none" stroke="none" display="none"></path><path id="kity_path_5557" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M351.5,15577.5A45,15545,0,0,0,396.5,31122.5"></path><path id="kity_path_5559" fill="none" stroke="none" display="none"></path><path id="kity_path_5561" fill="none" stroke="none" display="none"></path><path id="kity_path_5563" fill="none" stroke="none" display="none"></path><path id="kity_path_5565" fill="none" stroke="none" display="none"></path><path id="kity_path_5567" fill="none" stroke="none" display="none"></path><path id="kity_path_5569" fill="none" stroke="none" display="none"></path><path id="kity_path_5571" fill="none" stroke="none" display="none"></path><path id="kity_path_5573" fill="none" stroke="none" display="none"></path><path id="kity_path_5575" fill="none" stroke="none" display="none"></path><path id="kity_path_5577" fill="none" stroke="none" display="none"></path><path id="kity_path_5579" fill="none" stroke="none" display="none"></path><path id="kity_path_5581" fill="none" stroke="none" display="none"></path><path id="kity_path_5583" fill="none" stroke="none" display="none"></path><path id="kity_path_5585" fill="none" stroke="none" display="none"></path><path id="kity_path_5587" fill="none" stroke="none" display="none"></path><path id="kity_path_5589" fill="none" stroke="none" display="none"></path><path id="kity_path_5591" fill="none" stroke="none" display="none"></path><path id="kity_path_5593" fill="none" stroke="none" display="none"></path><path id="kity_path_5595" fill="none" stroke="none" display="none"></path><path id="kity_path_5597" fill="none" stroke="none" display="none"></path><path id="kity_path_5599" fill="none" stroke="none" display="none"></path><path id="kity_path_5601" fill="none" stroke="none" display="none"></path><path id="kity_path_5603" fill="none" stroke="none" display="none"></path><path id="kity_path_5605" fill="none" stroke="none" display="none"></path><path id="kity_path_5607" fill="none" stroke="none" display="none"></path><path id="kity_path_5609" fill="none" stroke="none" display="none"></path><path id="kity_path_5611" fill="none" stroke="none" display="none"></path><path id="kity_path_5613" fill="none" stroke="none" display="none"></path><path id="kity_path_5615" fill="none" stroke="none" display="none"></path><path id="kity_path_5617" fill="none" stroke="none" display="none"></path><path id="kity_path_5619" fill="none" stroke="none" display="none"></path><path id="kity_path_5621" fill="none" stroke="none" display="none"></path><path id="kity_path_5623" fill="none" stroke="none" display="none"></path><path id="kity_path_5625" fill="none" stroke="none" display="none"></path><path id="kity_path_5627" fill="none" stroke="none" display="none"></path><path id="kity_path_5629" fill="none" stroke="none" display="none"></path><path id="kity_path_5631" fill="none" stroke="none" display="none"></path><path id="kity_path_5633" fill="none" stroke="none" display="none"></path><path id="kity_path_5635" fill="none" stroke="none" display="none"></path><path id="kity_path_5637" fill="none" stroke="none" display="none"></path><path id="kity_path_5639" fill="none" stroke="none" display="none"></path><path id="kity_path_5641" fill="none" stroke="none" display="none"></path><path id="kity_path_5643" fill="none" stroke="none" display="none"></path><path id="kity_path_5645" fill="none" stroke="none" display="none"></path><path id="kity_path_5647" fill="none" stroke="none" display="none"></path><path id="kity_path_5649" fill="none" stroke="none" display="none"></path><path id="kity_path_5651" fill="none" stroke="none" display="none"></path><path id="kity_path_5653" fill="none" stroke="none" display="none"></path><path id="kity_path_5655" fill="none" stroke="none" display="none"></path><path id="kity_path_5657" fill="none" stroke="none" display="none"></path><path id="kity_path_5659" fill="none" stroke="none" display="none"></path><path id="kity_path_5661" fill="none" stroke="none" display="none"></path><path id="kity_path_5663" fill="none" stroke="none" display="none"></path><path id="kity_path_5665" fill="none" stroke="none" display="none"></path><path id="kity_path_5667" fill="none" stroke="none" display="none"></path><path id="kity_path_5669" fill="none" stroke="none" display="none"></path><path id="kity_path_5671" fill="none" stroke="none" display="none"></path><path id="kity_path_5673" fill="none" stroke="none" display="none"></path><path id="kity_path_5675" fill="none" stroke="none" display="none"></path><path id="kity_path_5677" fill="none" stroke="none" display="none"></path><path id="kity_path_5679" fill="none" stroke="none" display="none"></path><path id="kity_path_5681" fill="none" stroke="none" display="none"></path><path id="kity_path_5683" fill="none" stroke="none" display="none"></path><path id="kity_path_5685" fill="none" stroke="none" display="none"></path><path id="kity_path_5687" fill="none" stroke="none" display="none"></path><path id="kity_path_5689" fill="none" stroke="none" display="none"></path><path id="kity_path_5691" fill="none" stroke="none" display="none"></path><path id="kity_path_5693" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M351.5,15577.5A45,231,0,0,0,306.5,15346.5"></path><path id="kity_path_5695" fill="none" stroke="none" display="none"></path><path id="kity_path_5697" fill="none" stroke="none" display="none"></path><path id="kity_path_5699" fill="none" stroke="none" display="none"></path><path id="kity_path_5701" fill="none" stroke="none" display="none"></path><path id="kity_path_5703" fill="none" stroke="none" display="none"></path><path id="kity_path_5705" fill="none" stroke="none" display="none"></path><path id="kity_path_5707" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M351.5,15577.5A45,189,0,0,0,306.5,15388.5"></path><path id="kity_path_5709" fill="none" stroke="none" display="none"></path><path id="kity_path_5711" fill="none" stroke="none" display="none"></path><path id="kity_path_5713" fill="none" stroke="none" display="none"></path><path id="kity_path_5715" fill="none" stroke="none" display="none"></path><path id="kity_path_5717" fill="none" stroke="none" display="none"></path><path id="kity_path_5719" fill="none" stroke="none" display="none"></path><path id="kity_path_5721" fill="none" stroke="none" display="none"></path><path id="kity_path_5723" fill="none" stroke="none" display="none"></path><path id="kity_path_5725" fill="none" stroke="none" display="none"></path><path id="kity_path_5727" fill="none" stroke="none" display="none"></path><path id="kity_path_5729" fill="none" stroke="none" display="none"></path><path id="kity_path_5731" fill="none" stroke="none" display="none"></path><path id="kity_path_5733" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M351.5,15577.5A45,147,0,0,0,306.5,15430.5"></path><path id="kity_path_5735" fill="none" stroke="none" display="none"></path><path id="kity_path_5737" fill="none" stroke="none" display="none"></path><path id="kity_path_5739" fill="none" stroke="none" display="none"></path><path id="kity_path_5741" fill="none" stroke="none" display="none"></path><path id="kity_path_5743" fill="none" stroke="none" display="none"></path><path id="kity_path_5745" fill="none" stroke="none" display="none"></path><path id="kity_path_5747" fill="none" stroke="none" display="none"></path><path id="kity_path_5749" fill="none" stroke="none" display="none"></path><path id="kity_path_5751" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M351.5,15577.5A45,105,0,0,0,306.5,15472.5"></path><path id="kity_path_5753" fill="none" stroke="none" display="none"></path><path id="kity_path_5755" fill="none" stroke="none" display="none"></path><path id="kity_path_5757" fill="none" stroke="none" display="none"></path><path id="kity_path_5759" fill="none" stroke="none" display="none"></path><path id="kity_path_5761" fill="none" stroke="none" display="none"></path><path id="kity_path_5763" fill="none" stroke="none" display="none"></path><path id="kity_path_5765" fill="none" stroke="none" display="none"></path><path id="kity_path_5767" fill="none" stroke="none" display="none"></path><path id="kity_path_5769" fill="none" stroke="none" display="none"></path><path id="kity_path_5771" fill="none" stroke="none" display="none"></path><path id="kity_path_5773" fill="none" stroke="none" display="none"></path><path id="kity_path_5775" fill="none" stroke="none" display="none"></path><path id="kity_path_5777" fill="none" stroke="none" display="none"></path><path id="kity_path_5779" fill="none" stroke="none" display="none"></path><path id="kity_path_5781" fill="none" stroke="none" display="none"></path><path id="kity_path_5783" fill="none" stroke="none" display="none"></path><path id="kity_path_5785" fill="none" stroke="none" display="none"></path><path id="kity_path_5787" fill="none" stroke="none" display="none"></path><path id="kity_path_5789" fill="none" stroke="none" display="none"></path><path id="kity_path_5791" fill="none" stroke="none" display="none"></path><path id="kity_path_5793" fill="none" stroke="none" display="none"></path><path id="kity_path_5795" fill="none" stroke="none" display="none"></path><path id="kity_path_5797" fill="none" stroke="none" display="none"></path><path id="kity_path_5799" fill="none" stroke="none" display="none"></path><path id="kity_path_5801" fill="none" stroke="none" display="none"></path><path id="kity_path_5803" fill="none" stroke="none" display="none"></path><path id="kity_path_5805" fill="none" stroke="none" display="none"></path><path id="kity_path_5807" fill="none" stroke="none" display="none"></path><path id="kity_path_5809" fill="none" stroke="none" display="none"></path><path id="kity_path_5811" fill="none" stroke="none" display="none"></path><path id="kity_path_5813" fill="none" stroke="none" display="none"></path><path id="kity_path_5815" fill="none" stroke="none" display="none"></path><path id="kity_path_5817" fill="none" stroke="none" display="none"></path><path id="kity_path_5819" fill="none" stroke="none" display="none"></path><path id="kity_path_5821" fill="none" stroke="none" display="none"></path><path id="kity_path_5823" fill="none" stroke="none" display="none"></path><path id="kity_path_5825" fill="none" stroke="none" display="none"></path><path id="kity_path_5827" fill="none" stroke="none" display="none"></path><path id="kity_path_5829" fill="none" stroke="none" display="none"></path><path id="kity_path_5831" fill="none" stroke="none" display="none"></path><path id="kity_path_5833" fill="none" stroke="none" display="none"></path><path id="kity_path_5835" fill="none" stroke="none" display="none"></path><path id="kity_path_5837" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M351.5,15577.5A45,63,0,0,0,306.5,15514.5"></path><path id="kity_path_5839" fill="none" stroke="none" display="none"></path><path id="kity_path_5841" fill="none" stroke="none" display="none"></path><path id="kity_path_5843" fill="none" stroke="none" display="none"></path><path id="kity_path_5845" fill="none" stroke="none" display="none"></path><path id="kity_path_5847" fill="none" stroke="none" display="none"></path><path id="kity_path_5849" fill="none" stroke="none" display="none"></path><path id="kity_path_5851" fill="none" stroke="none" display="none"></path><path id="kity_path_5853" fill="none" stroke="none" display="none"></path><path id="kity_path_5855" fill="none" stroke="none" display="none"></path><path id="kity_path_5857" fill="none" stroke="none" display="none"></path><path id="kity_path_5859" fill="none" stroke="none" display="none"></path><path id="kity_path_5861" fill="none" stroke="none" display="none"></path><path id="kity_path_5863" fill="none" stroke="none" display="none"></path><path id="kity_path_5865" fill="none" stroke="none" display="none"></path><path id="kity_path_5867" fill="none" stroke="none" display="none"></path><path id="kity_path_5869" fill="none" stroke="none" display="none"></path><path id="kity_path_5871" fill="none" stroke="none" display="none"></path><path id="kity_path_5873" fill="none" stroke="none" display="none"></path><path id="kity_path_5875" fill="none" stroke="none" display="none"></path><path id="kity_path_5877" fill="none" stroke="none" display="none"></path><path id="kity_path_5879" fill="none" stroke="none" display="none"></path><path id="kity_path_5881" fill="none" stroke="none" display="none"></path><path id="kity_path_5883" fill="none" stroke="none" display="none"></path><path id="kity_path_5885" fill="none" stroke="none" display="none"></path><path id="kity_path_5887" fill="none" stroke="none" display="none"></path><path id="kity_path_5889" fill="none" stroke="none" display="none"></path><path id="kity_path_5891" fill="none" stroke="none" display="none"></path><path id="kity_path_5893" fill="none" stroke="none" display="none"></path><path id="kity_path_5895" fill="none" stroke="none" display="none"></path><path id="kity_path_5897" fill="none" stroke="none" display="none"></path><path id="kity_path_5899" fill="none" stroke="none" display="none"></path><path id="kity_path_5901" fill="none" stroke="none" display="none"></path><path id="kity_path_5903" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M351.5,15577.5A45,21,0,0,0,306.5,15556.5"></path><path id="kity_path_5905" fill="none" stroke="none" display="none"></path><path id="kity_path_5907" fill="none" stroke="none" display="none"></path><path id="kity_path_5909" fill="none" stroke="none" display="none"></path><path id="kity_path_5911" fill="none" stroke="none" display="none"></path><path id="kity_path_5913" fill="none" stroke="none" display="none"></path><path id="kity_path_5915" fill="none" stroke="none" display="none"></path><path id="kity_path_5917" fill="none" stroke="none" display="none"></path><path id="kity_path_5919" fill="none" stroke="none" display="none"></path><path id="kity_path_5921" fill="none" stroke="none" display="none"></path><path id="kity_path_5923" fill="none" stroke="none" display="none"></path><path id="kity_path_5925" fill="none" stroke="none" display="none"></path><path id="kity_path_5927" fill="none" stroke="none" display="none"></path><path id="kity_path_5929" fill="none" stroke="none" display="none"></path><path id="kity_path_5931" fill="none" stroke="none" display="none"></path><path id="kity_path_5933" fill="none" stroke="none" display="none"></path><path id="kity_path_5935" fill="none" stroke="none" display="none"></path><path id="kity_path_5937" fill="none" stroke="none" display="none"></path><path id="kity_path_5939" fill="none" stroke="none" display="none"></path><path id="kity_path_5941" fill="none" stroke="none" display="none"></path><path id="kity_path_5943" fill="none" stroke="none" display="none"></path><path id="kity_path_5945" fill="none" stroke="none" display="none"></path><path id="kity_path_5947" fill="none" stroke="none" display="none"></path><path id="kity_path_5949" fill="none" stroke="none" display="none"></path><path id="kity_path_5951" fill="none" stroke="none" display="none"></path><path id="kity_path_5953" fill="none" stroke="none" display="none"></path><path id="kity_path_5955" fill="none" stroke="none" display="none"></path><path id="kity_path_5957" fill="none" stroke="none" display="none"></path><path id="kity_path_5959" fill="none" stroke="none" display="none"></path><path id="kity_path_5961" fill="none" stroke="none" display="none"></path><path id="kity_path_5963" fill="none" stroke="none" display="none"></path><path id="kity_path_5965" fill="none" stroke="none" display="none"></path><path id="kity_path_5967" fill="none" stroke="none" display="none"></path><path id="kity_path_5969" fill="none" stroke="none" display="none"></path><path id="kity_path_5971" fill="none" stroke="none" display="none"></path><path id="kity_path_5973" fill="none" stroke="none" display="none"></path><path id="kity_path_5975" fill="none" stroke="none" display="none"></path><path id="kity_path_5977" fill="none" stroke="none" display="none"></path><path id="kity_path_5979" fill="none" stroke="none" display="none"></path><path id="kity_path_5981" fill="none" stroke="none" display="none"></path><path id="kity_path_5983" fill="none" stroke="none" display="none"></path><path id="kity_path_5985" fill="none" stroke="none" display="none"></path><path id="kity_path_5987" fill="none" stroke="none" display="none"></path><path id="kity_path_5989" fill="none" stroke="none" display="none"></path><path id="kity_path_5991" fill="none" stroke="none" display="none"></path><path id="kity_path_5993" fill="none" stroke="none" display="none"></path><path id="kity_path_5995" fill="none" stroke="none" display="none"></path><path id="kity_path_5997" fill="none" stroke="none" display="none"></path><path id="kity_path_5999" fill="none" stroke="none" display="none"></path><path id="kity_path_6001" fill="none" stroke="none" display="none"></path><path id="kity_path_6003" fill="none" stroke="none" display="none"></path><path id="kity_path_6005" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M351.5,15577.5A45,21,0,0,1,306.5,15598.5"></path><path id="kity_path_6007" fill="none" stroke="none" display="none"></path><path id="kity_path_6009" fill="none" stroke="none" display="none"></path><path id="kity_path_6011" fill="none" stroke="none" display="none"></path><path id="kity_path_6013" fill="none" stroke="none" display="none"></path><path id="kity_path_6015" fill="none" stroke="none" display="none"></path><path id="kity_path_6017" fill="none" stroke="none" display="none"></path><path id="kity_path_6019" fill="none" stroke="none" display="none"></path><path id="kity_path_6021" fill="none" stroke="none" display="none"></path><path id="kity_path_6023" fill="none" stroke="none" display="none"></path><path id="kity_path_6025" fill="none" stroke="none" display="none"></path><path id="kity_path_6027" fill="none" stroke="none" display="none"></path><path id="kity_path_6029" fill="none" stroke="none" display="none"></path><path id="kity_path_6031" fill="none" stroke="none" display="none"></path><path id="kity_path_6033" fill="none" stroke="none" display="none"></path><path id="kity_path_6035" fill="none" stroke="none" display="none"></path><path id="kity_path_6037" fill="none" stroke="none" display="none"></path><path id="kity_path_6039" fill="none" stroke="none" display="none"></path><path id="kity_path_6041" fill="none" stroke="none" display="none"></path><path id="kity_path_6043" fill="none" stroke="none" display="none"></path><path id="kity_path_6045" fill="none" stroke="none" display="none"></path><path id="kity_path_6047" fill="none" stroke="none" display="none"></path><path id="kity_path_6049" fill="none" stroke="none" display="none"></path><path id="kity_path_6051" fill="none" stroke="none" display="none"></path><path id="kity_path_6053" fill="none" stroke="none" display="none"></path><path id="kity_path_6055" fill="none" stroke="none" display="none"></path><path id="kity_path_6057" fill="none" stroke="none" display="none"></path><path id="kity_path_6059" fill="none" stroke="none" display="none"></path><path id="kity_path_6061" fill="none" stroke="none" display="none"></path><path id="kity_path_6063" fill="none" stroke="none" display="none"></path><path id="kity_path_6065" fill="none" stroke="none" display="none"></path><path id="kity_path_6067" fill="none" stroke="none" display="none"></path><path id="kity_path_6069" fill="none" stroke="none" display="none"></path><path id="kity_path_6071" fill="none" stroke="none" display="none"></path><path id="kity_path_6073" fill="none" stroke="none" display="none"></path><path id="kity_path_6075" fill="none" stroke="none" display="none"></path><path id="kity_path_6077" fill="none" stroke="none" display="none"></path><path id="kity_path_6079" fill="none" stroke="none" display="none"></path><path id="kity_path_6081" fill="none" stroke="none" display="none"></path><path id="kity_path_6083" fill="none" stroke="none" display="none"></path><path id="kity_path_6085" fill="none" stroke="none" display="none"></path><path id="kity_path_6087" fill="none" stroke="none" display="none"></path><path id="kity_path_6089" fill="none" stroke="none" display="none"></path><path id="kity_path_6091" fill="none" stroke="none" display="none"></path><path id="kity_path_6093" fill="none" stroke="none" display="none"></path><path id="kity_path_6095" fill="none" stroke="none" display="none"></path><path id="kity_path_6097" fill="none" stroke="none" display="none"></path><path id="kity_path_6099" fill="none" stroke="none" display="none"></path><path id="kity_path_6101" fill="none" stroke="none" display="none"></path><path id="kity_path_6103" fill="none" stroke="none" display="none"></path><path id="kity_path_6105" fill="none" stroke="none" display="none"></path><path id="kity_path_6107" fill="none" stroke="none" display="none"></path><path id="kity_path_6109" fill="none" stroke="none" display="none"></path><path id="kity_path_6111" fill="none" stroke="none" display="none"></path><path id="kity_path_6113" fill="none" stroke="none" display="none"></path><path id="kity_path_6115" fill="none" stroke="none" display="none"></path><path id="kity_path_6117" fill="none" stroke="none" display="none"></path><path id="kity_path_6119" fill="none" stroke="none" display="none"></path><path id="kity_path_6121" fill="none" stroke="none" display="none"></path><path id="kity_path_6123" fill="none" stroke="none" display="none"></path><path id="kity_path_6125" fill="none" stroke="none" display="none"></path><path id="kity_path_6127" fill="none" stroke="none" display="none"></path><path id="kity_path_6129" fill="none" stroke="none" display="none"></path><path id="kity_path_6131" fill="none" stroke="none" display="none"></path><path id="kity_path_6133" fill="none" stroke="none" display="none"></path><path id="kity_path_6135" fill="none" stroke="none" display="none"></path><path id="kity_path_6137" fill="none" stroke="none" display="none"></path><path id="kity_path_6139" fill="none" stroke="none" display="none"></path><path id="kity_path_6141" fill="none" stroke="none" display="none"></path><path id="kity_path_6143" fill="none" stroke="none" display="none"></path><path id="kity_path_6145" fill="none" stroke="none" display="none"></path><path id="kity_path_6147" fill="none" stroke="none" display="none"></path><path id="kity_path_6149" fill="none" stroke="none" display="none"></path><path id="kity_path_6151" fill="none" stroke="none" display="none"></path><path id="kity_path_6153" fill="none" stroke="none" display="none"></path><path id="kity_path_6155" fill="none" stroke="none" display="none"></path><path id="kity_path_6157" fill="none" stroke="none" display="none"></path><path id="kity_path_6159" fill="none" stroke="none" display="none"></path><path id="kity_path_6161" fill="none" stroke="none" display="none"></path><path id="kity_path_6163" fill="none" stroke="none" display="none"></path><path id="kity_path_6165" fill="none" stroke="none" display="none"></path><path id="kity_path_6167" fill="none" stroke="none" display="none"></path><path id="kity_path_6169" fill="none" stroke="none" display="none"></path><path id="kity_path_6171" fill="none" stroke="none" display="none"></path><path id="kity_path_6173" fill="none" stroke="none" display="none"></path><path id="kity_path_6175" fill="none" stroke="none" display="none"></path><path id="kity_path_6177" fill="none" stroke="none" display="none"></path><path id="kity_path_6179" fill="none" stroke="none" display="none"></path><path id="kity_path_6181" fill="none" stroke="none" display="none"></path><path id="kity_path_6183" fill="none" stroke="none" display="none"></path><path id="kity_path_6185" fill="none" stroke="none" display="none"></path><path id="kity_path_6187" fill="none" stroke="none" display="none"></path><path id="kity_path_6189" fill="none" stroke="none" display="none"></path><path id="kity_path_6191" fill="none" stroke="none" display="none"></path><path id="kity_path_6193" fill="none" stroke="none" display="none"></path><path id="kity_path_6195" fill="none" stroke="none" display="none"></path><path id="kity_path_6197" fill="none" stroke="none" display="none"></path><path id="kity_path_6199" fill="none" stroke="none" display="none"></path><path id="kity_path_6201" fill="none" stroke="none" display="none"></path><path id="kity_path_6203" fill="none" stroke="none" display="none"></path><path id="kity_path_6205" fill="none" stroke="none" display="none"></path><path id="kity_path_6207" fill="none" stroke="none" display="none"></path><path id="kity_path_6209" fill="none" stroke="none" display="none"></path><path id="kity_path_6211" fill="none" stroke="none" display="none"></path><path id="kity_path_6213" fill="none" stroke="none" display="none"></path><path id="kity_path_6215" fill="none" stroke="none" display="none"></path><path id="kity_path_6217" fill="none" stroke="none" display="none"></path><path id="kity_path_6219" fill="none" stroke="none" display="none"></path><path id="kity_path_6221" fill="none" stroke="none" display="none"></path><path id="kity_path_6223" fill="none" stroke="none" display="none"></path><path id="kity_path_6225" fill="none" stroke="none" display="none"></path><path id="kity_path_6227" fill="none" stroke="none" display="none"></path><path id="kity_path_6229" fill="none" stroke="none" display="none"></path><path id="kity_path_6231" fill="none" stroke="none" display="none"></path><path id="kity_path_6233" fill="none" stroke="none" display="none"></path><path id="kity_path_6235" fill="none" stroke="none" display="none"></path><path id="kity_path_6237" fill="none" stroke="none" display="none"></path><path id="kity_path_6239" fill="none" stroke="none" display="none"></path><path id="kity_path_6241" fill="none" stroke="none" display="none"></path><path id="kity_path_6243" fill="none" stroke="none" display="none"></path><path id="kity_path_6245" fill="none" stroke="none" display="none"></path><path id="kity_path_6247" fill="none" stroke="none" display="none"></path><path id="kity_path_6249" fill="none" stroke="none" display="none"></path><path id="kity_path_6251" fill="none" stroke="none" display="none"></path><path id="kity_path_6253" fill="none" stroke="none" display="none"></path><path id="kity_path_6255" fill="none" stroke="none" display="none"></path><path id="kity_path_6257" fill="none" stroke="none" display="none"></path><path id="kity_path_6259" fill="none" stroke="none" display="none"></path><path id="kity_path_6261" fill="none" stroke="none" display="none"></path><path id="kity_path_6263" fill="none" stroke="none" display="none"></path><path id="kity_path_6265" fill="none" stroke="none" display="none"></path><path id="kity_path_6267" fill="none" stroke="none" display="none"></path><path id="kity_path_6269" fill="none" stroke="none" display="none"></path><path id="kity_path_6271" fill="none" stroke="none" display="none"></path><path id="kity_path_6273" fill="none" stroke="none" display="none"></path><path id="kity_path_6275" fill="none" stroke="none" display="none"></path><path id="kity_path_6277" fill="none" stroke="none" display="none"></path><path id="kity_path_6279" fill="none" stroke="none" display="none"></path><path id="kity_path_6281" fill="none" stroke="none" display="none"></path><path id="kity_path_6283" fill="none" stroke="none" display="none"></path><path id="kity_path_6285" fill="none" stroke="none" display="none"></path><path id="kity_path_6287" fill="none" stroke="none" display="none"></path><path id="kity_path_6289" fill="none" stroke="none" display="none"></path><path id="kity_path_6291" fill="none" stroke="none" display="none"></path><path id="kity_path_6293" fill="none" stroke="none" display="none"></path><path id="kity_path_6295" fill="none" stroke="none" display="none"></path><path id="kity_path_6297" fill="none" stroke="none" display="none"></path><path id="kity_path_6299" fill="none" stroke="none" display="none"></path><path id="kity_path_6301" fill="none" stroke="none" display="none"></path><path id="kity_path_6303" fill="none" stroke="none" display="none"></path><path id="kity_path_6305" fill="none" stroke="none" display="none"></path><path id="kity_path_6307" fill="none" stroke="none" display="none"></path><path id="kity_path_6309" fill="none" stroke="none" display="none"></path><path id="kity_path_6311" fill="none" stroke="none" display="none"></path><path id="kity_path_6313" fill="none" stroke="none" display="none"></path><path id="kity_path_6315" fill="none" stroke="none" display="none"></path><path id="kity_path_6317" fill="none" stroke="none" display="none"></path><path id="kity_path_6319" fill="none" stroke="none" display="none"></path><path id="kity_path_6321" fill="none" stroke="none" display="none"></path><path id="kity_path_6323" fill="none" stroke="none" display="none"></path><path id="kity_path_6325" fill="none" stroke="none" display="none"></path><path id="kity_path_6327" fill="none" stroke="none" display="none"></path><path id="kity_path_6329" fill="none" stroke="none" display="none"></path><path id="kity_path_6331" fill="none" stroke="none" display="none"></path><path id="kity_path_6333" fill="none" stroke="none" display="none"></path><path id="kity_path_6335" fill="none" stroke="none" display="none"></path><path id="kity_path_6337" fill="none" stroke="none" display="none"></path><path id="kity_path_6339" fill="none" stroke="none" display="none"></path><path id="kity_path_6341" fill="none" stroke="none" display="none"></path><path id="kity_path_6343" fill="none" stroke="none" display="none"></path><path id="kity_path_6345" fill="none" stroke="none" display="none"></path><path id="kity_path_6347" fill="none" stroke="none" display="none"></path><path id="kity_path_6349" fill="none" stroke="none" display="none"></path><path id="kity_path_6351" fill="none" stroke="none" display="none"></path><path id="kity_path_6353" fill="none" stroke="none" display="none"></path><path id="kity_path_6355" fill="none" stroke="none" display="none"></path><path id="kity_path_6357" fill="none" stroke="none" display="none"></path><path id="kity_path_6359" fill="none" stroke="none" display="none"></path><path id="kity_path_6361" fill="none" stroke="none" display="none"></path><path id="kity_path_6363" fill="none" stroke="none" display="none"></path><path id="kity_path_6365" fill="none" stroke="none" display="none"></path><path id="kity_path_6367" fill="none" stroke="none" display="none"></path><path id="kity_path_6369" fill="none" stroke="none" display="none"></path><path id="kity_path_6371" fill="none" stroke="none" display="none"></path><path id="kity_path_6373" fill="none" stroke="none" display="none"></path><path id="kity_path_6375" fill="none" stroke="none" display="none"></path><path id="kity_path_6377" fill="none" stroke="none" display="none"></path><path id="kity_path_6379" fill="none" stroke="none" display="none"></path><path id="kity_path_6381" fill="none" stroke="none" display="none"></path><path id="kity_path_6383" fill="none" stroke="none" display="none"></path><path id="kity_path_6385" fill="none" stroke="none" display="none"></path><path id="kity_path_6387" fill="none" stroke="none" display="none"></path><path id="kity_path_6389" fill="none" stroke="none" display="none"></path><path id="kity_path_6391" fill="none" stroke="none" display="none"></path><path id="kity_path_6393" fill="none" stroke="none" display="none"></path><path id="kity_path_6395" fill="none" stroke="none" display="none"></path><path id="kity_path_6397" fill="none" stroke="none" display="none"></path><path id="kity_path_6399" fill="none" stroke="none" display="none"></path><path id="kity_path_6401" fill="none" stroke="none" display="none"></path><path id="kity_path_6403" fill="none" stroke="none" display="none"></path><path id="kity_path_6405" fill="none" stroke="none" display="none"></path><path id="kity_path_6407" fill="none" stroke="none" display="none"></path><path id="kity_path_6409" fill="none" stroke="none" display="none"></path><path id="kity_path_6411" fill="none" stroke="none" display="none"></path><path id="kity_path_6413" fill="none" stroke="none" display="none"></path><path id="kity_path_6415" fill="none" stroke="none" display="none"></path><path id="kity_path_6417" fill="none" stroke="none" display="none"></path><path id="kity_path_6419" fill="none" stroke="none" display="none"></path><path id="kity_path_6421" fill="none" stroke="none" display="none"></path><path id="kity_path_6423" fill="none" stroke="none" display="none"></path><path id="kity_path_6425" fill="none" stroke="none" display="none"></path><path id="kity_path_6427" fill="none" stroke="none" display="none"></path><path id="kity_path_6429" fill="none" stroke="none" display="none"></path><path id="kity_path_6431" fill="none" stroke="none" display="none"></path><path id="kity_path_6433" fill="none" stroke="none" display="none"></path><path id="kity_path_6435" fill="none" stroke="none" display="none"></path><path id="kity_path_6437" fill="none" stroke="none" display="none"></path><path id="kity_path_6439" fill="none" stroke="none" display="none"></path><path id="kity_path_6441" fill="none" stroke="none" display="none"></path><path id="kity_path_6443" fill="none" stroke="none" display="none"></path><path id="kity_path_6445" fill="none" stroke="none" display="none"></path><path id="kity_path_6447" fill="none" stroke="none" display="none"></path><path id="kity_path_6449" fill="none" stroke="none" display="none"></path><path id="kity_path_6451" fill="none" stroke="none" display="none"></path><path id="kity_path_6453" fill="none" stroke="none" display="none"></path><path id="kity_path_6455" fill="none" stroke="none" display="none"></path><path id="kity_path_6457" fill="none" stroke="none" display="none"></path><path id="kity_path_6459" fill="none" stroke="none" display="none"></path><path id="kity_path_6461" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M351.5,15577.5A45,63,0,0,1,306.5,15640.5"></path><path id="kity_path_6463" fill="none" stroke="none" display="none"></path><path id="kity_path_6465" fill="none" stroke="none" display="none"></path><path id="kity_path_6467" fill="none" stroke="none" display="none"></path><path id="kity_path_6469" fill="none" stroke="none" display="none"></path><path id="kity_path_6471" fill="none" stroke="none" display="none"></path><path id="kity_path_6473" fill="none" stroke="none" display="none"></path><path id="kity_path_6475" fill="none" stroke="none" display="none"></path><path id="kity_path_6477" fill="none" stroke="none" display="none"></path><path id="kity_path_6479" fill="none" stroke="none" display="none"></path><path id="kity_path_6481" fill="none" stroke="none" display="none"></path><path id="kity_path_6483" fill="none" stroke="none" display="none"></path><path id="kity_path_6485" fill="none" stroke="none" display="none"></path><path id="kity_path_6487" fill="none" stroke="none" display="none"></path><path id="kity_path_6489" fill="none" stroke="none" display="none"></path><path id="kity_path_6491" fill="none" stroke="none" display="none"></path><path id="kity_path_6493" fill="none" stroke="none" display="none"></path><path id="kity_path_6495" fill="none" stroke="none" display="none"></path><path id="kity_path_6497" fill="none" stroke="none" display="none"></path><path id="kity_path_6499" fill="none" stroke="none" display="none"></path><path id="kity_path_6501" fill="none" stroke="none" display="none"></path><path id="kity_path_6503" fill="none" stroke="none" display="none"></path><path id="kity_path_6505" fill="none" stroke="none" display="none"></path><path id="kity_path_6507" fill="none" stroke="none" display="none"></path><path id="kity_path_6509" fill="none" stroke="none" display="none"></path><path id="kity_path_6511" fill="none" stroke="none" display="none"></path><path id="kity_path_6513" fill="none" stroke="none" display="none"></path><path id="kity_path_6515" fill="none" stroke="none" display="none"></path><path id="kity_path_6517" fill="none" stroke="none" display="none"></path><path id="kity_path_6519" fill="none" stroke="none" display="none"></path><path id="kity_path_6521" fill="none" stroke="none" display="none"></path><path id="kity_path_6523" fill="none" stroke="none" display="none"></path><path id="kity_path_6525" fill="none" stroke="none" display="none"></path><path id="kity_path_6527" fill="none" stroke="none" display="none"></path><path id="kity_path_6529" fill="none" stroke="none" display="none"></path><path id="kity_path_6531" fill="none" stroke="none" display="none"></path><path id="kity_path_6533" fill="none" stroke="none" display="none"></path><path id="kity_path_6535" fill="none" stroke="none" display="none"></path><path id="kity_path_6537" fill="none" stroke="none" display="none"></path><path id="kity_path_6539" fill="none" stroke="none" display="none"></path><path id="kity_path_6541" fill="none" stroke="none" display="none"></path><path id="kity_path_6543" fill="none" stroke="none" display="none"></path><path id="kity_path_6545" fill="none" stroke="none" display="none"></path><path id="kity_path_6547" fill="none" stroke="none" display="none"></path><path id="kity_path_6549" fill="none" stroke="none" display="none"></path><path id="kity_path_6551" fill="none" stroke="none" display="none"></path><path id="kity_path_6553" fill="none" stroke="none" display="none"></path><path id="kity_path_6555" fill="none" stroke="none" display="none"></path><path id="kity_path_6557" fill="none" stroke="none" display="none"></path><path id="kity_path_6559" fill="none" stroke="none" display="none"></path><path id="kity_path_6561" fill="none" stroke="none" display="none"></path><path id="kity_path_6563" fill="none" stroke="none" display="none"></path><path id="kity_path_6565" fill="none" stroke="none" display="none"></path><path id="kity_path_6567" fill="none" stroke="none" display="none"></path><path id="kity_path_6569" fill="none" stroke="none" display="none"></path><path id="kity_path_6571" fill="none" stroke="none" display="none"></path><path id="kity_path_6573" fill="none" stroke="none" display="none"></path><path id="kity_path_6575" fill="none" stroke="none" display="none"></path><path id="kity_path_6577" fill="none" stroke="none" display="none"></path><path id="kity_path_6579" fill="none" stroke="none" display="none"></path><path id="kity_path_6581" fill="none" stroke="none" display="none"></path><path id="kity_path_6583" fill="none" stroke="none" display="none"></path><path id="kity_path_6585" fill="none" stroke="none" display="none"></path><path id="kity_path_6587" fill="none" stroke="none" display="none"></path><path id="kity_path_6589" fill="none" stroke="none" display="none"></path><path id="kity_path_6591" fill="none" stroke="none" display="none"></path><path id="kity_path_6593" fill="none" stroke="none" display="none"></path><path id="kity_path_6595" fill="none" stroke="none" display="none"></path><path id="kity_path_6597" fill="none" stroke="none" display="none"></path><path id="kity_path_6599" fill="none" stroke="none" display="none"></path><path id="kity_path_6601" fill="none" stroke="none" display="none"></path><path id="kity_path_6603" fill="none" stroke="none" display="none"></path><path id="kity_path_6605" fill="none" stroke="none" display="none"></path><path id="kity_path_6607" fill="none" stroke="none" display="none"></path><path id="kity_path_6609" fill="none" stroke="none" display="none"></path><path id="kity_path_6611" fill="none" stroke="none" display="none"></path><path id="kity_path_6613" fill="none" stroke="none" display="none"></path><path id="kity_path_6615" fill="none" stroke="none" display="none"></path><path id="kity_path_6617" fill="none" stroke="none" display="none"></path><path id="kity_path_6619" fill="none" stroke="none" display="none"></path><path id="kity_path_6621" fill="none" stroke="none" display="none"></path><path id="kity_path_6623" fill="none" stroke="none" display="none"></path><path id="kity_path_6625" fill="none" stroke="none" display="none"></path><path id="kity_path_6627" fill="none" stroke="none" display="none"></path><path id="kity_path_6629" fill="none" stroke="none" display="none"></path><path id="kity_path_6631" fill="none" stroke="none" display="none"></path><path id="kity_path_6633" fill="none" stroke="none" display="none"></path><path id="kity_path_6635" fill="none" stroke="none" display="none"></path><path id="kity_path_6637" fill="none" stroke="none" display="none"></path><path id="kity_path_6639" fill="none" stroke="none" display="none"></path><path id="kity_path_6641" fill="none" stroke="none" display="none"></path><path id="kity_path_6643" fill="none" stroke="none" display="none"></path><path id="kity_path_6645" fill="none" stroke="none" display="none"></path><path id="kity_path_6647" fill="none" stroke="none" display="none"></path><path id="kity_path_6649" fill="none" stroke="none" display="none"></path><path id="kity_path_6651" fill="none" stroke="none" display="none"></path><path id="kity_path_6653" fill="none" stroke="none" display="none"></path><path id="kity_path_6655" fill="none" stroke="none" display="none"></path><path id="kity_path_6657" fill="none" stroke="none" display="none"></path><path id="kity_path_6659" fill="none" stroke="none" display="none"></path><path id="kity_path_6661" fill="none" stroke="none" display="none"></path><path id="kity_path_6663" fill="none" stroke="none" display="none"></path><path id="kity_path_6665" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M351.5,15577.5A45,105,0,0,1,306.5,15682.5"></path><path id="kity_path_6667" fill="none" stroke="none" display="none"></path><path id="kity_path_6669" fill="none" stroke="none" display="none"></path><path id="kity_path_6671" fill="none" stroke="none" display="none"></path><path id="kity_path_6673" fill="none" stroke="none" display="none"></path><path id="kity_path_6675" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M351.5,15577.5A45,147,0,0,1,306.5,15724.5"></path><path id="kity_path_6677" fill="none" stroke="none" display="none"></path><path id="kity_path_6679" fill="none" stroke="none" display="none"></path><path id="kity_path_6681" fill="none" stroke="none" display="none"></path><path id="kity_path_6683" fill="none" stroke="none" display="none"></path><path id="kity_path_6685" fill="none" stroke="none" display="none"></path><path id="kity_path_6687" fill="none" stroke="none" display="none"></path><path id="kity_path_6689" fill="none" stroke="none" display="none"></path><path id="kity_path_6691" fill="none" stroke="none" display="none"></path><path id="kity_path_6693" fill="none" stroke="none" display="none"></path><path id="kity_path_6695" fill="none" stroke="none" display="none"></path><path id="kity_path_6697" fill="none" stroke="none" display="none"></path><path id="kity_path_6699" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M351.5,15577.5A45,189,0,0,1,306.5,15766.5"></path><path id="kity_path_6701" fill="none" stroke="none" display="none"></path><path id="kity_path_6703" fill="none" stroke="none" display="none"></path><path id="kity_path_6705" fill="none" stroke="none" display="none"></path><path id="kity_path_6707" fill="none" stroke="none" display="none"></path><path id="kity_path_6709" fill="none" stroke="none" display="none"></path><path id="kity_path_6711" fill="none" stroke="none" display="none"></path><path id="kity_path_6713" fill="none" stroke="none" display="none"></path><path id="kity_path_6715" fill="none" stroke="none" display="none"></path><path id="kity_path_6717" fill="none" stroke="none" display="none"></path><path id="kity_path_6719" fill="none" stroke="none" display="none"></path><path id="kity_path_6721" fill="none" stroke="none" display="none"></path><path id="kity_path_6723" fill="none" stroke="none" display="none"></path><path id="kity_path_6725" fill="none" stroke="none" display="none"></path><path id="kity_path_6727" fill="none" stroke="none" display="none"></path><path id="kity_path_6729" fill="none" stroke="none" display="none"></path><path id="kity_path_6731" fill="none" stroke="none" display="none"></path><path id="kity_path_6733" fill="none" stroke="none" display="none"></path><path id="kity_path_6735" fill="none" stroke="none" display="none"></path><path id="kity_path_6737" fill="none" stroke="none" display="none"></path><path id="kity_path_6739" fill="none" stroke="none" display="none"></path><path id="kity_path_6741" fill="none" stroke="none" display="none"></path><path id="kity_path_6743" fill="none" stroke="none" display="none"></path><path id="kity_path_6745" fill="none" stroke="none" display="none"></path><path id="kity_path_6747" fill="none" stroke="none" display="none"></path><path id="kity_path_6749" fill="none" stroke="none" display="none"></path><path id="kity_path_6751" fill="none" stroke="none" display="none"></path><path id="kity_path_6753" fill="none" stroke="none" display="none"></path><path id="kity_path_6755" fill="none" stroke="none" display="none"></path><path id="kity_path_6757" fill="none" stroke="none" display="none"></path><path id="kity_path_6759" fill="none" stroke="none" display="none"></path><path id="kity_path_6761" fill="none" stroke="none" display="none"></path><path id="kity_path_6763" fill="none" stroke="none" display="none"></path><path id="kity_path_6765" fill="none" stroke="none" display="none"></path><path id="kity_path_6767" fill="none" stroke="none" display="none"></path><path id="kity_path_6769" fill="none" stroke="none" display="none"></path><path id="kity_path_6771" fill="none" stroke="none" display="none"></path><path id="kity_path_6773" fill="none" stroke="none" display="none"></path><path id="kity_path_6775" fill="none" stroke="none" display="none"></path><path id="kity_path_6777" fill="none" stroke="none" display="none"></path><path id="kity_path_6779" fill="none" stroke="none" display="none"></path><path id="kity_path_6781" fill="none" stroke="none" display="none"></path><path id="kity_path_6783" fill="none" stroke="none" display="none"></path><path id="kity_path_6785" fill="none" stroke="none" display="none"></path><path id="kity_path_6787" fill="none" stroke="none" display="none"></path><path id="kity_path_6789" fill="none" stroke="none" display="none"></path><path id="kity_path_6791" fill="none" stroke="none" display="none"></path><path id="kity_path_6793" fill="none" stroke="none" display="none"></path><path id="kity_path_6795" fill="none" stroke="rgb(123, 115, 191)" stroke-width="1" d="M351.5,15577.5A45,231,0,0,1,306.5,15808.5"></path><path id="kity_path_6797" fill="none" stroke="none" display="none"></path><path id="kity_path_6799" fill="none" stroke="none" display="none"></path><path id="kity_path_6801" fill="none" stroke="none" display="none"></path><path id="kity_path_6803" fill="none" stroke="none" display="none"></path><path id="kity_path_6805" fill="none" stroke="none" display="none"></path><path id="kity_path_6807" fill="none" stroke="none" display="none"></path><path id="kity_path_6809" fill="none" stroke="none" display="none"></path><path id="kity_path_6811" fill="none" stroke="none" display="none"></path><path id="kity_path_6813" fill="none" stroke="none" display="none"></path><path id="kity_path_6815" fill="none" stroke="none" display="none"></path><path id="kity_path_6817" fill="none" stroke="none" display="none"></path><path id="kity_path_6819" fill="none" stroke="none" display="none"></path><path id="kity_path_6821" fill="none" stroke="none" display="none"></path><path id="kity_path_6823" fill="none" stroke="none" display="none"></path><path id="kity_path_6825" fill="none" stroke="none" display="none"></path><path id="kity_path_6827" fill="none" stroke="none" display="none"></path><path id="kity_path_6829" fill="none" stroke="none" display="none"></path><path id="kity_path_6831" fill="none" stroke="none" display="none"></path><path id="kity_path_6833" fill="none" stroke="none" display="none"></path><path id="kity_path_6835" fill="none" stroke="none" display="none"></path><path id="kity_path_6837" fill="none" stroke="none" display="none"></path><path id="kity_path_6839" fill="none" stroke="none" display="none"></path><path id="kity_path_6841" fill="none" stroke="none" display="none"></path><path id="kity_path_6843" fill="none" stroke="none" display="none"></path><path id="kity_path_6845" fill="none" stroke="none" display="none"></path><path id="kity_path_6847" fill="none" stroke="none" display="none"></path><path id="kity_path_6849" fill="none" stroke="none" display="none"></path><path id="kity_path_6851" fill="none" stroke="none" display="none"></path><path id="kity_path_6853" fill="none" stroke="none" display="none"></path><path id="kity_path_6855" fill="none" stroke="none" display="none"></path><path id="kity_path_6857" fill="none" stroke="none" display="none"></path><path id="kity_path_6859" fill="none" stroke="none" display="none"></path><path id="kity_path_6861" fill="none" stroke="none" display="none"></path><path id="kity_path_6863" fill="none" stroke="none" display="none"></path><path id="kity_path_6865" fill="none" stroke="none" display="none"></path><path id="kity_path_6867" fill="none" stroke="none" display="none"></path><path id="kity_path_6869" fill="none" stroke="none" display="none"></path></g><g id="minder_node1"><path id="node_outline1" fill="rgb(123, 115, 191)" stroke="rgb(123, 115, 191)" d="M327.5,15563.5h48a5,5,0,0,1,5,5v18a5,5,0,0,1,-5,5h-48a5,5,0,0,1,-5,-5v-18a5,5,0,0,1,5,-5z" stroke-width="3"></path><g id="node_text1" fill="white"><text id="kity_text_22" text-rendering="inherit" font-size="16" dy=".8em" y="15567.099999904633" x="334.5">沉默</text></g></g><g id="kity_g_12"><path id="kity_path_13" fill="none" stroke="none" d="M334.5,15577.5h0v0h0z"></path></g><g id="kity_g_14"><path id="kity_path_15" fill="none" stroke="none" d="M334.5,15577.5h0v0h0z"></path><path id="kity_path_16" fill="none" stroke="none"></path></g><g id="minder_node2"><g id="node_expander44" style="cursor: pointer;"><path id="kity_path_20654" fill="white" stroke="gray" d="M397.5,33.5A6,6,0,1,1,385.5,33.5A6,6,0,1,1,397.5,33.5"></path><path id="kity_path_20655" fill="none" stroke="gray" d="M387,33.5L396,33.5M391.5,29L391.5,38"></path></g><path id="node_outline45" fill="rgb(239, 238, 246)" stroke="rgb(123, 115, 191)" d="M401.5,20.5h145a3,3,0,0,1,3,3v20a3,3,0,0,1,-3,3h-145a3,3,0,0,1,-3,-3v-20a3,3,0,0,1,3,-3z" stroke-width="1"></path><g id="node_text45" fill="black"><text id="kity_text_6958" text-rendering="inherit" font-size="14" dy=".8em" y="24.40000009536743" x="418.5">0.数据结构和算法</text></g></g><g id="minder_node3" display="none"><g id="node_expander11" display="none" style="cursor: pointer;"><path id="kity_path_20555" fill="white" stroke="gray" d="M565.5,9.5A6,6,0,1,1,553.5,9.5A6,6,0,1,1,565.5,9.5"></path><path id="kity_path_20556" fill="none" stroke="gray"></path></g><path id="node_outline12" fill="none" stroke="none" d="M565.5,0.5h72a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-72a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text12" fill="black"><text id="kity_text_6891" text-rendering="inherit" font-size="12" dy=".8em" y="1.7000000476837158" x="565.5">常见数据结构</text></g></g><g id="minder_node4" display="none"><g id="node_expander1" display="none" style="cursor: pointer;"><path id="kity_path_20525" fill="white" stroke="gray" d="M581.5,-22.5A6,6,0,1,1,569.5,-22.5A6,6,0,1,1,581.5,-22.5"></path><path id="kity_path_20526" fill="none" stroke="gray"></path></g><path id="node_outline2" fill="none" stroke="none" d="M581.5,-31.5h14a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-14a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2" fill="black"><text id="kity_text_6871" text-rendering="inherit" font-size="12" dy=".8em" y="-30.299999952316284" x="581.5">栈</text></g></g><g id="minder_node5" display="none"><g id="node_expander2" display="none" style="cursor: pointer;"><path id="kity_path_20528" fill="white" stroke="gray" d="M581.5,-14.5A6,6,0,1,1,569.5,-14.5A6,6,0,1,1,581.5,-14.5"></path><path id="kity_path_20529" fill="none" stroke="gray"></path></g><path id="node_outline3" fill="none" stroke="none" d="M581.5,-23.5h28a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-28a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3" fill="black"><text id="kity_text_6873" text-rendering="inherit" font-size="12" dy=".8em" y="-22.299999952316284" x="581.5">队列&#xa0;</text></g></g><g id="minder_node6" display="none"><g id="node_expander3" display="none" style="cursor: pointer;"><path id="kity_path_20531" fill="white" stroke="gray" d="M581.5,-6.5A6,6,0,1,1,569.5,-6.5A6,6,0,1,1,581.5,-6.5"></path><path id="kity_path_20532" fill="none" stroke="gray"></path></g><path id="node_outline4" fill="none" stroke="none" d="M581.5,-15.5h41a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-41a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text4" fill="black"><text id="kity_text_6875" text-rendering="inherit" font-size="12" dy=".8em" y="-14.299999952316284" x="581.5">&#xa0;单链表</text></g></g><g id="minder_node7" display="none"><g id="node_expander4" display="none" style="cursor: pointer;"><path id="kity_path_20534" fill="white" stroke="gray" d="M581.5,1.5A6,6,0,1,1,569.5,1.5A6,6,0,1,1,581.5,1.5"></path><path id="kity_path_20535" fill="none" stroke="gray"></path></g><path id="node_outline5" fill="none" stroke="none" d="M581.5,-7.5h38a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-38a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text5" fill="black"><text id="kity_text_6877" text-rendering="inherit" font-size="12" dy=".8em" y="-6.299999952316284" x="581.5">双链表</text></g></g><g id="minder_node8" display="none"><g id="node_expander10" display="none" style="cursor: pointer;"><path id="kity_path_20552" fill="white" stroke="gray" d="M581.5,9.5A6,6,0,1,1,569.5,9.5A6,6,0,1,1,581.5,9.5"></path><path id="kity_path_20553" fill="none" stroke="gray"></path></g><path id="node_outline11" fill="none" stroke="none" d="M581.5,0.5h14a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-14a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text11" fill="black"><text id="kity_text_6889" text-rendering="inherit" font-size="12" dy=".8em" y="1.7000000476837158" x="581.5">树</text></g></g><g id="minder_node9" display="none"><g id="node_expander5" display="none" style="cursor: pointer;"><path id="kity_path_20537" fill="white" stroke="gray" d="M597.5,-22.5A6,6,0,1,1,585.5,-22.5A6,6,0,1,1,597.5,-22.5"></path><path id="kity_path_20538" fill="none" stroke="gray"></path></g><path id="node_outline6" fill="none" stroke="none" d="M597.5,-31.5h37a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-37a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text6" fill="black"><text id="kity_text_6879" text-rendering="inherit" font-size="12" dy=".8em" y="-30.299999952316284" x="597.5">二叉树</text></g></g><g id="minder_node10" display="none"><g id="node_expander6" display="none" style="cursor: pointer;"><path id="kity_path_20540" fill="white" stroke="gray" d="M597.5,-14.5A6,6,0,1,1,585.5,-14.5A6,6,0,1,1,597.5,-14.5"></path><path id="kity_path_20541" fill="none" stroke="gray"></path></g><path id="node_outline7" fill="none" stroke="none" d="M597.5,-23.5h61a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-61a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text7" fill="black"><text id="kity_text_6881" text-rendering="inherit" font-size="12" dy=".8em" y="-22.299999952316284" x="597.5">平衡二叉树</text></g></g><g id="minder_node11" display="none"><g id="node_expander7" display="none" style="cursor: pointer;"><path id="kity_path_20543" fill="white" stroke="gray" d="M597.5,-6.5A6,6,0,1,1,585.5,-6.5A6,6,0,1,1,597.5,-6.5"></path><path id="kity_path_20544" fill="none" stroke="gray"></path></g><path id="node_outline8" fill="none" stroke="none" d="M597.5,-15.5h37a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-37a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text8" fill="black"><text id="kity_text_6883" text-rendering="inherit" font-size="12" dy=".8em" y="-14.299999952316284" x="597.5">红黑树</text></g></g><g id="minder_node12" display="none"><g id="node_expander8" display="none" style="cursor: pointer;"><path id="kity_path_20546" fill="white" stroke="gray" d="M597.5,1.5A6,6,0,1,1,585.5,1.5A6,6,0,1,1,597.5,1.5"></path><path id="kity_path_20547" fill="none" stroke="gray"></path></g><path id="node_outline9" fill="none" stroke="none" d="M597.5,-7.5h21a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-21a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text9" fill="black"><text id="kity_text_6885" text-rendering="inherit" font-size="12" dy=".8em" y="-6.299999952316284" x="597.5">b树</text></g></g><g id="minder_node13" display="none"><g id="node_expander9" display="none" style="cursor: pointer;"><path id="kity_path_20549" fill="white" stroke="gray" d="M597.5,9.5A6,6,0,1,1,585.5,9.5A6,6,0,1,1,597.5,9.5"></path><path id="kity_path_20550" fill="none" stroke="gray"></path></g><path id="node_outline10" fill="none" stroke="none" d="M597.5,0.5h30a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-30a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text10" fill="black"><text id="kity_text_6887" text-rendering="inherit" font-size="12" dy=".8em" y="1.7000000476837158" x="597.5">b+树</text></g></g><g id="minder_node14" display="none"><g id="node_expander34" display="none" style="cursor: pointer;"><path id="kity_path_20624" fill="white" stroke="gray" d="M565.5,17.5A6,6,0,1,1,553.5,17.5A6,6,0,1,1,565.5,17.5"></path><path id="kity_path_20625" fill="none" stroke="gray"></path></g><path id="node_outline35" fill="none" stroke="none" d="M565.5,8.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text35" fill="black"><text id="kity_text_6938" text-rendering="inherit" font-size="12" dy=".8em" y="9.700000047683716" x="565.5">排序</text></g></g><g id="minder_node15" display="none"><g id="node_expander17" display="none" style="cursor: pointer;"><path id="kity_path_20573" fill="white" stroke="gray" d="M581.5,-38.5A6,6,0,1,1,569.5,-38.5A6,6,0,1,1,581.5,-38.5"></path><path id="kity_path_20574" fill="none" stroke="gray"></path></g><path id="node_outline18" fill="none" stroke="none" d="M581.5,-47.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text18" fill="black"><text id="kity_text_6903" text-rendering="inherit" font-size="12" dy=".8em" y="-46.299999952316284" x="581.5">交换</text></g></g><g id="minder_node16" display="none"><g id="node_expander15" display="none" style="cursor: pointer;"><path id="kity_path_20567" fill="white" stroke="gray" d="M597.5,-46.5A6,6,0,1,1,585.5,-46.5A6,6,0,1,1,597.5,-46.5"></path><path id="kity_path_20568" fill="none" stroke="gray"></path></g><path id="node_outline16" fill="none" stroke="none" d="M597.5,-55.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text16" fill="black"><text id="kity_text_6899" text-rendering="inherit" font-size="12" dy=".8em" y="-54.299999952316284" x="597.5">快排</text></g></g><g id="minder_node17" display="none"><g id="node_expander12" display="none" style="cursor: pointer;"><path id="kity_path_20558" fill="white" stroke="gray" d="M613.5,-54.5A6,6,0,1,1,601.5,-54.5A6,6,0,1,1,613.5,-54.5"></path><path id="kity_path_20559" fill="none" stroke="gray"></path></g><path id="node_outline13" fill="none" stroke="none" d="M613.5,-63.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text13" fill="black"><text id="kity_text_6893" text-rendering="inherit" font-size="12" dy=".8em" y="-62.299999952316284" x="613.5">说说你写的思路，再优化？</text></g></g><g id="minder_node18" display="none"><g id="node_expander14" display="none" style="cursor: pointer;"><path id="kity_path_20564" fill="white" stroke="gray" d="M613.5,-46.5A6,6,0,1,1,601.5,-46.5A6,6,0,1,1,613.5,-46.5"></path><path id="kity_path_20565" fill="none" stroke="gray"></path></g><path id="node_outline15" fill="none" stroke="none" d="M613.5,-55.5h349a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-349a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text15" fill="black"><text id="kity_text_6897" text-rendering="inherit" font-size="12" dy=".8em" y="-54.299999952316284" x="613.5">时间复杂度？最坏时间复杂度？最坏什么时候发生？怎么避免最坏</text></g></g><g id="minder_node19" display="none"><g id="node_expander13" display="none" style="cursor: pointer;"><path id="kity_path_20561" fill="white" stroke="gray" d="M629.5,-46.5A6,6,0,1,1,617.5,-46.5A6,6,0,1,1,629.5,-46.5"></path><path id="kity_path_20562" fill="none" stroke="gray"></path></g><path id="node_outline14" fill="none" stroke="none" d="M629.5,-55.5h720a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-720a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text14" fill="black"><text id="kity_text_6895" text-rendering="inherit" font-size="12" dy=".8em" y="-54.299999952316284" x="629.5">最优平均时间复杂度O(lgN)，最差时间复杂度O(N)，最差出现在基本有序时，空间复杂度可以说是O(1)，也可以说是O(N)，不稳定排序</text></g></g><g id="minder_node20" display="none"><g id="node_expander16" display="none" style="cursor: pointer;"><path id="kity_path_20570" fill="white" stroke="gray" d="M597.5,-38.5A6,6,0,1,1,585.5,-38.5A6,6,0,1,1,597.5,-38.5"></path><path id="kity_path_20571" fill="none" stroke="gray"></path></g><path id="node_outline17" fill="none" stroke="none" d="M597.5,-47.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text17" fill="black"><text id="kity_text_6901" text-rendering="inherit" font-size="12" dy=".8em" y="-46.299999952316284" x="597.5">冒泡</text></g></g><g id="minder_node21" display="none"><g id="node_expander20" display="none" style="cursor: pointer;"><path id="kity_path_20582" fill="white" stroke="gray" d="M581.5,-30.5A6,6,0,1,1,569.5,-30.5A6,6,0,1,1,581.5,-30.5"></path><path id="kity_path_20583" fill="none" stroke="gray"></path></g><path id="node_outline21" fill="none" stroke="none" d="M581.5,-39.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text21" fill="black"><text id="kity_text_6909" text-rendering="inherit" font-size="12" dy=".8em" y="-38.299999952316284" x="581.5">插入</text></g></g><g id="minder_node22" display="none"><g id="node_expander18" display="none" style="cursor: pointer;"><path id="kity_path_20576" fill="white" stroke="gray" d="M597.5,-38.5A6,6,0,1,1,585.5,-38.5A6,6,0,1,1,597.5,-38.5"></path><path id="kity_path_20577" fill="none" stroke="gray"></path></g><path id="node_outline19" fill="none" stroke="none" d="M597.5,-47.5h74a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-74a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text19" fill="black"><text id="kity_text_6905" text-rendering="inherit" font-size="12" dy=".8em" y="-46.299999952316284" x="597.5">直接插入排序</text></g></g><g id="minder_node23" display="none"><g id="node_expander19" display="none" style="cursor: pointer;"><path id="kity_path_20579" fill="white" stroke="gray" d="M597.5,-30.5A6,6,0,1,1,585.5,-30.5A6,6,0,1,1,597.5,-30.5"></path><path id="kity_path_20580" fill="none" stroke="gray"></path></g><path id="node_outline20" fill="none" stroke="none" d="M597.5,-39.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text20" fill="black"><text id="kity_text_6907" text-rendering="inherit" font-size="12" dy=".8em" y="-38.299999952316284" x="597.5">希尔排序</text></g></g><g id="minder_node24" display="none"><g id="node_expander25" display="none" style="cursor: pointer;"><path id="kity_path_20597" fill="white" stroke="gray" d="M581.5,-22.5A6,6,0,1,1,569.5,-22.5A6,6,0,1,1,581.5,-22.5"></path><path id="kity_path_20598" fill="none" stroke="gray"></path></g><path id="node_outline26" fill="none" stroke="none" d="M581.5,-31.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text26" fill="black"><text id="kity_text_6920" text-rendering="inherit" font-size="12" dy=".8em" y="-30.299999952316284" x="581.5">选择</text></g></g><g id="minder_node25" display="none"><g id="node_expander21" display="none" style="cursor: pointer;"><path id="kity_path_20585" fill="white" stroke="gray" d="M597.5,-30.5A6,6,0,1,1,585.5,-30.5A6,6,0,1,1,597.5,-30.5"></path><path id="kity_path_20586" fill="none" stroke="gray"></path></g><path id="node_outline22" fill="none" stroke="none" d="M597.5,-39.5h74a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-74a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text22" fill="black"><text id="kity_text_6911" text-rendering="inherit" font-size="12" dy=".8em" y="-38.299999952316284" x="597.5">简单选择排序</text></g></g><g id="minder_node26" display="none"><g id="node_expander24" display="none" style="cursor: pointer;"><path id="kity_path_20594" fill="white" stroke="gray" d="M597.5,-22.5A6,6,0,1,1,585.5,-22.5A6,6,0,1,1,597.5,-22.5"></path><path id="kity_path_20595" fill="none" stroke="gray"></path></g><path id="node_outline25" fill="none" stroke="none" d="M597.5,-31.5h38a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-38a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text25" fill="black"><text id="kity_text_6918" text-rendering="inherit" font-size="12" dy=".8em" y="-30.299999952316284" x="597.5">堆排序</text></g></g><g id="minder_node27" display="none"><g id="node_expander23" display="none" style="cursor: pointer;"><path id="kity_path_20591" fill="white" stroke="gray" d="M613.5,-22.5A6,6,0,1,1,601.5,-22.5A6,6,0,1,1,613.5,-22.5"></path><path id="kity_path_20592" fill="none" stroke="gray"></path></g><path id="node_outline24" fill="none" stroke="none" d="M613.5,-31.5h66a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-66a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text24" fill="black"><text id="kity_text_6916" text-rendering="inherit" font-size="12" dy=".8em" y="-30.299999952316284" x="613.5">时间复杂度?</text></g></g><g id="minder_node28" display="none"><g id="node_expander22" display="none" style="cursor: pointer;"><path id="kity_path_20588" fill="white" stroke="gray" d="M629.5,-22.5A6,6,0,1,1,617.5,-22.5A6,6,0,1,1,629.5,-22.5"></path><path id="kity_path_20589" fill="none" stroke="gray"></path></g><path id="node_outline23" fill="none" stroke="none" d="M629.5,-40.5h580a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-580a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text23" fill="black"><text id="kity_text_6913" text-rendering="inherit" font-size="12" dy=".8em" y="-39.299999952316284" x="629.5">最优最差平均时间复杂度都是O(lgN)，适合处理相对有序的数据，快排适合处理相对无序的数据，不稳定排序</text><text id="kity_text_6914" text-rendering="inherit" font-size="12" dy=".8em" y="-21.299999952316284" x="629.5">，空间复杂度O(1)</text></g></g><g id="minder_node29" display="none"><g id="node_expander26" display="none" style="cursor: pointer;"><path id="kity_path_20600" fill="white" stroke="gray" d="M581.5,-14.5A6,6,0,1,1,569.5,-14.5A6,6,0,1,1,581.5,-14.5"></path><path id="kity_path_20601" fill="none" stroke="gray"></path></g><path id="node_outline27" fill="none" stroke="none" d="M581.5,-23.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text27" fill="black"><text id="kity_text_6922" text-rendering="inherit" font-size="12" dy=".8em" y="-22.299999952316284" x="581.5">归并</text></g></g><g id="minder_node30" display="none"><g id="node_expander27" display="none" style="cursor: pointer;"><path id="kity_path_20603" fill="white" stroke="gray" d="M581.5,-6.5A6,6,0,1,1,569.5,-6.5A6,6,0,1,1,581.5,-6.5"></path><path id="kity_path_20604" fill="none" stroke="gray"></path></g><path id="node_outline28" fill="none" stroke="none" d="M581.5,-15.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text28" fill="black"><text id="kity_text_6924" text-rendering="inherit" font-size="12" dy=".8em" y="-14.299999952316284" x="581.5">基数</text></g></g><g id="minder_node31" display="none"><g id="node_expander30" display="none" style="cursor: pointer;"><path id="kity_path_20612" fill="white" stroke="gray" d="M581.5,1.5A6,6,0,1,1,569.5,1.5A6,6,0,1,1,581.5,1.5"></path><path id="kity_path_20613" fill="none" stroke="gray"></path></g><path id="node_outline31" fill="none" stroke="none" d="M581.5,-7.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text31" fill="black"><text id="kity_text_6930" text-rendering="inherit" font-size="12" dy=".8em" y="-6.299999952316284" x="581.5">二分查找</text></g></g><g id="minder_node32" display="none"><g id="node_expander29" display="none" style="cursor: pointer;"><path id="kity_path_20609" fill="white" stroke="gray" d="M597.5,1.5A6,6,0,1,1,585.5,1.5A6,6,0,1,1,597.5,1.5"></path><path id="kity_path_20610" fill="none" stroke="gray"></path></g><path id="node_outline30" fill="none" stroke="none" d="M597.5,-7.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text30" fill="black"><text id="kity_text_6928" text-rendering="inherit" font-size="12" dy=".8em" y="-6.299999952316284" x="597.5">二分查找的时间复杂度</text></g></g><g id="minder_node33" display="none"><g id="node_expander28" display="none" style="cursor: pointer;"><path id="kity_path_20606" fill="white" stroke="gray" d="M613.5,1.5A6,6,0,1,1,601.5,1.5A6,6,0,1,1,613.5,1.5"></path><path id="kity_path_20607" fill="none" stroke="gray"></path></g><path id="node_outline29" fill="none" stroke="none" d="M613.5,-7.5h92a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-92a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text29" fill="black"><text id="kity_text_6926" text-rendering="inherit" font-size="12" dy=".8em" y="-6.299999952316284" x="613.5">O(log2n)- 2为底</text></g></g><g id="minder_node34" display="none"><g id="node_expander32" display="none" style="cursor: pointer;"><path id="kity_path_20618" fill="white" stroke="gray" d="M581.5,9.5A6,6,0,1,1,569.5,9.5A6,6,0,1,1,581.5,9.5"></path><path id="kity_path_20619" fill="none" stroke="gray"></path></g><path id="node_outline33" fill="none" stroke="none" d="M581.5,0.5h86a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-86a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text33" fill="black"><text id="kity_text_6934" text-rendering="inherit" font-size="12" dy=".8em" y="1.7000000476837158" x="581.5">排序时间复杂度</text></g></g><g id="minder_node35" display="none"><g id="node_expander31" display="none" style="cursor: pointer;"><path id="kity_path_20615" fill="white" stroke="gray" d="M597.5,9.5A6,6,0,1,1,585.5,9.5A6,6,0,1,1,597.5,9.5"></path><path id="kity_path_20616" fill="none" stroke="gray"></path></g><path id="node_outline32" fill="none" stroke="none" d="M522.5,-125.5h200a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text32" fill="black"><text id="kity_text_6932" text-rendering="inherit" font-size="12" dy=".8em" y="1.7000000476837158" x="597.5">分支主题</text></g><image id="kity_image_17009" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210503231134.png" x="522.5" y="-122.5" width="200" height="121"></image></g><g id="minder_node36" display="none"><g id="node_expander33" display="none" style="cursor: pointer;"><path id="kity_path_20621" fill="white" stroke="gray" d="M581.5,17.5A6,6,0,1,1,569.5,17.5A6,6,0,1,1,581.5,17.5"></path><path id="kity_path_20622" fill="none" stroke="gray"></path></g><path id="node_outline34" fill="none" stroke="none" d="M581.5,8.5h170a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-170a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text34" fill="black"><text id="kity_text_6936" text-rendering="inherit" font-size="12" dy=".8em" y="9.700000047683716" x="581.5">什么时候用快排什么时候用堆排</text></g></g><g id="minder_node37" display="none"><g id="node_expander41" display="none" style="cursor: pointer;"><path id="kity_path_20645" fill="white" stroke="gray" d="M565.5,25.5A6,6,0,1,1,553.5,25.5A6,6,0,1,1,565.5,25.5"></path><path id="kity_path_20646" fill="none" stroke="gray"></path></g><path id="node_outline42" fill="none" stroke="none" d="M565.5,16.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text42" fill="black"><text id="kity_text_6952" text-rendering="inherit" font-size="12" dy=".8em" y="17.700000047683716" x="565.5">其他算法</text></g></g><g id="minder_node38" display="none"><g id="node_expander35" display="none" style="cursor: pointer;"><path id="kity_path_20627" fill="white" stroke="gray" d="M581.5,-6.5A6,6,0,1,1,569.5,-6.5A6,6,0,1,1,581.5,-6.5"></path><path id="kity_path_20628" fill="none" stroke="gray"></path></g><path id="node_outline36" fill="none" stroke="none" d="M581.5,-15.5h48a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-48a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text36" fill="black"><text id="kity_text_6940" text-rendering="inherit" font-size="12" dy=".8em" y="-14.299999952316284" x="581.5">动态规划</text></g></g><g id="minder_node39" display="none"><g id="node_expander37" display="none" style="cursor: pointer;"><path id="kity_path_20633" fill="white" stroke="gray" d="M581.5,1.5A6,6,0,1,1,569.5,1.5A6,6,0,1,1,581.5,1.5"></path><path id="kity_path_20634" fill="none" stroke="gray"></path></g><path id="node_outline38" fill="none" stroke="none" d="M581.5,-7.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text38" fill="black"><text id="kity_text_6944" text-rendering="inherit" font-size="12" dy=".8em" y="-6.299999952316284" x="581.5">贪心</text></g></g><g id="minder_node40" display="none"><g id="node_expander36" display="none" style="cursor: pointer;"><path id="kity_path_20630" fill="white" stroke="gray" d="M597.5,1.5A6,6,0,1,1,585.5,1.5A6,6,0,1,1,597.5,1.5"></path><path id="kity_path_20631" fill="none" stroke="gray"></path></g><path id="node_outline37" fill="none" stroke="none" d="M597.5,-7.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text37" fill="black"><text id="kity_text_6942" text-rendering="inherit" font-size="12" dy=".8em" y="-6.299999952316284" x="597.5">讲讲贪心算法；</text></g></g><g id="minder_node41" display="none"><g id="node_expander38" display="none" style="cursor: pointer;"><path id="kity_path_20636" fill="white" stroke="gray" d="M581.5,9.5A6,6,0,1,1,569.5,9.5A6,6,0,1,1,581.5,9.5"></path><path id="kity_path_20637" fill="none" stroke="gray"></path></g><path id="node_outline39" fill="none" stroke="none" d="M581.5,0.5h24a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-24a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text39" fill="black"><text id="kity_text_6946" text-rendering="inherit" font-size="12" dy=".8em" y="1.7000000476837158" x="581.5">回溯</text></g></g><g id="minder_node42" display="none"><g id="node_expander39" display="none" style="cursor: pointer;"><path id="kity_path_20639" fill="white" stroke="gray" d="M581.5,17.5A6,6,0,1,1,569.5,17.5A6,6,0,1,1,581.5,17.5"></path><path id="kity_path_20640" fill="none" stroke="gray"></path></g><path id="node_outline40" fill="none" stroke="none" d="M581.5,8.5h18a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-18a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text40" fill="black"><text id="kity_text_6948" text-rendering="inherit" font-size="12" dy=".8em" y="9.700000047683716" x="581.5">dfs</text></g></g><g id="minder_node43" display="none"><g id="node_expander40" display="none" style="cursor: pointer;"><path id="kity_path_20642" fill="white" stroke="gray" d="M581.5,25.5A6,6,0,1,1,569.5,25.5A6,6,0,1,1,581.5,25.5"></path><path id="kity_path_20643" fill="none" stroke="gray"></path></g><path id="node_outline41" fill="none" stroke="none" d="M581.5,16.5h18a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-18a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text41" fill="black"><text id="kity_text_6950" text-rendering="inherit" font-size="12" dy=".8em" y="17.700000047683716" x="581.5">bfs</text></g></g><g id="minder_node44" display="none"><g id="node_expander43" display="none" style="cursor: pointer;"><path id="kity_path_20651" fill="white" stroke="gray" d="M565.5,33.5A6,6,0,1,1,553.5,33.5A6,6,0,1,1,565.5,33.5"></path><path id="kity_path_20652" fill="none" stroke="gray"></path></g><path id="node_outline44" fill="none" stroke="none" d="M565.5,24.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text44" fill="black"><text id="kity_text_6956" text-rendering="inherit" font-size="12" dy=".8em" y="25.700000047683716" x="565.5">leetcode</text></g></g><g id="minder_node45" display="none"><g id="node_expander42" display="none" style="cursor: pointer;"><path id="kity_path_20648" fill="white" stroke="gray" d="M581.5,33.5A6,6,0,1,1,569.5,33.5A6,6,0,1,1,581.5,33.5"></path><path id="kity_path_20649" fill="none" stroke="gray"></path></g><path id="node_outline43" fill="none" stroke="none" d="M581.5,24.5h53a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-53a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text43" fill="black"><text id="kity_text_6954" text-rendering="inherit" font-size="12" dy=".8em" y="25.700000047683716" x="581.5">剑指offer</text></g></g><g id="minder_node46"><g id="node_expander69" style="cursor: pointer;"><path id="kity_path_20729" fill="white" stroke="gray" d="M397.5,75.5A6,6,0,1,1,385.5,75.5A6,6,0,1,1,397.5,75.5"></path><path id="kity_path_20730" fill="none" stroke="gray" d="M387,75.5L396,75.5M391.5,71L391.5,80"></path></g><path id="node_outline70" fill="rgb(239, 238, 246)" stroke="rgb(123, 115, 191)" d="M401.5,62.5h103a3,3,0,0,1,3,3v20a3,3,0,0,1,-3,3h-103a3,3,0,0,1,-3,-3v-20a3,3,0,0,1,3,-3z" stroke-width="1"></path><g id="node_text70" fill="black"><text id="kity_text_7020" text-rendering="inherit" font-size="14" dy=".8em" y="66.40000009536743" x="418.5">1.操作系统</text></g></g><g id="minder_node47" display="none"><g id="node_expander66" display="none" style="cursor: pointer;"><path id="kity_path_20720" fill="white" stroke="gray" d="M523.5,59.5A6,6,0,1,1,511.5,59.5A6,6,0,1,1,523.5,59.5"></path><path id="kity_path_20721" fill="none" stroke="gray"></path></g><path id="node_outline67" fill="none" stroke="none" d="M523.5,50.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text67" fill="black"><text id="kity_text_7014" text-rendering="inherit" font-size="12" dy=".8em" y="51.700000047683716" x="523.5">基础</text></g></g><g id="minder_node48" display="none"><g id="node_expander46" display="none" style="cursor: pointer;"><path id="kity_path_20660" fill="white" stroke="gray" d="M539.5,-28.5A6,6,0,1,1,527.5,-28.5A6,6,0,1,1,539.5,-28.5"></path><path id="kity_path_20661" fill="none" stroke="gray"></path></g><path id="node_outline47" fill="none" stroke="none" d="M539.5,-37.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text47" fill="black"><text id="kity_text_6967" text-rendering="inherit" font-size="12" dy=".8em" y="-36.299999952316284" x="539.5">进程 协程&#xa0; 线程</text></g></g><g id="minder_node49" display="none"><g id="node_expander45" display="none" style="cursor: pointer;"><path id="kity_path_20657" fill="white" stroke="gray" d="M555.5,-28.5A6,6,0,1,1,543.5,-28.5A6,6,0,1,1,555.5,-28.5"></path><path id="kity_path_20658" fill="none" stroke="gray"></path></g><path id="node_outline46" fill="none" stroke="none" d="M555.5,-82.5h1093a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1093a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text46" fill="black"><text id="kity_text_6960" text-rendering="inherit" font-size="12" dy=".8em" y="-81.29999995231628" x="555.5">1.进程，线程</text><text id="kity_text_6961" text-rendering="inherit" font-size="12" dy=".8em" y="-63.299999952316284" x="555.5">2.协程：</text><text id="kity_text_6962" text-rendering="inherit" font-size="12" dy=".8em" y="-45.299999952316284" x="555.5">轻量级线程；协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。重入的时候就相当于进入上一次调用的状态；</text><text id="kity_text_6963" text-rendering="inherit" font-size="12" dy=".8em" y="-27.299999952316284" x="555.5">协程在执行过程中不会由操作系统直接操作，而是由编译器决定，</text><text id="kity_text_6964" text-rendering="inherit" font-size="12" dy=".8em" y="-9.299999952316284" x="555.5">优点：无线程上下文切换的开销，无原子锁定及同步的开销，一个cpu可以开上万的协程，适合高并发和IO密集型的任务(网络调用)；</text><text id="kity_text_6965" text-rendering="inherit" font-size="12" dy=".8em" y="8.700000047683716" x="555.5">缺点：无法利用多核资源，协程的本质是个单线程，进行阻塞操作会阻塞掉整个程序；</text></g></g><g id="minder_node50" display="none"><g id="node_expander48" display="none" style="cursor: pointer;"><path id="kity_path_20666" fill="white" stroke="gray" d="M539.5,-20.5A6,6,0,1,1,527.5,-20.5A6,6,0,1,1,539.5,-20.5"></path><path id="kity_path_20667" fill="none" stroke="gray"></path></g><path id="node_outline49" fill="none" stroke="none" d="M539.5,-29.5h126a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-126a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text49" fill="black"><text id="kity_text_6972" text-rendering="inherit" font-size="12" dy=".8em" y="-28.299999952316284" x="539.5">用户态 和内核态是什么</text></g></g><g id="minder_node51" display="none"><g id="node_expander47" display="none" style="cursor: pointer;"><path id="kity_path_20663" fill="white" stroke="gray" d="M555.5,-20.5A6,6,0,1,1,543.5,-20.5A6,6,0,1,1,555.5,-20.5"></path><path id="kity_path_20664" fill="none" stroke="gray"></path></g><path id="node_outline48" fill="none" stroke="none" d="M555.5,-38.5h1162a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1162a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text48" fill="black"><text id="kity_text_6969" text-rendering="inherit" font-size="12" dy=".8em" y="-37.299999952316284" x="555.5">1.处于内核态的 CPU 可以访问任意的数据，包括外围设备，比如网卡、硬盘等，处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况，一般处于特权级 0 的状态我们称之为内核态。</text><text id="kity_text_6970" text-rendering="inherit" font-size="12" dy=".8em" y="-19.299999952316284" x="555.5">2.处于用户态的 CPU 只能受限的访问内存，并且不允许访问外围设备，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。</text></g></g><g id="minder_node52" display="none"><g id="node_expander50" display="none" style="cursor: pointer;"><path id="kity_path_20672" fill="white" stroke="gray" d="M539.5,-12.5A6,6,0,1,1,527.5,-12.5A6,6,0,1,1,539.5,-12.5"></path><path id="kity_path_20673" fill="none" stroke="gray"></path></g><path id="node_outline51" fill="none" stroke="none" d="M539.5,-21.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text51" fill="black"><text id="kity_text_6976" text-rendering="inherit" font-size="12" dy=".8em" y="-20.299999952316284" x="539.5">为什么需要用户态和内核态</text></g></g><g id="minder_node53" display="none"><g id="node_expander49" display="none" style="cursor: pointer;"><path id="kity_path_20669" fill="white" stroke="gray" d="M555.5,-12.5A6,6,0,1,1,543.5,-12.5A6,6,0,1,1,555.5,-12.5"></path><path id="kity_path_20670" fill="none" stroke="gray"></path></g><path id="node_outline50" fill="none" stroke="none" d="M555.5,-21.5h898a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-898a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text50" fill="black"><text id="kity_text_6974" text-rendering="inherit" font-size="12" dy=".8em" y="-20.299999952316284" x="555.5">1.这个主要是访问能力的限制的考量，计算机中有一些比较危险的操作，比如设置时钟、内存清理，这些都需要在内核态下完成，如果随意进行这些操作，系统容易崩溃。</text></g></g><g id="minder_node54" display="none"><g id="node_expander51" display="none" style="cursor: pointer;"><path id="kity_path_20675" fill="white" stroke="gray" d="M539.5,-4.5A6,6,0,1,1,527.5,-4.5A6,6,0,1,1,539.5,-4.5"></path><path id="kity_path_20676" fill="none" stroke="gray"></path></g><path id="node_outline52" fill="none" stroke="none" d="M539.5,-13.5h206a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-206a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text52" fill="black"><text id="kity_text_6978" text-rendering="inherit" font-size="12" dy=".8em" y="-12.299999952316284" x="539.5">用户态切换到内核态哪些方式可以实现</text></g></g><g id="minder_node55" display="none"><g id="node_expander53" display="none" style="cursor: pointer;"><path id="kity_path_20681" fill="white" stroke="gray" d="M539.5,3.5A6,6,0,1,1,527.5,3.5A6,6,0,1,1,539.5,3.5"></path><path id="kity_path_20682" fill="none" stroke="gray"></path></g><path id="node_outline54" fill="none" stroke="none" d="M539.5,-5.5h146a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-146a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text54" fill="black"><text id="kity_text_6982" text-rendering="inherit" font-size="12" dy=".8em" y="-4.299999952316284" x="539.5">有哪些方式可以进入内核态</text></g></g><g id="minder_node56" display="none"><g id="node_expander52" display="none" style="cursor: pointer;"><path id="kity_path_20678" fill="white" stroke="gray" d="M555.5,3.5A6,6,0,1,1,543.5,3.5A6,6,0,1,1,555.5,3.5"></path><path id="kity_path_20679" fill="none" stroke="gray"></path></g><path id="node_outline53" fill="none" stroke="none" d="M555.5,-5.5h203a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-203a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text53" fill="black"><text id="kity_text_6980" text-rendering="inherit" font-size="12" dy=".8em" y="-4.299999952316284" x="555.5">1.系统调用，各种异常，各种设备中断</text></g></g><g id="minder_node57" display="none"><g id="node_expander55" display="none" style="cursor: pointer;"><path id="kity_path_20687" fill="white" stroke="gray" d="M539.5,11.5A6,6,0,1,1,527.5,11.5A6,6,0,1,1,539.5,11.5"></path><path id="kity_path_20688" fill="none" stroke="gray"></path></g><path id="node_outline56" fill="none" stroke="none" d="M539.5,2.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text56" fill="black"><text id="kity_text_6988" text-rendering="inherit" font-size="12" dy=".8em" y="3.700000047683716" x="539.5">知道进程调度算法有哪些吗</text></g></g><g id="minder_node58" display="none"><g id="node_expander54" display="none" style="cursor: pointer;"><path id="kity_path_20684" fill="white" stroke="gray" d="M555.5,11.5A6,6,0,1,1,543.5,11.5A6,6,0,1,1,555.5,11.5"></path><path id="kity_path_20685" fill="none" stroke="gray"></path></g><path id="node_outline55" fill="none" stroke="none" d="M555.5,-15.5h906a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-906a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text55" fill="black"><text id="kity_text_6984" text-rendering="inherit" font-size="12" dy=".8em" y="-14.299999952316284" x="555.5">1.先来先服务 优点：公平&#xa0; 缺点：利于长进程，不利于短进程</text><text id="kity_text_6985" text-rendering="inherit" font-size="12" dy=".8em" y="3.700000047683716" x="555.5">2.时间片轮转算法；每个进程被分配一个时间片，是该进程允许运行的时间。到了就暂停等待下一次获取时间片。优点：简单 平均响应时间短。 缺点：不利于处理紧急作业</text><text id="kity_text_6986" text-rendering="inherit" font-size="12" dy=".8em" y="21.700000047683716" x="555.5">3.最短作业优先；预计执行时间短的进程优先处理；优点：提高系统的吞吐量 缺点：对长进程非常不利</text></g></g><g id="minder_node59" display="none"><g id="node_expander56" display="none" style="cursor: pointer;"><path id="kity_path_20690" fill="white" stroke="gray" d="M539.5,19.5A6,6,0,1,1,527.5,19.5A6,6,0,1,1,539.5,19.5"></path><path id="kity_path_20691" fill="none" stroke="gray"></path></g><path id="node_outline57" fill="none" stroke="none" d="M539.5,10.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text57" fill="black"><text id="kity_text_6990" text-rendering="inherit" font-size="12" dy=".8em" y="11.700000047683716" x="539.5">逻辑地址和物理地址知道吗</text></g></g><g id="minder_node60" display="none"><g id="node_expander57" display="none" style="cursor: pointer;"><path id="kity_path_20693" fill="white" stroke="gray" d="M539.5,27.5A6,6,0,1,1,527.5,27.5A6,6,0,1,1,539.5,27.5"></path><path id="kity_path_20694" fill="none" stroke="gray"></path></g><path id="node_outline58" fill="none" stroke="none" d="M539.5,18.5h172a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-172a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text58" fill="black"><text id="kity_text_6992" text-rendering="inherit" font-size="12" dy=".8em" y="19.700000047683716" x="539.5">64位和32位有什么区别了解过吗</text></g></g><g id="minder_node61" display="none"><g id="node_expander58" display="none" style="cursor: pointer;"><path id="kity_path_20696" fill="white" stroke="gray" d="M539.5,35.5A6,6,0,1,1,527.5,35.5A6,6,0,1,1,539.5,35.5"></path><path id="kity_path_20697" fill="none" stroke="gray"></path></g><path id="node_outline59" fill="none" stroke="none" d="M539.5,17.5h181a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-181a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text59" fill="black"><text id="kity_text_6994" text-rendering="inherit" font-size="12" dy=".8em" y="18.700000047683716" x="539.5">操作系统的内存管理方式有哪些？</text><text id="kity_text_6995" text-rendering="inherit" font-size="12" dy=".8em" y="36.700000047683716" x="539.5">内存管理、虚拟内存？</text></g></g><g id="minder_node62" display="none"><g id="node_expander61" display="none" style="cursor: pointer;"><path id="kity_path_20705" fill="white" stroke="gray" d="M539.5,43.5A6,6,0,1,1,527.5,43.5A6,6,0,1,1,539.5,43.5"></path><path id="kity_path_20706" fill="none" stroke="gray"></path></g><path id="node_outline62" fill="none" stroke="none" d="M539.5,34.5h86a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-86a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text62" fill="black"><text id="kity_text_7004" text-rendering="inherit" font-size="12" dy=".8em" y="35.700000047683716" x="539.5">进程间通讯方式</text></g></g><g id="minder_node63" display="none"><g id="node_expander60" display="none" style="cursor: pointer;"><path id="kity_path_20702" fill="white" stroke="gray" d="M555.5,43.5A6,6,0,1,1,543.5,43.5A6,6,0,1,1,555.5,43.5"></path><path id="kity_path_20703" fill="none" stroke="gray"></path></g><path id="node_outline61" fill="none" stroke="none" d="M555.5,16.5h370a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-370a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text61" fill="black"><text id="kity_text_7000" text-rendering="inherit" font-size="12" dy=".8em" y="17.700000047683716" x="555.5">1.管道； 一端读，一端写； 缺点：只能单向通信， 只能亲缘关系通信</text><text id="kity_text_7001" text-rendering="inherit" font-size="12" dy=".8em" y="35.700000047683716" x="555.5">2.共享内存</text><text id="kity_text_7002" text-rendering="inherit" font-size="12" dy=".8em" y="53.700000047683716" x="555.5">3.信号</text></g></g><g id="minder_node64" display="none"><g id="node_expander59" display="none" style="cursor: pointer;"><path id="kity_path_20699" fill="white" stroke="gray" d="M571.5,43.5A6,6,0,1,1,559.5,43.5A6,6,0,1,1,571.5,43.5"></path><path id="kity_path_20700" fill="none" stroke="gray"></path></g><path id="node_outline60" fill="none" stroke="none" d="M571.5,25.5h368a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-368a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text60" fill="black"><text id="kity_text_6997" text-rendering="inherit" font-size="12" dy=".8em" y="26.700000047683716" x="571.5">https://blog.csdn.net/violet_echo_0908/article/details/51201278</text><text id="kity_text_6998" text-rendering="inherit" font-size="12" dy=".8em" y="44.700000047683716" x="571.5">https://mp.weixin.qq.com/s/mblyh6XrLj1bCwL0Evs-Vg</text></g></g><g id="minder_node65" display="none"><g id="node_expander63" display="none" style="cursor: pointer;"><path id="kity_path_20711" fill="white" stroke="gray" d="M539.5,51.5A6,6,0,1,1,527.5,51.5A6,6,0,1,1,539.5,51.5"></path><path id="kity_path_20712" fill="none" stroke="gray"></path></g><path id="node_outline64" fill="none" stroke="none" d="M539.5,42.5h72a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-72a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text64" fill="black"><text id="kity_text_7008" text-rendering="inherit" font-size="12" dy=".8em" y="43.700000047683716" x="539.5">哪个比较快？</text></g></g><g id="minder_node66" display="none"><g id="node_expander62" display="none" style="cursor: pointer;"><path id="kity_path_20708" fill="white" stroke="gray" d="M555.5,51.5A6,6,0,1,1,543.5,51.5A6,6,0,1,1,555.5,51.5"></path><path id="kity_path_20709" fill="none" stroke="gray"></path></g><path id="node_outline63" fill="none" stroke="none" d="M555.5,42.5h454a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-454a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text63" fill="black"><text id="kity_text_7006" text-rendering="inherit" font-size="12" dy=".8em" y="43.700000047683716" x="555.5">1.共享内存，减少了数据从内核态到用户态的拷贝，直接将内核空间和用户空间映射。</text></g></g><g id="minder_node67" display="none"><g id="node_expander65" display="none" style="cursor: pointer;"><path id="kity_path_20717" fill="white" stroke="gray" d="M539.5,59.5A6,6,0,1,1,527.5,59.5A6,6,0,1,1,539.5,59.5"></path><path id="kity_path_20718" fill="none" stroke="gray"></path></g><path id="node_outline66" fill="none" stroke="none" d="M539.5,50.5h86a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-86a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text66" fill="black"><text id="kity_text_7012" text-rendering="inherit" font-size="12" dy=".8em" y="51.700000047683716" x="539.5">mmap内存映射</text></g></g><g id="minder_node68" display="none"><g id="node_expander64" display="none" style="cursor: pointer;"><path id="kity_path_20714" fill="white" stroke="gray" d="M555.5,59.5A6,6,0,1,1,543.5,59.5A6,6,0,1,1,555.5,59.5"></path><path id="kity_path_20715" fill="none" stroke="gray"></path></g><path id="node_outline65" fill="none" stroke="none" d="M555.5,50.5h1541a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1541a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text65" fill="black"><text id="kity_text_7010" text-rendering="inherit" font-size="12" dy=".8em" y="51.700000047683716" x="555.5">mmap的优势在于通过把文件的某一块内容映射到用户空间上，用户可以直接向内核缓冲池读写这一块内容，这样一来就少了内核与用户空间的来回拷贝所以通常更快。但 mmap方式只适用于更新、读写一块固定大小的文件区域而不能做像诸如不断的写内容进入文件导到文件增长这类的事。</text></g></g><g id="minder_node69" display="none"><g id="node_expander67" display="none" style="cursor: pointer;"><path id="kity_path_20723" fill="white" stroke="gray" d="M523.5,67.5A6,6,0,1,1,511.5,67.5A6,6,0,1,1,523.5,67.5"></path><path id="kity_path_20724" fill="none" stroke="gray"></path></g><path id="node_outline68" fill="none" stroke="none" d="M523.5,58.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text68" fill="black"><text id="kity_text_7016" text-rendering="inherit" font-size="12" dy=".8em" y="59.700000047683716" x="523.5">场景</text></g></g><g id="minder_node70" display="none"><g id="node_expander68" display="none" style="cursor: pointer;"><path id="kity_path_20726" fill="white" stroke="gray" d="M523.5,75.5A6,6,0,1,1,511.5,75.5A6,6,0,1,1,523.5,75.5"></path><path id="kity_path_20727" fill="none" stroke="gray"></path></g><path id="node_outline69" fill="none" stroke="none" d="M523.5,66.5h24a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-24a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text69" fill="black"><text id="kity_text_7018" text-rendering="inherit" font-size="12" dy=".8em" y="67.70000004768372" x="523.5">参考</text></g></g><g id="minder_node71"><g id="node_expander257" style="cursor: pointer;"><path id="kity_path_21293" fill="white" stroke="gray" d="M397.5,117.5A6,6,0,1,1,385.5,117.5A6,6,0,1,1,397.5,117.5"></path><path id="kity_path_21294" fill="none" stroke="gray" d="M387,117.5L396,117.5M391.5,113L391.5,122"></path></g><path id="node_outline258" fill="rgb(239, 238, 246)" stroke="rgb(123, 115, 191)" d="M401.5,104.5h117a3,3,0,0,1,3,3v20a3,3,0,0,1,-3,3h-117a3,3,0,0,1,-3,-3v-20a3,3,0,0,1,3,-3z" stroke-width="1"></path><g id="node_text258" fill="black"><text id="kity_text_7579" text-rendering="inherit" font-size="14" dy=".8em" y="108.40000009536743" x="418.5">2.计算机网络</text></g></g><g id="minder_node72" display="none"><g id="node_expander110" display="none" style="cursor: pointer;"><path id="kity_path_20852" fill="white" stroke="gray" d="M537.5,45.5A6,6,0,1,1,525.5,45.5A6,6,0,1,1,537.5,45.5"></path><path id="kity_path_20853" fill="none" stroke="gray"></path></g><path id="node_outline111" fill="none" stroke="none" d="M537.5,36.5h64a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-64a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text111" fill="black"><text id="kity_text_7154" text-rendering="inherit" font-size="12" dy=".8em" y="37.700000047683716" x="537.5">http&amp;https</text></g></g><g id="minder_node73" display="none"><g id="node_expander71" display="none" style="cursor: pointer;"><path id="kity_path_20735" fill="white" stroke="gray" d="M553.5,-74.5A6,6,0,1,1,541.5,-74.5A6,6,0,1,1,553.5,-74.5"></path><path id="kity_path_20736" fill="none" stroke="gray"></path></g><path id="node_outline72" fill="none" stroke="none" d="M553.5,-83.5h60a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-60a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text72" fill="black"><text id="kity_text_7024" text-rendering="inherit" font-size="12" dy=".8em" y="-82.29999995231628" x="553.5">七层协议图</text></g></g><g id="minder_node74" display="none"><g id="node_expander70" display="none" style="cursor: pointer;"><path id="kity_path_20732" fill="white" stroke="gray" d="M569.5,-74.5A6,6,0,1,1,557.5,-74.5A6,6,0,1,1,569.5,-74.5"></path><path id="kity_path_20733" fill="none" stroke="gray"></path></g><path id="node_outline71" fill="none" stroke="none" d="M523.5,-288.5h141a5,5,0,0,1,5,5v213a5,5,0,0,1,-5,5h-141a5,5,0,0,1,-5,-5v-213a5,5,0,0,1,5,-5z"></path><g id="node_text71" fill="black"><text id="kity_text_7022" text-rendering="inherit" font-size="12" dy=".8em" y="-82.29999995231628" x="569.5">七层协议</text></g><image id="kity_image_17010" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210429205540.png" x="523.5" y="-285.5" width="141" height="200"></image></g><g id="minder_node75" display="none"><g id="node_expander73" display="none" style="cursor: pointer;"><path id="kity_path_20741" fill="white" stroke="gray" d="M553.5,-66.5A6,6,0,1,1,541.5,-66.5A6,6,0,1,1,553.5,-66.5"></path><path id="kity_path_20742" fill="none" stroke="gray"></path></g><path id="node_outline74" fill="none" stroke="none" d="M553.5,-75.5h127a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-127a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text74" fill="black"><text id="kity_text_7033" text-rendering="inherit" font-size="12" dy=".8em" y="-74.29999995231628" x="553.5">说说http和https的区别</text></g></g><g id="minder_node76" display="none"><g id="node_expander72" display="none" style="cursor: pointer;"><path id="kity_path_20738" fill="white" stroke="gray" d="M569.5,-66.5A6,6,0,1,1,557.5,-66.5A6,6,0,1,1,569.5,-66.5"></path><path id="kity_path_20739" fill="none" stroke="gray"></path></g><path id="node_outline73" fill="none" stroke="none" d="M569.5,-120.5h1157a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1157a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text73" fill="black"><text id="kity_text_7026" text-rendering="inherit" font-size="12" dy=".8em" y="-119.29999995231628" x="569.5">打开浏览器</text><text id="kity_text_7027" text-rendering="inherit" font-size="12" dy=".8em" y="-101.29999995231628" x="569.5">1.http&#xa0; 默认端口80， 运行在TCP协议之上 ， 地址栏上的协议是以 http:// 开头， 未经安全加密的协议，它的传输过程容易被监听、窃取、伪造。</text><text id="kity_text_7028" text-rendering="inherit" font-size="12" dy=".8em" y="-83.29999995231628" x="569.5">2.https 默认端口443，运行在SSL协议之上，SSL运行在TCP协议之上， 地址栏上的协议是以 https:// 开头&#xa0; HTTPS 是安全的协议，它通过 密钥交换算法 - 签名算法 - 对称加密算法 - 摘要算法 能够解决https的安全问题&#xa0; </text><text id="kity_text_7029" text-rendering="inherit" font-size="12" dy=".8em" y="-65.29999995231628" x="569.5">本质上 https是在http上加了ssl，安全性是ssl做的</text><text id="kity_text_7030" text-rendering="inherit" font-size="12" dy=".8em" y="-47.299999952316284" x="569.5">3.由于加密处理，https资源消耗更多 https</text><text id="kity_text_7031" text-rendering="inherit" font-size="12" dy=".8em" y="-29.299999952316284" x="569.5">4.http是超文本传输协议，应用层，信息是明文传输，https则是具有安全性的ssl加密传输协议。</text></g></g><g id="minder_node77" display="none"><g id="node_expander75" display="none" style="cursor: pointer;"><path id="kity_path_20747" fill="white" stroke="gray" d="M553.5,-58.5A6,6,0,1,1,541.5,-58.5A6,6,0,1,1,553.5,-58.5"></path><path id="kity_path_20748" fill="none" stroke="gray"></path></g><path id="node_outline76" fill="none" stroke="none" d="M553.5,-67.5h108a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-108a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text76" fill="black"><text id="kity_text_7045" text-rendering="inherit" font-size="12" dy=".8em" y="-66.29999995231628" x="553.5">http的优点和缺点？</text></g></g><g id="minder_node78" display="none"><g id="node_expander74" display="none" style="cursor: pointer;"><path id="kity_path_20744" fill="white" stroke="gray" d="M569.5,-58.5A6,6,0,1,1,557.5,-58.5A6,6,0,1,1,569.5,-58.5"></path><path id="kity_path_20745" fill="none" stroke="gray"></path></g><path id="node_outline75" fill="none" stroke="none" d="M569.5,-139.5h801a5,5,0,0,1,5,5v152a5,5,0,0,1,-5,5h-801a5,5,0,0,1,-5,-5v-152a5,5,0,0,1,5,-5z"></path><g id="node_text75" fill="black"><text id="kity_text_7035" text-rendering="inherit" font-size="12" dy=".8em" y="-138.29999995231628" x="569.5">特点</text><text id="kity_text_7036" text-rendering="inherit" font-size="12" dy=".8em" y="-120.29999995231628" x="569.5">1.灵活可扩展，只规定了基本格式，比如空格分隔单词，传输形式的多样性，传输文本，图片、视频</text><text id="kity_text_7037" text-rendering="inherit" font-size="12" dy=".8em" y="-102.29999995231628" x="569.5">2.可靠传，HTTP 基于 TCP/IP，TCP是可靠的</text><text id="kity_text_7038" text-rendering="inherit" font-size="12" dy=".8em" y="-84.29999995231628" x="569.5">3.请求-应答， 一发一收、有来有回 短连接</text><text id="kity_text_7039" text-rendering="inherit" font-size="12" dy=".8em" y="-66.29999995231628" x="569.5">4.无状态，每次 http 请求都是独立、无关的，默认不需要保留通信过程的上下文状态信息。</text><text id="kity_text_7040" text-rendering="inherit" font-size="12" dy=".8em" y="-48.299999952316284" x="569.5">缺点：</text><text id="kity_text_7041" text-rendering="inherit" font-size="12" dy=".8em" y="-30.299999952316284" x="569.5">1.需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，无状态就是 http 的缺点。不需要保存连接上下文信息 无状态就是优点</text><text id="kity_text_7042" text-rendering="inherit" font-size="12" dy=".8em" y="-12.299999952316284" x="569.5">2.明文传输。报文头部是文本形式。</text><text id="kity_text_7043" text-rendering="inherit" font-size="12" dy=".8em" y="5.700000047683716" x="569.5">3.队头阻塞问题，http开启长连接，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态</text></g></g><g id="minder_node79" display="none"><g id="node_expander77" display="none" style="cursor: pointer;"><path id="kity_path_20753" fill="white" stroke="gray" d="M553.5,-50.5A6,6,0,1,1,541.5,-50.5A6,6,0,1,1,553.5,-50.5"></path><path id="kity_path_20754" fill="none" stroke="gray"></path></g><path id="node_outline78" fill="none" stroke="none" d="M553.5,-59.5h114a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-114a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text78" fill="black"><text id="kity_text_7050" text-rendering="inherit" font-size="12" dy=".8em" y="-58.299999952316284" x="553.5">https为什么是安全的</text></g></g><g id="minder_node80" display="none"><g id="node_expander76" display="none" style="cursor: pointer;"><path id="kity_path_20750" fill="white" stroke="gray" d="M569.5,-50.5A6,6,0,1,1,557.5,-50.5A6,6,0,1,1,569.5,-50.5"></path><path id="kity_path_20751" fill="none" stroke="gray"></path></g><path id="node_outline77" fill="none" stroke="none" d="M569.5,-68.5h622a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-622a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text77" fill="black"><text id="kity_text_7047" text-rendering="inherit" font-size="12" dy=".8em" y="-67.29999995231628" x="569.5">1.HTTPS 协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全</text><text id="kity_text_7048" text-rendering="inherit" font-size="12" dy=".8em" y="-49.299999952316284" x="569.5">2.使用混合加密算法。具体做法就是使用非对称加密来传输对称密钥来保证安全性，使用对称加密来保证通信的效率。</text></g></g><g id="minder_node81" display="none"><g id="node_expander79" display="none" style="cursor: pointer;"><path id="kity_path_20759" fill="white" stroke="gray" d="M553.5,-42.5A6,6,0,1,1,541.5,-42.5A6,6,0,1,1,553.5,-42.5"></path><path id="kity_path_20760" fill="none" stroke="gray"></path></g><path id="node_outline80" fill="none" stroke="none" d="M553.5,-51.5h102a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-102a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text80" fill="black"><text id="kity_text_7055" text-rendering="inherit" font-size="12" dy=".8em" y="-50.299999952316284" x="553.5">https的原理了解吗</text></g></g><g id="minder_node82" display="none"><g id="node_expander78" display="none" style="cursor: pointer;"><path id="kity_path_20756" fill="white" stroke="gray" d="M569.5,-42.5A6,6,0,1,1,557.5,-42.5A6,6,0,1,1,569.5,-42.5"></path><path id="kity_path_20757" fill="none" stroke="gray"></path></g><path id="node_outline79" fill="none" stroke="none" d="M569.5,-60.5h994a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-994a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text79" fill="black"><text id="kity_text_7052" text-rendering="inherit" font-size="12" dy=".8em" y="-59.299999952316284" x="569.5">1.服务端生成一对非对称密钥，将公钥发给客户端。客户端生成对称密钥，用服务端发来的公钥进行加密，加密后发给服务端。服务端收到后用私钥进行解密，得到客户端发送的对称密钥。</text><text id="kity_text_7053" text-rendering="inherit" font-size="12" dy=".8em" y="-41.299999952316284" x="569.5">2.为了防止服务端被冒充。客户端通过 服务端发送的权威机构的SSL来证明(证书中包含了公钥)，客户端收到证书后既证明了服务端的身份又拿到了公钥就可以进行下一步操作了。</text></g></g><g id="minder_node83" display="none"><g id="node_expander82" display="none" style="cursor: pointer;"><path id="kity_path_20768" fill="white" stroke="gray" d="M553.5,-34.5A6,6,0,1,1,541.5,-34.5A6,6,0,1,1,553.5,-34.5"></path><path id="kity_path_20769" fill="none" stroke="gray"></path></g><path id="node_outline83" fill="none" stroke="none" d="M553.5,-43.5h138a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-138a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text83" fill="black"><text id="kity_text_7068" text-rendering="inherit" font-size="12" dy=".8em" y="-42.299999952316284" x="553.5">https加密流程简单说一下</text></g></g><g id="minder_node84" display="none"><g id="node_expander81" display="none" style="cursor: pointer;"><path id="kity_path_20765" fill="white" stroke="gray" d="M569.5,-34.5A6,6,0,1,1,557.5,-34.5A6,6,0,1,1,569.5,-34.5"></path><path id="kity_path_20766" fill="none" stroke="gray"></path></g><path id="node_outline82" fill="none" stroke="none" d="M569.5,-106.5h1036a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-1036a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text82" fill="black"><text id="kity_text_7059" text-rendering="inherit" font-size="12" dy=".8em" y="-105.29999995231628" x="569.5">简单点说 就是 首先你要有SSL证书，证书里面有服务端公钥(结构利用自己的私钥对服务器的公钥进行数字签名，给服务端公钥)，服务端把证书给客户端，这个时侯客户端有了服务端的对称密钥。&#xa0;</text><text id="kity_text_7060" text-rendering="inherit" font-size="12" dy=".8em" y="-87.29999995231628" x="569.5">然后就是 客户端用证书公钥+随机数 加密 把自己生成的对称密钥发给服务端，服务端用自己的私钥解密得到客户端的对称密钥</text><text id="kity_text_7061" text-rendering="inherit" font-size="12" dy=".8em" y="-69.29999995231628" x="569.5">1.客户端向服务端发起第一次握手请求，告诉服务端,客户端所支持的SSL的指定版本、加密算法及密钥长度等信息。</text><text id="kity_text_7062" text-rendering="inherit" font-size="12" dy=".8em" y="-51.299999952316284" x="569.5">2.服务端将自己的公钥发给数字证书认证机构，认证机构对服务器的公钥进行数字签名，并给服务器颁发公钥证书。</text><text id="kity_text_7063" text-rendering="inherit" font-size="12" dy=".8em" y="-33.299999952316284" x="569.5">3.服务端将证书发给客服端。客户端首先会去判断是否有效，根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密</text><text id="kity_text_7064" text-rendering="inherit" font-size="12" dy=".8em" y="-15.299999952316284" x="569.5">4.客户端使用服务端的公钥加密自己生成的对称密钥，发给服务端。</text><text id="kity_text_7065" text-rendering="inherit" font-size="12" dy=".8em" y="2.700000047683716" x="569.5">5.服务端用私钥解密获得客户端发来的对称密钥。</text><text id="kity_text_7066" text-rendering="inherit" font-size="12" dy=".8em" y="20.700000047683716" x="569.5">6.通信双方可用对称密钥来加密解密信息。</text></g></g><g id="minder_node85" display="none"><g id="node_expander80" display="none" style="cursor: pointer;"><path id="kity_path_20762" fill="white" stroke="gray" d="M585.5,-34.5A6,6,0,1,1,573.5,-34.5A6,6,0,1,1,585.5,-34.5"></path><path id="kity_path_20763" fill="none" stroke="gray"></path></g><path id="node_outline81" fill="none" stroke="none" d="M510.5,-203.5h200a5,5,0,0,1,5,5v168a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-168a5,5,0,0,1,5,-5z"></path><g id="node_text81" fill="black"><text id="kity_text_7057" text-rendering="inherit" font-size="12" dy=".8em" y="-42.299999952316284" x="585.5">加密流程</text></g><image id="kity_image_17011" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210429015809.png" x="510.5" y="-200.5" width="200" height="155"></image></g><g id="minder_node86" display="none"><g id="node_expander84" display="none" style="cursor: pointer;"><path id="kity_path_20774" fill="white" stroke="gray" d="M553.5,-26.5A6,6,0,1,1,541.5,-26.5A6,6,0,1,1,553.5,-26.5"></path><path id="kity_path_20775" fill="none" stroke="gray"></path></g><path id="node_outline85" fill="none" stroke="none" d="M553.5,-35.5h102a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-102a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text85" fill="black"><text id="kity_text_7072" text-rendering="inherit" font-size="12" dy=".8em" y="-34.299999952316284" x="553.5">https的连接过程？</text></g></g><g id="minder_node87" display="none"><g id="node_expander83" display="none" style="cursor: pointer;"><path id="kity_path_20771" fill="white" stroke="gray" d="M569.5,-26.5A6,6,0,1,1,557.5,-26.5A6,6,0,1,1,569.5,-26.5"></path><path id="kity_path_20772" fill="none" stroke="gray"></path></g><path id="node_outline84" fill="none" stroke="none" d="M569.5,-35.5h179a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-179a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text84" fill="black"><text id="kity_text_7070" text-rendering="inherit" font-size="12" dy=".8em" y="-34.299999952316284" x="569.5">1.同上，加密完就是双方正常通信</text></g></g><g id="minder_node88" display="none"><g id="node_expander87" display="none" style="cursor: pointer;"><path id="kity_path_20783" fill="white" stroke="gray" d="M553.5,-18.5A6,6,0,1,1,541.5,-18.5A6,6,0,1,1,553.5,-18.5"></path><path id="kity_path_20784" fill="none" stroke="gray"></path></g><path id="node_outline88" fill="none" stroke="none" d="M553.5,-27.5h155a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-155a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text88" fill="black"><text id="kity_text_7081" text-rendering="inherit" font-size="12" dy=".8em" y="-26.299999952316284" x="553.5">说说http1.1相比于1.0的特点</text></g></g><g id="minder_node89" display="none"><g id="node_expander86" display="none" style="cursor: pointer;"><path id="kity_path_20780" fill="white" stroke="gray" d="M569.5,-18.5A6,6,0,1,1,557.5,-18.5A6,6,0,1,1,569.5,-18.5"></path><path id="kity_path_20781" fill="none" stroke="gray"></path></g><path id="node_outline87" fill="none" stroke="none" d="M569.5,-54.5h1073a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1073a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text87" fill="black"><text id="kity_text_7076" text-rendering="inherit" font-size="12" dy=".8em" y="-53.299999952316284" x="569.5">1.http1.0 默认使用短连接，每次请求都要重新建立一次TCP连接，资源消耗较大 即每次发送数据都会经过 TCP 的三次握手和四次挥手，效率比较低。 不支持断点续传，每次都会传送全部的页面和数据。</text><text id="kity_text_7077" text-rendering="inherit" font-size="12" dy=".8em" y="-35.299999952316284" x="569.5">HTTP 1.0 认为每台计算机只能绑定一个 IP, 请求消息中的 URL 并没有传递hostname</text><text id="kity_text_7078" text-rendering="inherit" font-size="12" dy=".8em" y="-17.299999952316284" x="569.5">2.http1.1&#xa0; HTTP 1.1支持长连接,长连接就是只需一次建立就可以传输多次数据，传输完成后，只需要一次切断连接即可。长连接的连接时长可以通过请求头中的 keep-alive 来设置</text><text id="kity_text_7079" text-rendering="inherit" font-size="12" dy=".8em" y="0.7000000476837158" x="569.5">支持断点续传，通过使用请求头中的 Range 来实现。一台物理服务器上多个虚拟主机共享一个IP地址。</text></g></g><g id="minder_node90" display="none"><g id="node_expander85" display="none" style="cursor: pointer;"><path id="kity_path_20777" fill="white" stroke="gray" d="M585.5,-18.5A6,6,0,1,1,573.5,-18.5A6,6,0,1,1,585.5,-18.5"></path><path id="kity_path_20778" fill="none" stroke="gray"></path></g><path id="node_outline86" fill="none" stroke="none" d="M585.5,-27.5h333a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text86" fill="black"><text id="kity_text_7074" text-rendering="inherit" font-size="12" dy=".8em" y="-26.299999952316284" x="585.5">https://juejin.cn/post/6844904132067885064#heading-11</text></g></g><g id="minder_node91" display="none"><g id="node_expander90" display="none" style="cursor: pointer;"><path id="kity_path_20792" fill="white" stroke="gray" d="M553.5,-10.5A6,6,0,1,1,541.5,-10.5A6,6,0,1,1,553.5,-10.5"></path><path id="kity_path_20793" fill="none" stroke="gray"></path></g><path id="node_outline91" fill="none" stroke="none" d="M553.5,-19.5h154a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-154a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text91" fill="black"><text id="kity_text_7090" text-rendering="inherit" font-size="12" dy=".8em" y="-18.299999952316284" x="553.5">http2.0 了解吗，有哪些特性</text></g></g><g id="minder_node92" display="none"><g id="node_expander89" display="none" style="cursor: pointer;"><path id="kity_path_20789" fill="white" stroke="gray" d="M569.5,-10.5A6,6,0,1,1,557.5,-10.5A6,6,0,1,1,569.5,-10.5"></path><path id="kity_path_20790" fill="none" stroke="gray"></path></g><path id="node_outline90" fill="none" stroke="none" d="M569.5,-46.5h555a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-555a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text90" fill="black"><text id="kity_text_7085" text-rendering="inherit" font-size="12" dy=".8em" y="-45.299999952316284" x="569.5">1.头部压缩&#xa0; 避免头部偏重 Body却经常只有几十字节</text><text id="kity_text_7086" text-rendering="inherit" font-size="12" dy=".8em" y="-27.299999952316284" x="569.5">2.二进制格式。提升了解析效率，HTTP 2.0 使用了更加靠近 TCP/IP 的二进制格式，而抛弃了 ASCII 码，</text><text id="kity_text_7087" text-rendering="inherit" font-size="12" dy=".8em" y="-9.299999952316284" x="569.5">3. 安全。HTTP2.0 一般都跑在 HTTPS 上。</text><text id="kity_text_7088" text-rendering="inherit" font-size="12" dy=".8em" y="8.700000047683716" x="569.5">4.多路复用 一个连接上可以有多个请求。</text></g></g><g id="minder_node93" display="none"><g id="node_expander88" display="none" style="cursor: pointer;"><path id="kity_path_20786" fill="white" stroke="gray" d="M585.5,-10.5A6,6,0,1,1,573.5,-10.5A6,6,0,1,1,585.5,-10.5"></path><path id="kity_path_20787" fill="none" stroke="gray"></path></g><path id="node_outline89" fill="none" stroke="none" d="M585.5,-19.5h333a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text89" fill="black"><text id="kity_text_7083" text-rendering="inherit" font-size="12" dy=".8em" y="-18.299999952316284" x="585.5">https://juejin.cn/post/6844904132067885064#heading-13</text></g></g><g id="minder_node94" display="none"><g id="node_expander93" display="none" style="cursor: pointer;"><path id="kity_path_20801" fill="white" stroke="gray" d="M553.5,-2.5A6,6,0,1,1,541.5,-2.5A6,6,0,1,1,553.5,-2.5"></path><path id="kity_path_20802" fill="none" stroke="gray"></path></g><path id="node_outline94" fill="none" stroke="none" d="M553.5,-11.5h271a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-271a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text94" fill="black"><text id="kity_text_7101" text-rendering="inherit" font-size="12" dy=".8em" y="-10.299999952316284" x="553.5">说说HTTP长连接和短连接区别？场景？微服务呢？</text></g></g><g id="minder_node95" display="none"><g id="node_expander92" display="none" style="cursor: pointer;"><path id="kity_path_20798" fill="white" stroke="gray" d="M569.5,-2.5A6,6,0,1,1,557.5,-2.5A6,6,0,1,1,569.5,-2.5"></path><path id="kity_path_20799" fill="none" stroke="gray"></path></g><path id="node_outline93" fill="none" stroke="none" d="M569.5,-56.5h1081a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1081a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text93" fill="black"><text id="kity_text_7094" text-rendering="inherit" font-size="12" dy=".8em" y="-55.299999952316284" x="569.5">1.长连接只需一次建立就可以传输多次数据，传输完成后，只需要一次切断连接即可(多是客户端关闭连接)，不需要每次请求都重新建立一次连接。长连接的连接时长可以通过请求头中的 keep-alive 来设置</text><text id="kity_text_7095" text-rendering="inherit" font-size="12" dy=".8em" y="-37.299999952316284" x="569.5">2.短连接，每次请求都要重新建立一次TCP连接</text><text id="kity_text_7096" text-rendering="inherit" font-size="12" dy=".8em" y="-19.299999952316284" x="569.5">3.长连接场景：操作频繁，点对点的通讯，而且连接数不能太多情况，比如数据库的连接用长连接</text><text id="kity_text_7097" text-rendering="inherit" font-size="12" dy=".8em" y="-1.2999999523162842" x="569.5">短连接：http服务一般都用短链接 ，并发大用户多用短连接会更省一些资源</text><text id="kity_text_7098" text-rendering="inherit" font-size="12" dy=".8em" y="16.700000047683716" x="569.5">4.一个TCP连接是否为长连接，是通过设置HTTP的Connection Header来决定的，而且是需要两边都设置才有效。</text><text id="kity_text_7099" text-rendering="inherit" font-size="12" dy=".8em" y="34.700000047683716" x="569.5">5.微服务 使用长连接，性能好，省略了建连接的耗时</text></g></g><g id="minder_node96" display="none"><g id="node_expander91" display="none" style="cursor: pointer;"><path id="kity_path_20795" fill="white" stroke="gray" d="M585.5,-2.5A6,6,0,1,1,573.5,-2.5A6,6,0,1,1,585.5,-2.5"></path><path id="kity_path_20796" fill="none" stroke="gray"></path></g><path id="node_outline92" fill="none" stroke="none" d="M585.5,-11.5h238a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-238a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text92" fill="black"><text id="kity_text_7092" text-rendering="inherit" font-size="12" dy=".8em" y="-10.299999952316284" x="585.5">https://www.jianshu.com/p/3fc3646fad80</text></g></g><g id="minder_node97" display="none"><g id="node_expander97" display="none" style="cursor: pointer;"><path id="kity_path_20813" fill="white" stroke="gray" d="M553.5,5.5A6,6,0,1,1,541.5,5.5A6,6,0,1,1,553.5,5.5"></path><path id="kity_path_20814" fill="none" stroke="gray"></path></g><path id="node_outline98" fill="none" stroke="none" d="M553.5,-3.5h192a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-192a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text98" fill="black"><text id="kity_text_7111" text-rendering="inherit" font-size="12" dy=".8em" y="-2.299999952316284" x="553.5">http是无状态的怎么保存用户状态的</text></g></g><g id="minder_node98" display="none"><g id="node_expander96" display="none" style="cursor: pointer;"><path id="kity_path_20810" fill="white" stroke="gray" d="M569.5,5.5A6,6,0,1,1,557.5,5.5A6,6,0,1,1,569.5,5.5"></path><path id="kity_path_20811" fill="none" stroke="gray"></path></g><path id="node_outline97" fill="none" stroke="none" d="M569.5,-21.5h751a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-751a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text97" fill="black"><text id="kity_text_7107" text-rendering="inherit" font-size="12" dy=".8em" y="-20.299999952316284" x="569.5">1.基于Session实现的会话保持 优点： 状态信息保存在服务器端安全，缺点是不便于服务器的水平扩展。分布式session的问题</text><text id="kity_text_7108" text-rendering="inherit" font-size="12" dy=".8em" y="-2.299999952316284" x="569.5">2.基于Cookie实现的会话保持，优点减轻服务端存储压力 缺点不够安全 每次HTTP请求都需要发送额外的Cookie到服务端，会消耗更多带宽。</text><text id="kity_text_7109" text-rendering="inherit" font-size="12" dy=".8em" y="15.700000047683716" x="569.5">3.客户端JWT，请求带着token来进入认证服务，还可以解决单点登录问题</text></g></g><g id="minder_node99" display="none"><g id="node_expander94" display="none" style="cursor: pointer;"><path id="kity_path_20804" fill="white" stroke="gray" d="M585.5,-2.5A6,6,0,1,1,573.5,-2.5A6,6,0,1,1,585.5,-2.5"></path><path id="kity_path_20805" fill="none" stroke="gray"></path></g><path id="node_outline95" fill="none" stroke="none" d="M585.5,-11.5h350a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-350a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text95" fill="black"><text id="kity_text_7103" text-rendering="inherit" font-size="12" dy=".8em" y="-10.299999952316284" x="585.5">https://blog.csdn.net/xxxxxxxxxxxyn/article/details/98530211</text></g></g><g id="minder_node100" display="none"><g id="node_expander95" display="none" style="cursor: pointer;"><path id="kity_path_20807" fill="white" stroke="gray" d="M585.5,5.5A6,6,0,1,1,573.5,5.5A6,6,0,1,1,585.5,5.5"></path><path id="kity_path_20808" fill="none" stroke="gray"></path></g><path id="node_outline96" fill="none" stroke="none" d="M510.5,-78.5h200a5,5,0,0,1,5,5v83a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-83a5,5,0,0,1,5,-5z"></path><g id="node_text96" fill="black"><text id="kity_text_7105" text-rendering="inherit" font-size="12" dy=".8em" y="-2.299999952316284" x="585.5">分支主题</text></g><image id="kity_image_17012" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210430015937.png" x="510.5" y="-75.5" width="200" height="70"></image></g><g id="minder_node101" display="none"><g id="node_expander98" display="none" style="cursor: pointer;"><path id="kity_path_20816" fill="white" stroke="gray" d="M553.5,13.5A6,6,0,1,1,541.5,13.5A6,6,0,1,1,553.5,13.5"></path><path id="kity_path_20817" fill="none" stroke="gray"></path></g><path id="node_outline99" fill="none" stroke="none" d="M553.5,4.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text99" fill="black"><text id="kity_text_7113" text-rendering="inherit" font-size="12" dy=".8em" y="5.700000047683716" x="553.5">http优化方案有哪些</text></g></g><g id="minder_node102" display="none"><g id="node_expander101" display="none" style="cursor: pointer;"><path id="kity_path_20825" fill="white" stroke="gray" d="M553.5,21.5A6,6,0,1,1,541.5,21.5A6,6,0,1,1,553.5,21.5"></path><path id="kity_path_20826" fill="none" stroke="gray"></path></g><path id="node_outline102" fill="none" stroke="none" d="M553.5,12.5h153a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-153a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text102" fill="black"><text id="kity_text_7128" text-rendering="inherit" font-size="12" dy=".8em" y="13.700000047683716" x="553.5">浏览器输入一个url 说说过程</text></g></g><g id="minder_node103" display="none"><g id="node_expander100" display="none" style="cursor: pointer;"><path id="kity_path_20822" fill="white" stroke="gray" d="M569.5,21.5A6,6,0,1,1,557.5,21.5A6,6,0,1,1,569.5,21.5"></path><path id="kity_path_20823" fill="none" stroke="gray"></path></g><path id="node_outline101" fill="none" stroke="none" d="M569.5,-50.5h944a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-944a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text101" fill="black"><text id="kity_text_7119" text-rendering="inherit" font-size="12" dy=".8em" y="-49.299999952316284" x="569.5">大体上可以分为网络通信 和 页面渲染 两个阶段</text><text id="kity_text_7120" text-rendering="inherit" font-size="12" dy=".8em" y="-31.299999952316284" x="569.5">1.对输入到浏览器的url进行DNS解析，将域名转换为IP地址。浏览器向本地 DNS 服务器发起请求，为了将消息从你的PC上传到服务器上，需要用到IP协议、ARP协议和OSPF协议</text><text id="kity_text_7121" text-rendering="inherit" font-size="12" dy=".8em" y="-13.299999952316284" x="569.5">2.发起TCP的三次握手 建立TCP连接</text><text id="kity_text_7122" text-rendering="inherit" font-size="12" dy=".8em" y="4.700000047683716" x="569.5">3.建立TCP连接后发起HTTP请求</text><text id="kity_text_7123" text-rendering="inherit" font-size="12" dy=".8em" y="22.700000047683716" x="569.5">4.服务器响应HTTP请求</text><text id="kity_text_7124" text-rendering="inherit" font-size="12" dy=".8em" y="40.700000047683716" x="569.5">5.浏览器解析html代码，并请求HTML代码中的资源（如js、css、图片等）</text><text id="kity_text_7125" text-rendering="inherit" font-size="12" dy=".8em" y="58.700000047683716" x="569.5">6.断开TCP连接</text><text id="kity_text_7126" text-rendering="inherit" font-size="12" dy=".8em" y="76.70000004768372" x="569.5">7.浏览器对页面进行布局渲染呈现给用户</text></g></g><g id="minder_node104" display="none"><g id="node_expander99" display="none" style="cursor: pointer;"><path id="kity_path_20819" fill="white" stroke="gray" d="M585.5,21.5A6,6,0,1,1,573.5,21.5A6,6,0,1,1,585.5,21.5"></path><path id="kity_path_20820" fill="none" stroke="gray"></path></g><path id="node_outline100" fill="none" stroke="none" d="M585.5,-5.5h346a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-346a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text100" fill="black"><text id="kity_text_7115" text-rendering="inherit" font-size="12" dy=".8em" y="-4.299999952316284" x="585.5">https://blog.csdn.net/qq_36520235/article/details/82559847</text><text id="kity_text_7116" text-rendering="inherit" font-size="12" dy=".8em" y="13.700000047683716" x="585.5">https://www.cnblogs.com/HuiH/p/12622328.html</text><text id="kity_text_7117" text-rendering="inherit" font-size="12" dy=".8em" y="31.700000047683716" x="585.5">https://juejin.cn/post/6844904155077672968#heading-2</text></g></g><g id="minder_node105" display="none"><g id="node_expander103" display="none" style="cursor: pointer;"><path id="kity_path_20831" fill="white" stroke="gray" d="M553.5,29.5A6,6,0,1,1,541.5,29.5A6,6,0,1,1,553.5,29.5"></path><path id="kity_path_20832" fill="none" stroke="gray"></path></g><path id="node_outline104" fill="none" stroke="none" d="M553.5,20.5h300a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-300a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text104" fill="black"><text id="kity_text_7133" text-rendering="inherit" font-size="12" dy=".8em" y="21.700000047683716" x="553.5">一个完整的http请求涉及到哪些协议(输入url涉及的协议)</text></g></g><g id="minder_node106" display="none"><g id="node_expander102" display="none" style="cursor: pointer;"><path id="kity_path_20828" fill="white" stroke="gray" d="M569.5,29.5A6,6,0,1,1,557.5,29.5A6,6,0,1,1,569.5,29.5"></path><path id="kity_path_20829" fill="none" stroke="gray"></path></g><path id="node_outline103" fill="none" stroke="none" d="M569.5,11.5h1057a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1057a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text103" fill="black"><text id="kity_text_7130" text-rendering="inherit" font-size="12" dy=".8em" y="12.700000047683716" x="569.5">1. ARP（地址解析协议）解决的是同一个局域网内，主机或路由器的IP地址和MAC地址的映射问题</text><text id="kity_text_7131" text-rendering="inherit" font-size="12" dy=".8em" y="30.700000047683716" x="569.5">2.路由选择协议 主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，通过查找路由表决定通过哪个路径到达服务器，其中用到路由选择协议。</text></g></g><g id="minder_node107" display="none"><g id="node_expander106" display="none" style="cursor: pointer;"><path id="kity_path_20840" fill="white" stroke="gray" d="M553.5,37.5A6,6,0,1,1,541.5,37.5A6,6,0,1,1,553.5,37.5"></path><path id="kity_path_20841" fill="none" stroke="gray"></path></g><path id="node_outline107" fill="none" stroke="none" d="M553.5,28.5h211a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-211a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text107" fill="black"><text id="kity_text_7144" text-rendering="inherit" font-size="12" dy=".8em" y="29.700000047683716" x="553.5">HTTP请求报文和响应报文的组成有哪些</text></g></g><g id="minder_node108" display="none"><g id="node_expander105" display="none" style="cursor: pointer;"><path id="kity_path_20837" fill="white" stroke="gray" d="M569.5,37.5A6,6,0,1,1,557.5,37.5A6,6,0,1,1,569.5,37.5"></path><path id="kity_path_20838" fill="none" stroke="gray"></path></g><path id="node_outline106" fill="none" stroke="none" d="M569.5,-16.5h739a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-739a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text106" fill="black"><text id="kity_text_7137" text-rendering="inherit" font-size="12" dy=".8em" y="-15.299999952316284" x="569.5">大概结构就是 起始行 + 头部 + 空行 + 实体</text><text id="kity_text_7138" text-rendering="inherit" font-size="12" dy=".8em" y="2.700000047683716" x="569.5">1.请求报文起始行：&#xa0; 方法(get post)+路径(/home) + http版本；响应报文 http版本、状态码和原因</text><text id="kity_text_7139" text-rendering="inherit" font-size="12" dy=".8em" y="20.700000047683716" x="569.5">2.头部：请求报文： 服务器主机名和端口号，客户端用它向服务器传送数据的cookie 和 版本信息 长度 告诉服务器能够发送哪些媒体类型等</text><text id="kity_text_7140" text-rendering="inherit" font-size="12" dy=".8em" y="38.700000047683716" x="569.5">响应报文： 响应体的内容长度，时间 Web服务器软件名称等 ，</text><text id="kity_text_7141" text-rendering="inherit" font-size="12" dy=".8em" y="56.700000047683716" x="569.5">3.空行 区分开头部和实体。如果故意加一个空行，空行后的内容全部被视为实体。</text><text id="kity_text_7142" text-rendering="inherit" font-size="12" dy=".8em" y="74.70000004768372" x="569.5">4.实体&#xa0; 请求报文对应请求体, 响应报文对应响应体。</text></g></g><g id="minder_node109" display="none"><g id="node_expander104" display="none" style="cursor: pointer;"><path id="kity_path_20834" fill="white" stroke="gray" d="M585.5,37.5A6,6,0,1,1,573.5,37.5A6,6,0,1,1,585.5,37.5"></path><path id="kity_path_20835" fill="none" stroke="gray"></path></g><path id="node_outline105" fill="none" stroke="none" d="M585.5,28.5h306a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-306a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text105" fill="black"><text id="kity_text_7135" text-rendering="inherit" font-size="12" dy=".8em" y="29.700000047683716" x="585.5">https://blog.csdn.net/lyn_00/article/details/84953763</text></g></g><g id="minder_node110" display="none"><g id="node_expander109" display="none" style="cursor: pointer;"><path id="kity_path_20849" fill="white" stroke="gray" d="M553.5,45.5A6,6,0,1,1,541.5,45.5A6,6,0,1,1,553.5,45.5"></path><path id="kity_path_20850" fill="none" stroke="gray"></path></g><path id="node_outline110" fill="none" stroke="none" d="M553.5,36.5h96a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-96a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text110" fill="black"><text id="kity_text_7152" text-rendering="inherit" font-size="12" dy=".8em" y="37.700000047683716" x="553.5">http的缓存机制？</text></g></g><g id="minder_node111" display="none"><g id="node_expander108" display="none" style="cursor: pointer;"><path id="kity_path_20846" fill="white" stroke="gray" d="M569.5,45.5A6,6,0,1,1,557.5,45.5A6,6,0,1,1,569.5,45.5"></path><path id="kity_path_20847" fill="none" stroke="gray"></path></g><path id="node_outline109" fill="none" stroke="none" d="M569.5,18.5h727a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-727a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text109" fill="black"><text id="kity_text_7148" text-rendering="inherit" font-size="12" dy=".8em" y="19.700000047683716" x="569.5">1.HTTP 缓存 首先是通过 响应头部的Cache-Control验证强缓存是否可用&#xa0;&#xa0;</text><text id="kity_text_7149" text-rendering="inherit" font-size="12" dy=".8em" y="37.700000047683716" x="569.5">2.如果不可用 进入协商缓存 发送http请求 看请求头的字段 If-Modified-Since或者If-None-Match这些条件请求字段检查资源是否更新了</text><text id="kity_text_7150" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="569.5">3.如果资源更新了 ， 就返回资源 和200；如果资源没更新 返回 304 告诉浏览器从缓存中获取资源</text></g></g><g id="minder_node112" display="none"><g id="node_expander107" display="none" style="cursor: pointer;"><path id="kity_path_20843" fill="white" stroke="gray" d="M585.5,45.5A6,6,0,1,1,573.5,45.5A6,6,0,1,1,585.5,45.5"></path><path id="kity_path_20844" fill="none" stroke="gray"></path></g><path id="node_outline108" fill="none" stroke="none" d="M585.5,36.5h333a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text108" fill="black"><text id="kity_text_7146" text-rendering="inherit" font-size="12" dy=".8em" y="37.700000047683716" x="585.5">https://juejin.cn/post/6844904100035821575#heading-58</text></g></g><g id="minder_node113" display="none"><g id="node_expander164" display="none" style="cursor: pointer;"><path id="kity_path_21014" fill="white" stroke="gray" d="M537.5,53.5A6,6,0,1,1,525.5,53.5A6,6,0,1,1,537.5,53.5"></path><path id="kity_path_21015" fill="none" stroke="gray"></path></g><path id="node_outline165" fill="none" stroke="none" d="M537.5,44.5h68a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-68a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text165" fill="black"><text id="kity_text_7321" text-rendering="inherit" font-size="12" dy=".8em" y="45.700000047683716" x="537.5">tcp连接相关</text></g></g><g id="minder_node114" display="none"><g id="node_expander113" display="none" style="cursor: pointer;"><path id="kity_path_20861" fill="white" stroke="gray" d="M553.5,-106.5A6,6,0,1,1,541.5,-106.5A6,6,0,1,1,553.5,-106.5"></path><path id="kity_path_20862" fill="none" stroke="gray"></path></g><path id="node_outline114" fill="none" stroke="none" d="M553.5,-115.5h74a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-74a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text114" fill="black"><text id="kity_text_7166" text-rendering="inherit" font-size="12" dy=".8em" y="-114.29999995231628" x="553.5">说说三次握手</text></g></g><g id="minder_node115" display="none"><g id="node_expander112" display="none" style="cursor: pointer;"><path id="kity_path_20858" fill="white" stroke="gray" d="M569.5,-106.5A6,6,0,1,1,557.5,-106.5A6,6,0,1,1,569.5,-106.5"></path><path id="kity_path_20859" fill="none" stroke="gray"></path></g><path id="node_outline113" fill="none" stroke="none" d="M569.5,-169.5h925a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-925a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text113" fill="black"><text id="kity_text_7158" text-rendering="inherit" font-size="12" dy=".8em" y="-168.29999995231628" x="569.5">1.三次握手的本质就是确定发送端和接收端具备收发信息的能力并建立可靠的通信信道，就像打电话一样要知道你电话打的通 和你本人能回复我</text><text id="kity_text_7159" text-rendering="inherit" font-size="12" dy=".8em" y="-150.29999995231628" x="569.5">简单点说是&#xa0; 客户端向服务端发送SYN 然后服务端返回SYN,ACK 然后客户端发送ACK</text><text id="kity_text_7160" text-rendering="inherit" font-size="12" dy=".8em" y="-132.29999995231628" x="569.5">开始双方都是关闭状态。服务端要提供服务，会主动监听某个端口，进入 LISTEN (监听状态)</text><text id="kity_text_7161" text-rendering="inherit" font-size="12" dy=".8em" y="-114.29999995231628" x="569.5">第一次：客户端主动发送连接的SYN包(SYN置1和随机数seq)，之后进入 SYN-SENT (同步已发送状态)</text><text id="kity_text_7162" text-rendering="inherit" font-size="12" dy=".8em" y="-96.29999995231628" x="569.5">第二次：服务端在收到客户端发来的SYN包后，回复SYN/ACK包(SYN置1和ack=第一次随机数+1和本次随机数+1)，之后进入 SYN-RCVD (同步收到状态)</text><text id="kity_text_7163" text-rendering="inherit" font-size="12" dy=".8em" y="-78.29999995231628" x="569.5">第三次：客户端收到服务端发来的SYN/ACK包后，确认对方后回复ACK包(ACK置1 ack=第二次接收的随机数+1 和 第一次的随机数)，并进入 ESTABLISHED (已建立连接状态)</text><text id="kity_text_7164" text-rendering="inherit" font-size="12" dy=".8em" y="-60.299999952316284" x="569.5">当服务器收到客户端的确认后也进入 ESTABLISHED (已建立连接状态) ，此后双方就可以开始通信了。</text></g></g><g id="minder_node116" display="none"><g id="node_expander111" display="none" style="cursor: pointer;"><path id="kity_path_20855" fill="white" stroke="gray" d="M585.5,-106.5A6,6,0,1,1,573.5,-106.5A6,6,0,1,1,585.5,-106.5"></path><path id="kity_path_20856" fill="none" stroke="gray"></path></g><path id="node_outline112" fill="none" stroke="none" d="M510.5,-249.5h200a5,5,0,0,1,5,5v142a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-142a5,5,0,0,1,5,-5z"></path><g id="node_text112" fill="black"><text id="kity_text_7156" text-rendering="inherit" font-size="12" dy=".8em" y="-114.29999995231628" x="585.5">分支主题</text></g><image id="kity_image_17013" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210429212830.png" x="510.5" y="-246.5" width="200" height="129"></image></g><g id="minder_node117" display="none"><g id="node_expander115" display="none" style="cursor: pointer;"><path id="kity_path_20867" fill="white" stroke="gray" d="M553.5,-98.5A6,6,0,1,1,541.5,-98.5A6,6,0,1,1,553.5,-98.5"></path><path id="kity_path_20868" fill="none" stroke="gray"></path></g><path id="node_outline116" fill="none" stroke="none" d="M553.5,-107.5h163a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-163a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text116" fill="black"><text id="kity_text_7173" text-rendering="inherit" font-size="12" dy=".8em" y="-106.29999995231628" x="553.5">tcp的三次握手可以传输数据？</text></g></g><g id="minder_node118" display="none"><g id="node_expander114" display="none" style="cursor: pointer;"><path id="kity_path_20864" fill="white" stroke="gray" d="M569.5,-98.5A6,6,0,1,1,557.5,-98.5A6,6,0,1,1,569.5,-98.5"></path><path id="kity_path_20865" fill="none" stroke="gray"></path></g><path id="node_outline115" fill="none" stroke="none" d="M569.5,-134.5h919a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-919a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text115" fill="black"><text id="kity_text_7168" text-rendering="inherit" font-size="12" dy=".8em" y="-133.29999995231628" x="569.5">第一次和第二次是不可以携带数据的，但是第三次是可以携带数据的。</text><text id="kity_text_7169" text-rendering="inherit" font-size="12" dy=".8em" y="-115.29999995231628" x="569.5">假如第一次握手可以携带数据的话，那对于服务器太危险了，有人如果恶意攻击服务器，每次都在第一次握手中的SYN报文中放入大量数据。</text><text id="kity_text_7170" text-rendering="inherit" font-size="12" dy=".8em" y="-97.29999995231628" x="569.5">而且频繁重复发SYN报文，服务器会花费很多的时间和内存空间去接收这些报文。</text><text id="kity_text_7171" text-rendering="inherit" font-size="12" dy=".8em" y="-79.29999995231628" x="569.5">第三次握手，此时客户端已经处于ESTABLISHED状态。对于客户端来说，他已经建立起连接了，并且已经知道服务器的接收和发送能力是正常的。所以也就可以携带数据了。</text></g></g><g id="minder_node119" display="none"><g id="node_expander118" display="none" style="cursor: pointer;"><path id="kity_path_20876" fill="white" stroke="gray" d="M553.5,-90.5A6,6,0,1,1,541.5,-90.5A6,6,0,1,1,553.5,-90.5"></path><path id="kity_path_20877" fill="none" stroke="gray"></path></g><path id="node_outline119" fill="none" stroke="none" d="M553.5,-99.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text119" fill="black"><text id="kity_text_7179" text-rendering="inherit" font-size="12" dy=".8em" y="-98.29999995231628" x="553.5">二次握手可以吗，为什么</text></g></g><g id="minder_node120" display="none"><g id="node_expander117" display="none" style="cursor: pointer;"><path id="kity_path_20873" fill="white" stroke="gray" d="M569.5,-90.5A6,6,0,1,1,557.5,-90.5A6,6,0,1,1,569.5,-90.5"></path><path id="kity_path_20874" fill="none" stroke="gray"></path></g><path id="node_outline118" fill="none" stroke="none" d="M569.5,-99.5h888a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-888a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text118" fill="black"><text id="kity_text_7177" text-rendering="inherit" font-size="12" dy=".8em" y="-98.29999995231628" x="569.5">1.两次无法确认客户端的接收能力。防止网络延迟导致&#xa0; 两次握手时重传的数据 在断开连接以后 又到了服务端，服务端默认你要连接，就又正常通信了，造成了资源浪费</text></g></g><g id="minder_node121" display="none"><g id="node_expander116" display="none" style="cursor: pointer;"><path id="kity_path_20870" fill="white" stroke="gray" d="M585.5,-90.5A6,6,0,1,1,573.5,-90.5A6,6,0,1,1,585.5,-90.5"></path><path id="kity_path_20871" fill="none" stroke="gray"></path></g><path id="node_outline117" fill="none" stroke="none" d="M585.5,-99.5h327a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-327a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text117" fill="black"><text id="kity_text_7175" text-rendering="inherit" font-size="12" dy=".8em" y="-98.29999995231628" x="585.5">https://juejin.cn/post/6844904070889603085#heading-4</text></g></g><g id="minder_node122" display="none"><g id="node_expander120" display="none" style="cursor: pointer;"><path id="kity_path_20882" fill="white" stroke="gray" d="M553.5,-82.5A6,6,0,1,1,541.5,-82.5A6,6,0,1,1,553.5,-82.5"></path><path id="kity_path_20883" fill="none" stroke="gray"></path></g><path id="node_outline121" fill="none" stroke="none" d="M553.5,-91.5h96a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-96a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text121" fill="black"><text id="kity_text_7183" text-rendering="inherit" font-size="12" dy=".8em" y="-90.29999995231628" x="553.5">为什么不是四次？</text></g></g><g id="minder_node123" display="none"><g id="node_expander119" display="none" style="cursor: pointer;"><path id="kity_path_20879" fill="white" stroke="gray" d="M569.5,-82.5A6,6,0,1,1,557.5,-82.5A6,6,0,1,1,569.5,-82.5"></path><path id="kity_path_20880" fill="none" stroke="gray"></path></g><path id="node_outline120" fill="none" stroke="none" d="M569.5,-91.5h347a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-347a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text120" fill="black"><text id="kity_text_7181" text-rendering="inherit" font-size="12" dy=".8em" y="-90.29999995231628" x="569.5">1.三次握手的目的是确认双方发送和接收的能力。超过三次没必要</text></g></g><g id="minder_node124" display="none"><g id="node_expander122" display="none" style="cursor: pointer;"><path id="kity_path_20888" fill="white" stroke="gray" d="M553.5,-74.5A6,6,0,1,1,541.5,-74.5A6,6,0,1,1,553.5,-74.5"></path><path id="kity_path_20889" fill="none" stroke="gray"></path></g><path id="node_outline123" fill="none" stroke="none" d="M553.5,-83.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text123" fill="black"><text id="kity_text_7187" text-rendering="inherit" font-size="12" dy=".8em" y="-82.29999995231628" x="553.5">第三次握手失败怎么办？</text></g></g><g id="minder_node125" display="none"><g id="node_expander121" display="none" style="cursor: pointer;"><path id="kity_path_20885" fill="white" stroke="gray" d="M569.5,-74.5A6,6,0,1,1,557.5,-74.5A6,6,0,1,1,569.5,-74.5"></path><path id="kity_path_20886" fill="none" stroke="gray"></path></g><path id="node_outline122" fill="none" stroke="none" d="M569.5,-83.5h718a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-718a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text122" fill="black"><text id="kity_text_7185" text-rendering="inherit" font-size="12" dy=".8em" y="-82.29999995231628" x="569.5">1当第三次握手失败时，服务器并不会重传ack报文，而是直接发送RST报文段，进入CLOSED状态。这样做的目的是为了防止SYN攻击。</text></g></g><g id="minder_node126" display="none"><g id="node_expander124" display="none" style="cursor: pointer;"><path id="kity_path_20894" fill="white" stroke="gray" d="M553.5,-66.5A6,6,0,1,1,541.5,-66.5A6,6,0,1,1,553.5,-66.5"></path><path id="kity_path_20895" fill="none" stroke="gray"></path></g><path id="node_outline125" fill="none" stroke="none" d="M553.5,-75.5h96a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-96a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text125" fill="black"><text id="kity_text_7194" text-rendering="inherit" font-size="12" dy=".8em" y="-74.29999995231628" x="553.5">SYN攻击是什么？</text></g></g><g id="minder_node127" display="none"><g id="node_expander123" display="none" style="cursor: pointer;"><path id="kity_path_20891" fill="white" stroke="gray" d="M569.5,-66.5A6,6,0,1,1,557.5,-66.5A6,6,0,1,1,569.5,-66.5"></path><path id="kity_path_20892" fill="none" stroke="gray"></path></g><path id="node_outline124" fill="none" stroke="none" d="M569.5,-102.5h909a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-909a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text124" fill="black"><text id="kity_text_7189" text-rendering="inherit" font-size="12" dy=".8em" y="-101.29999995231628" x="569.5">1.发送方短时间内发送大量不存在的IP地址，向接受方不断地发送SYN包，由于ip不存在，而server会不断的重发并等待发送方确认，伪造的SYN包将长时间占用未连接队列.</text><text id="kity_text_7190" text-rendering="inherit" font-size="12" dy=".8em" y="-83.29999995231628" x="569.5">导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪</text><text id="kity_text_7191" text-rendering="inherit" font-size="12" dy=".8em" y="-65.29999995231628" x="569.5">2.检测：可以通过看服务器是否有大量的半连接状态&#xa0; 源IP地址是随机</text><text id="kity_text_7192" text-rendering="inherit" font-size="12" dy=".8em" y="-47.299999952316284" x="569.5">3.解决：缩短超时（SYN Timeout）时间；减少syn ack重试次数；增加最大半连接数；过滤，网关防护；增大SYN连接数；处理不过来就拒绝；</text></g></g><g id="minder_node128" display="none"><g id="node_expander127" display="none" style="cursor: pointer;"><path id="kity_path_20903" fill="white" stroke="gray" d="M553.5,-58.5A6,6,0,1,1,541.5,-58.5A6,6,0,1,1,553.5,-58.5"></path><path id="kity_path_20904" fill="none" stroke="gray"></path></g><path id="node_outline128" fill="none" stroke="none" d="M553.5,-67.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text128" fill="black"><text id="kity_text_7203" text-rendering="inherit" font-size="12" dy=".8em" y="-66.29999995231628" x="553.5">半连接队列？全连接队列？</text></g></g><g id="minder_node129" display="none"><g id="node_expander126" display="none" style="cursor: pointer;"><path id="kity_path_20900" fill="white" stroke="gray" d="M569.5,-58.5A6,6,0,1,1,557.5,-58.5A6,6,0,1,1,569.5,-58.5"></path><path id="kity_path_20901" fill="none" stroke="gray"></path></g><path id="node_outline127" fill="none" stroke="none" d="M569.5,-94.5h828a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-828a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text127" fill="black"><text id="kity_text_7198" text-rendering="inherit" font-size="12" dy=".8em" y="-93.29999995231628" x="569.5">1.服务端第一次收到客户端的 SYN 之后，就会处于 syn 接收 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个半连接队列里</text><text id="kity_text_7199" text-rendering="inherit" font-size="12" dy=".8em" y="-75.29999995231628" x="569.5">服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，时间指数增加 直到断开</text><text id="kity_text_7200" text-rendering="inherit" font-size="12" dy=".8em" y="-57.299999952316284" x="569.5">linux默认重试5次，重传时间为1+2+4+8+16 = 31s&#xa0; &#xa0;但是要 加个32s 因为第六次才知道超时了，总超时时间为32+31 tcp才会去断开连接</text><text id="kity_text_7201" text-rendering="inherit" font-size="12" dy=".8em" y="-39.299999952316284" x="569.5">2.全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</text></g></g><g id="minder_node130" display="none"><g id="node_expander125" display="none" style="cursor: pointer;"><path id="kity_path_20897" fill="white" stroke="gray" d="M585.5,-58.5A6,6,0,1,1,573.5,-58.5A6,6,0,1,1,585.5,-58.5"></path><path id="kity_path_20898" fill="none" stroke="gray"></path></g><path id="node_outline126" fill="none" stroke="none" d="M585.5,-67.5h250a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-250a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text126" fill="black"><text id="kity_text_7196" text-rendering="inherit" font-size="12" dy=".8em" y="-66.29999995231628" x="585.5">https://yuanrengu.com/2020/77eef79f.html</text></g></g><g id="minder_node131" display="none"><g id="node_expander130" display="none" style="cursor: pointer;"><path id="kity_path_20912" fill="white" stroke="gray" d="M553.5,-50.5A6,6,0,1,1,541.5,-50.5A6,6,0,1,1,553.5,-50.5"></path><path id="kity_path_20913" fill="none" stroke="gray"></path></g><path id="node_outline131" fill="none" stroke="none" d="M553.5,-59.5h86a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-86a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text131" fill="black"><text id="kity_text_7215" text-rendering="inherit" font-size="12" dy=".8em" y="-58.299999952316284" x="553.5">再说说四次挥手</text></g></g><g id="minder_node132" display="none"><g id="node_expander129" display="none" style="cursor: pointer;"><path id="kity_path_20909" fill="white" stroke="gray" d="M569.5,-50.5A6,6,0,1,1,557.5,-50.5A6,6,0,1,1,569.5,-50.5"></path><path id="kity_path_20910" fill="none" stroke="gray"></path></g><path id="node_outline130" fill="none" stroke="none" d="M569.5,-113.5h1281a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-1281a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text130" fill="black"><text id="kity_text_7207" text-rendering="inherit" font-size="12" dy=".8em" y="-112.29999995231628" x="569.5">四次挥手就是传输层协议断开连接</text><text id="kity_text_7208" text-rendering="inherit" font-size="12" dy=".8em" y="-94.29999995231628" x="569.5">1.</text><text id="kity_text_7209" text-rendering="inherit" font-size="12" dy=".8em" y="-76.29999995231628" x="569.5">第一次：刚开始双方传输数据还处于 ESTABLISHED (已建立连接状态)。某一端主动发起 FIN 包准备断开连接。客户端进入 FIN-WAIT-1 (终止等待状态1)</text><text id="kity_text_7210" text-rendering="inherit" font-size="12" dy=".8em" y="-58.299999952316284" x="569.5">第二次：服务端收到 FIN 消息后，回复 ACK 表示知道了，并从ESTABLISHED (已建立连接状态)进入 CLOSED-WAIT (关闭等待状态)，开始做一些断开连接前的准备工作,此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。</text><text id="kity_text_7211" text-rendering="inherit" font-size="12" dy=".8em" y="-40.299999952316284" x="569.5">第三次：客户端收到服务端的ACK后，进入 FIN-WAIT-2 (终止等待状态2)，然后服务端做完准备工作给客户端发ACK说我已经准备好断开连接了，然后服务端进入 LAST-ACK (最后确认状态)</text><text id="kity_text_7212" text-rendering="inherit" font-size="12" dy=".8em" y="-22.299999952316284" x="569.5">第四次:客户端在收到服务端的准备好断开连接ACK 消息后，会立即回复 ACK ，并进入 TIME_WAIT 。为了稳定和安全考虑，客户端会在 TIME-WAIT ( 时间等待状态) 等待 2MSL ( 最长报文段寿命 ) 的时长，最终进入 CLOSED ( 关闭状态 )。</text><text id="kity_text_7213" text-rendering="inherit" font-size="12" dy=".8em" y="-4.299999952316284" x="569.5">而服务端在收到最后一次ACK后就直接close</text></g></g><g id="minder_node133" display="none"><g id="node_expander128" display="none" style="cursor: pointer;"><path id="kity_path_20906" fill="white" stroke="gray" d="M585.5,-50.5A6,6,0,1,1,573.5,-50.5A6,6,0,1,1,585.5,-50.5"></path><path id="kity_path_20907" fill="none" stroke="gray"></path></g><path id="node_outline129" fill="none" stroke="none" d="M510.5,-191.5h200a5,5,0,0,1,5,5v140a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-140a5,5,0,0,1,5,-5z"></path><g id="node_text129" fill="black"><text id="kity_text_7205" text-rendering="inherit" font-size="12" dy=".8em" y="-58.299999952316284" x="585.5">分支主题</text></g><image id="kity_image_17014" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210429221302.png" x="510.5" y="-188.5" width="200" height="127"></image></g><g id="minder_node134" display="none"><g id="node_expander133" display="none" style="cursor: pointer;"><path id="kity_path_20921" fill="white" stroke="gray" d="M553.5,-42.5A6,6,0,1,1,541.5,-42.5A6,6,0,1,1,553.5,-42.5"></path><path id="kity_path_20922" fill="none" stroke="gray"></path></g><path id="node_outline134" fill="none" stroke="none" d="M553.5,-51.5h140a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-140a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text134" fill="black"><text id="kity_text_7225" text-rendering="inherit" font-size="12" dy=".8em" y="-50.299999952316284" x="553.5">为什么要等待2MSL时长？</text></g></g><g id="minder_node135" display="none"><g id="node_expander132" display="none" style="cursor: pointer;"><path id="kity_path_20918" fill="white" stroke="gray" d="M569.5,-42.5A6,6,0,1,1,557.5,-42.5A6,6,0,1,1,569.5,-42.5"></path><path id="kity_path_20919" fill="none" stroke="gray"></path></g><path id="node_outline133" fill="none" stroke="none" d="M569.5,-87.5h788a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-788a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text133" fill="black"><text id="kity_text_7219" text-rendering="inherit" font-size="12" dy=".8em" y="-86.29999995231628" x="569.5">1. MSL是最长报文段寿命，它指的是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃，TCP允许不同的实现可以设置不同的 MSL 值。</text><text id="kity_text_7220" text-rendering="inherit" font-size="12" dy=".8em" y="-68.29999995231628" x="569.5">2.在2MSL等待中 如果客户端没有收到服务端的重发请求，那么表示 ACK 成功到达，挥手结束，否则客户端重发 ACK。</text><text id="kity_text_7221" text-rendering="inherit" font-size="12" dy=".8em" y="-50.299999952316284" x="569.5">而如果不等待就导致 如果最后服务端有发送的数据在路上，而端口被新应用占了 数据混乱</text><text id="kity_text_7222" text-rendering="inherit" font-size="12" dy=".8em" y="-32.299999952316284" x="569.5">一个MSL保证 第四次挥手主动关闭方 ACK 报文不丢失 一个MSL 保证如果需要重传，服务端ACK FIN报文可以到达 让客户端重传</text><text id="kity_text_7223" text-rendering="inherit" font-size="12" dy=".8em" y="-14.299999952316284" x="569.5">3.2MSL 大概是4分钟 可能更小一点 2MSL是请求和回复的最大时长</text></g></g><g id="minder_node136" display="none"><g id="node_expander131" display="none" style="cursor: pointer;"><path id="kity_path_20915" fill="white" stroke="gray" d="M585.5,-42.5A6,6,0,1,1,573.5,-42.5A6,6,0,1,1,585.5,-42.5"></path><path id="kity_path_20916" fill="none" stroke="gray"></path></g><path id="node_outline132" fill="none" stroke="none" d="M585.5,-51.5h333a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text132" fill="black"><text id="kity_text_7217" text-rendering="inherit" font-size="12" dy=".8em" y="-50.299999952316284" x="585.5">https://juejin.cn/post/6844904070889603085#heading-10</text></g></g><g id="minder_node137" display="none"><g id="node_expander136" display="none" style="cursor: pointer;"><path id="kity_path_20930" fill="white" stroke="gray" d="M553.5,-34.5A6,6,0,1,1,541.5,-34.5A6,6,0,1,1,553.5,-34.5"></path><path id="kity_path_20931" fill="none" stroke="gray"></path></g><path id="node_outline137" fill="none" stroke="none" d="M553.5,-43.5h384a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-384a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text137" fill="black"><text id="kity_text_7233" text-rendering="inherit" font-size="12" dy=".8em" y="-42.299999952316284" x="553.5">为什么连接的时候是三次握手，关闭的时候却是四次握手？如果是三次呢</text></g></g><g id="minder_node138" display="none"><g id="node_expander135" display="none" style="cursor: pointer;"><path id="kity_path_20927" fill="white" stroke="gray" d="M569.5,-34.5A6,6,0,1,1,557.5,-34.5A6,6,0,1,1,569.5,-34.5"></path><path id="kity_path_20928" fill="none" stroke="gray"></path></g><path id="node_outline136" fill="none" stroke="none" d="M569.5,-61.5h598a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-598a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text136" fill="black"><text id="kity_text_7229" text-rendering="inherit" font-size="12" dy=".8em" y="-60.299999952316284" x="569.5">1.因为服务端在接收到FIN, 要做准备，不会立即返回FIN, 必须等到服务端所有的报文都发送完毕了，才能发FIN。</text><text id="kity_text_7230" text-rendering="inherit" font-size="12" dy=".8em" y="-42.299999952316284" x="569.5">因此先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN。这就造成了四次挥手。</text><text id="kity_text_7231" text-rendering="inherit" font-size="12" dy=".8em" y="-24.299999952316284" x="569.5">2.如果是三次就会导致客户端误以为FIN没有到达服务端，从而让客户端不断的重发FIN。</text></g></g><g id="minder_node139" display="none"><g id="node_expander134" display="none" style="cursor: pointer;"><path id="kity_path_20924" fill="white" stroke="gray" d="M585.5,-34.5A6,6,0,1,1,573.5,-34.5A6,6,0,1,1,585.5,-34.5"></path><path id="kity_path_20925" fill="none" stroke="gray"></path></g><path id="node_outline135" fill="none" stroke="none" d="M585.5,-43.5h333a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text135" fill="black"><text id="kity_text_7227" text-rendering="inherit" font-size="12" dy=".8em" y="-42.299999952316284" x="585.5">https://juejin.cn/post/6844904070889603085#heading-11</text></g></g><g id="minder_node140" display="none"><g id="node_expander138" display="none" style="cursor: pointer;"><path id="kity_path_20936" fill="white" stroke="gray" d="M553.5,-26.5A6,6,0,1,1,541.5,-26.5A6,6,0,1,1,553.5,-26.5"></path><path id="kity_path_20937" fill="none" stroke="gray"></path></g><path id="node_outline139" fill="none" stroke="none" d="M553.5,-35.5h318a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-318a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text139" fill="black"><text id="kity_text_7237" text-rendering="inherit" font-size="12" dy=".8em" y="-34.299999952316284" x="553.5">time_wait是什么，为什么需要time_wait(time_wait的作用)</text></g></g><g id="minder_node141" display="none"><g id="node_expander137" display="none" style="cursor: pointer;"><path id="kity_path_20933" fill="white" stroke="gray" d="M569.5,-26.5A6,6,0,1,1,557.5,-26.5A6,6,0,1,1,569.5,-26.5"></path><path id="kity_path_20934" fill="none" stroke="gray"></path></g><path id="node_outline138" fill="none" stroke="none" d="M569.5,-35.5h792a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-792a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text138" fill="black"><text id="kity_text_7235" text-rendering="inherit" font-size="12" dy=".8em" y="-34.299999952316284" x="569.5">1.第四次挥手时，客户端发送给服务器的ACK有可能丢失，客户端进入TIME_WAIT状态(2MSL)，TIME_WAIT状态就是用来重发可能丢失的ACK报文。</text></g></g><g id="minder_node142" display="none"><g id="node_expander141" display="none" style="cursor: pointer;"><path id="kity_path_20945" fill="white" stroke="gray" d="M553.5,-18.5A6,6,0,1,1,541.5,-18.5A6,6,0,1,1,553.5,-18.5"></path><path id="kity_path_20946" fill="none" stroke="gray"></path></g><path id="node_outline142" fill="none" stroke="none" d="M553.5,-27.5h303a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-303a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text142" fill="black"><text id="kity_text_7251" text-rendering="inherit" font-size="12" dy=".8em" y="-26.299999952316284" x="553.5">怎么优化tcp连接中的大量time_wait状态，从哪几个角度</text></g></g><g id="minder_node143" display="none"><g id="node_expander140" display="none" style="cursor: pointer;"><path id="kity_path_20942" fill="white" stroke="gray" d="M569.5,-18.5A6,6,0,1,1,557.5,-18.5A6,6,0,1,1,569.5,-18.5"></path><path id="kity_path_20943" fill="none" stroke="gray"></path></g><path id="node_outline141" fill="none" stroke="none" d="M569.5,-81.5h560a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-560a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text141" fill="black"><text id="kity_text_7243" text-rendering="inherit" font-size="12" dy=".8em" y="-80.29999995231628" x="569.5">1.可以改sysctl.conf配置优化&#xa0; &#xa0;降低msl周期，tcp_fin_timeout值。增加time_wait的队列 增加端口的数量</text><text id="kity_text_7244" text-rendering="inherit" font-size="12" dy=".8em" y="-62.299999952316284" x="569.5">2.让服务端主动关闭连接&#xa0; 或者 客户端主动关闭</text><text id="kity_text_7245" text-rendering="inherit" font-size="12" dy=".8em" y="-44.299999952316284" x="569.5">3.增加服务器</text><text id="kity_text_7246" text-rendering="inherit" font-size="12" dy=".8em" y="-26.299999952316284" x="569.5">4.短连接换长连接</text><text id="kity_text_7247" text-rendering="inherit" font-size="12" dy=".8em" y="-8.299999952316284" x="569.5">5,开启tw快速回收： net.ipv4.tcp_tw_recycle = 1，直接回收。</text><text id="kity_text_7248" text-rendering="inherit" font-size="12" dy=".8em" y="9.700000047683716" x="569.5">6.开启tw重用，允许重用time_wait的socket连接</text><text id="kity_text_7249" text-rendering="inherit" font-size="12" dy=".8em" y="27.700000047683716" x="569.5">7.降低系统同时保持TIME_WAIT套接字的最大数量 默认18000变5000，也就是修改上限值</text></g></g><g id="minder_node144" display="none"><g id="node_expander139" display="none" style="cursor: pointer;"><path id="kity_path_20939" fill="white" stroke="gray" d="M585.5,-18.5A6,6,0,1,1,573.5,-18.5A6,6,0,1,1,585.5,-18.5"></path><path id="kity_path_20940" fill="none" stroke="gray"></path></g><path id="node_outline140" fill="none" stroke="none" d="M585.5,-45.5h331a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-331a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text140" fill="black"><text id="kity_text_7239" text-rendering="inherit" font-size="12" dy=".8em" y="-44.299999952316284" x="585.5">https://blog.csdn.net/langouster/article/details/93870139</text><text id="kity_text_7240" text-rendering="inherit" font-size="12" dy=".8em" y="-26.299999952316284" x="585.5">https://blog.csdn.net/dog250/article/details/13760985</text><text id="kity_text_7241" text-rendering="inherit" font-size="12" dy=".8em" y="-8.299999952316284" x="585.5">https://yuanrengu.com/2020/77eef79f.html</text></g></g><g id="minder_node145" display="none"><g id="node_expander143" display="none" style="cursor: pointer;"><path id="kity_path_20951" fill="white" stroke="gray" d="M553.5,-10.5A6,6,0,1,1,541.5,-10.5A6,6,0,1,1,553.5,-10.5"></path><path id="kity_path_20952" fill="none" stroke="gray"></path></g><path id="node_outline144" fill="none" stroke="none" d="M553.5,-19.5h165a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-165a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text144" fill="black"><text id="kity_text_7255" text-rendering="inherit" font-size="12" dy=".8em" y="-18.299999952316284" x="553.5">怎么查看time_wait的连接数量</text></g></g><g id="minder_node146" display="none"><g id="node_expander142" display="none" style="cursor: pointer;"><path id="kity_path_20948" fill="white" stroke="gray" d="M569.5,-10.5A6,6,0,1,1,557.5,-10.5A6,6,0,1,1,569.5,-10.5"></path><path id="kity_path_20949" fill="none" stroke="gray"></path></g><path id="node_outline143" fill="none" stroke="none" d="M569.5,-19.5h225a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-225a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text143" fill="black"><text id="kity_text_7253" text-rendering="inherit" font-size="12" dy=".8em" y="-18.299999952316284" x="569.5">1.linux中 netstat开头的，后面具体忘记了</text></g></g><g id="minder_node147" display="none"><g id="node_expander145" display="none" style="cursor: pointer;"><path id="kity_path_20957" fill="white" stroke="gray" d="M553.5,-2.5A6,6,0,1,1,541.5,-2.5A6,6,0,1,1,553.5,-2.5"></path><path id="kity_path_20958" fill="none" stroke="gray"></path></g><path id="node_outline146" fill="none" stroke="none" d="M553.5,-11.5h213a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-213a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text146" fill="black"><text id="kity_text_7260" text-rendering="inherit" font-size="12" dy=".8em" y="-10.299999952316284" x="553.5">close_wait是什么，close_wait的意义？</text></g></g><g id="minder_node148" display="none"><g id="node_expander144" display="none" style="cursor: pointer;"><path id="kity_path_20954" fill="white" stroke="gray" d="M569.5,-2.5A6,6,0,1,1,557.5,-2.5A6,6,0,1,1,569.5,-2.5"></path><path id="kity_path_20955" fill="none" stroke="gray"></path></g><path id="node_outline145" fill="none" stroke="none" d="M569.5,-20.5h990a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-990a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text145" fill="black"><text id="kity_text_7257" text-rendering="inherit" font-size="12" dy=".8em" y="-19.299999952316284" x="569.5">1.第二次挥手，服务端收到 FIN 消息后，回复 ACK 进入 CLOSED-WAIT (关闭等待状态)，后面开始做一些断开连接前的准备工作。</text><text id="kity_text_7258" text-rendering="inherit" font-size="12" dy=".8em" y="-1.2999999523162842" x="569.5">2.因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。</text></g></g><g id="minder_node149" display="none"><g id="node_expander148" display="none" style="cursor: pointer;"><path id="kity_path_20966" fill="white" stroke="gray" d="M553.5,5.5A6,6,0,1,1,541.5,5.5A6,6,0,1,1,553.5,5.5"></path><path id="kity_path_20967" fill="none" stroke="gray"></path></g><path id="node_outline149" fill="none" stroke="none" d="M553.5,-3.5h251a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-251a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text149" fill="black"><text id="kity_text_7273" text-rendering="inherit" font-size="12" dy=".8em" y="-2.299999952316284" x="553.5">close_wait太多怎么办，为什么会出现这种情况</text></g></g><g id="minder_node150" display="none"><g id="node_expander147" display="none" style="cursor: pointer;"><path id="kity_path_20963" fill="white" stroke="gray" d="M569.5,5.5A6,6,0,1,1,557.5,5.5A6,6,0,1,1,569.5,5.5"></path><path id="kity_path_20964" fill="none" stroke="gray"></path></g><path id="node_outline148" fill="none" stroke="none" d="M569.5,-66.5h1233a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-1233a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text148" fill="black"><text id="kity_text_7264" text-rendering="inherit" font-size="12" dy=".8em" y="-65.29999995231628" x="569.5">1.发生在第二次挥手。close_wait只会发生在客户端先关闭连接的时候，但已经收到客户端的fin包，但服务器还没有关闭的时候会产生这个状态，如果服务器产生大量的这种连接一般是程序问题导致的，基本都是连接无法释放</text><text id="kity_text_7265" text-rendering="inherit" font-size="12" dy=".8em" y="-47.299999952316284" x="569.5">比如因为代码问题导致 MySQL 连接无法释放 而大量close wait状态&#xa0;</text><text id="kity_text_7266" text-rendering="inherit" font-size="12" dy=".8em" y="-29.299999952316284" x="569.5">2.服务端没有调用close()，有耗时操作 导致超时了，比如说mysql&#xa0; 代码对事务不回滚&#xa0; 导致服务端不主动发起close</text><text id="kity_text_7267" text-rendering="inherit" font-size="12" dy=".8em" y="-11.299999952316284" x="569.5">3.解决思路 看日志，看监控 通过netstat 检查情况看看是哪个进程的问题， 抓包分析一下为什么连接会被动断开。</text><text id="kity_text_7268" text-rendering="inherit" font-size="12" dy=".8em" y="6.700000047683716" x="569.5">然后看看</text><text id="kity_text_7269" text-rendering="inherit" font-size="12" dy=".8em" y="24.700000047683716" x="569.5">4.例子：MySQL主动断开连接 给我的服务发送 FIN 包，我进行了响应，此时我进入了 CLOSE_WAIT 状态，但是后续作为被动关闭方的我，并没有发送 FIN，导致我服务端一直处于 CLOSE_WAIT 状态，无法最终进入 CLOSED 状态。</text><text id="kity_text_7270" text-rendering="inherit" font-size="12" dy=".8em" y="42.700000047683716" x="569.5">代码里面事务没有rollback，也就是说代码事务执行后应该回滚，都是服务没有去发送 FIN，只回复了一个ack 发送在第三次握手，就可能方式这种情况</text><text id="kity_text_7271" text-rendering="inherit" font-size="12" dy=".8em" y="60.700000047683716" x="569.5">5.perf 查看进程调用栈，输出整个调用链上的信息。 netstat -an查看 tcp连接情况</text></g></g><g id="minder_node151" display="none"><g id="node_expander146" display="none" style="cursor: pointer;"><path id="kity_path_20960" fill="white" stroke="gray" d="M585.5,5.5A6,6,0,1,1,573.5,5.5A6,6,0,1,1,585.5,5.5"></path><path id="kity_path_20961" fill="none" stroke="gray"></path></g><path id="node_outline147" fill="none" stroke="none" d="M585.5,-3.5h326a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text147" fill="black"><text id="kity_text_7262" text-rendering="inherit" font-size="12" dy=".8em" y="-2.299999952316284" x="585.5">https://juejin.cn/post/6844903734300901390#heading-0</text></g></g><g id="minder_node152" display="none"><g id="node_expander150" display="none" style="cursor: pointer;"><path id="kity_path_20972" fill="white" stroke="gray" d="M553.5,13.5A6,6,0,1,1,541.5,13.5A6,6,0,1,1,553.5,13.5"></path><path id="kity_path_20973" fill="none" stroke="gray"></path></g><path id="node_outline151" fill="none" stroke="none" d="M553.5,4.5h161a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-161a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text151" fill="black"><text id="kity_text_7278" text-rendering="inherit" font-size="12" dy=".8em" y="5.700000047683716" x="553.5">close_wait和time_wait区别？</text></g></g><g id="minder_node153" display="none"><g id="node_expander149" display="none" style="cursor: pointer;"><path id="kity_path_20969" fill="white" stroke="gray" d="M569.5,13.5A6,6,0,1,1,557.5,13.5A6,6,0,1,1,569.5,13.5"></path><path id="kity_path_20970" fill="none" stroke="gray"></path></g><path id="node_outline150" fill="none" stroke="none" d="M569.5,-4.5h488a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-488a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text150" fill="black"><text id="kity_text_7275" text-rendering="inherit" font-size="12" dy=".8em" y="-3.299999952316284" x="569.5">1.客户端首先发起断开连接请求，客户端发送FIN，服务端进入CLOSE_WAIT状态，是被动的</text><text id="kity_text_7276" text-rendering="inherit" font-size="12" dy=".8em" y="14.700000047683716" x="569.5">2.TIME_WAIT是主动关闭形成的，当第四次挥手完成后，客户端进入TIME_WAIT状态。</text></g></g><g id="minder_node154" display="none"><g id="node_expander153" display="none" style="cursor: pointer;"><path id="kity_path_20981" fill="white" stroke="gray" d="M553.5,21.5A6,6,0,1,1,541.5,21.5A6,6,0,1,1,553.5,21.5"></path><path id="kity_path_20982" fill="none" stroke="gray"></path></g><path id="node_outline154" fill="none" stroke="none" d="M553.5,12.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text154" fill="black"><text id="kity_text_7287" text-rendering="inherit" font-size="12" dy=".8em" y="13.700000047683716" x="553.5">知道流量控制吗</text></g></g><g id="minder_node155" display="none"><g id="node_expander152" display="none" style="cursor: pointer;"><path id="kity_path_20978" fill="white" stroke="gray" d="M569.5,21.5A6,6,0,1,1,557.5,21.5A6,6,0,1,1,569.5,21.5"></path><path id="kity_path_20979" fill="none" stroke="gray"></path></g><path id="node_outline153" fill="none" stroke="none" d="M569.5,-14.5h946a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-946a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text153" fill="black"><text id="kity_text_7282" text-rendering="inherit" font-size="12" dy=".8em" y="-13.299999952316284" x="569.5">1.解决发送端发送的数据太快，接收端来不及接收出现丢包的问题。TCP协议利用了滑动窗口进行了流量控制</text><text id="kity_text_7283" text-rendering="inherit" font-size="12" dy=".8em" y="4.700000047683716" x="569.5">2.在TCP首部有一个16位字段大小的窗口，窗口的大小就是接收端接收数据缓冲区的剩余大小。</text><text id="kity_text_7284" text-rendering="inherit" font-size="12" dy=".8em" y="22.700000047683716" x="569.5">3.接收端会在收到数据包后发送ACK报文时，将自己的窗口大小填入ACK中，发送方会根据ACK报文中的窗口大小进而控制发送速度。如果窗口大小为零，发送方会停止发送数据。</text><text id="kity_text_7285" text-rendering="inherit" font-size="12" dy=".8em" y="40.700000047683716" x="569.5">4.TCP要做的就是把发送的数据放到发送缓存区, 将接收的数据放到接收缓存区。</text></g></g><g id="minder_node156" display="none"><g id="node_expander151" display="none" style="cursor: pointer;"><path id="kity_path_20975" fill="white" stroke="gray" d="M585.5,21.5A6,6,0,1,1,573.5,21.5A6,6,0,1,1,585.5,21.5"></path><path id="kity_path_20976" fill="none" stroke="gray"></path></g><path id="node_outline152" fill="none" stroke="none" d="M585.5,12.5h326a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text152" fill="black"><text id="kity_text_7280" text-rendering="inherit" font-size="12" dy=".8em" y="13.700000047683716" x="585.5">https://juejin.cn/post/6907433588183007245#heading-1</text></g></g><g id="minder_node157" display="none"><g id="node_expander156" display="none" style="cursor: pointer;"><path id="kity_path_20990" fill="white" stroke="gray" d="M553.5,29.5A6,6,0,1,1,541.5,29.5A6,6,0,1,1,553.5,29.5"></path><path id="kity_path_20991" fill="none" stroke="gray"></path></g><path id="node_outline157" fill="none" stroke="none" d="M553.5,20.5h73a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-73a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text157" fill="black"><text id="kity_text_7294" text-rendering="inherit" font-size="12" dy=".8em" y="21.700000047683716" x="553.5">说说滑动窗口</text></g></g><g id="minder_node158" display="none"><g id="node_expander155" display="none" style="cursor: pointer;"><path id="kity_path_20987" fill="white" stroke="gray" d="M569.5,29.5A6,6,0,1,1,557.5,29.5A6,6,0,1,1,569.5,29.5"></path><path id="kity_path_20988" fill="none" stroke="gray"></path></g><path id="node_outline156" fill="none" stroke="none" d="M569.5,11.5h688a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-688a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text156" fill="black"><text id="kity_text_7291" text-rendering="inherit" font-size="12" dy=".8em" y="12.700000047683716" x="569.5">1.TCP 滑动窗口分为两种: 发送窗口和接收窗口。</text><text id="kity_text_7292" text-rendering="inherit" font-size="12" dy=".8em" y="30.700000047683716" x="569.5">2.发送窗口表示我发送了什么，还有什么没有发送，接收窗口 表示 我还可以接收窗口有多大，你不能超过。如果为0 就不要发送了</text></g></g><g id="minder_node159" display="none"><g id="node_expander154" display="none" style="cursor: pointer;"><path id="kity_path_20984" fill="white" stroke="gray" d="M585.5,29.5A6,6,0,1,1,573.5,29.5A6,6,0,1,1,585.5,29.5"></path><path id="kity_path_20985" fill="none" stroke="gray"></path></g><path id="node_outline155" fill="none" stroke="none" d="M585.5,20.5h333a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text155" fill="black"><text id="kity_text_7289" text-rendering="inherit" font-size="12" dy=".8em" y="21.700000047683716" x="585.5">https://juejin.cn/post/6844904070889603085#heading-39</text></g></g><g id="minder_node160" display="none"><g id="node_expander159" display="none" style="cursor: pointer;"><path id="kity_path_20999" fill="white" stroke="gray" d="M553.5,37.5A6,6,0,1,1,541.5,37.5A6,6,0,1,1,553.5,37.5"></path><path id="kity_path_21000" fill="none" stroke="gray"></path></g><path id="node_outline160" fill="none" stroke="none" d="M553.5,28.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text160" fill="black"><text id="kity_text_7309" text-rendering="inherit" font-size="12" dy=".8em" y="29.700000047683716" x="553.5">知道拥塞控制吗</text></g></g><g id="minder_node161" display="none"><g id="node_expander158" display="none" style="cursor: pointer;"><path id="kity_path_20996" fill="white" stroke="gray" d="M569.5,37.5A6,6,0,1,1,557.5,37.5A6,6,0,1,1,569.5,37.5"></path><path id="kity_path_20997" fill="none" stroke="gray"></path></g><path id="node_outline159" fill="none" stroke="none" d="M569.5,-43.5h1302a5,5,0,0,1,5,5v152a5,5,0,0,1,-5,5h-1302a5,5,0,0,1,-5,-5v-152a5,5,0,0,1,5,-5z"></path><g id="node_text159" fill="black"><text id="kity_text_7299" text-rendering="inherit" font-size="12" dy=".8em" y="-42.299999952316284" x="569.5">流量控制没有考虑到整个网络环境的影响，这些问题拥塞控制来处理</text><text id="kity_text_7300" text-rendering="inherit" font-size="12" dy=".8em" y="-24.299999952316284" x="569.5">发送方维护一个状态变量，拥塞窗口是根据网络的拥塞情况动态确定的，一般来说发送方真实的发送窗口为滑动窗口(接收方对发送方的限制)和拥塞窗口(发送端的选择)中的最小值。</text><text id="kity_text_7301" text-rendering="inherit" font-size="12" dy=".8em" y="-6.299999952316284" x="569.5">拥塞控制就是控制拥塞窗口的限制</text><text id="kity_text_7302" text-rendering="inherit" font-size="12" dy=".8em" y="11.700000047683716" x="569.5">1.</text><text id="kity_text_7303" text-rendering="inherit" font-size="12" dy=".8em" y="29.700000047683716" x="569.5">(1)慢开始：为了避免一开始发送大量的数据而产生网络阻塞，拥塞窗口指数增长来适应整个网路。直到阈值。</text><text id="kity_text_7304" text-rendering="inherit" font-size="12" dy=".8em" y="47.700000047683716" x="569.5">(2)拥塞避免：达到阈值以后，如果出现网络超时。把阈值变为出现超时拥塞窗口数值的一半，并且拥塞窗口设置为1</text><text id="kity_text_7305" text-rendering="inherit" font-size="12" dy=".8em" y="65.70000004768372" x="569.5">(3)快重传：如果只是丢失某一个报文段，使用快重传算法(解决是否重传的问题)。快重传就是 1 2 3序号的报文，3丢了，需要快速向发送端发送2的确认报文，在发送方收到三个2的ack后，无需等待重传计时器所设置的时间，可直接进行3的重传，</text><text id="kity_text_7306" text-rendering="inherit" font-size="12" dy=".8em" y="83.70000004768372" x="569.5">选择性重传解决的是如何重传的问题，传哪一个的问题。</text><text id="kity_text_7307" text-rendering="inherit" font-size="12" dy=".8em" y="101.70000004768372" x="569.5">(4)快恢复：当发送收到三个重复的ACK，会进行快重传和快恢复，快恢复是指将拥塞窗口阈值设置为发生快重传时的拥塞窗口数量的一半，避免出现拥塞避免</text></g></g><g id="minder_node162" display="none"><g id="node_expander157" display="none" style="cursor: pointer;"><path id="kity_path_20993" fill="white" stroke="gray" d="M585.5,37.5A6,6,0,1,1,573.5,37.5A6,6,0,1,1,585.5,37.5"></path><path id="kity_path_20994" fill="none" stroke="gray"></path></g><path id="node_outline158" fill="none" stroke="none" d="M585.5,19.5h333a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text158" fill="black"><text id="kity_text_7296" text-rendering="inherit" font-size="12" dy=".8em" y="20.700000047683716" x="585.5">https://juejin.cn/post/6844904070889603085#heading-43</text><text id="kity_text_7297" text-rendering="inherit" font-size="12" dy=".8em" y="38.700000047683716" x="585.5">https://juejin.cn/post/6907433588183007245#heading-1</text></g></g><g id="minder_node163" display="none"><g id="node_expander161" display="none" style="cursor: pointer;"><path id="kity_path_21005" fill="white" stroke="gray" d="M553.5,45.5A6,6,0,1,1,541.5,45.5A6,6,0,1,1,553.5,45.5"></path><path id="kity_path_21006" fill="none" stroke="gray"></path></g><path id="node_outline162" fill="none" stroke="none" d="M553.5,36.5h217a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-217a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text162" fill="black"><text id="kity_text_7313" text-rendering="inherit" font-size="12" dy=".8em" y="37.700000047683716" x="553.5">慢开始前期是指数型增长还是线性增长？</text></g></g><g id="minder_node164" display="none"><g id="node_expander160" display="none" style="cursor: pointer;"><path id="kity_path_21002" fill="white" stroke="gray" d="M569.5,45.5A6,6,0,1,1,557.5,45.5A6,6,0,1,1,569.5,45.5"></path><path id="kity_path_21003" fill="none" stroke="gray"></path></g><path id="node_outline161" fill="none" stroke="none" d="M569.5,36.5h35a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-35a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text161" fill="black"><text id="kity_text_7311" text-rendering="inherit" font-size="12" dy=".8em" y="37.700000047683716" x="569.5">1.指数</text></g></g><g id="minder_node165" display="none"><g id="node_expander163" display="none" style="cursor: pointer;"><path id="kity_path_21011" fill="white" stroke="gray" d="M553.5,53.5A6,6,0,1,1,541.5,53.5A6,6,0,1,1,553.5,53.5"></path><path id="kity_path_21012" fill="none" stroke="gray"></path></g><path id="node_outline164" fill="none" stroke="none" d="M553.5,44.5h154a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-154a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text164" fill="black"><text id="kity_text_7319" text-rendering="inherit" font-size="12" dy=".8em" y="45.700000047683716" x="553.5">知道Tcp拥塞控制那些算法吗</text></g></g><g id="minder_node166" display="none"><g id="node_expander162" display="none" style="cursor: pointer;"><path id="kity_path_21008" fill="white" stroke="gray" d="M569.5,53.5A6,6,0,1,1,557.5,53.5A6,6,0,1,1,569.5,53.5"></path><path id="kity_path_21009" fill="none" stroke="gray"></path></g><path id="node_outline163" fill="none" stroke="none" d="M569.5,26.5h110a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-110a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text163" fill="black"><text id="kity_text_7315" text-rendering="inherit" font-size="12" dy=".8em" y="27.700000047683716" x="569.5">1.慢启动</text><text id="kity_text_7316" text-rendering="inherit" font-size="12" dy=".8em" y="45.700000047683716" x="569.5">拥塞避免</text><text id="kity_text_7317" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="569.5">快速重传和快速恢复</text></g></g><g id="minder_node167" display="none"><g id="node_expander180" display="none" style="cursor: pointer;"><path id="kity_path_21062" fill="white" stroke="gray" d="M537.5,61.5A6,6,0,1,1,525.5,61.5A6,6,0,1,1,537.5,61.5"></path><path id="kity_path_21063" fill="none" stroke="gray"></path></g><path id="node_outline181" fill="none" stroke="none" d="M537.5,52.5h53a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-53a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text181" fill="black"><text id="kity_text_7370" text-rendering="inherit" font-size="12" dy=".8em" y="53.700000047683716" x="537.5">tcp&amp;udp</text></g></g><g id="minder_node168" display="none"><g id="node_expander166" display="none" style="cursor: pointer;"><path id="kity_path_21020" fill="white" stroke="gray" d="M553.5,21.5A6,6,0,1,1,541.5,21.5A6,6,0,1,1,553.5,21.5"></path><path id="kity_path_21021" fill="none" stroke="gray"></path></g><path id="node_outline167" fill="none" stroke="none" d="M553.5,12.5h126a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-126a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text167" fill="black"><text id="kity_text_7329" text-rendering="inherit" font-size="12" dy=".8em" y="13.700000047683716" x="553.5">知道tcp和udp的区别吗</text></g></g><g id="minder_node169" display="none"><g id="node_expander165" display="none" style="cursor: pointer;"><path id="kity_path_21017" fill="white" stroke="gray" d="M569.5,21.5A6,6,0,1,1,557.5,21.5A6,6,0,1,1,569.5,21.5"></path><path id="kity_path_21018" fill="none" stroke="gray"></path></g><path id="node_outline166" fill="none" stroke="none" d="M569.5,-23.5h1115a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1115a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text166" fill="black"><text id="kity_text_7323" text-rendering="inherit" font-size="12" dy=".8em" y="-22.299999952316284" x="569.5">1.从tcp udp报文格式就可以看出差别:tcp头部比udp头部字节更多，说明相同情况下控制开销更多，在一定时间内，传输数据的时延更大，所以tcp不适合用于即时场景；</text><text id="kity_text_7324" text-rendering="inherit" font-size="12" dy=".8em" y="-4.299999952316284" x="569.5">2.从报文格式还可以看出，tcp存在多个控制位，意味着会交互更多的控制信息，再从控制位字段提起，比如syn fin ack，意味着tcp会发一下控制消息进行握手，这样一来传输信息时更加可靠，面向连接，可靠；</text><text id="kity_text_7325" text-rendering="inherit" font-size="12" dy=".8em" y="13.700000047683716" x="569.5">3.还有窗口位，意味着tcp有拥塞控制优势，可以扯到拥塞或者流控；</text><text id="kity_text_7326" text-rendering="inherit" font-size="12" dy=".8em" y="31.700000047683716" x="569.5">4.再从udp报文头部数据长度扯，udp有数据长度字段，而tcp没有，只有头部偏移字段，意味着udp是一包一包数据传输，发端和收端不会分片或者重组，能很快识别这包数据；</text><text id="kity_text_7327" text-rendering="inherit" font-size="12" dy=".8em" y="49.700000047683716" x="569.5">而tcp是流，每次是个数据块，也就是沾包，也就是这个tcp独有的特性，从发端和收端来看就行；</text></g></g><g id="minder_node170" display="none"><g id="node_expander168" display="none" style="cursor: pointer;"><path id="kity_path_21026" fill="white" stroke="gray" d="M553.5,29.5A6,6,0,1,1,541.5,29.5A6,6,0,1,1,553.5,29.5"></path><path id="kity_path_21027" fill="none" stroke="gray"></path></g><path id="node_outline169" fill="none" stroke="none" d="M553.5,20.5h134a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-134a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text169" fill="black"><text id="kity_text_7338" text-rendering="inherit" font-size="12" dy=".8em" y="21.700000047683716" x="553.5">TCP与UDP应用场景知道</text></g></g><g id="minder_node171" display="none"><g id="node_expander167" display="none" style="cursor: pointer;"><path id="kity_path_21023" fill="white" stroke="gray" d="M569.5,29.5A6,6,0,1,1,557.5,29.5A6,6,0,1,1,569.5,29.5"></path><path id="kity_path_21024" fill="none" stroke="gray"></path></g><path id="node_outline168" fill="none" stroke="none" d="M569.5,-24.5h1379a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1379a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text168" fill="black"><text id="kity_text_7331" text-rendering="inherit" font-size="12" dy=".8em" y="-23.299999952316284" x="569.5">tcp相当于打电话，udp相当于学校大广播</text><text id="kity_text_7332" text-rendering="inherit" font-size="12" dy=".8em" y="-5.299999952316284" x="569.5">1.tcp 面向连接（发送数据前要先建立连接），可靠的字节流传输（通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达；指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送），消耗资源多， 可以做文件/邮件传输， 首部字节 20~60</text><text id="kity_text_7333" text-rendering="inherit" font-size="12" dy=".8em" y="12.700000047683716" x="569.5">2.udp 无连接(发送数据前不需要建立连接)，不可靠的数据报文段传输（UDP一个报文只能一次发完。），传输快，消耗资源少可以做视频/语音传输，首部字节8</text><text id="kity_text_7334" text-rendering="inherit" font-size="12" dy=".8em" y="30.700000047683716" x="569.5">3.TCP首部 前20个字节是固定的，包含一些 源端口，目到端口，窗口。UDP 首部，源端口号、目的端口号、长度和校验和各两个字节。</text><text id="kity_text_7335" text-rendering="inherit" font-size="12" dy=".8em" y="48.700000047683716" x="569.5">4.TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；</text><text id="kity_text_7336" text-rendering="inherit" font-size="12" dy=".8em" y="66.70000004768372" x="569.5">5.对某些实时性要求比较高的情况使用UDP，比如游戏，媒体通信，实时直播，即使出现传输错误也可以容忍；其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失的情况</text></g></g><g id="minder_node172" display="none"><g id="node_expander170" display="none" style="cursor: pointer;"><path id="kity_path_21032" fill="white" stroke="gray" d="M553.5,37.5A6,6,0,1,1,541.5,37.5A6,6,0,1,1,553.5,37.5"></path><path id="kity_path_21033" fill="none" stroke="gray"></path></g><path id="node_outline171" fill="none" stroke="none" d="M553.5,28.5h139a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-139a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text171" fill="black"><text id="kity_text_7342" text-rendering="inherit" font-size="12" dy=".8em" y="29.700000047683716" x="553.5">tcp是怎么保证可靠传输的</text></g></g><g id="minder_node173" display="none"><g id="node_expander169" display="none" style="cursor: pointer;"><path id="kity_path_21029" fill="white" stroke="gray" d="M569.5,37.5A6,6,0,1,1,557.5,37.5A6,6,0,1,1,569.5,37.5"></path><path id="kity_path_21030" fill="none" stroke="gray"></path></g><path id="node_outline170" fill="none" stroke="none" d="M569.5,28.5h881a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-881a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text170" fill="black"><text id="kity_text_7340" text-rendering="inherit" font-size="12" dy=".8em" y="29.700000047683716" x="569.5">1.点对点通信，TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达；</text></g></g><g id="minder_node174" display="none"><g id="node_expander173" display="none" style="cursor: pointer;"><path id="kity_path_21041" fill="white" stroke="gray" d="M553.5,45.5A6,6,0,1,1,541.5,45.5A6,6,0,1,1,553.5,45.5"></path><path id="kity_path_21042" fill="none" stroke="gray"></path></g><path id="node_outline174" fill="none" stroke="none" d="M553.5,36.5h139a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-139a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text174" fill="black"><text id="kity_text_7354" text-rendering="inherit" font-size="12" dy=".8em" y="37.700000047683716" x="553.5">tcp怎么保证传输安全性的</text></g></g><g id="minder_node175" display="none"><g id="node_expander172" display="none" style="cursor: pointer;"><path id="kity_path_21038" fill="white" stroke="gray" d="M569.5,45.5A6,6,0,1,1,557.5,45.5A6,6,0,1,1,569.5,45.5"></path><path id="kity_path_21039" fill="none" stroke="gray"></path></g><path id="node_outline173" fill="none" stroke="none" d="M569.5,-17.5h1325a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-1325a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text173" fill="black"><text id="kity_text_7346" text-rendering="inherit" font-size="12" dy=".8em" y="-16.299999952316284" x="569.5">1.校验和、序列号、超时重传、流量控制及拥塞避免等几种方法。</text><text id="kity_text_7347" text-rendering="inherit" font-size="12" dy=".8em" y="1.7000000476837158" x="569.5">(1)校验和：在发送算和接收端分别计算数据的校验和，如果两者不一致，则说明数据在传输过程中出现了差错，TCP将丢弃和不确认此报文段。</text><text id="kity_text_7348" text-rendering="inherit" font-size="12" dy=".8em" y="19.700000047683716" x="569.5">(2)序列号：对每一个发送的字节进行编号，通过ack报文来告诉发送方 下一次发送的数据从编号多少开始发。可以来判断是否有相同数据</text><text id="kity_text_7349" text-rendering="inherit" font-size="12" dy=".8em" y="37.700000047683716" x="569.5">(3)超时重传：如果发送方在发送数据后一段时间内没有收到确认序号ACK，那么发送方就会重新发送数据。如果数据被重发之后还是没有收到接收方的确认应答，会再次发送。等待确认应答的时间将会以2倍、4倍的指数函数延长，直到最后关闭连接。</text><text id="kity_text_7350" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="569.5">(4)流量控制：如果发送端发送的数据太快，接收端来不及接收就会出现丢包问题。TCP协议利用了滑动窗口进行了流量控制。</text><text id="kity_text_7351" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="569.5">TCP通过首部16位字段窗口 告诉发送方 接收端接收数据缓冲区的剩余大小.，发送方看ACK报文中的窗口大小控制发送速度</text><text id="kity_text_7352" text-rendering="inherit" font-size="12" dy=".8em" y="91.70000004768372" x="569.5">(5)拥塞控制:减少网络拥塞时 发送方重传 导致拥塞更加严重 主要组成：慢开始、拥塞避免、快重传、快恢复</text></g></g><g id="minder_node176" display="none"><g id="node_expander171" display="none" style="cursor: pointer;"><path id="kity_path_21035" fill="white" stroke="gray" d="M585.5,45.5A6,6,0,1,1,573.5,45.5A6,6,0,1,1,585.5,45.5"></path><path id="kity_path_21036" fill="none" stroke="gray"></path></g><path id="node_outline172" fill="none" stroke="none" d="M585.5,36.5h326a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text172" fill="black"><text id="kity_text_7344" text-rendering="inherit" font-size="12" dy=".8em" y="37.700000047683716" x="585.5">https://juejin.cn/post/6907433588183007245#heading-1</text></g></g><g id="minder_node177" display="none"><g id="node_expander177" display="none" style="cursor: pointer;"><path id="kity_path_21053" fill="white" stroke="gray" d="M553.5,53.5A6,6,0,1,1,541.5,53.5A6,6,0,1,1,553.5,53.5"></path><path id="kity_path_21054" fill="none" stroke="gray"></path></g><path id="node_outline178" fill="none" stroke="none" d="M553.5,44.5h230a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-230a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text178" fill="black"><text id="kity_text_7364" text-rendering="inherit" font-size="12" dy=".8em" y="45.700000047683716" x="553.5">基于TCP的协议有哪些，基于UDP的有哪些</text></g></g><g id="minder_node178" display="none"><g id="node_expander176" display="none" style="cursor: pointer;"><path id="kity_path_21050" fill="white" stroke="gray" d="M569.5,53.5A6,6,0,1,1,557.5,53.5A6,6,0,1,1,569.5,53.5"></path><path id="kity_path_21051" fill="none" stroke="gray"></path></g><path id="node_outline177" fill="none" stroke="none" d="M569.5,26.5h785a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-785a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text177" fill="black"><text id="kity_text_7360" text-rendering="inherit" font-size="12" dy=".8em" y="27.700000047683716" x="569.5">1.基于tcp的有&#xa0; http（超文本传输协议 默认端口80）&#xa0; ftp（文件传输协议，默认端口20） smtp（简单邮件传输协议，默认端口25） ssh（端口22）</text><text id="kity_text_7361" text-rendering="inherit" font-size="12" dy=".8em" y="45.700000047683716" x="569.5">2.基于udp的有 dns(域名服务)&#xa0; &#xa0;tftp(简单文件传输协议)</text><text id="kity_text_7362" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="569.5">3.基于tcp协议的都用&#xa0; C/S模式， 客户端/服务器</text></g></g><g id="minder_node179" display="none"><g id="node_expander175" display="none" style="cursor: pointer;"><path id="kity_path_21047" fill="white" stroke="gray" d="M585.5,53.5A6,6,0,1,1,573.5,53.5A6,6,0,1,1,585.5,53.5"></path><path id="kity_path_21048" fill="none" stroke="gray"></path></g><path id="node_outline176" fill="none" stroke="none" d="M510.5,-85.5h200a5,5,0,0,1,5,5v138a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-138a5,5,0,0,1,5,-5z"></path><g id="node_text176" fill="black"><text id="kity_text_7358" text-rendering="inherit" font-size="12" dy=".8em" y="45.700000047683716" x="585.5">分支主题</text></g><image id="kity_image_17015" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210429205336.png" x="510.5" y="-82.5" width="200" height="125"></image></g><g id="minder_node180" display="none"><g id="node_expander174" display="none" style="cursor: pointer;"><path id="kity_path_21044" fill="white" stroke="gray" d="M601.5,53.5A6,6,0,1,1,589.5,53.5A6,6,0,1,1,601.5,53.5"></path><path id="kity_path_21045" fill="none" stroke="gray"></path></g><path id="node_outline175" fill="none" stroke="none" d="M601.5,44.5h333a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text175" fill="black"><text id="kity_text_7356" text-rendering="inherit" font-size="12" dy=".8em" y="45.700000047683716" x="601.5">https://blog.csdn.net/boyaaboy/article/details/102566522</text></g></g><g id="minder_node181" display="none"><g id="node_expander179" display="none" style="cursor: pointer;"><path id="kity_path_21059" fill="white" stroke="gray" d="M553.5,61.5A6,6,0,1,1,541.5,61.5A6,6,0,1,1,553.5,61.5"></path><path id="kity_path_21060" fill="none" stroke="gray"></path></g><path id="node_outline180" fill="none" stroke="none" d="M553.5,52.5h140a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-140a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text180" fill="black"><text id="kity_text_7368" text-rendering="inherit" font-size="12" dy=".8em" y="53.700000047683716" x="553.5">tcp的端口是为了区分什么</text></g></g><g id="minder_node182" display="none"><g id="node_expander178" display="none" style="cursor: pointer;"><path id="kity_path_21056" fill="white" stroke="gray" d="M569.5,61.5A6,6,0,1,1,557.5,61.5A6,6,0,1,1,569.5,61.5"></path><path id="kity_path_21057" fill="none" stroke="gray"></path></g><path id="node_outline179" fill="none" stroke="none" d="M569.5,52.5h851a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-851a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text179" fill="black"><text id="kity_text_7366" text-rendering="inherit" font-size="12" dy=".8em" y="53.700000047683716" x="569.5">端口号就是唯一的表示这些进程的编号。(进程：运行着的程序)端口号有16位，0到65535，一共有2^16个端口号。通过端口号可以找到计算机运行的应用程序。</text></g></g><g id="minder_node183" display="none"><g id="node_expander206" display="none" style="cursor: pointer;"><path id="kity_path_21140" fill="white" stroke="gray" d="M537.5,69.5A6,6,0,1,1,525.5,69.5A6,6,0,1,1,537.5,69.5"></path><path id="kity_path_21141" fill="none" stroke="gray"></path></g><path id="node_outline207" fill="none" stroke="none" d="M537.5,60.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text207" fill="black"><text id="kity_text_7444" text-rendering="inherit" font-size="12" dy=".8em" y="61.700000047683716" x="537.5">基础</text></g></g><g id="minder_node184" display="none"><g id="node_expander184" display="none" style="cursor: pointer;"><path id="kity_path_21074" fill="white" stroke="gray" d="M553.5,-2.5A6,6,0,1,1,541.5,-2.5A6,6,0,1,1,553.5,-2.5"></path><path id="kity_path_21075" fill="none" stroke="gray"></path></g><path id="node_outline185" fill="none" stroke="none" d="M553.5,-11.5h201a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-201a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text185" fill="black"><text id="kity_text_7383" text-rendering="inherit" font-size="12" dy=".8em" y="-10.299999952316284" x="553.5">TCP、UDP和HTTP和TCP/IP的关系？</text></g></g><g id="minder_node185" display="none"><g id="node_expander183" display="none" style="cursor: pointer;"><path id="kity_path_21071" fill="white" stroke="gray" d="M569.5,-2.5A6,6,0,1,1,557.5,-2.5A6,6,0,1,1,569.5,-2.5"></path><path id="kity_path_21072" fill="none" stroke="gray"></path></g><path id="node_outline184" fill="none" stroke="none" d="M569.5,-56.5h788a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-788a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text184" fill="black"><text id="kity_text_7376" text-rendering="inherit" font-size="12" dy=".8em" y="-55.299999952316284" x="569.5">1.TCP/IP是个协议组，可分为三个层次：网络层(ip协议，ARP协议，RARP协议等)、传输层(TCP协议 UDP协议)和应用层(FTP HTTP&#xa0; SMTP协议等)。</text><text id="kity_text_7377" text-rendering="inherit" font-size="12" dy=".8em" y="-37.299999952316284" x="569.5">2.HTTP本身也是一个协议，建立在请求/响应模型上的，是从Web服务器传输超文本到本地浏览器的传送协议。</text><text id="kity_text_7378" text-rendering="inherit" font-size="12" dy=".8em" y="-19.299999952316284" x="569.5">3.首先由客户建立一条与服务器的TCP链接，并发送一个请求到服务器，请求中包含请求方法、URI、协议版本以及相关的MIME样式的消息。</text><text id="kity_text_7379" text-rendering="inherit" font-size="12" dy=".8em" y="-1.2999999523162842" x="569.5">服务器响应一个状态行，包含消息的协议版本、一个成功和失败码以及相关的MIME式样的消息。</text><text id="kity_text_7380" text-rendering="inherit" font-size="12" dy=".8em" y="16.700000047683716" x="569.5">4.一次TCP链接的建立将需要3次握手。</text><text id="kity_text_7381" text-rendering="inherit" font-size="12" dy=".8em" y="34.700000047683716" x="569.5">5.http基于tcp</text></g></g><g id="minder_node186" display="none"><g id="node_expander182" display="none" style="cursor: pointer;"><path id="kity_path_21068" fill="white" stroke="gray" d="M585.5,-2.5A6,6,0,1,1,573.5,-2.5A6,6,0,1,1,585.5,-2.5"></path><path id="kity_path_21069" fill="none" stroke="gray"></path></g><path id="node_outline183" fill="none" stroke="none" d="M510.5,-105.5h200a5,5,0,0,1,5,5v102a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-102a5,5,0,0,1,5,-5z"></path><g id="node_text183" fill="black"><text id="kity_text_7374" text-rendering="inherit" font-size="12" dy=".8em" y="-10.299999952316284" x="585.5">分支主题</text></g><image id="kity_image_17016" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210429205208.png" x="510.5" y="-102.5" width="200" height="89"></image></g><g id="minder_node187" display="none"><g id="node_expander181" display="none" style="cursor: pointer;"><path id="kity_path_21065" fill="white" stroke="gray" d="M601.5,-2.5A6,6,0,1,1,589.5,-2.5A6,6,0,1,1,601.5,-2.5"></path><path id="kity_path_21066" fill="none" stroke="gray"></path></g><path id="node_outline182" fill="none" stroke="none" d="M601.5,-11.5h333a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text182" fill="black"><text id="kity_text_7372" text-rendering="inherit" font-size="12" dy=".8em" y="-10.299999952316284" x="601.5">https://blog.csdn.net/boyaaboy/article/details/102566522</text></g></g><g id="minder_node188" display="none"><g id="node_expander186" display="none" style="cursor: pointer;"><path id="kity_path_21080" fill="white" stroke="gray" d="M553.5,5.5A6,6,0,1,1,541.5,5.5A6,6,0,1,1,553.5,5.5"></path><path id="kity_path_21081" fill="none" stroke="gray"></path></g><path id="node_outline187" fill="none" stroke="none" d="M553.5,-3.5h181a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-181a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text187" fill="black"><text id="kity_text_7388" text-rendering="inherit" font-size="12" dy=".8em" y="-2.299999952316284" x="553.5">说说你们项目中是怎么解决跨域的</text></g></g><g id="minder_node189" display="none"><g id="node_expander185" display="none" style="cursor: pointer;"><path id="kity_path_21077" fill="white" stroke="gray" d="M569.5,5.5A6,6,0,1,1,557.5,5.5A6,6,0,1,1,569.5,5.5"></path><path id="kity_path_21078" fill="none" stroke="gray"></path></g><path id="node_outline186" fill="none" stroke="none" d="M569.5,-12.5h320a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-320a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text186" fill="black"><text id="kity_text_7385" text-rendering="inherit" font-size="12" dy=".8em" y="-11.299999952316284" x="569.5">1.springboot可以用一个注解@CrossOrigin 在controller上</text><text id="kity_text_7386" text-rendering="inherit" font-size="12" dy=".8em" y="6.700000047683716" x="569.5">2.用gateway网关&#xa0; 通过&#xa0;CorsConfiguration 来配置跨域</text></g></g><g id="minder_node190" display="none"><g id="node_expander189" display="none" style="cursor: pointer;"><path id="kity_path_21089" fill="white" stroke="gray" d="M553.5,13.5A6,6,0,1,1,541.5,13.5A6,6,0,1,1,553.5,13.5"></path><path id="kity_path_21090" fill="none" stroke="gray"></path></g><path id="node_outline190" fill="none" stroke="none" d="M553.5,4.5h219a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-219a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text190" fill="black"><text id="kity_text_7398" text-rendering="inherit" font-size="12" dy=".8em" y="5.700000047683716" x="553.5">你怎么判断网络上发送的拥塞 重传&#xa0; 失序&#xa0;</text></g></g><g id="minder_node191" display="none"><g id="node_expander188" display="none" style="cursor: pointer;"><path id="kity_path_21086" fill="white" stroke="gray" d="M569.5,13.5A6,6,0,1,1,557.5,13.5A6,6,0,1,1,569.5,13.5"></path><path id="kity_path_21087" fill="none" stroke="gray"></path></g><path id="node_outline189" fill="none" stroke="none" d="M569.5,-31.5h1043a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1043a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text189" fill="black"><text id="kity_text_7392" text-rendering="inherit" font-size="12" dy=".8em" y="-30.299999952316284" x="569.5">你怎么判断网络上发送的拥塞 重传&#xa0; 失序&#xa0;</text><text id="kity_text_7393" text-rendering="inherit" font-size="12" dy=".8em" y="-12.299999952316284" x="569.5">1.拥塞：发送端判断网络发生拥塞的依据是：发送端设置一个重传计时器RTO，对于某个已发出的数据报文段，如果在RTO计时到期后，还没有收到来自接收端的确认，则认为此时网络发生了拥塞。</text><text id="kity_text_7394" text-rendering="inherit" font-size="12" dy=".8em" y="5.700000047683716" x="569.5">如果网络得吞吐量随着网络负载的增大反而下降，那么网络就可能进入拥塞状态。</text><text id="kity_text_7395" text-rendering="inherit" font-size="12" dy=".8em" y="23.700000047683716" x="569.5">2.重传：通过抓包分析TCP重传</text><text id="kity_text_7396" text-rendering="inherit" font-size="12" dy=".8em" y="41.700000047683716" x="569.5">3.失序：查看网络丢包率</text></g></g><g id="minder_node192" display="none"><g id="node_expander187" display="none" style="cursor: pointer;"><path id="kity_path_21083" fill="white" stroke="gray" d="M585.5,13.5A6,6,0,1,1,573.5,13.5A6,6,0,1,1,585.5,13.5"></path><path id="kity_path_21084" fill="none" stroke="gray"></path></g><path id="node_outline188" fill="none" stroke="none" d="M585.5,4.5h242a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-242a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text188" fill="black"><text id="kity_text_7390" text-rendering="inherit" font-size="12" dy=".8em" y="5.700000047683716" x="585.5">https://www.jianshu.com/p/9fc60e49dde7</text></g></g><g id="minder_node193" display="none"><g id="node_expander191" display="none" style="cursor: pointer;"><path id="kity_path_21095" fill="white" stroke="gray" d="M553.5,21.5A6,6,0,1,1,541.5,21.5A6,6,0,1,1,553.5,21.5"></path><path id="kity_path_21096" fill="none" stroke="gray"></path></g><path id="node_outline192" fill="none" stroke="none" d="M553.5,12.5h154a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-154a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text192" fill="black"><text id="kity_text_7402" text-rendering="inherit" font-size="12" dy=".8em" y="13.700000047683716" x="553.5">tcp的接收窗口 是0 会怎么样</text></g></g><g id="minder_node194" display="none"><g id="node_expander190" display="none" style="cursor: pointer;"><path id="kity_path_21092" fill="white" stroke="gray" d="M569.5,21.5A6,6,0,1,1,557.5,21.5A6,6,0,1,1,569.5,21.5"></path><path id="kity_path_21093" fill="none" stroke="gray"></path></g><path id="node_outline191" fill="none" stroke="none" d="M569.5,12.5h550a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-550a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text191" fill="black"><text id="kity_text_7400" text-rendering="inherit" font-size="12" dy=".8em" y="13.700000047683716" x="569.5">1.接收窗口是用于流量控制的， 是接收方告诉发送方还有多大的缓存接收区，0就不要传了，传也是阻塞</text></g></g><g id="minder_node195" display="none"><g id="node_expander194" display="none" style="cursor: pointer;"><path id="kity_path_21104" fill="white" stroke="gray" d="M553.5,29.5A6,6,0,1,1,541.5,29.5A6,6,0,1,1,553.5,29.5"></path><path id="kity_path_21105" fill="none" stroke="gray"></path></g><path id="node_outline195" fill="none" stroke="none" d="M553.5,20.5h212a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-212a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text195" fill="black"><text id="kity_text_7415" text-rendering="inherit" font-size="12" dy=".8em" y="21.700000047683716" x="553.5">tcp粘包知道吗，是在哪一层，如何解决</text></g></g><g id="minder_node196" display="none"><g id="node_expander193" display="none" style="cursor: pointer;"><path id="kity_path_21101" fill="white" stroke="gray" d="M569.5,29.5A6,6,0,1,1,557.5,29.5A6,6,0,1,1,569.5,29.5"></path><path id="kity_path_21102" fill="none" stroke="gray"></path></g><path id="node_outline194" fill="none" stroke="none" d="M569.5,-42.5h659a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-659a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text194" fill="black"><text id="kity_text_7406" text-rendering="inherit" font-size="12" dy=".8em" y="-41.299999952316284" x="569.5">1.发送在网络层，为什么会TCP粘包 是因为数据到了tcp层是做流式传输。没有边界。</text><text id="kity_text_7407" text-rendering="inherit" font-size="12" dy=".8em" y="-23.299999952316284" x="569.5">TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</text><text id="kity_text_7408" text-rendering="inherit" font-size="12" dy=".8em" y="-5.299999952316284" x="569.5">2.原因：</text><text id="kity_text_7409" text-rendering="inherit" font-size="12" dy=".8em" y="12.700000047683716" x="569.5">(1)多个进程使用一个TCP连接 而导致多种不同结构的数据进到TCP的流式传输，边界分割而导致的问题</text><text id="kity_text_7410" text-rendering="inherit" font-size="12" dy=".8em" y="30.700000047683716" x="569.5">(2)数据包过大；应用进程缓冲区的一条消息的字节的大小超过了发送缓冲区的大小</text><text id="kity_text_7411" text-rendering="inherit" font-size="12" dy=".8em" y="48.700000047683716" x="569.5">(3)接收方不及时接收缓冲区的包，造成多个包接收</text><text id="kity_text_7412" text-rendering="inherit" font-size="12" dy=".8em" y="66.70000004768372" x="569.5">(4)流量控制，拥塞控制也可能导致粘包</text><text id="kity_text_7413" text-rendering="inherit" font-size="12" dy=".8em" y="84.70000004768372" x="569.5">3.尾部标记序列;头部标记分步接收,在TCP报文的头部加上表示数据长度;关闭Nagle 算法(把多个很小的包合在一起发送)</text></g></g><g id="minder_node197" display="none"><g id="node_expander192" display="none" style="cursor: pointer;"><path id="kity_path_21098" fill="white" stroke="gray" d="M585.5,29.5A6,6,0,1,1,573.5,29.5A6,6,0,1,1,585.5,29.5"></path><path id="kity_path_21099" fill="none" stroke="gray"></path></g><path id="node_outline193" fill="none" stroke="none" d="M585.5,20.5h326a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text193" fill="black"><text id="kity_text_7404" text-rendering="inherit" font-size="12" dy=".8em" y="21.700000047683716" x="585.5">https://juejin.cn/post/6844904089684279303#heading-6</text></g></g><g id="minder_node198" display="none"><g id="node_expander196" display="none" style="cursor: pointer;"><path id="kity_path_21110" fill="white" stroke="gray" d="M553.5,37.5A6,6,0,1,1,541.5,37.5A6,6,0,1,1,553.5,37.5"></path><path id="kity_path_21111" fill="none" stroke="gray"></path></g><path id="node_outline197" fill="none" stroke="none" d="M553.5,28.5h89a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-89a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text197" fill="black"><text id="kity_text_7419" text-rendering="inherit" font-size="12" dy=".8em" y="29.700000047683716" x="553.5">安全协议有哪些&#xa0;</text></g></g><g id="minder_node199" display="none"><g id="node_expander195" display="none" style="cursor: pointer;"><path id="kity_path_21107" fill="white" stroke="gray" d="M569.5,37.5A6,6,0,1,1,557.5,37.5A6,6,0,1,1,569.5,37.5"></path><path id="kity_path_21108" fill="none" stroke="gray"></path></g><path id="node_outline196" fill="none" stroke="none" d="M569.5,28.5h82a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-82a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text196" fill="black"><text id="kity_text_7417" text-rendering="inherit" font-size="12" dy=".8em" y="29.700000047683716" x="569.5">1.SSL;SSH;TLS;</text></g></g><g id="minder_node200" display="none"><g id="node_expander198" display="none" style="cursor: pointer;"><path id="kity_path_21116" fill="white" stroke="gray" d="M553.5,45.5A6,6,0,1,1,541.5,45.5A6,6,0,1,1,553.5,45.5"></path><path id="kity_path_21117" fill="none" stroke="gray"></path></g><path id="node_outline199" fill="none" stroke="none" d="M553.5,36.5h86a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-86a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text199" fill="black"><text id="kity_text_7425" text-rendering="inherit" font-size="12" dy=".8em" y="37.700000047683716" x="553.5">DNS协议了解吗</text></g></g><g id="minder_node201" display="none"><g id="node_expander197" display="none" style="cursor: pointer;"><path id="kity_path_21113" fill="white" stroke="gray" d="M569.5,45.5A6,6,0,1,1,557.5,45.5A6,6,0,1,1,569.5,45.5"></path><path id="kity_path_21114" fill="none" stroke="gray"></path></g><path id="node_outline198" fill="none" stroke="none" d="M569.5,18.5h638a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-638a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text198" fill="black"><text id="kity_text_7421" text-rendering="inherit" font-size="12" dy=".8em" y="19.700000047683716" x="569.5">1.DNS协议就是域名或IP解析协议</text><text id="kity_text_7422" text-rendering="inherit" font-size="12" dy=".8em" y="37.700000047683716" x="569.5">输入的URL通常都是一个域名，计算机不认识域名只知道IP，所以需要DNS解析通过域名查询得到对应IP，DNS解析流程</text><text id="kity_text_7423" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="569.5">(1)查看浏览器DNS缓存；(2)查看本地DNS缓存；（3）询问递归式DNS服务器；（4）从权威DNS服务器 找记录</text></g></g><g id="minder_node202" display="none"><g id="node_expander200" display="none" style="cursor: pointer;"><path id="kity_path_21122" fill="white" stroke="gray" d="M553.5,53.5A6,6,0,1,1,541.5,53.5A6,6,0,1,1,553.5,53.5"></path><path id="kity_path_21123" fill="none" stroke="gray"></path></g><path id="node_outline201" fill="none" stroke="none" d="M553.5,44.5h124a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-124a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text201" fill="black"><text id="kity_text_7430" text-rendering="inherit" font-size="12" dy=".8em" y="45.700000047683716" x="553.5">SSL和TSL的区别知道吗</text></g></g><g id="minder_node203" display="none"><g id="node_expander199" display="none" style="cursor: pointer;"><path id="kity_path_21119" fill="white" stroke="gray" d="M569.5,53.5A6,6,0,1,1,557.5,53.5A6,6,0,1,1,569.5,53.5"></path><path id="kity_path_21120" fill="none" stroke="gray"></path></g><path id="node_outline200" fill="none" stroke="none" d="M569.5,35.5h739a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-739a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text200" fill="black"><text id="kity_text_7427" text-rendering="inherit" font-size="12" dy=".8em" y="36.700000047683716" x="569.5">1.SSL：是一种可靠的面向连接的一种协议层，位于网络层协议和应用层协议之间。通过数字签名，加密确保客户端和服务器之间的安全通讯</text><text id="kity_text_7428" text-rendering="inherit" font-size="12" dy=".8em" y="54.700000047683716" x="569.5">2.TSL 是传输层安全协议 两个应用程序之间提供保密性和数据完整性。</text></g></g><g id="minder_node204" display="none"><g id="node_expander203" display="none" style="cursor: pointer;"><path id="kity_path_21131" fill="white" stroke="gray" d="M553.5,61.5A6,6,0,1,1,541.5,61.5A6,6,0,1,1,553.5,61.5"></path><path id="kity_path_21132" fill="none" stroke="gray"></path></g><path id="node_outline204" fill="none" stroke="none" d="M553.5,52.5h142a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-142a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text204" fill="black"><text id="kity_text_7436" text-rendering="inherit" font-size="12" dy=".8em" y="53.700000047683716" x="553.5">SSL/TSL协议建立连接过程</text></g></g><g id="minder_node205" display="none"><g id="node_expander202" display="none" style="cursor: pointer;"><path id="kity_path_21128" fill="white" stroke="gray" d="M569.5,61.5A6,6,0,1,1,557.5,61.5A6,6,0,1,1,569.5,61.5"></path><path id="kity_path_21129" fill="none" stroke="gray"></path></g><path id="node_outline203" fill="none" stroke="none" d="M569.5,52.5h188a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-188a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text203" fill="black"><text id="kity_text_7434" text-rendering="inherit" font-size="12" dy=".8em" y="53.700000047683716" x="569.5">1.SSL创建过程就是HTTPS加密过程</text></g></g><g id="minder_node206" display="none"><g id="node_expander201" display="none" style="cursor: pointer;"><path id="kity_path_21125" fill="white" stroke="gray" d="M585.5,61.5A6,6,0,1,1,573.5,61.5A6,6,0,1,1,585.5,61.5"></path><path id="kity_path_21126" fill="none" stroke="gray"></path></g><path id="node_outline202" fill="none" stroke="none" d="M585.5,52.5h333a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text202" fill="black"><text id="kity_text_7432" text-rendering="inherit" font-size="12" dy=".8em" y="53.700000047683716" x="585.5">https://juejin.cn/post/6844904132067885064#heading-20</text></g></g><g id="minder_node207" display="none"><g id="node_expander205" display="none" style="cursor: pointer;"><path id="kity_path_21137" fill="white" stroke="gray" d="M553.5,69.5A6,6,0,1,1,541.5,69.5A6,6,0,1,1,553.5,69.5"></path><path id="kity_path_21138" fill="none" stroke="gray"></path></g><path id="node_outline206" fill="none" stroke="none" d="M553.5,60.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text206" fill="black"><text id="kity_text_7442" text-rendering="inherit" font-size="12" dy=".8em" y="61.700000047683716" x="553.5">你知道有哪些常见的状态码</text></g></g><g id="minder_node208" display="none"><g id="node_expander204" display="none" style="cursor: pointer;"><path id="kity_path_21134" fill="white" stroke="gray" d="M569.5,69.5A6,6,0,1,1,557.5,69.5A6,6,0,1,1,569.5,69.5"></path><path id="kity_path_21135" fill="none" stroke="gray"></path></g><path id="node_outline205" fill="none" stroke="none" d="M569.5,42.5h807a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-807a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text205" fill="black"><text id="kity_text_7438" text-rendering="inherit" font-size="12" dy=".8em" y="43.700000047683716" x="569.5">1.1xx 是协议处理中状态&#xa0; 2xx 是成功 204是请求处理都是没有资源返回&#xa0; 3xx 是重定向&#xa0; 301是永久重定向&#xa0; 302是临时重定向</text><text id="kity_text_7439" text-rendering="inherit" font-size="12" dy=".8em" y="61.700000047683716" x="569.5">4xx 是请求报文错误，403请求的对应资源禁止被访问， 404找不到服务器资源， 405请求方法不允许 413 请求体数据过大 429是客户端发送的请求过多</text><text id="kity_text_7440" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="569.5">5xx是服务端错误 501服务器内部错误。503 服务器正忙。</text></g></g><g id="minder_node209" display="none"><g id="node_expander217" display="none" style="cursor: pointer;"><path id="kity_path_21173" fill="white" stroke="gray" d="M537.5,77.5A6,6,0,1,1,525.5,77.5A6,6,0,1,1,537.5,77.5"></path><path id="kity_path_21174" fill="none" stroke="gray"></path></g><path id="node_outline218" fill="none" stroke="none" d="M537.5,68.5h11a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-11a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text218" fill="black"><text id="kity_text_7479" text-rendering="inherit" font-size="12" dy=".8em" y="69.70000004768372" x="537.5">io</text></g></g><g id="minder_node210" display="none"><g id="node_expander208" display="none" style="cursor: pointer;"><path id="kity_path_21146" fill="white" stroke="gray" d="M553.5,37.5A6,6,0,1,1,541.5,37.5A6,6,0,1,1,553.5,37.5"></path><path id="kity_path_21147" fill="none" stroke="gray"></path></g><path id="node_outline209" fill="none" stroke="none" d="M553.5,28.5h132a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-132a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text209" fill="black"><text id="kity_text_7456" text-rendering="inherit" font-size="12" dy=".8em" y="29.700000047683716" x="553.5">知道网络io模型有哪些吗</text></g></g><g id="minder_node211" display="none"><g id="node_expander207" display="none" style="cursor: pointer;"><path id="kity_path_21143" fill="white" stroke="gray" d="M569.5,37.5A6,6,0,1,1,557.5,37.5A6,6,0,1,1,569.5,37.5"></path><path id="kity_path_21144" fill="none" stroke="gray"></path></g><path id="node_outline208" fill="none" stroke="none" d="M569.5,-43.5h1300a5,5,0,0,1,5,5v152a5,5,0,0,1,-5,5h-1300a5,5,0,0,1,-5,-5v-152a5,5,0,0,1,5,-5z"></path><g id="node_text208" fill="black"><text id="kity_text_7446" text-rendering="inherit" font-size="12" dy=".8em" y="-42.299999952316284" x="569.5">1.有五种io模型</text><text id="kity_text_7447" text-rendering="inherit" font-size="12" dy=".8em" y="-24.299999952316284" x="569.5">2.同步阻塞IO(BIO):用户线程通过系统调用read发起IO读操作，由用户空间转到内核空间。此时用户线程在内核的IO操作阻塞。内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作。</text><text id="kity_text_7448" text-rendering="inherit" font-size="12" dy=".8em" y="-6.299999952316284" x="569.5">Java io从文件中读取内容或者向文件中写入数据均使用此模型；从sokect读取数据或者向socket中写入数据也使用此模型。</text><text id="kity_text_7449" text-rendering="inherit" font-size="12" dy=".8em" y="11.700000047683716" x="569.5">3.同步非阻塞IO（NIO）:默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为NONBLOCK。用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。</text><text id="kity_text_7450" text-rendering="inherit" font-size="12" dy=".8em" y="29.700000047683716" x="569.5">第一阶段：用户进程没有阻塞，也就是没有挂起，它一值在询问数据有没有到达内核缓冲区中，等待；</text><text id="kity_text_7451" text-rendering="inherit" font-size="12" dy=".8em" y="47.700000047683716" x="569.5">第二个阶段：数据从内核缓存区复制到用户进程空间，是阻塞的。</text><text id="kity_text_7452" text-rendering="inherit" font-size="12" dy=".8em" y="65.70000004768372" x="569.5">4.IO多路复用：当一个线程执行从Channel读取数据的IO操作时，如果有数据，则返回数据；如果没数据，不需要阻塞，而是可以直接返回。</text><text id="kity_text_7453" text-rendering="inherit" font-size="12" dy=".8em" y="83.70000004768372" x="569.5">5.信号驱动IO：应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的</text><text id="kity_text_7454" text-rendering="inherit" font-size="12" dy=".8em" y="101.70000004768372" x="569.5">6.异步非阻塞IO：应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</text></g></g><g id="minder_node212" display="none"><g id="node_expander210" display="none" style="cursor: pointer;"><path id="kity_path_21152" fill="white" stroke="gray" d="M553.5,45.5A6,6,0,1,1,541.5,45.5A6,6,0,1,1,553.5,45.5"></path><path id="kity_path_21153" fill="none" stroke="gray"></path></g><path id="node_outline211" fill="none" stroke="none" d="M553.5,36.5h84a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-84a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text211" fill="black"><text id="kity_text_7464" text-rendering="inherit" font-size="12" dy=".8em" y="37.700000047683716" x="553.5">说说io多路复用</text></g></g><g id="minder_node213" display="none"><g id="node_expander209" display="none" style="cursor: pointer;"><path id="kity_path_21149" fill="white" stroke="gray" d="M569.5,45.5A6,6,0,1,1,557.5,45.5A6,6,0,1,1,569.5,45.5"></path><path id="kity_path_21150" fill="none" stroke="gray"></path></g><path id="node_outline210" fill="none" stroke="none" d="M569.5,0.5h1091a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1091a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text210" fill="black"><text id="kity_text_7458" text-rendering="inherit" font-size="12" dy=".8em" y="1.7000000476837158" x="569.5">1.当用户线程调用IO操作，用户线程不直接访问 内核 ，而是进行 select/poll/epoll（多路复用器）系统调用。需要将目标网络连接，提前注册到 select/poll/epoll 的可查询 socket 列表中（由 内核完成）。</text><text id="kity_text_7459" text-rendering="inherit" font-size="12" dy=".8em" y="19.700000047683716" x="569.5">用户线程进行 select/poll/epoll 系统调用，线程阻塞，kernel 会查询所有 select/poll/epoll 的可查询 socket 列表，当任何一个 socket 中的数据准备好了，select/poll/epoll 就会返回。</text><text id="kity_text_7460" text-rendering="inherit" font-size="12" dy=".8em" y="37.700000047683716" x="569.5">用户线程获得了目标连接后，发起IO操作调用，线程阻塞，内核开始复制数据，它就会将数据从内核缓冲区，拷贝到用户缓冲区（用户内存），然后 内核 返回结果。</text><text id="kity_text_7461" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="569.5">用户线程才解除 block 的状态，用户线程读取到数据，继续执行。</text><text id="kity_text_7462" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="569.5">2."多路"指的是多个连接；"复用"指的是复用一个进程/线程进行监控。</text></g></g><g id="minder_node214" display="none"><g id="node_expander213" display="none" style="cursor: pointer;"><path id="kity_path_21161" fill="white" stroke="gray" d="M553.5,53.5A6,6,0,1,1,541.5,53.5A6,6,0,1,1,553.5,53.5"></path><path id="kity_path_21162" fill="none" stroke="gray"></path></g><path id="node_outline214" fill="none" stroke="none" d="M553.5,44.5h131a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-131a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text214" fill="black"><text id="kity_text_7471" text-rendering="inherit" font-size="12" dy=".8em" y="45.700000047683716" x="553.5">io多路复用有什么优缺点</text></g></g><g id="minder_node215" display="none"><g id="node_expander212" display="none" style="cursor: pointer;"><path id="kity_path_21158" fill="white" stroke="gray" d="M569.5,53.5A6,6,0,1,1,557.5,53.5A6,6,0,1,1,569.5,53.5"></path><path id="kity_path_21159" fill="none" stroke="gray"></path></g><path id="node_outline213" fill="none" stroke="none" d="M569.5,35.5h1087a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1087a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text213" fill="black"><text id="kity_text_7468" text-rendering="inherit" font-size="12" dy=".8em" y="36.700000047683716" x="569.5">1.优点:用 select/poll/epoll 的优势在于，它可以同时处理成千上万个连接（connection）。与一条线程维护一个连接相比，I/O 多路复用不必创建线程，也不必维护这些线程，从而大大减小了系统的开销。</text><text id="kity_text_7469" text-rendering="inherit" font-size="12" dy=".8em" y="54.700000047683716" x="569.5">2.缺点：本质上，select/poll/epoll 系统调用，属于同步 IO，也是阻塞 IO，需要在读写事件就绪后，自己负责进行读写，也就是说这个读写过程是阻塞的。</text></g></g><g id="minder_node216" display="none"><g id="node_expander211" display="none" style="cursor: pointer;"><path id="kity_path_21155" fill="white" stroke="gray" d="M585.5,53.5A6,6,0,1,1,573.5,53.5A6,6,0,1,1,585.5,53.5"></path><path id="kity_path_21156" fill="none" stroke="gray"></path></g><path id="node_outline212" fill="none" stroke="none" d="M544.5,-35.5h200a5,5,0,0,1,5,5v88a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-88a5,5,0,0,1,5,-5z"></path><g id="node_text212" fill="black"><text id="kity_text_7466" text-rendering="inherit" font-size="12" dy=".8em" y="45.700000047683716" x="585.5">IO多路复用(来自网络)</text></g><image id="kity_image_17017" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210420144946.png" x="544.5" y="-32.5" width="200" height="75" xlink:title="IO多路复用图(来自网络)"></image></g><g id="minder_node217" display="none"><g id="node_expander214" display="none" style="cursor: pointer;"><path id="kity_path_21164" fill="white" stroke="gray" d="M553.5,61.5A6,6,0,1,1,541.5,61.5A6,6,0,1,1,553.5,61.5"></path><path id="kity_path_21165" fill="none" stroke="gray"></path></g><path id="node_outline215" fill="none" stroke="none" d="M553.5,52.5h84a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-84a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text215" fill="black"><text id="kity_text_7473" text-rendering="inherit" font-size="12" dy=".8em" y="53.700000047683716" x="553.5">多路复用怎么用</text></g></g><g id="minder_node218" display="none"><g id="node_expander215" display="none" style="cursor: pointer;"><path id="kity_path_21167" fill="white" stroke="gray" d="M553.5,69.5A6,6,0,1,1,541.5,69.5A6,6,0,1,1,553.5,69.5"></path><path id="kity_path_21168" fill="none" stroke="gray"></path></g><path id="node_outline216" fill="none" stroke="none" d="M553.5,60.5h156a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-156a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text216" fill="black"><text id="kity_text_7475" text-rendering="inherit" font-size="12" dy=".8em" y="61.700000047683716" x="553.5">你了解哪些io多路复用的场景</text></g></g><g id="minder_node219" display="none"><g id="node_expander216" display="none" style="cursor: pointer;"><path id="kity_path_21170" fill="white" stroke="gray" d="M553.5,77.5A6,6,0,1,1,541.5,77.5A6,6,0,1,1,553.5,77.5"></path><path id="kity_path_21171" fill="none" stroke="gray"></path></g><path id="node_outline217" fill="none" stroke="none" d="M553.5,68.5h72a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-72a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text217" fill="black"><text id="kity_text_7477" text-rendering="inherit" font-size="12" dy=".8em" y="69.70000004768372" x="553.5">什么是异步io</text></g></g><g id="minder_node220" display="none"><g id="node_expander225" display="none" style="cursor: pointer;"><path id="kity_path_21197" fill="white" stroke="gray" d="M537.5,85.5A6,6,0,1,1,525.5,85.5A6,6,0,1,1,537.5,85.5"></path><path id="kity_path_21198" fill="none" stroke="gray"></path></g><path id="node_outline226" fill="none" stroke="none" d="M537.5,76.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text226" fill="black"><text id="kity_text_7500" text-rendering="inherit" font-size="12" dy=".8em" y="77.70000004768372" x="537.5">安全</text></g></g><g id="minder_node221" display="none"><g id="node_expander220" display="none" style="cursor: pointer;"><path id="kity_path_21182" fill="white" stroke="gray" d="M553.5,77.5A6,6,0,1,1,541.5,77.5A6,6,0,1,1,553.5,77.5"></path><path id="kity_path_21183" fill="none" stroke="gray"></path></g><path id="node_outline221" fill="none" stroke="none" d="M553.5,68.5h86a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-86a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text221" fill="black"><text id="kity_text_7485" text-rendering="inherit" font-size="12" dy=".8em" y="69.70000004768372" x="553.5">对称加密是什么</text></g></g><g id="minder_node222" display="none"><g id="node_expander219" display="none" style="cursor: pointer;"><path id="kity_path_21179" fill="white" stroke="gray" d="M569.5,77.5A6,6,0,1,1,557.5,77.5A6,6,0,1,1,569.5,77.5"></path><path id="kity_path_21180" fill="none" stroke="gray"></path></g><path id="node_outline220" fill="none" stroke="none" d="M569.5,68.5h193a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-193a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text220" fill="black"><text id="kity_text_7483" text-rendering="inherit" font-size="12" dy=".8em" y="69.70000004768372" x="569.5">1.发送方和接受收 使用同一把钥匙。</text></g></g><g id="minder_node223" display="none"><g id="node_expander218" display="none" style="cursor: pointer;"><path id="kity_path_21176" fill="white" stroke="gray" d="M585.5,77.5A6,6,0,1,1,573.5,77.5A6,6,0,1,1,585.5,77.5"></path><path id="kity_path_21177" fill="none" stroke="gray"></path></g><path id="node_outline219" fill="none" stroke="none" d="M510.5,2.5h200a5,5,0,0,1,5,5v74a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-74a5,5,0,0,1,5,-5z"></path><g id="node_text219" fill="black"><text id="kity_text_7481" text-rendering="inherit" font-size="12" dy=".8em" y="69.70000004768372" x="585.5">分支主题</text></g><image id="kity_image_17018" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210429115513.png" x="510.5" y="5.5" width="200" height="61"></image></g><g id="minder_node224" display="none"><g id="node_expander224" display="none" style="cursor: pointer;"><path id="kity_path_21194" fill="white" stroke="gray" d="M553.5,85.5A6,6,0,1,1,541.5,85.5A6,6,0,1,1,553.5,85.5"></path><path id="kity_path_21195" fill="none" stroke="gray"></path></g><path id="node_outline225" fill="none" stroke="none" d="M553.5,76.5h98a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-98a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text225" fill="black"><text id="kity_text_7498" text-rendering="inherit" font-size="12" dy=".8em" y="77.70000004768372" x="553.5">非对称加密是什么</text></g></g><g id="minder_node225" display="none"><g id="node_expander223" display="none" style="cursor: pointer;"><path id="kity_path_21191" fill="white" stroke="gray" d="M569.5,85.5A6,6,0,1,1,557.5,85.5A6,6,0,1,1,569.5,85.5"></path><path id="kity_path_21192" fill="none" stroke="gray"></path></g><path id="node_outline224" fill="none" stroke="none" d="M569.5,31.5h958a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-958a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text224" fill="black"><text id="kity_text_7491" text-rendering="inherit" font-size="12" dy=".8em" y="32.700000047683716" x="569.5">1.使用一对非对称密钥，即公钥和私钥，钥可以随意发布，但私钥只有自己知道，发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。</text><text id="kity_text_7492" text-rendering="inherit" font-size="12" dy=".8em" y="50.700000047683716" x="569.5">2.</text><text id="kity_text_7493" text-rendering="inherit" font-size="12" dy=".8em" y="68.70000004768372" x="569.5">(1)A和B 都有自己的公钥和 私钥，然后把自己公钥给对方</text><text id="kity_text_7494" text-rendering="inherit" font-size="12" dy=".8em" y="86.70000004768372" x="569.5">(2)A给B发信息，用B的公钥加密，B收到后用私钥解密。反过来也一样，不需要发送用来解密的私钥。多个用户也只需要保存自己的私钥。</text><text id="kity_text_7495" text-rendering="inherit" font-size="12" dy=".8em" y="104.70000004768372" x="569.5">3.非对称加密的缺点是加解密速度要远远慢于对称加密</text><text id="kity_text_7496" text-rendering="inherit" font-size="12" dy=".8em" y="122.70000004768372" x="569.5">4.还可以通过数字签名确保发送者无法否认曾发送过该信息</text></g></g><g id="minder_node226" display="none"><g id="node_expander221" display="none" style="cursor: pointer;"><path id="kity_path_21185" fill="white" stroke="gray" d="M585.5,77.5A6,6,0,1,1,573.5,77.5A6,6,0,1,1,585.5,77.5"></path><path id="kity_path_21186" fill="none" stroke="gray"></path></g><path id="node_outline222" fill="none" stroke="none" d="M510.5,-24.5h200a5,5,0,0,1,5,5v101a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-101a5,5,0,0,1,5,-5z"></path><g id="node_text222" fill="black"><text id="kity_text_7487" text-rendering="inherit" font-size="12" dy=".8em" y="69.70000004768372" x="585.5">分支主题</text></g><image id="kity_image_17019" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210429120008.png" x="510.5" y="-21.5" width="200" height="88"></image></g><g id="minder_node227" display="none"><g id="node_expander222" display="none" style="cursor: pointer;"><path id="kity_path_21188" fill="white" stroke="gray" d="M585.5,85.5A6,6,0,1,1,573.5,85.5A6,6,0,1,1,585.5,85.5"></path><path id="kity_path_21189" fill="none" stroke="gray"></path></g><path id="node_outline223" fill="none" stroke="none" d="M585.5,76.5h352a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-352a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text223" fill="black"><text id="kity_text_7489" text-rendering="inherit" font-size="12" dy=".8em" y="77.70000004768372" x="585.5">https://blog.csdn.net/ljx1400052550/article/details/79587133</text></g></g><g id="minder_node228" display="none"><g id="node_expander229" display="none" style="cursor: pointer;"><path id="kity_path_21209" fill="white" stroke="gray" d="M537.5,93.5A6,6,0,1,1,525.5,93.5A6,6,0,1,1,537.5,93.5"></path><path id="kity_path_21210" fill="none" stroke="gray"></path></g><path id="node_outline230" fill="none" stroke="none" d="M537.5,84.5h35a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-35a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text230" fill="black"><text id="kity_text_7509" text-rendering="inherit" font-size="12" dy=".8em" y="85.70000004768372" x="537.5">ip方面</text></g></g><g id="minder_node229" display="none"><g id="node_expander228" display="none" style="cursor: pointer;"><path id="kity_path_21206" fill="white" stroke="gray" d="M553.5,93.5A6,6,0,1,1,541.5,93.5A6,6,0,1,1,553.5,93.5"></path><path id="kity_path_21207" fill="none" stroke="gray"></path></g><path id="node_outline229" fill="none" stroke="none" d="M553.5,84.5h96a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-96a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text229" fill="black"><text id="kity_text_7507" text-rendering="inherit" font-size="12" dy=".8em" y="85.70000004768372" x="553.5">ipv4和ipv6的区别</text></g></g><g id="minder_node230" display="none"><g id="node_expander227" display="none" style="cursor: pointer;"><path id="kity_path_21203" fill="white" stroke="gray" d="M569.5,93.5A6,6,0,1,1,557.5,93.5A6,6,0,1,1,569.5,93.5"></path><path id="kity_path_21204" fill="none" stroke="gray"></path></g><path id="node_outline228" fill="none" stroke="none" d="M569.5,75.5h959a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-959a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text228" fill="black"><text id="kity_text_7504" text-rendering="inherit" font-size="12" dy=".8em" y="76.70000004768372" x="569.5">1.主要是IPv4 首部与 IPv6 首部有差别，</text><text id="kity_text_7505" text-rendering="inherit" font-size="12" dy=".8em" y="94.70000004768372" x="569.5">IPv6 取消了首部校验和字段。 因为在数据链路层和传输层都会校验；取消选项字段。 选项字段不再是标准 IP 首部的一部分了；取消了分片/重新组装相关字段，提高路由器转发速度</text></g></g><g id="minder_node231" display="none"><g id="node_expander226" display="none" style="cursor: pointer;"><path id="kity_path_21200" fill="white" stroke="gray" d="M585.5,93.5A6,6,0,1,1,573.5,93.5A6,6,0,1,1,585.5,93.5"></path><path id="kity_path_21201" fill="none" stroke="gray"></path></g><path id="node_outline227" fill="none" stroke="none" d="M585.5,84.5h333a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text227" fill="black"><text id="kity_text_7502" text-rendering="inherit" font-size="12" dy=".8em" y="85.70000004768372" x="585.5">https://juejin.cn/post/6844904147955941384#heading-11</text></g></g><g id="minder_node232" display="none"><g id="node_expander243" display="none" style="cursor: pointer;"><path id="kity_path_21251" fill="white" stroke="gray" d="M537.5,101.5A6,6,0,1,1,525.5,101.5A6,6,0,1,1,537.5,101.5"></path><path id="kity_path_21252" fill="none" stroke="gray"></path></g><path id="node_outline244" fill="none" stroke="none" d="M537.5,92.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text244" fill="black"><text id="kity_text_7540" text-rendering="inherit" font-size="12" dy=".8em" y="93.70000004768372" x="537.5">进阶</text></g></g><g id="minder_node233" display="none"><g id="node_expander231" display="none" style="cursor: pointer;"><path id="kity_path_21215" fill="white" stroke="gray" d="M553.5,69.5A6,6,0,1,1,541.5,69.5A6,6,0,1,1,553.5,69.5"></path><path id="kity_path_21216" fill="none" stroke="gray"></path></g><path id="node_outline232" fill="none" stroke="none" d="M553.5,60.5h222a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-222a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text232" fill="black"><text id="kity_text_7513" text-rendering="inherit" font-size="12" dy=".8em" y="61.700000047683716" x="553.5">TCP连接server端跟client端都有几种状态</text></g></g><g id="minder_node234" display="none"><g id="node_expander230" display="none" style="cursor: pointer;"><path id="kity_path_21212" fill="white" stroke="gray" d="M569.5,69.5A6,6,0,1,1,557.5,69.5A6,6,0,1,1,569.5,69.5"></path><path id="kity_path_21213" fill="none" stroke="gray"></path></g><path id="node_outline231" fill="none" stroke="none" d="M569.5,60.5h126a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-126a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text231" fill="black"><text id="kity_text_7511" text-rendering="inherit" font-size="12" dy=".8em" y="61.700000047683716" x="569.5">1. 看三次握手 四次挥手</text></g></g><g id="minder_node235" display="none"><g id="node_expander234" display="none" style="cursor: pointer;"><path id="kity_path_21224" fill="white" stroke="gray" d="M553.5,77.5A6,6,0,1,1,541.5,77.5A6,6,0,1,1,553.5,77.5"></path><path id="kity_path_21225" fill="none" stroke="gray"></path></g><path id="node_outline235" fill="none" stroke="none" d="M553.5,68.5h351a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-351a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text235" fill="black"><text id="kity_text_7519" text-rendering="inherit" font-size="12" dy=".8em" y="69.70000004768372" x="553.5">linux作为client端可以最多建立多少个tcp连接？作为server端呢？</text></g></g><g id="minder_node236" display="none"><g id="node_expander233" display="none" style="cursor: pointer;"><path id="kity_path_21221" fill="white" stroke="gray" d="M569.5,77.5A6,6,0,1,1,557.5,77.5A6,6,0,1,1,569.5,77.5"></path><path id="kity_path_21222" fill="none" stroke="gray"></path></g><path id="node_outline234" fill="none" stroke="none" d="M569.5,68.5h603a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-603a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text234" fill="black"><text id="kity_text_7517" text-rendering="inherit" font-size="12" dy=".8em" y="69.70000004768372" x="569.5">1.理论上n个，实际中 一个进程 可以维护60000个左右连接&#xa0; 和机器有关系，可以通过系统级参数 进程级参数 调整</text></g></g><g id="minder_node237" display="none"><g id="node_expander232" display="none" style="cursor: pointer;"><path id="kity_path_21218" fill="white" stroke="gray" d="M585.5,77.5A6,6,0,1,1,573.5,77.5A6,6,0,1,1,585.5,77.5"></path><path id="kity_path_21219" fill="none" stroke="gray"></path></g><path id="node_outline233" fill="none" stroke="none" d="M585.5,68.5h259a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-259a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text233" fill="black"><text id="kity_text_7515" text-rendering="inherit" font-size="12" dy=".8em" y="69.70000004768372" x="585.5">https://www.sohu.com/a/441787429_463994</text></g></g><g id="minder_node238" display="none"><g id="node_expander237" display="none" style="cursor: pointer;"><path id="kity_path_21233" fill="white" stroke="gray" d="M553.5,85.5A6,6,0,1,1,541.5,85.5A6,6,0,1,1,553.5,85.5"></path><path id="kity_path_21234" fill="none" stroke="gray"></path></g><path id="node_outline238" fill="none" stroke="none" d="M553.5,76.5h425a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-425a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text238" fill="black"><text id="kity_text_7525" text-rendering="inherit" font-size="12" dy=".8em" y="77.70000004768372" x="553.5">建立tcp连接时，如何connect时候阻塞了，那么怎么能不阻塞，去干别的事情？</text></g></g><g id="minder_node239" display="none"><g id="node_expander236" display="none" style="cursor: pointer;"><path id="kity_path_21230" fill="white" stroke="gray" d="M569.5,85.5A6,6,0,1,1,557.5,85.5A6,6,0,1,1,569.5,85.5"></path><path id="kity_path_21231" fill="none" stroke="gray"></path></g><path id="node_outline237" fill="none" stroke="none" d="M569.5,76.5h287a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-287a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text237" fill="black"><text id="kity_text_7523" text-rendering="inherit" font-size="12" dy=".8em" y="77.70000004768372" x="569.5">1.设置为非阻塞connect。把接口描述符设置成非阻塞;</text></g></g><g id="minder_node240" display="none"><g id="node_expander235" display="none" style="cursor: pointer;"><path id="kity_path_21227" fill="white" stroke="gray" d="M585.5,85.5A6,6,0,1,1,573.5,85.5A6,6,0,1,1,585.5,85.5"></path><path id="kity_path_21228" fill="none" stroke="gray"></path></g><path id="node_outline236" fill="none" stroke="none" d="M585.5,76.5h335a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-335a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text236" fill="black"><text id="kity_text_7521" text-rendering="inherit" font-size="12" dy=".8em" y="77.70000004768372" x="585.5">https://blog.csdn.net/xiaofei0859/article/details/77141575</text></g></g><g id="minder_node241" display="none"><g id="node_expander239" display="none" style="cursor: pointer;"><path id="kity_path_21239" fill="white" stroke="gray" d="M553.5,93.5A6,6,0,1,1,541.5,93.5A6,6,0,1,1,553.5,93.5"></path><path id="kity_path_21240" fill="none" stroke="gray"></path></g><path id="node_outline240" fill="none" stroke="none" d="M553.5,84.5h150a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-150a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text240" fill="black"><text id="kity_text_7529" text-rendering="inherit" font-size="12" dy=".8em" y="85.70000004768372" x="553.5">http keep-alive 有什么作用</text></g></g><g id="minder_node242" display="none"><g id="node_expander238" display="none" style="cursor: pointer;"><path id="kity_path_21236" fill="white" stroke="gray" d="M569.5,93.5A6,6,0,1,1,557.5,93.5A6,6,0,1,1,569.5,93.5"></path><path id="kity_path_21237" fill="none" stroke="gray"></path></g><path id="node_outline239" fill="none" stroke="none" d="M569.5,84.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text239" fill="black"><text id="kity_text_7527" text-rendering="inherit" font-size="12" dy=".8em" y="85.70000004768372" x="569.5">1.长连接 和指定时长</text></g></g><g id="minder_node243" display="none"><g id="node_expander242" display="none" style="cursor: pointer;"><path id="kity_path_21248" fill="white" stroke="gray" d="M553.5,101.5A6,6,0,1,1,541.5,101.5A6,6,0,1,1,553.5,101.5"></path><path id="kity_path_21249" fill="none" stroke="gray"></path></g><path id="node_outline243" fill="none" stroke="none" d="M553.5,92.5h142a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-142a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text243" fill="black"><text id="kity_text_7538" text-rendering="inherit" font-size="12" dy=".8em" y="93.70000004768372" x="553.5">keepalived的VIP漂移原理</text></g></g><g id="minder_node244" display="none"><g id="node_expander241" display="none" style="cursor: pointer;"><path id="kity_path_21245" fill="white" stroke="gray" d="M569.5,101.5A6,6,0,1,1,557.5,101.5A6,6,0,1,1,569.5,101.5"></path><path id="kity_path_21246" fill="none" stroke="gray"></path></g><path id="node_outline242" fill="none" stroke="none" d="M569.5,74.5h938a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-938a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text242" fill="black"><text id="kity_text_7534" text-rendering="inherit" font-size="12" dy=".8em" y="75.70000004768372" x="569.5">1.VRRP协议</text><text id="kity_text_7535" text-rendering="inherit" font-size="12" dy=".8em" y="93.70000004768372" x="569.5">可以把多台物理路由虚拟成一个虚拟路由，然后在虚拟路由内部，同一时间只有一台物理路由器在对外提供服务，里面还有选举算法。主路由失效的时候，备份路由重新进行选举</text><text id="kity_text_7536" text-rendering="inherit" font-size="12" dy=".8em" y="111.70000004768372" x="569.5">2.一般来做集群的中间件</text></g></g><g id="minder_node245" display="none"><g id="node_expander240" display="none" style="cursor: pointer;"><path id="kity_path_21242" fill="white" stroke="gray" d="M585.5,101.5A6,6,0,1,1,573.5,101.5A6,6,0,1,1,585.5,101.5"></path><path id="kity_path_21243" fill="none" stroke="gray"></path></g><path id="node_outline241" fill="none" stroke="none" d="M585.5,83.5h346a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-346a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text241" fill="black"><text id="kity_text_7531" text-rendering="inherit" font-size="12" dy=".8em" y="84.70000004768372" x="585.5">https://blog.csdn.net/L835311324/article/details/82707346</text><text id="kity_text_7532" text-rendering="inherit" font-size="12" dy=".8em" y="102.70000004768372" x="585.5">https://blog.csdn.net/qq_22996201/article/details/98091210</text></g></g><g id="minder_node246" display="none"><g id="node_expander254" display="none" style="cursor: pointer;"><path id="kity_path_21284" fill="white" stroke="gray" d="M537.5,109.5A6,6,0,1,1,525.5,109.5A6,6,0,1,1,537.5,109.5"></path><path id="kity_path_21285" fill="none" stroke="gray"></path></g><path id="node_outline255" fill="none" stroke="none" d="M537.5,100.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text255" fill="black"><text id="kity_text_7565" text-rendering="inherit" font-size="12" dy=".8em" y="101.70000004768372" x="537.5">问题排查和分析</text></g></g><g id="minder_node247" display="none"><g id="node_expander245" display="none" style="cursor: pointer;"><path id="kity_path_21257" fill="white" stroke="gray" d="M553.5,77.5A6,6,0,1,1,541.5,77.5A6,6,0,1,1,553.5,77.5"></path><path id="kity_path_21258" fill="none" stroke="gray"></path></g><path id="node_outline246" fill="none" stroke="none" d="M553.5,68.5h214a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-214a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text246" fill="black"><text id="kity_text_7544" text-rendering="inherit" font-size="12" dy=".8em" y="69.70000004768372" x="553.5">如果线上用户出现502错误你怎么排查？</text></g></g><g id="minder_node248" display="none"><g id="node_expander244" display="none" style="cursor: pointer;"><path id="kity_path_21254" fill="white" stroke="gray" d="M569.5,77.5A6,6,0,1,1,557.5,77.5A6,6,0,1,1,569.5,77.5"></path><path id="kity_path_21255" fill="none" stroke="gray"></path></g><path id="node_outline245" fill="none" stroke="none" d="M569.5,68.5h344a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-344a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text245" fill="black"><text id="kity_text_7542" text-rendering="inherit" font-size="12" dy=".8em" y="69.70000004768372" x="569.5">1.502 Bad Gateway: 服务器自身是正常的，但访问的时候出错了</text></g></g><g id="minder_node249" display="none"><g id="node_expander247" display="none" style="cursor: pointer;"><path id="kity_path_21263" fill="white" stroke="gray" d="M553.5,85.5A6,6,0,1,1,541.5,85.5A6,6,0,1,1,553.5,85.5"></path><path id="kity_path_21264" fill="none" stroke="gray"></path></g><path id="node_outline248" fill="none" stroke="none" d="M553.5,76.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text248" fill="black"><text id="kity_text_7548" text-rendering="inherit" font-size="12" dy=".8em" y="77.70000004768372" x="553.5">项目跨域问题怎么解决的</text></g></g><g id="minder_node250" display="none"><g id="node_expander246" display="none" style="cursor: pointer;"><path id="kity_path_21260" fill="white" stroke="gray" d="M569.5,85.5A6,6,0,1,1,557.5,85.5A6,6,0,1,1,569.5,85.5"></path><path id="kity_path_21261" fill="none" stroke="gray"></path></g><path id="node_outline247" fill="none" stroke="none" d="M569.5,76.5h46a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-46a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text247" fill="black"><text id="kity_text_7546" text-rendering="inherit" font-size="12" dy=".8em" y="77.70000004768372" x="569.5">1.在上面</text></g></g><g id="minder_node251" display="none"><g id="node_expander249" display="none" style="cursor: pointer;"><path id="kity_path_21269" fill="white" stroke="gray" d="M553.5,93.5A6,6,0,1,1,541.5,93.5A6,6,0,1,1,553.5,93.5"></path><path id="kity_path_21270" fill="none" stroke="gray"></path></g><path id="node_outline250" fill="none" stroke="none" d="M553.5,84.5h181a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-181a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text250" fill="black"><text id="kity_text_7552" text-rendering="inherit" font-size="12" dy=".8em" y="85.70000004768372" x="553.5">连接池是长连接和还是短连接好？</text></g></g><g id="minder_node252" display="none"><g id="node_expander248" display="none" style="cursor: pointer;"><path id="kity_path_21266" fill="white" stroke="gray" d="M569.5,93.5A6,6,0,1,1,557.5,93.5A6,6,0,1,1,569.5,93.5"></path><path id="kity_path_21267" fill="none" stroke="gray"></path></g><path id="node_outline249" fill="none" stroke="none" d="M569.5,84.5h214a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-214a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text249" fill="black"><text id="kity_text_7550" text-rendering="inherit" font-size="12" dy=".8em" y="85.70000004768372" x="569.5">1.长，创建连接是比较浪费时间和性能的</text></g></g><g id="minder_node253" display="none"><g id="node_expander251" display="none" style="cursor: pointer;"><path id="kity_path_21275" fill="white" stroke="gray" d="M553.5,101.5A6,6,0,1,1,541.5,101.5A6,6,0,1,1,553.5,101.5"></path><path id="kity_path_21276" fill="none" stroke="gray"></path></g><path id="node_outline252" fill="none" stroke="none" d="M553.5,92.5h192a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-192a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text252" fill="black"><text id="kity_text_7556" text-rendering="inherit" font-size="12" dy=".8em" y="93.70000004768372" x="553.5">了解检测网络抖动导致的数据丢失吗</text></g></g><g id="minder_node254" display="none"><g id="node_expander250" display="none" style="cursor: pointer;"><path id="kity_path_21272" fill="white" stroke="gray" d="M569.5,101.5A6,6,0,1,1,557.5,101.5A6,6,0,1,1,569.5,101.5"></path><path id="kity_path_21273" fill="none" stroke="gray"></path></g><path id="node_outline251" fill="none" stroke="none" d="M569.5,92.5h562a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-562a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text251" fill="black"><text id="kity_text_7554" text-rendering="inherit" font-size="12" dy=".8em" y="93.70000004768372" x="569.5">1.延迟，抖动和丢包率，直接使用ping做测试即可。如果想测量这个值，建议抓100个包测试。简单测试过</text></g></g><g id="minder_node255" display="none"><g id="node_expander253" display="none" style="cursor: pointer;"><path id="kity_path_21281" fill="white" stroke="gray" d="M553.5,109.5A6,6,0,1,1,541.5,109.5A6,6,0,1,1,553.5,109.5"></path><path id="kity_path_21282" fill="none" stroke="gray"></path></g><path id="node_outline254" fill="none" stroke="none" d="M553.5,100.5h192a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-192a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text254" fill="black"><text id="kity_text_7563" text-rendering="inherit" font-size="12" dy=".8em" y="101.70000004768372" x="553.5">TCP通信客户端断开服务端如何判断</text></g></g><g id="minder_node256" display="none"><g id="node_expander252" display="none" style="cursor: pointer;"><path id="kity_path_21278" fill="white" stroke="gray" d="M569.5,109.5A6,6,0,1,1,557.5,109.5A6,6,0,1,1,569.5,109.5"></path><path id="kity_path_21279" fill="none" stroke="gray"></path></g><path id="node_outline253" fill="none" stroke="none" d="M569.5,73.5h834a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-834a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text253" fill="black"><text id="kity_text_7558" text-rendering="inherit" font-size="12" dy=".8em" y="74.70000004768372" x="569.5">检测连接是否丢失的方法大致有两种：keepalive和heart-beat。</text><text id="kity_text_7559" text-rendering="inherit" font-size="12" dy=".8em" y="92.70000004768372" x="569.5">Keepalive它允许连接在空闲的时候双方会发送一些特殊的数据段，并通过响应与否来判断连接是否还存活着。Keepalive适用于清除死亡时间比较长的连接。&#xa0;</text><text id="kity_text_7560" text-rendering="inherit" font-size="12" dy=".8em" y="110.70000004768372" x="569.5">Heart-beat，原理和keepalive类似，发送一个信号给对方，如果多次发送都没有响应的话，则判断连接中断。</text><text id="kity_text_7561" text-rendering="inherit" font-size="12" dy=".8em" y="128.70000004768372" x="569.5">不同点在于，keepalive是tcp实现中内建的机制，是在创建tcp连接时通过设置参数启动keepalive机制；而heart-beat则需要在tcp之上的应用层实现。</text></g></g><g id="minder_node257" display="none"><g id="node_expander256" display="none" style="cursor: pointer;"><path id="kity_path_21290" fill="white" stroke="gray" d="M537.5,117.5A6,6,0,1,1,525.5,117.5A6,6,0,1,1,537.5,117.5"></path><path id="kity_path_21291" fill="none" stroke="gray"></path></g><path id="node_outline257" fill="none" stroke="none" d="M537.5,108.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text257" fill="black"><text id="kity_text_7577" text-rendering="inherit" font-size="12" dy=".8em" y="109.70000004768372" x="537.5">参考文章</text></g></g><g id="minder_node258" display="none"><g id="node_expander255" display="none" style="cursor: pointer;"><path id="kity_path_21287" fill="white" stroke="gray" d="M553.5,117.5A6,6,0,1,1,541.5,117.5A6,6,0,1,1,553.5,117.5"></path><path id="kity_path_21288" fill="none" stroke="gray"></path></g><path id="node_outline256" fill="none" stroke="none" d="M553.5,36.5h270a5,5,0,0,1,5,5v152a5,5,0,0,1,-5,5h-270a5,5,0,0,1,-5,-5v-152a5,5,0,0,1,5,-5z"></path><g id="node_text256" fill="black"><text id="kity_text_7567" text-rendering="inherit" font-size="12" dy=".8em" y="37.700000047683716" x="553.5">1.https://juejin.cn/post/6844904147955941384</text><text id="kity_text_7568" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="553.5">2.https://juejin.cn/post/6844904100035821575</text><text id="kity_text_7569" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="553.5">3.https://juejin.cn/post/6844904070889603085</text><text id="kity_text_7570" text-rendering="inherit" font-size="12" dy=".8em" y="91.70000004768372" x="553.5">4.https://juejin.cn/post/6907433588183007245</text><text id="kity_text_7571" text-rendering="inherit" font-size="12" dy=".8em" y="109.70000004768372" x="553.5">5.https://juejin.cn/post/6844904125692379143</text><text id="kity_text_7572" text-rendering="inherit" font-size="12" dy=".8em" y="127.70000004768372" x="553.5">6.https://juejin.cn/post/6844904155077672968</text><text id="kity_text_7573" text-rendering="inherit" font-size="12" dy=".8em" y="145.70000004768372" x="553.5">7.https://juejin.cn/post/6844904132067885064</text><text id="kity_text_7574" text-rendering="inherit" font-size="12" dy=".8em" y="163.70000004768372" x="553.5">8.https://juejin.cn/post/6885468617580904455</text><text id="kity_text_7575" text-rendering="inherit" font-size="12" dy=".8em" y="181.70000004768372" x="553.5">9.https://juejin.cn/post/6844903592164343821</text></g></g><g id="minder_node259"><g id="node_expander764" style="cursor: pointer;"><path id="kity_path_22814" fill="white" stroke="gray" d="M397.5,159.5A6,6,0,1,1,385.5,159.5A6,6,0,1,1,397.5,159.5"></path><path id="kity_path_22815" fill="none" stroke="gray" d="M387,159.5L396,159.5M391.5,155L391.5,164"></path></g><path id="node_outline765" fill="rgb(239, 238, 246)" stroke="rgb(123, 115, 191)" d="M401.5,146.5h85a3,3,0,0,1,3,3v20a3,3,0,0,1,-3,3h-85a3,3,0,0,1,-3,-3v-20a3,3,0,0,1,3,-3z" stroke-width="1"></path><g id="node_text765" fill="black"><text id="kity_text_9046" text-rendering="inherit" font-size="14" dy=".8em" y="150.40000009536743" x="418.5">3.mysql</text></g></g><g id="minder_node260" display="none"><g id="node_expander310" display="none" style="cursor: pointer;"><path id="kity_path_21452" fill="white" stroke="gray" d="M505.5,71.5A6,6,0,1,1,493.5,71.5A6,6,0,1,1,505.5,71.5"></path><path id="kity_path_21453" fill="none" stroke="gray"></path></g><path id="node_outline311" fill="none" stroke="none" d="M505.5,62.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text311" fill="black"><text id="kity_text_7707" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="505.5">基础</text></g></g><g id="minder_node261" display="none"><g id="node_expander261" display="none" style="cursor: pointer;"><path id="kity_path_21305" fill="white" stroke="gray" d="M521.5,-112.5A6,6,0,1,1,509.5,-112.5A6,6,0,1,1,521.5,-112.5"></path><path id="kity_path_21306" fill="none" stroke="gray"></path></g><path id="node_outline262" fill="none" stroke="none" d="M521.5,-121.5h162a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-162a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text262" fill="black"><text id="kity_text_7590" text-rendering="inherit" font-size="12" dy=".8em" y="-120.29999995231628" x="521.5">说说一条sql在底层的执行流程</text></g></g><g id="minder_node262" display="none"><g id="node_expander260" display="none" style="cursor: pointer;"><path id="kity_path_21302" fill="white" stroke="gray" d="M537.5,-112.5A6,6,0,1,1,525.5,-112.5A6,6,0,1,1,537.5,-112.5"></path><path id="kity_path_21303" fill="none" stroke="gray"></path></g><path id="node_outline261" fill="none" stroke="none" d="M537.5,-148.5h792a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-792a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text261" fill="black"><text id="kity_text_7585" text-rendering="inherit" font-size="12" dy=".8em" y="-147.29999995231628" x="537.5">1.服务器发起一条查询sql指令，</text><text id="kity_text_7586" text-rendering="inherit" font-size="12" dy=".8em" y="-129.29999995231628" x="537.5">2.是否命中查询缓存(mysql8废弃)，命中就直接返回，3.mysql通过关键字进行解析生成解析树，然后预处理判断语法是否规范，列名 表名是否规范等 </text><text id="kity_text_7587" text-rendering="inherit" font-size="12" dy=".8em" y="-111.29999995231628" x="537.5">4. 查询优化器，把生成的解析树解析成执行计划，选择一条最优执行计划，</text><text id="kity_text_7588" text-rendering="inherit" font-size="12" dy=".8em" y="-93.29999995231628" x="537.5">5.调用存储引擎的api，存储引擎执行查询计划 向数据中查询数据 如果允许缓存就把返回的结果放入缓存 并返回结果</text></g></g><g id="minder_node263" display="none"><g id="node_expander259" display="none" style="cursor: pointer;"><path id="kity_path_21299" fill="white" stroke="gray" d="M553.5,-112.5A6,6,0,1,1,541.5,-112.5A6,6,0,1,1,553.5,-112.5"></path><path id="kity_path_21300" fill="none" stroke="gray"></path></g><path id="node_outline260" fill="none" stroke="none" d="M454.5,-258.5h200a5,5,0,0,1,5,5v145a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-145a5,5,0,0,1,5,-5z"></path><g id="node_text260" fill="black"><text id="kity_text_7583" text-rendering="inherit" font-size="12" dy=".8em" y="-120.29999995231628" x="553.5">                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </text></g><image id="kity_image_17021" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210318162032.png" x="454.5" y="-255.5" width="200" height="132"></image></g><g id="minder_node264" display="none"><g id="node_expander258" display="none" style="cursor: pointer;"><path id="kity_path_21296" fill="white" stroke="gray" d="M569.5,-112.5A6,6,0,1,1,557.5,-112.5A6,6,0,1,1,569.5,-112.5"></path><path id="kity_path_21297" fill="none" stroke="gray"></path></g><path id="node_outline259" fill="none" stroke="none" d="M470.5,-276.5h200a5,5,0,0,1,5,5v163a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-163a5,5,0,0,1,5,-5z"></path><g id="node_text259" fill="black"><text id="kity_text_7581" text-rendering="inherit" font-size="12" dy=".8em" y="-120.29999995231628" x="569.5"> </text></g><image id="kity_image_17020" xlink:href="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" x="470.5" y="-273.5" width="200" height="150"></image></g><g id="minder_node265" display="none"><g id="node_expander263" display="none" style="cursor: pointer;"><path id="kity_path_21311" fill="white" stroke="gray" d="M521.5,-104.5A6,6,0,1,1,509.5,-104.5A6,6,0,1,1,521.5,-104.5"></path><path id="kity_path_21312" fill="none" stroke="gray"></path></g><path id="node_outline264" fill="none" stroke="none" d="M521.5,-113.5h54a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-54a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text264" fill="black"><text id="kity_text_7594" text-rendering="inherit" font-size="12" dy=".8em" y="-112.29999995231628" x="521.5">说说ACID</text></g></g><g id="minder_node266" display="none"><g id="node_expander262" display="none" style="cursor: pointer;"><path id="kity_path_21308" fill="white" stroke="gray" d="M537.5,-104.5A6,6,0,1,1,525.5,-104.5A6,6,0,1,1,537.5,-104.5"></path><path id="kity_path_21309" fill="none" stroke="gray"></path></g><path id="node_outline263" fill="none" stroke="none" d="M537.5,-113.5h784a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-784a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text263" fill="black"><text id="kity_text_7592" text-rendering="inherit" font-size="12" dy=".8em" y="-112.29999995231628" x="537.5">分别是事务的四大特性，原子(不可分割) 一致(要么完成要么失败) 隔离(事务之间不影响) 持久(事务commit的影响是持久性的，不被其他因素被影响)</text></g></g><g id="minder_node267" display="none"><g id="node_expander265" display="none" style="cursor: pointer;"><path id="kity_path_21317" fill="white" stroke="gray" d="M521.5,-96.5A6,6,0,1,1,509.5,-96.5A6,6,0,1,1,521.5,-96.5"></path><path id="kity_path_21318" fill="none" stroke="gray"></path></g><path id="node_outline266" fill="none" stroke="none" d="M521.5,-105.5h220a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-220a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text266" fill="black"><text id="kity_text_7598" text-rendering="inherit" font-size="12" dy=".8em" y="-104.29999995231628" x="521.5">为什么建议不要在数据库中使用utf-8编码</text></g></g><g id="minder_node268" display="none"><g id="node_expander264" display="none" style="cursor: pointer;"><path id="kity_path_21314" fill="white" stroke="gray" d="M537.5,-96.5A6,6,0,1,1,525.5,-96.5A6,6,0,1,1,537.5,-96.5"></path><path id="kity_path_21315" fill="none" stroke="gray"></path></g><path id="node_outline265" fill="none" stroke="none" d="M537.5,-105.5h662a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-662a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text265" fill="black"><text id="kity_text_7596" text-rendering="inherit" font-size="12" dy=".8em" y="-104.29999995231628" x="537.5">可以使用utf8mb4，他和utf8在字符集位数不一样，可以理解为utf8mb4是utf8的小升级，utf8没法改，直接出了个utf8mb4</text></g></g><g id="minder_node269" display="none"><g id="node_expander267" display="none" style="cursor: pointer;"><path id="kity_path_21323" fill="white" stroke="gray" d="M521.5,-88.5A6,6,0,1,1,509.5,-88.5A6,6,0,1,1,521.5,-88.5"></path><path id="kity_path_21324" fill="none" stroke="gray"></path></g><path id="node_outline268" fill="none" stroke="none" d="M521.5,-97.5h156a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-156a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text268" fill="black"><text id="kity_text_7602" text-rendering="inherit" font-size="12" dy=".8em" y="-96.29999995231628" x="521.5">知道全局id唯一方式有哪些吗</text></g></g><g id="minder_node270" display="none"><g id="node_expander266" display="none" style="cursor: pointer;"><path id="kity_path_21320" fill="white" stroke="gray" d="M537.5,-88.5A6,6,0,1,1,525.5,-88.5A6,6,0,1,1,537.5,-88.5"></path><path id="kity_path_21321" fill="none" stroke="gray"></path></g><path id="node_outline267" fill="none" stroke="none" d="M537.5,-97.5h785a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-785a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text267" fill="black"><text id="kity_text_7600" text-rendering="inherit" font-size="12" dy=".8em" y="-96.29999995231628" x="537.5">1.id区间隔离，如一台奇数，一台偶数 2.UUID 3.mysql主键自增，4.通过redis的函数，单实例通过incr函数(原子操作)，集群就设置步长&#xa0; 5.雪花算法</text></g></g><g id="minder_node271" display="none"><g id="node_expander269" display="none" style="cursor: pointer;"><path id="kity_path_21329" fill="white" stroke="gray" d="M521.5,-80.5A6,6,0,1,1,509.5,-80.5A6,6,0,1,1,521.5,-80.5"></path><path id="kity_path_21330" fill="none" stroke="gray"></path></g><path id="node_outline270" fill="none" stroke="none" d="M521.5,-89.5h97a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-97a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text270" fill="black"><text id="kity_text_7606" text-rendering="inherit" font-size="12" dy=".8em" y="-88.29999995231628" x="521.5">知道什么是视图吗</text></g></g><g id="minder_node272" display="none"><g id="node_expander268" display="none" style="cursor: pointer;"><path id="kity_path_21326" fill="white" stroke="gray" d="M537.5,-80.5A6,6,0,1,1,525.5,-80.5A6,6,0,1,1,537.5,-80.5"></path><path id="kity_path_21327" fill="none" stroke="gray"></path></g><path id="node_outline269" fill="none" stroke="none" d="M537.5,-89.5h381a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-381a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text269" fill="black"><text id="kity_text_7604" text-rendering="inherit" font-size="12" dy=".8em" y="-88.29999995231628" x="537.5">视图就是内部对我们要查询的再封装，并不是实表(不存储真正的数据)，</text></g></g><g id="minder_node273" display="none"><g id="node_expander271" display="none" style="cursor: pointer;"><path id="kity_path_21335" fill="white" stroke="gray" d="M521.5,-72.5A6,6,0,1,1,509.5,-72.5A6,6,0,1,1,521.5,-72.5"></path><path id="kity_path_21336" fill="none" stroke="gray"></path></g><path id="node_outline272" fill="none" stroke="none" d="M521.5,-81.5h98a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-98a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text272" fill="black"><text id="kity_text_7610" text-rendering="inherit" font-size="12" dy=".8em" y="-80.29999995231628" x="521.5">视图的优缺点说说</text></g></g><g id="minder_node274" display="none"><g id="node_expander270" display="none" style="cursor: pointer;"><path id="kity_path_21332" fill="white" stroke="gray" d="M537.5,-72.5A6,6,0,1,1,525.5,-72.5A6,6,0,1,1,537.5,-72.5"></path><path id="kity_path_21333" fill="none" stroke="gray"></path></g><path id="node_outline271" fill="none" stroke="none" d="M537.5,-81.5h657a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-657a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text271" fill="black"><text id="kity_text_7608" text-rendering="inherit" font-size="12" dy=".8em" y="-80.29999995231628" x="537.5">优点：使用视图可以让我们专注与逻辑，但不提高查询效率 缺点：1.性能消耗，提高sql查询复杂 2.条件限制，牵一发动全身</text></g></g><g id="minder_node275" display="none"><g id="node_expander273" display="none" style="cursor: pointer;"><path id="kity_path_21341" fill="white" stroke="gray" d="M521.5,-64.5A6,6,0,1,1,509.5,-64.5A6,6,0,1,1,521.5,-64.5"></path><path id="kity_path_21342" fill="none" stroke="gray"></path></g><path id="node_outline274" fill="none" stroke="none" d="M521.5,-73.5h97a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-97a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text274" fill="black"><text id="kity_text_7614" text-rendering="inherit" font-size="12" dy=".8em" y="-72.29999995231628" x="521.5">视图的使用场景呢</text></g></g><g id="minder_node276" display="none"><g id="node_expander272" display="none" style="cursor: pointer;"><path id="kity_path_21338" fill="white" stroke="gray" d="M537.5,-64.5A6,6,0,1,1,525.5,-64.5A6,6,0,1,1,537.5,-64.5"></path><path id="kity_path_21339" fill="none" stroke="gray"></path></g><path id="node_outline273" fill="none" stroke="none" d="M537.5,-73.5h563a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-563a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text273" fill="black"><text id="kity_text_7612" text-rendering="inherit" font-size="12" dy=".8em" y="-72.29999995231628" x="537.5">1.重用业务查询sql 2.只用到了表的一部分 3.对使用者来说直接调用即可，不需要知道里面细节 4. 保护数据</text></g></g><g id="minder_node277" display="none"><g id="node_expander275" display="none" style="cursor: pointer;"><path id="kity_path_21347" fill="white" stroke="gray" d="M521.5,-56.5A6,6,0,1,1,509.5,-56.5A6,6,0,1,1,521.5,-56.5"></path><path id="kity_path_21348" fill="none" stroke="gray"></path></g><path id="node_outline276" fill="none" stroke="none" d="M521.5,-65.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text276" fill="black"><text id="kity_text_7618" text-rendering="inherit" font-size="12" dy=".8em" y="-64.29999995231628" x="521.5">知道什么是存储函数吗</text></g></g><g id="minder_node278" display="none"><g id="node_expander274" display="none" style="cursor: pointer;"><path id="kity_path_21344" fill="white" stroke="gray" d="M537.5,-56.5A6,6,0,1,1,525.5,-56.5A6,6,0,1,1,537.5,-56.5"></path><path id="kity_path_21345" fill="none" stroke="gray"></path></g><path id="node_outline275" fill="none" stroke="none" d="M537.5,-65.5h815a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-815a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text275" fill="black"><text id="kity_text_7616" text-rendering="inherit" font-size="12" dy=".8em" y="-64.29999995231628" x="537.5">就是一个预编译的sql，编译一次，调用多次，比如一次查询需要很多sql，那么调用一次存储过程很更好，而且存储过程可以设置权限，然后预编译效率高</text></g></g><g id="minder_node279" display="none"><g id="node_expander277" display="none" style="cursor: pointer;"><path id="kity_path_21353" fill="white" stroke="gray" d="M521.5,-48.5A6,6,0,1,1,509.5,-48.5A6,6,0,1,1,521.5,-48.5"></path><path id="kity_path_21354" fill="none" stroke="gray"></path></g><path id="node_outline278" fill="none" stroke="none" d="M521.5,-57.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text278" fill="black"><text id="kity_text_7622" text-rendering="inherit" font-size="12" dy=".8em" y="-56.299999952316284" x="521.5">存储函数的缺点知道吗</text></g></g><g id="minder_node280" display="none"><g id="node_expander276" display="none" style="cursor: pointer;"><path id="kity_path_21350" fill="white" stroke="gray" d="M537.5,-48.5A6,6,0,1,1,525.5,-48.5A6,6,0,1,1,537.5,-48.5"></path><path id="kity_path_21351" fill="none" stroke="gray"></path></g><path id="node_outline277" fill="none" stroke="none" d="M537.5,-57.5h258a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-258a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text277" fill="black"><text id="kity_text_7620" text-rendering="inherit" font-size="12" dy=".8em" y="-56.299999952316284" x="537.5">1.提高了后期维护难度 2.移植麻烦 3.没法debug&#xa0;</text></g></g><g id="minder_node281" display="none"><g id="node_expander279" display="none" style="cursor: pointer;"><path id="kity_path_21359" fill="white" stroke="gray" d="M521.5,-40.5A6,6,0,1,1,509.5,-40.5A6,6,0,1,1,521.5,-40.5"></path><path id="kity_path_21360" fill="none" stroke="gray"></path></g><path id="node_outline280" fill="none" stroke="none" d="M521.5,-49.5h77a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-77a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text280" fill="black"><text id="kity_text_7626" text-rendering="inherit" font-size="12" dy=".8em" y="-48.299999952316284" x="521.5">sql约束有哪些</text></g></g><g id="minder_node282" display="none"><g id="node_expander278" display="none" style="cursor: pointer;"><path id="kity_path_21356" fill="white" stroke="gray" d="M537.5,-40.5A6,6,0,1,1,525.5,-40.5A6,6,0,1,1,537.5,-40.5"></path><path id="kity_path_21357" fill="none" stroke="gray"></path></g><path id="node_outline279" fill="none" stroke="none" d="M537.5,-49.5h583a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-583a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text279" fill="black"><text id="kity_text_7624" text-rendering="inherit" font-size="12" dy=".8em" y="-48.299999952316284" x="537.5">NOT NULL 不能为空&#xa0; UNIQE 不能重复(一表中可多个) 主键约束(一表中不可重复)&#xa0; 外键约束 CHECK 控制范围</text></g></g><g id="minder_node283" display="none"><g id="node_expander281" display="none" style="cursor: pointer;"><path id="kity_path_21365" fill="white" stroke="gray" d="M521.5,-32.5A6,6,0,1,1,509.5,-32.5A6,6,0,1,1,521.5,-32.5"></path><path id="kity_path_21366" fill="none" stroke="gray"></path></g><path id="node_outline282" fill="none" stroke="none" d="M521.5,-41.5h131a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-131a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text282" fill="black"><text id="kity_text_7630" text-rendering="inherit" font-size="12" dy=".8em" y="-40.299999952316284" x="521.5">知道in 和exists的区别吗</text></g></g><g id="minder_node284" display="none"><g id="node_expander280" display="none" style="cursor: pointer;"><path id="kity_path_21362" fill="white" stroke="gray" d="M537.5,-32.5A6,6,0,1,1,525.5,-32.5A6,6,0,1,1,537.5,-32.5"></path><path id="kity_path_21363" fill="none" stroke="gray"></path></g><path id="node_outline281" fill="none" stroke="none" d="M537.5,-41.5h379a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-379a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text281" fill="black"><text id="kity_text_7628" text-rendering="inherit" font-size="12" dy=".8em" y="-40.299999952316284" x="537.5">in是外表连接内表, 相当于or，exist 是外表循环匹配内表，他会循环n遍</text></g></g><g id="minder_node285" display="none"><g id="node_expander283" display="none" style="cursor: pointer;"><path id="kity_path_21371" fill="white" stroke="gray" d="M521.5,-24.5A6,6,0,1,1,509.5,-24.5A6,6,0,1,1,521.5,-24.5"></path><path id="kity_path_21372" fill="none" stroke="gray"></path></g><path id="node_outline284" fill="none" stroke="none" d="M521.5,-33.5h191a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-191a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text284" fill="black"><text id="kity_text_7634" text-rendering="inherit" font-size="12" dy=".8em" y="-32.299999952316284" x="521.5">知道drop delete truncate的区别吗</text></g></g><g id="minder_node286" display="none"><g id="node_expander282" display="none" style="cursor: pointer;"><path id="kity_path_21368" fill="white" stroke="gray" d="M537.5,-24.5A6,6,0,1,1,525.5,-24.5A6,6,0,1,1,537.5,-24.5"></path><path id="kity_path_21369" fill="none" stroke="gray"></path></g><path id="node_outline283" fill="none" stroke="none" d="M537.5,-33.5h700a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-700a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text283" fill="black"><text id="kity_text_7632" text-rendering="inherit" font-size="12" dy=".8em" y="-32.299999952316284" x="537.5">drop删全部，不可恢复 delete 有删除日志(可回滚)，一条一条删 删数据 不删结构 truncate 不可恢复 删除速度快 表结构在，数据删</text></g></g><g id="minder_node287" display="none"><g id="node_expander285" display="none" style="cursor: pointer;"><path id="kity_path_21377" fill="white" stroke="gray" d="M521.5,-16.5A6,6,0,1,1,509.5,-16.5A6,6,0,1,1,521.5,-16.5"></path><path id="kity_path_21378" fill="none" stroke="gray"></path></g><path id="node_outline286" fill="none" stroke="none" d="M521.5,-25.5h278a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-278a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text286" fill="black"><text id="kity_text_7638" text-rendering="inherit" font-size="12" dy=".8em" y="-24.299999952316284" x="521.5">我数据库表损坏了，可以修复吗，可以的话你怎么办</text></g></g><g id="minder_node288" display="none"><g id="node_expander284" display="none" style="cursor: pointer;"><path id="kity_path_21374" fill="white" stroke="gray" d="M537.5,-16.5A6,6,0,1,1,525.5,-16.5A6,6,0,1,1,537.5,-16.5"></path><path id="kity_path_21375" fill="none" stroke="gray"></path></g><path id="node_outline285" fill="none" stroke="none" d="M537.5,-25.5h762a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-762a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text285" fill="black"><text id="kity_text_7636" text-rendering="inherit" font-size="12" dy=".8em" y="-24.299999952316284" x="537.5">使用myisamchk修复，1.停止服务 2.进入bin目录 3.执行myisamchk –recover [数据库所在路径]/*.MYI&#xa0; 4.REPAIR TABLE table\_name 修复表 </text></g></g><g id="minder_node289" display="none"><g id="node_expander287" display="none" style="cursor: pointer;"><path id="kity_path_21383" fill="white" stroke="gray" d="M521.5,-8.5A6,6,0,1,1,509.5,-8.5A6,6,0,1,1,521.5,-8.5"></path><path id="kity_path_21384" fill="none" stroke="gray"></path></g><path id="node_outline288" fill="none" stroke="none" d="M521.5,-17.5h253a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-253a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text288" fill="black"><text id="kity_text_7642" text-rendering="inherit" font-size="12" dy=".8em" y="-16.299999952316284" x="521.5">数据库运行于哪种状态下可以防止数据的丢失？</text></g></g><g id="minder_node290" display="none"><g id="node_expander286" display="none" style="cursor: pointer;"><path id="kity_path_21380" fill="white" stroke="gray" d="M537.5,-8.5A6,6,0,1,1,525.5,-8.5A6,6,0,1,1,537.5,-8.5"></path><path id="kity_path_21381" fill="none" stroke="gray"></path></g><path id="node_outline287" fill="none" stroke="none" d="M537.5,-17.5h221a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-221a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text287" fill="black"><text id="kity_text_7640" text-rendering="inherit" font-size="12" dy=".8em" y="-16.299999952316284" x="537.5">归档模式中只要归档日志不丢 就可以恢复</text></g></g><g id="minder_node291" display="none"><g id="node_expander289" display="none" style="cursor: pointer;"><path id="kity_path_21389" fill="white" stroke="gray" d="M521.5,-0.5A6,6,0,1,1,509.5,-0.5A6,6,0,1,1,521.5,-0.5"></path><path id="kity_path_21390" fill="none" stroke="gray"></path></g><path id="node_outline290" fill="none" stroke="none" d="M521.5,-9.5h143a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-143a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text290" fill="black"><text id="kity_text_7647" text-rendering="inherit" font-size="12" dy=".8em" y="-8.299999952316284" x="521.5">mysql需要主键吗，为什么</text></g></g><g id="minder_node292" display="none"><g id="node_expander288" display="none" style="cursor: pointer;"><path id="kity_path_21386" fill="white" stroke="gray" d="M537.5,-0.5A6,6,0,1,1,525.5,-0.5A6,6,0,1,1,537.5,-0.5"></path><path id="kity_path_21387" fill="none" stroke="gray"></path></g><path id="node_outline289" fill="none" stroke="none" d="M537.5,-18.5h1056a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1056a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text289" fill="black"><text id="kity_text_7644" text-rendering="inherit" font-size="12" dy=".8em" y="-17.299999952316284" x="537.5">1.有主键时主键索引相当于聚集索引，如果没有指定主键，该表的第一个唯一非空索引被作为聚集索引，如果还没有，内部生成一个包含了ROW_ID值隐式聚簇索引，行都会根据这个ROW_ID排序。</text><text id="kity_text_7645" text-rendering="inherit" font-size="12" dy=".8em" y="0.7000000476837158" x="537.5">2.ROW_ID是一个6个字节，48位单调递增字段。不能被任何查询访问，也不能被内部(如基于行的复制)使用。每生成256次ROW_ID，计数器就会日志写入被刷到磁盘持久化，这些都会引起性能问题。</text></g></g><g id="minder_node293" display="none"><g id="node_expander292" display="none" style="cursor: pointer;"><path id="kity_path_21398" fill="white" stroke="gray" d="M521.5,7.5A6,6,0,1,1,509.5,7.5A6,6,0,1,1,521.5,7.5"></path><path id="kity_path_21399" fill="none" stroke="gray"></path></g><path id="node_outline293" fill="none" stroke="none" d="M521.5,-10.5h229a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-229a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text293" fill="black"><text id="kity_text_7654" text-rendering="inherit" font-size="12" dy=".8em" y="-9.299999952316284" x="521.5">继续上面那个问题，那我可以随机主键吗，</text><text id="kity_text_7655" text-rendering="inherit" font-size="12" dy=".8em" y="8.700000047683716" x="521.5">为什么自增主键</text></g></g><g id="minder_node294" display="none"><g id="node_expander291" display="none" style="cursor: pointer;"><path id="kity_path_21395" fill="white" stroke="gray" d="M537.5,7.5A6,6,0,1,1,525.5,7.5A6,6,0,1,1,537.5,7.5"></path><path id="kity_path_21396" fill="none" stroke="gray"></path></g><path id="node_outline292" fill="none" stroke="none" d="M537.5,-10.5h937a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-937a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text292" fill="black"><text id="kity_text_7651" text-rendering="inherit" font-size="12" dy=".8em" y="-9.299999952316284" x="537.5">1.可以。但是主键顺序插入行数据效率更高。因为页能被更充分的填满。更高效的通过创建一个新的空白页来达到裂变的目的，而不是把页分裂为两半。</text><text id="kity_text_7652" text-rendering="inherit" font-size="12" dy=".8em" y="8.700000047683716" x="537.5">2.而随机&#xa0;所有页都会被频繁写入（每个索引页都有均等的机会被插入），从而导致无法高效的缓存页。并且频繁的裂变还会导致页填充率不理想，从而额外占用很多的磁盘空间。</text></g></g><g id="minder_node295" display="none"><g id="node_expander290" display="none" style="cursor: pointer;"><path id="kity_path_21392" fill="white" stroke="gray" d="M553.5,7.5A6,6,0,1,1,541.5,7.5A6,6,0,1,1,553.5,7.5"></path><path id="kity_path_21393" fill="none" stroke="gray"></path></g><path id="node_outline291" fill="none" stroke="none" d="M553.5,-1.5h332a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-332a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text291" fill="black"><text id="kity_text_7649" text-rendering="inherit" font-size="12" dy=".8em" y="-0.2999999523162842" x="553.5">https://www.cnblogs.com/ZhuChangwu/p/14041410.html</text></g></g><g id="minder_node296" display="none"><g id="node_expander294" display="none" style="cursor: pointer;"><path id="kity_path_21404" fill="white" stroke="gray" d="M521.5,15.5A6,6,0,1,1,509.5,15.5A6,6,0,1,1,521.5,15.5"></path><path id="kity_path_21405" fill="none" stroke="gray"></path></g><path id="node_outline295" fill="none" stroke="none" d="M521.5,6.5h117a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-117a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text295" fill="black"><text id="kity_text_7660" text-rendering="inherit" font-size="12" dy=".8em" y="7.700000047683716" x="521.5">unicode和utf8的区别</text></g></g><g id="minder_node297" display="none"><g id="node_expander293" display="none" style="cursor: pointer;"><path id="kity_path_21401" fill="white" stroke="gray" d="M537.5,15.5A6,6,0,1,1,525.5,15.5A6,6,0,1,1,537.5,15.5"></path><path id="kity_path_21402" fill="none" stroke="gray"></path></g><path id="node_outline294" fill="none" stroke="none" d="M537.5,-2.5h989a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-989a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text294" fill="black"><text id="kity_text_7657" text-rendering="inherit" font-size="12" dy=".8em" y="-1.2999999523162842" x="537.5">1.unicode将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，这是一种所有符号的编码。它是集合，现在规模可以容纳100多万个符号。规定了符号的二进制代码。</text><text id="kity_text_7658" text-rendering="inherit" font-size="12" dy=".8em" y="16.700000047683716" x="537.5">2.UTF-8 是 Unicode 的实现方式之一，是一种变长的编码方式，unicode一个中文字符占2个字节，而UTF-8一个中文字符占3个字节</text></g></g><g id="minder_node298" display="none"><g id="node_expander296" display="none" style="cursor: pointer;"><path id="kity_path_21410" fill="white" stroke="gray" d="M521.5,23.5A6,6,0,1,1,509.5,23.5A6,6,0,1,1,521.5,23.5"></path><path id="kity_path_21411" fill="none" stroke="gray"></path></g><path id="node_outline297" fill="none" stroke="none" d="M521.5,14.5h155a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-155a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text297" fill="black"><text id="kity_text_7665" text-rendering="inherit" font-size="12" dy=".8em" y="15.700000047683716" x="521.5">union和union all有什么区别</text></g></g><g id="minder_node299" display="none"><g id="node_expander295" display="none" style="cursor: pointer;"><path id="kity_path_21407" fill="white" stroke="gray" d="M537.5,23.5A6,6,0,1,1,525.5,23.5A6,6,0,1,1,537.5,23.5"></path><path id="kity_path_21408" fill="none" stroke="gray"></path></g><path id="node_outline296" fill="none" stroke="none" d="M537.5,5.5h517a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-517a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text296" fill="black"><text id="kity_text_7662" text-rendering="inherit" font-size="12" dy=".8em" y="6.700000047683716" x="537.5">1.union会对查询出来的结果集进行去重，而union all 会把结果集全部查询出来，不管有没有重复</text><text id="kity_text_7663" text-rendering="inherit" font-size="12" dy=".8em" y="24.700000047683716" x="537.5">2.union会对查询字段默认排序，而union all 不会，只管把结果集展示出来</text></g></g><g id="minder_node300" display="none"><g id="node_expander298" display="none" style="cursor: pointer;"><path id="kity_path_21416" fill="white" stroke="gray" d="M521.5,31.5A6,6,0,1,1,509.5,31.5A6,6,0,1,1,521.5,31.5"></path><path id="kity_path_21417" fill="none" stroke="gray"></path></g><path id="node_outline299" fill="none" stroke="none" d="M521.5,22.5h168a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-168a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text299" fill="black"><text id="kity_text_7670" text-rendering="inherit" font-size="12" dy=".8em" y="23.700000047683716" x="521.5">&#xa0;in和join怎么选择，有什么区别</text></g></g><g id="minder_node301" display="none"><g id="node_expander297" display="none" style="cursor: pointer;"><path id="kity_path_21413" fill="white" stroke="gray" d="M537.5,31.5A6,6,0,1,1,525.5,31.5A6,6,0,1,1,537.5,31.5"></path><path id="kity_path_21414" fill="none" stroke="gray"></path></g><path id="node_outline298" fill="none" stroke="none" d="M537.5,13.5h821a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-821a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text298" fill="black"><text id="kity_text_7667" text-rendering="inherit" font-size="12" dy=".8em" y="14.700000047683716" x="537.5">1.in会以外层查询的表作为驱动表,用in子查询的话，将外层查询的结果集降下来，降低io次数，降低nested loop循环次数，用小结果集驱动大的结果集。</text><text id="kity_text_7668" text-rendering="inherit" font-size="12" dy=".8em" y="32.700000047683716" x="537.5">2.join查询在有索引条件下,驱动表有索引不会使用到索引,被驱动表建立索引会使用到索引。JOIN走嵌套查询的。小表驱动大表，且通过索引字段进行关联。</text></g></g><g id="minder_node302" display="none"><g id="node_expander300" display="none" style="cursor: pointer;"><path id="kity_path_21422" fill="white" stroke="gray" d="M521.5,39.5A6,6,0,1,1,509.5,39.5A6,6,0,1,1,521.5,39.5"></path><path id="kity_path_21423" fill="none" stroke="gray"></path></g><path id="node_outline301" fill="none" stroke="none" d="M521.5,30.5h170a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-170a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text301" fill="black"><text id="kity_text_7678" text-rendering="inherit" font-size="12" dy=".8em" y="31.700000047683716" x="521.5">什么是驱动表，什么是被驱动表</text></g></g><g id="minder_node303" display="none"><g id="node_expander299" display="none" style="cursor: pointer;"><path id="kity_path_21419" fill="white" stroke="gray" d="M537.5,39.5A6,6,0,1,1,525.5,39.5A6,6,0,1,1,537.5,39.5"></path><path id="kity_path_21420" fill="none" stroke="gray"></path></g><path id="node_outline300" fill="none" stroke="none" d="M537.5,-5.5h426a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-426a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text300" fill="black"><text id="kity_text_7672" text-rendering="inherit" font-size="12" dy=".8em" y="-4.299999952316284" x="537.5">1.当使用left join时，左表是驱动表，右表是被驱动表</text><text id="kity_text_7673" text-rendering="inherit" font-size="12" dy=".8em" y="13.700000047683716" x="537.5">2.当使用right join时，右表时驱动表，左表是驱动表</text><text id="kity_text_7674" text-rendering="inherit" font-size="12" dy=".8em" y="31.700000047683716" x="537.5">3.当使用join时，mysql会选择数据量比较小的表作为驱动表，大表作为被驱动表</text><text id="kity_text_7675" text-rendering="inherit" font-size="12" dy=".8em" y="49.700000047683716" x="537.5">在sql优化中，永远是以小表驱动大表</text><text id="kity_text_7676" text-rendering="inherit" font-size="12" dy=".8em" y="67.70000004768372" x="537.5">可以用explain看sql，第一行的就是驱动表</text></g></g><g id="minder_node304" display="none"><g id="node_expander303" display="none" style="cursor: pointer;"><path id="kity_path_21431" fill="white" stroke="gray" d="M521.5,47.5A6,6,0,1,1,509.5,47.5A6,6,0,1,1,521.5,47.5"></path><path id="kity_path_21432" fill="none" stroke="gray"></path></g><path id="node_outline304" fill="none" stroke="none" d="M521.5,38.5h120a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-120a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text304" fill="black"><text id="kity_text_7687" text-rendering="inherit" font-size="12" dy=".8em" y="39.700000047683716" x="521.5">内连接左连接右连接？</text></g></g><g id="minder_node305" display="none"><g id="node_expander302" display="none" style="cursor: pointer;"><path id="kity_path_21428" fill="white" stroke="gray" d="M537.5,47.5A6,6,0,1,1,525.5,47.5A6,6,0,1,1,537.5,47.5"></path><path id="kity_path_21429" fill="none" stroke="gray"></path></g><path id="node_outline303" fill="none" stroke="none" d="M537.5,11.5h646a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-646a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text303" fill="black"><text id="kity_text_7682" text-rendering="inherit" font-size="12" dy=".8em" y="12.700000047683716" x="537.5">1.左连接 右连接都是外连接，</text><text id="kity_text_7683" text-rendering="inherit" font-size="12" dy=".8em" y="30.700000047683716" x="537.5">内连接 inner join 显示两个表中字段相符的记录，也就是两个表的交集</text><text id="kity_text_7684" text-rendering="inherit" font-size="12" dy=".8em" y="48.700000047683716" x="537.5">左连接left join 会把左表的数据全部展示出来，而右表的数据只会显示符合搜索条件的，不符合的显示null。反之是右连接</text><text id="kity_text_7685" text-rendering="inherit" font-size="12" dy=".8em" y="66.70000004768372" x="537.5">mysql不支持全外连接。</text></g></g><g id="minder_node306" display="none"><g id="node_expander301" display="none" style="cursor: pointer;"><path id="kity_path_21425" fill="white" stroke="gray" d="M553.5,47.5A6,6,0,1,1,541.5,47.5A6,6,0,1,1,553.5,47.5"></path><path id="kity_path_21426" fill="none" stroke="gray"></path></g><path id="node_outline302" fill="none" stroke="none" d="M553.5,38.5h302a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-302a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text302" fill="black"><text id="kity_text_7680" text-rendering="inherit" font-size="12" dy=".8em" y="39.700000047683716" x="553.5">https://blog.csdn.net/plg17/article/details/78758593</text></g></g><g id="minder_node307" display="none"><g id="node_expander305" display="none" style="cursor: pointer;"><path id="kity_path_21437" fill="white" stroke="gray" d="M521.5,55.5A6,6,0,1,1,509.5,55.5A6,6,0,1,1,521.5,55.5"></path><path id="kity_path_21438" fill="none" stroke="gray"></path></g><path id="node_outline306" fill="none" stroke="none" d="M521.5,46.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text306" fill="black"><text id="kity_text_7694" text-rendering="inherit" font-size="12" dy=".8em" y="47.700000047683716" x="521.5">被驱动表有什么优化？</text></g></g><g id="minder_node308" display="none"><g id="node_expander304" display="none" style="cursor: pointer;"><path id="kity_path_21434" fill="white" stroke="gray" d="M537.5,55.5A6,6,0,1,1,525.5,55.5A6,6,0,1,1,537.5,55.5"></path><path id="kity_path_21435" fill="none" stroke="gray"></path></g><path id="node_outline305" fill="none" stroke="none" d="M537.5,19.5h825a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-825a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text305" fill="black"><text id="kity_text_7689" text-rendering="inherit" font-size="12" dy=".8em" y="20.700000047683716" x="537.5">MySQL 表关联的算法会把驱动表的结果集作为循环基础数据，然后一条一条地通过该结果集中的数据作为过滤条件到下一个表中查询数据，然后合并结果。</text><text id="kity_text_7690" text-rendering="inherit" font-size="12" dy=".8em" y="38.700000047683716" x="537.5">如果还有第三个参与Join，则再通过前两个表的Join结果集作为循环基础数据，再一次通过循环查询条件到第三个表中查询数据，如此往复。</text><text id="kity_text_7691" text-rendering="inherit" font-size="12" dy=".8em" y="56.700000047683716" x="537.5">1.以小表驱动大表 for(100){for(10000){}&#xa0; }</text><text id="kity_text_7692" text-rendering="inherit" font-size="12" dy=".8em" y="74.70000004768372" x="537.5">2.给被驱动表建立索引</text></g></g><g id="minder_node309" display="none"><g id="node_expander307" display="none" style="cursor: pointer;"><path id="kity_path_21443" fill="white" stroke="gray" d="M521.5,63.5A6,6,0,1,1,509.5,63.5A6,6,0,1,1,521.5,63.5"></path><path id="kity_path_21444" fill="none" stroke="gray"></path></g><path id="node_outline308" fill="none" stroke="none" d="M521.5,54.5h202a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-202a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text308" fill="black"><text id="kity_text_7700" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="521.5">Mysql dateTime跟timeStamp的区别</text></g></g><g id="minder_node310" display="none"><g id="node_expander306" display="none" style="cursor: pointer;"><path id="kity_path_21440" fill="white" stroke="gray" d="M537.5,63.5A6,6,0,1,1,525.5,63.5A6,6,0,1,1,537.5,63.5"></path><path id="kity_path_21441" fill="none" stroke="gray"></path></g><path id="node_outline307" fill="none" stroke="none" d="M537.5,36.5h633a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-633a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text307" fill="black"><text id="kity_text_7696" text-rendering="inherit" font-size="12" dy=".8em" y="37.700000047683716" x="537.5">1.mysql 日期有三种类型,date,datetime(日期时间类型),timestamp(邮戳类型)</text><text id="kity_text_7697" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="537.5">2.datetime8个字节(存什么拿到的就是什么)，timestamp4个字节(会自动检索当前时区并进行转换)，其他没什么大区别</text><text id="kity_text_7698" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="537.5">3.对于跨时区的业务，要使用自动插入时间或者自动更新时间功能的，可以使用timestamp。</text></g></g><g id="minder_node311" display="none"><g id="node_expander309" display="none" style="cursor: pointer;"><path id="kity_path_21449" fill="white" stroke="gray" d="M521.5,71.5A6,6,0,1,1,509.5,71.5A6,6,0,1,1,521.5,71.5"></path><path id="kity_path_21450" fill="none" stroke="gray"></path></g><path id="node_outline310" fill="none" stroke="none" d="M521.5,62.5h132a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-132a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text310" fill="black"><text id="kity_text_7705" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="521.5">count * 和 1 有什么区别</text></g></g><g id="minder_node312" display="none"><g id="node_expander308" display="none" style="cursor: pointer;"><path id="kity_path_21446" fill="white" stroke="gray" d="M537.5,71.5A6,6,0,1,1,525.5,71.5A6,6,0,1,1,537.5,71.5"></path><path id="kity_path_21447" fill="none" stroke="gray"></path></g><path id="node_outline309" fill="none" stroke="none" d="M537.5,53.5h849a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-849a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text309" fill="black"><text id="kity_text_7702" text-rendering="inherit" font-size="12" dy=".8em" y="54.700000047683716" x="537.5">1.本质上没有什么区别。都遍历了整个表，数据量大应该优化，比如带where，where创索引，业务层对数据拆分查询。减轻db压力，单机mysql QPS 2500左右</text><text id="kity_text_7703" text-rendering="inherit" font-size="12" dy=".8em" y="72.70000004768372" x="537.5">2.可以直接用count(*避免很多麻烦)</text></g></g><g id="minder_node313" display="none"><g id="node_expander326" display="none" style="cursor: pointer;"><path id="kity_path_21500" fill="white" stroke="gray" d="M505.5,79.5A6,6,0,1,1,493.5,79.5A6,6,0,1,1,505.5,79.5"></path><path id="kity_path_21501" fill="none" stroke="gray"></path></g><path id="node_outline327" fill="none" stroke="none" d="M505.5,70.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text327" fill="black"><text id="kity_text_7748" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="505.5">引擎</text></g></g><g id="minder_node314" display="none"><g id="node_expander312" display="none" style="cursor: pointer;"><path id="kity_path_21458" fill="white" stroke="gray" d="M521.5,31.5A6,6,0,1,1,509.5,31.5A6,6,0,1,1,521.5,31.5"></path><path id="kity_path_21459" fill="none" stroke="gray"></path></g><path id="node_outline313" fill="none" stroke="none" d="M521.5,22.5h144a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-144a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text313" fill="black"><text id="kity_text_7711" text-rendering="inherit" font-size="12" dy=".8em" y="23.700000047683716" x="521.5">说说mysql的两个主流引擎</text></g></g><g id="minder_node315" display="none"><g id="node_expander311" display="none" style="cursor: pointer;"><path id="kity_path_21455" fill="white" stroke="gray" d="M537.5,31.5A6,6,0,1,1,525.5,31.5A6,6,0,1,1,537.5,31.5"></path><path id="kity_path_21456" fill="none" stroke="gray"></path></g><path id="node_outline312" fill="none" stroke="none" d="M537.5,22.5h93a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-93a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text312" fill="black"><text id="kity_text_7709" text-rendering="inherit" font-size="12" dy=".8em" y="23.700000047683716" x="537.5">myiasm&#xa0;&#xa0;Innodb</text></g></g><g id="minder_node316" display="none"><g id="node_expander314" display="none" style="cursor: pointer;"><path id="kity_path_21464" fill="white" stroke="gray" d="M521.5,39.5A6,6,0,1,1,509.5,39.5A6,6,0,1,1,521.5,39.5"></path><path id="kity_path_21465" fill="none" stroke="gray"></path></g><path id="node_outline315" fill="none" stroke="none" d="M521.5,30.5h69a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-69a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text315" fill="black"><text id="kity_text_7715" text-rendering="inherit" font-size="12" dy=".8em" y="31.700000047683716" x="521.5">说说myiasm</text></g></g><g id="minder_node317" display="none"><g id="node_expander313" display="none" style="cursor: pointer;"><path id="kity_path_21461" fill="white" stroke="gray" d="M537.5,39.5A6,6,0,1,1,525.5,39.5A6,6,0,1,1,537.5,39.5"></path><path id="kity_path_21462" fill="none" stroke="gray"></path></g><path id="node_outline314" fill="none" stroke="none" d="M537.5,30.5h569a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-569a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text314" fill="black"><text id="kity_text_7713" text-rendering="inherit" font-size="12" dy=".8em" y="31.700000047683716" x="537.5">不支持事务，不支持外键，表锁&#xa0; 存储空间小，备份 恢复方便，查询优innodb。MyISAM索引是非聚簇索引</text></g></g><g id="minder_node318" display="none"><g id="node_expander316" display="none" style="cursor: pointer;"><path id="kity_path_21470" fill="white" stroke="gray" d="M521.5,47.5A6,6,0,1,1,509.5,47.5A6,6,0,1,1,521.5,47.5"></path><path id="kity_path_21471" fill="none" stroke="gray"></path></g><path id="node_outline317" fill="none" stroke="none" d="M521.5,38.5h66a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-66a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text317" fill="black"><text id="kity_text_7721" text-rendering="inherit" font-size="12" dy=".8em" y="39.700000047683716" x="521.5">说说innodb</text></g></g><g id="minder_node319" display="none"><g id="node_expander315" display="none" style="cursor: pointer;"><path id="kity_path_21467" fill="white" stroke="gray" d="M537.5,47.5A6,6,0,1,1,525.5,47.5A6,6,0,1,1,537.5,47.5"></path><path id="kity_path_21468" fill="none" stroke="gray"></path></g><path id="node_outline316" fill="none" stroke="none" d="M537.5,20.5h512a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-512a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text316" fill="black"><text id="kity_text_7717" text-rendering="inherit" font-size="12" dy=".8em" y="21.700000047683716" x="537.5">支持事务支持外键，行锁 占空间因为都在一个文件中，增删改 innodb优，支持hash索引。</text><text id="kity_text_7718" text-rendering="inherit" font-size="12" dy=".8em" y="39.700000047683716" x="537.5">InnoDB索引是聚簇索引。</text><text id="kity_text_7719" text-rendering="inherit" font-size="12" dy=".8em" y="57.700000047683716" x="537.5">InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。 InnoDB 必须要有主键。</text></g></g><g id="minder_node320" display="none"><g id="node_expander318" display="none" style="cursor: pointer;"><path id="kity_path_21476" fill="white" stroke="gray" d="M521.5,55.5A6,6,0,1,1,509.5,55.5A6,6,0,1,1,521.5,55.5"></path><path id="kity_path_21477" fill="none" stroke="gray"></path></g><path id="node_outline319" fill="none" stroke="none" d="M521.5,46.5h243a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-243a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text319" fill="black"><text id="kity_text_7730" text-rendering="inherit" font-size="12" dy=".8em" y="47.700000047683716" x="521.5">说说myisam和innodb的使用场景分别是什么</text></g></g><g id="minder_node321" display="none"><g id="node_expander317" display="none" style="cursor: pointer;"><path id="kity_path_21473" fill="white" stroke="gray" d="M537.5,55.5A6,6,0,1,1,525.5,55.5A6,6,0,1,1,537.5,55.5"></path><path id="kity_path_21474" fill="none" stroke="gray"></path></g><path id="node_outline318" fill="none" stroke="none" d="M537.5,1.5h674a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-674a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text318" fill="black"><text id="kity_text_7723" text-rendering="inherit" font-size="12" dy=".8em" y="2.700000047683716" x="537.5">1.如果没有特别的需求，使用默认的Innodb。MyISAM：以读写插入为主。Innodb：更新（删除）操作为主</text><text id="kity_text_7724" text-rendering="inherit" font-size="12" dy=".8em" y="20.700000047683716" x="537.5">数据库如有外键，选择&#xa0;InnoDB。</text><text id="kity_text_7725" text-rendering="inherit" font-size="12" dy=".8em" y="38.700000047683716" x="537.5">需要事务支持选择 InnoDB。</text><text id="kity_text_7726" text-rendering="inherit" font-size="12" dy=".8em" y="56.700000047683716" x="537.5">如果表中绝大多数都只是读查询，可以考虑 MyISAM，如果既有读写也挺频繁，请使用 InnoDB。</text><text id="kity_text_7727" text-rendering="inherit" font-size="12" dy=".8em" y="74.70000004768372" x="537.5">数据量大，选择 InnoDB，因为其支持事务处理和故障恢复。MyISAM 可能需要几小时或几天来恢复，InnoDB 只需要几分钟。</text><text id="kity_text_7728" text-rendering="inherit" font-size="12" dy=".8em" y="92.70000004768372" x="537.5">需要在线热备份选择 InnoDB。</text></g></g><g id="minder_node322" display="none"><g id="node_expander320" display="none" style="cursor: pointer;"><path id="kity_path_21482" fill="white" stroke="gray" d="M521.5,63.5A6,6,0,1,1,509.5,63.5A6,6,0,1,1,521.5,63.5"></path><path id="kity_path_21483" fill="none" stroke="gray"></path></g><path id="node_outline321" fill="none" stroke="none" d="M521.5,54.5h266a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-266a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text321" fill="black"><text id="kity_text_7734" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="521.5">说说myisam和innodb的锁级别，分别有什么影响</text></g></g><g id="minder_node323" display="none"><g id="node_expander319" display="none" style="cursor: pointer;"><path id="kity_path_21479" fill="white" stroke="gray" d="M537.5,63.5A6,6,0,1,1,525.5,63.5A6,6,0,1,1,537.5,63.5"></path><path id="kity_path_21480" fill="none" stroke="gray"></path></g><path id="node_outline320" fill="none" stroke="none" d="M537.5,54.5h439a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-439a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text320" fill="black"><text id="kity_text_7732" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="537.5">表锁锁表，行锁锁表中的一行，并发度高。innodb行锁基与索引，索引失效升表锁</text></g></g><g id="minder_node324" display="none"><g id="node_expander322" display="none" style="cursor: pointer;"><path id="kity_path_21488" fill="white" stroke="gray" d="M521.5,71.5A6,6,0,1,1,509.5,71.5A6,6,0,1,1,521.5,71.5"></path><path id="kity_path_21489" fill="none" stroke="gray"></path></g><path id="node_outline323" fill="none" stroke="none" d="M521.5,62.5h278a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-278a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text323" fill="black"><text id="kity_text_7740" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="521.5">innodb 和 myisam 的select count(*) 有什么区别吗</text></g></g><g id="minder_node325" display="none"><g id="node_expander321" display="none" style="cursor: pointer;"><path id="kity_path_21485" fill="white" stroke="gray" d="M537.5,71.5A6,6,0,1,1,525.5,71.5A6,6,0,1,1,537.5,71.5"></path><path id="kity_path_21486" fill="none" stroke="gray"></path></g><path id="node_outline322" fill="none" stroke="none" d="M537.5,44.5h342a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-342a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text322" fill="black"><text id="kity_text_7736" text-rendering="inherit" font-size="12" dy=".8em" y="45.700000047683716" x="537.5">1.求表的行数，</text><text id="kity_text_7737" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="537.5">InnoDB：没有保存。select count(*) from table;会扫描全表。</text><text id="kity_text_7738" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="537.5">MyISAM：保存。select count(*) from table;会直接取出该值。</text></g></g><g id="minder_node326" display="none"><g id="node_expander325" display="none" style="cursor: pointer;"><path id="kity_path_21497" fill="white" stroke="gray" d="M521.5,79.5A6,6,0,1,1,509.5,79.5A6,6,0,1,1,521.5,79.5"></path><path id="kity_path_21498" fill="none" stroke="gray"></path></g><path id="node_outline326" fill="none" stroke="none" d="M521.5,70.5h166a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-166a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text326" fill="black"><text id="kity_text_7746" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="521.5">innodb的b+树层高，数据量？</text></g></g><g id="minder_node327" display="none"><g id="node_expander324" display="none" style="cursor: pointer;"><path id="kity_path_21494" fill="white" stroke="gray" d="M537.5,79.5A6,6,0,1,1,525.5,79.5A6,6,0,1,1,537.5,79.5"></path><path id="kity_path_21495" fill="none" stroke="gray"></path></g><path id="node_outline325" fill="none" stroke="none" d="M537.5,70.5h417a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-417a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text325" fill="black"><text id="kity_text_7744" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="537.5">1.innodb一页16kb， B+ 树高度一般为 1-3 层，就能满足千万级的数据存储。</text></g></g><g id="minder_node328" display="none"><g id="node_expander323" display="none" style="cursor: pointer;"><path id="kity_path_21491" fill="white" stroke="gray" d="M553.5,79.5A6,6,0,1,1,541.5,79.5A6,6,0,1,1,553.5,79.5"></path><path id="kity_path_21492" fill="none" stroke="gray"></path></g><path id="node_outline324" fill="none" stroke="none" d="M553.5,70.5h354a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-354a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text324" fill="black"><text id="kity_text_7742" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="553.5">https://blog.csdn.net/qq_41999455/article/details/104946754</text></g></g><g id="minder_node329" display="none"><g id="node_expander364" display="none" style="cursor: pointer;"><path id="kity_path_21614" fill="white" stroke="gray" d="M505.5,87.5A6,6,0,1,1,493.5,87.5A6,6,0,1,1,505.5,87.5"></path><path id="kity_path_21615" fill="none" stroke="gray"></path></g><path id="node_outline365" fill="none" stroke="none" d="M505.5,78.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text365" fill="black"><text id="kity_text_7862" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="505.5">事务</text></g></g><g id="minder_node330" display="none"><g id="node_expander329" display="none" style="cursor: pointer;"><path id="kity_path_21509" fill="white" stroke="gray" d="M521.5,-32.5A6,6,0,1,1,509.5,-32.5A6,6,0,1,1,521.5,-32.5"></path><path id="kity_path_21510" fill="none" stroke="gray"></path></g><path id="node_outline330" fill="none" stroke="none" d="M521.5,-41.5h180a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-180a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text330" fill="black"><text id="kity_text_7757" text-rendering="inherit" font-size="12" dy=".8em" y="-40.299999952316284" x="521.5">说说mysql的事务隔离级别有哪些</text></g></g><g id="minder_node331" display="none"><g id="node_expander328" display="none" style="cursor: pointer;"><path id="kity_path_21506" fill="white" stroke="gray" d="M537.5,-32.5A6,6,0,1,1,525.5,-32.5A6,6,0,1,1,537.5,-32.5"></path><path id="kity_path_21507" fill="none" stroke="gray"></path></g><path id="node_outline329" fill="none" stroke="none" d="M537.5,-68.5h841a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-841a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text329" fill="black"><text id="kity_text_7752" text-rendering="inherit" font-size="12" dy=".8em" y="-67.29999995231628" x="537.5">未提交读（RU）：一个事务提交之前，它的执行结果对其它事务也是可见的，允许读取尚未提交的数据变更 会导致脏读、不可重复读、幻读，</text><text id="kity_text_7753" text-rendering="inherit" font-size="12" dy=".8em" y="-49.299999952316284" x="537.5">提交读（Read Commited）:一个事务只能看见已经提交的事务所作的改变，允许读取并发事务已经提交的数据，解决脏读问题，可能出现不可重复读，幻读。</text><text id="kity_text_7754" text-rendering="inherit" font-size="12" dy=".8em" y="-31.299999952316284" x="537.5">可重复读（RR）可以确保同一个事务在多次读取同样的字段数据时得到相同的结果，除非本身修改了数据，解决不可重复读，脏读，可能幻读。</text><text id="kity_text_7755" text-rendering="inherit" font-size="12" dy=".8em" y="-13.299999952316284" x="537.5">可串行化(seri)：强制事务串行执行</text></g></g><g id="minder_node332" display="none"><g id="node_expander327" display="none" style="cursor: pointer;"><path id="kity_path_21503" fill="white" stroke="gray" d="M553.5,-32.5A6,6,0,1,1,541.5,-32.5A6,6,0,1,1,553.5,-32.5"></path><path id="kity_path_21504" fill="none" stroke="gray"></path></g><path id="node_outline328" fill="none" stroke="none" d="M478.5,-180.5h200a5,5,0,0,1,5,5v147a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-147a5,5,0,0,1,5,-5z"></path><g id="node_text328" fill="black"><text id="kity_text_7750" text-rendering="inherit" font-size="12" dy=".8em" y="-40.299999952316284" x="553.5">分支主题</text></g><image id="kity_image_17022" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210319110701.png" x="478.5" y="-177.5" width="200" height="134"></image></g><g id="minder_node333" display="none"><g id="node_expander332" display="none" style="cursor: pointer;"><path id="kity_path_21518" fill="white" stroke="gray" d="M521.5,-24.5A6,6,0,1,1,509.5,-24.5A6,6,0,1,1,521.5,-24.5"></path><path id="kity_path_21519" fill="none" stroke="gray"></path></g><path id="node_outline333" fill="none" stroke="none" d="M521.5,-33.5h205a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-205a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text333" fill="black"><text id="kity_text_7766" text-rendering="inherit" font-size="12" dy=".8em" y="-32.299999952316284" x="521.5">说说脏读？幻读？不可重复读？脏写？</text></g></g><g id="minder_node334" display="none"><g id="node_expander331" display="none" style="cursor: pointer;"><path id="kity_path_21515" fill="white" stroke="gray" d="M537.5,-24.5A6,6,0,1,1,525.5,-24.5A6,6,0,1,1,537.5,-24.5"></path><path id="kity_path_21516" fill="none" stroke="gray"></path></g><path id="node_outline332" fill="none" stroke="none" d="M537.5,-60.5h1197a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1197a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text332" fill="black"><text id="kity_text_7761" text-rendering="inherit" font-size="12" dy=".8em" y="-59.299999952316284" x="537.5">脏读：事务A读到事务B修改没提交的数据。</text><text id="kity_text_7762" text-rendering="inherit" font-size="12" dy=".8em" y="-41.299999952316284" x="537.5">幻读：事务A中查询集n次查询结果不一样，因为期间被事务B改了，针对insert/delete。</text><text id="kity_text_7763" text-rendering="inherit" font-size="12" dy=".8em" y="-23.299999952316284" x="537.5">不可重复读：在同一个事务中，某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据，发现数据已经发生修改（针对update操作）。</text><text id="kity_text_7764" text-rendering="inherit" font-size="12" dy=".8em" y="-5.299999952316284" x="537.5">脏写：如果一个事务修改了另一个未提交事务修改过的数据，那就意味着发生了脏写(无论哪个隔离级别都不需要脏写)，，我两个事务来写同一行数据，前面的事务反悔了，回滚了。后面的事务明明修改了数据，怎么会写错呢？</text></g></g><g id="minder_node335" display="none"><g id="node_expander330" display="none" style="cursor: pointer;"><path id="kity_path_21512" fill="white" stroke="gray" d="M553.5,-24.5A6,6,0,1,1,541.5,-24.5A6,6,0,1,1,553.5,-24.5"></path><path id="kity_path_21513" fill="none" stroke="gray"></path></g><path id="node_outline331" fill="none" stroke="none" d="M454.5,-96.5h200a5,5,0,0,1,5,5v71a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-71a5,5,0,0,1,5,-5z"></path><g id="node_text331" fill="black"><text id="kity_text_7759" text-rendering="inherit" font-size="12" dy=".8em" y="-32.299999952316284" x="553.5"> </text></g><image id="kity_image_17023" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210319153620.png" x="454.5" y="-93.5" width="200" height="58"></image></g><g id="minder_node336" display="none"><g id="node_expander334" display="none" style="cursor: pointer;"><path id="kity_path_21524" fill="white" stroke="gray" d="M521.5,-16.5A6,6,0,1,1,509.5,-16.5A6,6,0,1,1,521.5,-16.5"></path><path id="kity_path_21525" fill="none" stroke="gray"></path></g><path id="node_outline335" fill="none" stroke="none" d="M521.5,-25.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text335" fill="black"><text id="kity_text_7770" text-rendering="inherit" font-size="12" dy=".8em" y="-24.299999952316284" x="521.5">知道丢失修改吗</text></g></g><g id="minder_node337" display="none"><g id="node_expander333" display="none" style="cursor: pointer;"><path id="kity_path_21521" fill="white" stroke="gray" d="M537.5,-16.5A6,6,0,1,1,525.5,-16.5A6,6,0,1,1,537.5,-16.5"></path><path id="kity_path_21522" fill="none" stroke="gray"></path></g><path id="node_outline334" fill="none" stroke="none" d="M537.5,-25.5h624a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-624a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text334" fill="black"><text id="kity_text_7768" text-rendering="inherit" font-size="12" dy=".8em" y="-24.299999952316284" x="537.5">丢失修改：一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改；</text></g></g><g id="minder_node338" display="none"><g id="node_expander336" display="none" style="cursor: pointer;"><path id="kity_path_21530" fill="white" stroke="gray" d="M521.5,-8.5A6,6,0,1,1,509.5,-8.5A6,6,0,1,1,521.5,-8.5"></path><path id="kity_path_21531" fill="none" stroke="gray"></path></g><path id="node_outline337" fill="none" stroke="none" d="M521.5,-17.5h179a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-179a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text337" fill="black"><text id="kity_text_7774" text-rendering="inherit" font-size="12" dy=".8em" y="-16.299999952316284" x="521.5">mysql的默认事务隔离级别是什么</text></g></g><g id="minder_node339" display="none"><g id="node_expander335" display="none" style="cursor: pointer;"><path id="kity_path_21527" fill="white" stroke="gray" d="M537.5,-8.5A6,6,0,1,1,525.5,-8.5A6,6,0,1,1,537.5,-8.5"></path><path id="kity_path_21528" fill="none" stroke="gray"></path></g><path id="node_outline336" fill="none" stroke="none" d="M537.5,-17.5h170a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-170a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text336" fill="black"><text id="kity_text_7772" text-rendering="inherit" font-size="12" dy=".8em" y="-16.299999952316284" x="537.5">可重复读（Repeatable Read）</text></g></g><g id="minder_node340" display="none"><g id="node_expander339" display="none" style="cursor: pointer;"><path id="kity_path_21539" fill="white" stroke="gray" d="M521.5,-0.5A6,6,0,1,1,509.5,-0.5A6,6,0,1,1,521.5,-0.5"></path><path id="kity_path_21540" fill="none" stroke="gray"></path></g><path id="node_outline340" fill="none" stroke="none" d="M521.5,-9.5h240a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-240a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text340" fill="black"><text id="kity_text_7782" text-rendering="inherit" font-size="12" dy=".8em" y="-8.299999952316284" x="521.5">那你说说事务隔离级别可能出现的几个问题，</text></g></g><g id="minder_node341" display="none"><g id="node_expander338" display="none" style="cursor: pointer;"><path id="kity_path_21536" fill="white" stroke="gray" d="M537.5,-0.5A6,6,0,1,1,525.5,-0.5A6,6,0,1,1,537.5,-0.5"></path><path id="kity_path_21537" fill="none" stroke="gray"></path></g><path id="node_outline339" fill="none" stroke="none" d="M537.5,-27.5h369a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-369a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text339" fill="black"><text id="kity_text_7778" text-rendering="inherit" font-size="12" dy=".8em" y="-26.299999952316284" x="537.5">读未提交会导致脏读，不可重复读，幻读。</text><text id="kity_text_7779" text-rendering="inherit" font-size="12" dy=".8em" y="-8.299999952316284" x="537.5">读已提交可以解决脏读。</text><text id="kity_text_7780" text-rendering="inherit" font-size="12" dy=".8em" y="9.700000047683716" x="537.5">可重复读可避免不可重复读，脏读。可串行化解决幻读(实际上很少用)</text></g></g><g id="minder_node342" display="none"><g id="node_expander337" display="none" style="cursor: pointer;"><path id="kity_path_21533" fill="white" stroke="gray" d="M553.5,-0.5A6,6,0,1,1,541.5,-0.5A6,6,0,1,1,553.5,-0.5"></path><path id="kity_path_21534" fill="none" stroke="gray"></path></g><path id="node_outline338" fill="none" stroke="none" d="M553.5,-14.5h102a5,5,0,0,1,5,5v18a5,5,0,0,1,-5,5h-102a5,5,0,0,1,-5,-5v-18a5,5,0,0,1,5,-5z"></path><g id="node_text338" fill="black"><text id="kity_text_7776" text-rendering="inherit" font-size="12" dy=".8em" y="-8.299999952316284" x="553.5">参考锁的部分</text></g><a id="kity_a_16886" xlink:href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484721&amp;idx=1&amp;sn=410dea1863ba823bec802769e1e6fe8a&amp;chksm=ebd74430dca0cd265a9a91dcb2059e368f43a25f3de578c9dbb105e1fba0947e1fd0b9c2f4ef&amp;token=1676899695&amp;lang=zh_CN###rd" target="_blank" xlink:title="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484721&amp;idx=1&amp;sn=410dea1863ba823bec802769e1e6fe8a&amp;chksm=ebd74430dca0cd265a9a91dcb2059e368f43a25f3de578c9dbb105e1fba0947e1fd0b9c2f4ef&amp;token=1676899695&amp;lang=zh_CN###rd" style="cursor: pointer;"><path id="kity_path_16888" fill="rgba(255, 255, 255, 0)" stroke="none" d="M635.5,-11.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16887" fill="#666" stroke="none" d="M650.114,4.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V-1.666c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C645.766,-4.429,647.168,-5.5,648.836,-5.5h1.278c2.116,0,3.834,1.716,3.834,3.834V0.8899999999999997C653.948,3.007999999999999,652.23,4.724,650.114,4.724zM638.612,-0.3879999999999999c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S648.265,0.8899999999999997,647.558,0.8899999999999997H639.89C639.185,0.8899999999999997,638.612,0.31899999999999995,638.612,-0.3879999999999999zM636.056,-1.666V0.8899999999999997c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H637.334C635.216,4.724,633.5,3.007999999999999,633.5,0.8899999999999997V-1.666C633.5,-3.784,635.216,-5.5,637.334,-5.5h1.278c1.667,0,3.071,1.071,3.599,2.556H637.334C636.629,-2.944,636.056,-2.373,636.056,-1.666z"></path></a></g><g id="minder_node343" display="none"><g id="node_expander341" display="none" style="cursor: pointer;"><path id="kity_path_21545" fill="white" stroke="gray" d="M521.5,7.5A6,6,0,1,1,509.5,7.5A6,6,0,1,1,521.5,7.5"></path><path id="kity_path_21546" fill="none" stroke="gray"></path></g><path id="node_outline342" fill="none" stroke="none" d="M521.5,-1.5h152a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-152a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text342" fill="black"><text id="kity_text_7789" text-rendering="inherit" font-size="12" dy=".8em" y="-0.2999999523162842" x="521.5">说说mvcc，解决了什么问题   </text></g></g><g id="minder_node344" display="none"><g id="node_expander340" display="none" style="cursor: pointer;"><path id="kity_path_21542" fill="white" stroke="gray" d="M537.5,7.5A6,6,0,1,1,525.5,7.5A6,6,0,1,1,537.5,7.5"></path><path id="kity_path_21543" fill="none" stroke="gray"></path></g><path id="node_outline341" fill="none" stroke="none" d="M537.5,-28.5h1053a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1053a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text341" fill="black"><text id="kity_text_7784" text-rendering="inherit" font-size="12" dy=".8em" y="-27.299999952316284" x="537.5">1.MVCC 最大的优点是读不加锁，因此读写不冲突，多次读取只生成一个版本，并发性能好。当读取数据时，MySQL 可以通过隐藏列判断是否需要回滚并找到回滚需要的 undo log，从而实现 MVCC</text><text id="kity_text_7785" text-rendering="inherit" font-size="12" dy=".8em" y="-9.299999952316284" x="537.5">2.MVCC在每行记录后面都保存有两个隐藏的列，用来存储创建版本号和删除版本号。通过版本号减少了锁的争用，提高了系统并发性能；</text><text id="kity_text_7786" text-rendering="inherit" font-size="12" dy=".8em" y="8.700000047683716" x="537.5">3.可以实现提交读和可重复读两种隔离级别，未提交读无需使用MVCC。用MVCC&#xa0;读写、写读都可以并行，写写不可以。</text><text id="kity_text_7787" text-rendering="inherit" font-size="12" dy=".8em" y="26.700000047683716" x="537.5">4.innodb下解决了快照读的幻读问题,mvcc相当于读的一个快照，非阻塞读</text></g></g><g id="minder_node345" display="none"><g id="node_expander344" display="none" style="cursor: pointer;"><path id="kity_path_21554" fill="white" stroke="gray" d="M521.5,15.5A6,6,0,1,1,509.5,15.5A6,6,0,1,1,521.5,15.5"></path><path id="kity_path_21555" fill="none" stroke="gray"></path></g><path id="node_outline345" fill="none" stroke="none" d="M521.5,6.5h92a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-92a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text345" fill="black"><text id="kity_text_7798" text-rendering="inherit" font-size="12" dy=".8em" y="7.700000047683716" x="521.5">说说mvcc的原理</text></g></g><g id="minder_node346" display="none"><g id="node_expander343" display="none" style="cursor: pointer;"><path id="kity_path_21551" fill="white" stroke="gray" d="M537.5,15.5A6,6,0,1,1,525.5,15.5A6,6,0,1,1,537.5,15.5"></path><path id="kity_path_21552" fill="none" stroke="gray"></path></g><path id="node_outline344" fill="none" stroke="none" d="M537.5,-20.5h941a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-941a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text344" fill="black"><text id="kity_text_7793" text-rendering="inherit" font-size="12" dy=".8em" y="-19.299999952316284" x="537.5">1.MVCC是基于ReadView版本链和undo log原理。</text><text id="kity_text_7794" text-rendering="inherit" font-size="12" dy=".8em" y="-1.2999999523162842" x="537.5">在使用提交读、可重复读这两种隔离级别的事务在执行普通的SELECT操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。</text><text id="kity_text_7795" text-rendering="inherit" font-size="12" dy=".8em" y="16.700000047683716" x="537.5">RC每一次普通查询生成ReadView,RR第一次普通查询生成ReadView,之后重复使用</text><text id="kity_text_7796" text-rendering="inherit" font-size="12" dy=".8em" y="34.700000047683716" x="537.5">2.:undo log 中记录某行数据的多个版本的数据。read view :用来判断当前版本数据的可见性</text></g></g><g id="minder_node347" display="none"><g id="node_expander342" display="none" style="cursor: pointer;"><path id="kity_path_21548" fill="white" stroke="gray" d="M553.5,15.5A6,6,0,1,1,541.5,15.5A6,6,0,1,1,553.5,15.5"></path><path id="kity_path_21549" fill="none" stroke="gray"></path></g><path id="node_outline343" fill="none" stroke="none" d="M478.5,-103.5h200a5,5,0,0,1,5,5v118a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-118a5,5,0,0,1,5,-5z"></path><g id="node_text343" fill="black"><text id="kity_text_7791" text-rendering="inherit" font-size="12" dy=".8em" y="7.700000047683716" x="553.5">分支主题</text></g><image id="kity_image_17024" xlink:href="https://user-gold-cdn.xitu.io/2019/4/19/16a33e277a98dbec?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" x="478.5" y="-100.5" width="200" height="105"></image></g><g id="minder_node348" display="none"><g id="node_expander345" display="none" style="cursor: pointer;"><path id="kity_path_21557" fill="white" stroke="gray" d="M521.5,23.5A6,6,0,1,1,509.5,23.5A6,6,0,1,1,521.5,23.5"></path><path id="kity_path_21558" fill="none" stroke="gray"></path></g><path id="node_outline346" fill="none" stroke="none" d="M521.5,14.5h144a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-144a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text346" fill="black"><text id="kity_text_7800" text-rendering="inherit" font-size="12" dy=".8em" y="15.700000047683716" x="521.5">mysql mvcc 双写机制说说</text></g></g><g id="minder_node349" display="none"><g id="node_expander347" display="none" style="cursor: pointer;"><path id="kity_path_21563" fill="white" stroke="gray" d="M521.5,31.5A6,6,0,1,1,509.5,31.5A6,6,0,1,1,521.5,31.5"></path><path id="kity_path_21564" fill="none" stroke="gray"></path></g><path id="node_outline348" fill="none" stroke="none" d="M521.5,22.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text348" fill="black"><text id="kity_text_7808" text-rendering="inherit" font-size="12" dy=".8em" y="23.700000047683716" x="521.5">知道事务调度有哪几种吗</text></g></g><g id="minder_node350" display="none"><g id="node_expander346" display="none" style="cursor: pointer;"><path id="kity_path_21560" fill="white" stroke="gray" d="M537.5,31.5A6,6,0,1,1,525.5,31.5A6,6,0,1,1,537.5,31.5"></path><path id="kity_path_21561" fill="none" stroke="gray"></path></g><path id="node_outline347" fill="none" stroke="none" d="M537.5,-13.5h1122a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1122a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text347" fill="black"><text id="kity_text_7802" text-rendering="inherit" font-size="12" dy=".8em" y="-12.299999952316284" x="537.5">1.InnoDB使用竞争感知事务调度（CATS）算法对等待锁的事务进行优先级排序。当多个事务正在等待同一对象上的锁时，CATS算法将确定哪个事务首先接收到该锁。</text><text id="kity_text_7803" text-rendering="inherit" font-size="12" dy=".8em" y="5.700000047683716" x="537.5">CATS算法通过分配调度权重来确定等待的事务的优先级，调度权是基于事务阻止的事务数来计算的。</text><text id="kity_text_7804" text-rendering="inherit" font-size="12" dy=".8em" y="23.700000047683716" x="537.5">例如，如果两个事务正在等待对同一对象的锁定，则为阻塞最多事务的事务分配更大的调度权重。如果权重相等，则优先考虑等待时间最长的事务。</text><text id="kity_text_7805" text-rendering="inherit" font-size="12" dy=".8em" y="41.700000047683716" x="537.5">在MySQL 8.之前，InnoDB还使用先进先出（FIFO）算法来调度事务，并且CATS算法仅在重锁争用下使用。</text><text id="kity_text_7806" text-rendering="inherit" font-size="12" dy=".8em" y="59.700000047683716" x="537.5">MySQL 8.0.20中的CATS算法增强功能使FIFO算法变得多余，从而可以删除它。从MySQL 8.0.20开始，以前由FIFO算法执行的事务调度由CATS算法执行。在某些情况下，此更改可能会影响授予事务锁定的顺序。</text></g></g><g id="minder_node351" display="none"><g id="node_expander350" display="none" style="cursor: pointer;"><path id="kity_path_21572" fill="white" stroke="gray" d="M521.5,39.5A6,6,0,1,1,509.5,39.5A6,6,0,1,1,521.5,39.5"></path><path id="kity_path_21573" fill="none" stroke="gray"></path></g><path id="node_outline351" fill="none" stroke="none" d="M521.5,30.5h192a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-192a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text351" fill="black"><text id="kity_text_7820" text-rendering="inherit" font-size="12" dy=".8em" y="31.700000047683716" x="521.5">当前读和快照读是什么，有什么区别</text></g></g><g id="minder_node352" display="none"><g id="node_expander349" display="none" style="cursor: pointer;"><path id="kity_path_21569" fill="white" stroke="gray" d="M537.5,39.5A6,6,0,1,1,525.5,39.5A6,6,0,1,1,537.5,39.5"></path><path id="kity_path_21570" fill="none" stroke="gray"></path></g><path id="node_outline350" fill="none" stroke="none" d="M537.5,-23.5h629a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-629a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text350" fill="black"><text id="kity_text_7812" text-rendering="inherit" font-size="12" dy=".8em" y="-22.299999952316284" x="537.5">1.select...lock in share mode (共享读锁)　　</text><text id="kity_text_7813" text-rendering="inherit" font-size="12" dy=".8em" y="-4.299999952316284" x="537.5">select...for update</text><text id="kity_text_7814" text-rendering="inherit" font-size="12" dy=".8em" y="13.700000047683716" x="537.5">update , delete , insert</text><text id="kity_text_7815" text-rendering="inherit" font-size="12" dy=".8em" y="31.700000047683716" x="537.5">当前读, 读取的是最新版本数据, 并且对读取的记录加锁, 阻塞其他事务同时改动相同记录，避免出现安全问题。</text><text id="kity_text_7816" text-rendering="inherit" font-size="12" dy=".8em" y="49.700000047683716" x="537.5">2.&#xa0;快照读 单纯的select操作，读的是别事务的提交的快照数据，可能并不是最新的数据，因为可能数据改了但是没提交&#xa0;</text><text id="kity_text_7817" text-rendering="inherit" font-size="12" dy=".8em" y="67.70000004768372" x="537.5">Read Committed隔离级别：每次select都生成一个快照读。</text><text id="kity_text_7818" text-rendering="inherit" font-size="12" dy=".8em" y="85.70000004768372" x="537.5">Read Repeatable隔离级别：开启事务后第一个select语句才是快照读的地方，而不是一开启事务就快照读。</text></g></g><g id="minder_node353" display="none"><g id="node_expander348" display="none" style="cursor: pointer;"><path id="kity_path_21566" fill="white" stroke="gray" d="M553.5,39.5A6,6,0,1,1,541.5,39.5A6,6,0,1,1,553.5,39.5"></path><path id="kity_path_21567" fill="none" stroke="gray"></path></g><path id="node_outline349" fill="none" stroke="none" d="M553.5,30.5h374a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-374a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text349" fill="black"><text id="kity_text_7810" text-rendering="inherit" font-size="12" dy=".8em" y="31.700000047683716" x="553.5">https://blog.csdn.net/weixin_42030357/article/details/106877489</text></g></g><g id="minder_node354" display="none"><g id="node_expander352" display="none" style="cursor: pointer;"><path id="kity_path_21578" fill="white" stroke="gray" d="M521.5,47.5A6,6,0,1,1,509.5,47.5A6,6,0,1,1,521.5,47.5"></path><path id="kity_path_21579" fill="none" stroke="gray"></path></g><path id="node_outline353" fill="none" stroke="none" d="M521.5,38.5h132a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-132a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text353" fill="black"><text id="kity_text_7828" text-rendering="inherit" font-size="12" dy=".8em" y="39.700000047683716" x="521.5">当前读和快照读的实现？</text></g></g><g id="minder_node355" display="none"><g id="node_expander351" display="none" style="cursor: pointer;"><path id="kity_path_21575" fill="white" stroke="gray" d="M537.5,47.5A6,6,0,1,1,525.5,47.5A6,6,0,1,1,537.5,47.5"></path><path id="kity_path_21576" fill="none" stroke="gray"></path></g><path id="node_outline352" fill="none" stroke="none" d="M537.5,2.5h1359a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1359a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text352" fill="black"><text id="kity_text_7822" text-rendering="inherit" font-size="12" dy=".8em" y="3.700000047683716" x="537.5">1.快照读：undolog和多版本并发控制MVCC，如事务会先使用“排他锁”锁定改行，将该行当前的值复制到undo log中，然后再真正地修改当前行的值，最后填写事务的DB_TRX_ID，使用回滚指针DB_ROLL_PTR指向undo log中修改前的行DB_ROW_ID。</text><text id="kity_text_7823" text-rendering="inherit" font-size="12" dy=".8em" y="21.700000047683716" x="537.5">2.当前读，读取的是最新版本，并且需要先获取对应记录的锁。通过 next-key 锁(行记录锁+间隙锁)来是实现的。更新数据时，都是先读后写，而这个读，就是当前读。读取数据时，读取该条数据的已经提交的最新的事务，生成的 readView。</text><text id="kity_text_7824" text-rendering="inherit" font-size="12" dy=".8em" y="39.700000047683716" x="537.5">行锁（Record Lock）：锁直接加在索引记录上面。</text><text id="kity_text_7825" text-rendering="inherit" font-size="12" dy=".8em" y="57.700000047683716" x="537.5">间隙锁（Gap Lock）：是 Innodb 为了解决幻读问题时引入的锁机制，所以只有在 Read Repeatable 、Serializable 隔离级别才有。</text><text id="kity_text_7826" text-rendering="inherit" font-size="12" dy=".8em" y="75.70000004768372" x="537.5">Next-Key Lock ：Record Lock + Gap Lock，锁定一个范围并且锁定记录本身 。</text></g></g><g id="minder_node356" display="none"><g id="node_expander354" display="none" style="cursor: pointer;"><path id="kity_path_21584" fill="white" stroke="gray" d="M521.5,55.5A6,6,0,1,1,509.5,55.5A6,6,0,1,1,521.5,55.5"></path><path id="kity_path_21585" fill="none" stroke="gray"></path></g><path id="node_outline355" fill="none" stroke="none" d="M521.5,46.5h96a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-96a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text355" fill="black"><text id="kity_text_7832" text-rendering="inherit" font-size="12" dy=".8em" y="47.700000047683716" x="521.5">事务一定会锁表吗</text></g></g><g id="minder_node357" display="none"><g id="node_expander353" display="none" style="cursor: pointer;"><path id="kity_path_21581" fill="white" stroke="gray" d="M537.5,55.5A6,6,0,1,1,525.5,55.5A6,6,0,1,1,537.5,55.5"></path><path id="kity_path_21582" fill="none" stroke="gray"></path></g><path id="node_outline354" fill="none" stroke="none" d="M537.5,46.5h838a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-838a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text354" fill="black"><text id="kity_text_7830" text-rendering="inherit" font-size="12" dy=".8em" y="47.700000047683716" x="537.5">1.这个要看事务隔离级别，mysql默认是“可重复读”，并且通过innodb引擎的多版本并发控制MVCC机制防止了幻像读，同样，后面的select也不会被锁定。</text></g></g><g id="minder_node358" display="none"><g id="node_expander356" display="none" style="cursor: pointer;"><path id="kity_path_21590" fill="white" stroke="gray" d="M521.5,63.5A6,6,0,1,1,509.5,63.5A6,6,0,1,1,521.5,63.5"></path><path id="kity_path_21591" fill="none" stroke="gray"></path></g><path id="node_outline357" fill="none" stroke="none" d="M521.5,54.5h289a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-289a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text357" fill="black"><text id="kity_text_7836" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="521.5">事务A 读写(1)读 事务B 读写(2)读，同时执行 会怎么样</text></g></g><g id="minder_node359" display="none"><g id="node_expander355" display="none" style="cursor: pointer;"><path id="kity_path_21587" fill="white" stroke="gray" d="M537.5,63.5A6,6,0,1,1,525.5,63.5A6,6,0,1,1,537.5,63.5"></path><path id="kity_path_21588" fill="none" stroke="gray"></path></g><path id="node_outline356" fill="none" stroke="none" d="M537.5,54.5h66a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-66a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text356" fill="black"><text id="kity_text_7834" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="537.5">行锁 会阻塞</text></g></g><g id="minder_node360" display="none"><g id="node_expander358" display="none" style="cursor: pointer;"><path id="kity_path_21596" fill="white" stroke="gray" d="M521.5,71.5A6,6,0,1,1,509.5,71.5A6,6,0,1,1,521.5,71.5"></path><path id="kity_path_21597" fill="none" stroke="gray"></path></g><path id="node_outline359" fill="none" stroke="none" d="M521.5,62.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text359" fill="black"><text id="kity_text_7840" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="521.5">可重复读是怎么解决脏读的</text></g></g><g id="minder_node361" display="none"><g id="node_expander357" display="none" style="cursor: pointer;"><path id="kity_path_21593" fill="white" stroke="gray" d="M537.5,71.5A6,6,0,1,1,525.5,71.5A6,6,0,1,1,537.5,71.5"></path><path id="kity_path_21594" fill="none" stroke="gray"></path></g><path id="node_outline358" fill="none" stroke="none" d="M537.5,62.5h662a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-662a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text358" fill="black"><text id="kity_text_7838" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="537.5">1.重复读，就是在开始读取数据（事务开启）时，不再允许修改操作 而脏读是一个事务读到了另一个未提交事务修改过的数据</text></g></g><g id="minder_node362" display="none"><g id="node_expander360" display="none" style="cursor: pointer;"><path id="kity_path_21602" fill="white" stroke="gray" d="M521.5,79.5A6,6,0,1,1,509.5,79.5A6,6,0,1,1,521.5,79.5"></path><path id="kity_path_21603" fill="none" stroke="gray"></path></g><path id="node_outline361" fill="none" stroke="none" d="M521.5,70.5h84a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-84a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text361" fill="black"><text id="kity_text_7847" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="521.5">幻读怎么解决？</text></g></g><g id="minder_node363" display="none"><g id="node_expander359" display="none" style="cursor: pointer;"><path id="kity_path_21599" fill="white" stroke="gray" d="M537.5,79.5A6,6,0,1,1,525.5,79.5A6,6,0,1,1,537.5,79.5"></path><path id="kity_path_21600" fill="none" stroke="gray"></path></g><path id="node_outline360" fill="none" stroke="none" d="M537.5,43.5h829a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-829a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text360" fill="black"><text id="kity_text_7842" text-rendering="inherit" font-size="12" dy=".8em" y="44.700000047683716" x="537.5">1.innodb下快照读的幻读是用MVCC解决的，当前的读的幻读是用间隙锁解决的。</text><text id="kity_text_7843" text-rendering="inherit" font-size="12" dy=".8em" y="62.700000047683716" x="537.5">2.事务A，系统版本号2：select * from books；因为1&lt;=2所以此时会读取5条数据。</text><text id="kity_text_7844" text-rendering="inherit" font-size="12" dy=".8em" y="80.70000004768372" x="537.5">事务B，系统版本号3：insert into books ...，插入一条数据，新插入的数据版本号为3，而其他的数据的版本号仍然是2，插入完成之后commit，事务结束。</text><text id="kity_text_7845" text-rendering="inherit" font-size="12" dy=".8em" y="98.70000004768372" x="537.5">事务A，系统版本号2：再次select * from books；只能读取&lt;=2的数据，事务B新插入的那条数据版本号为3，因此读不出来，解决了幻读的问题。</text></g></g><g id="minder_node364" display="none"><g id="node_expander363" display="none" style="cursor: pointer;"><path id="kity_path_21611" fill="white" stroke="gray" d="M521.5,87.5A6,6,0,1,1,509.5,87.5A6,6,0,1,1,521.5,87.5"></path><path id="kity_path_21612" fill="none" stroke="gray"></path></g><path id="node_outline364" fill="none" stroke="none" d="M521.5,78.5h84a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-84a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text364" fill="black"><text id="kity_text_7860" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="521.5">事务完整流程？</text></g></g><g id="minder_node365" display="none"><g id="node_expander362" display="none" style="cursor: pointer;"><path id="kity_path_21608" fill="white" stroke="gray" d="M537.5,87.5A6,6,0,1,1,525.5,87.5A6,6,0,1,1,537.5,87.5"></path><path id="kity_path_21609" fill="none" stroke="gray"></path></g><path id="node_outline363" fill="none" stroke="none" d="M537.5,15.5h301a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-301a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text363" fill="black"><text id="kity_text_7851" text-rendering="inherit" font-size="12" dy=".8em" y="16.700000047683716" x="537.5">1.事务开始</text><text id="kity_text_7852" text-rendering="inherit" font-size="12" dy=".8em" y="34.700000047683716" x="537.5">2.申请锁资源，对行数据上排他锁</text><text id="kity_text_7853" text-rendering="inherit" font-size="12" dy=".8em" y="52.700000047683716" x="537.5">3.将需要修改的data pages读取到innodb_buffer_cache</text><text id="kity_text_7854" text-rendering="inherit" font-size="12" dy=".8em" y="70.70000004768372" x="537.5">4.记录这一条数据到undo log</text><text id="kity_text_7855" text-rendering="inherit" font-size="12" dy=".8em" y="88.70000004768372" x="537.5">5.记录这一天修改后的数据到redo log buffer</text><text id="kity_text_7856" text-rendering="inherit" font-size="12" dy=".8em" y="106.70000004768372" x="537.5">6.将buffer cache中id=2得name改为test</text><text id="kity_text_7857" text-rendering="inherit" font-size="12" dy=".8em" y="124.70000004768372" x="537.5">7.commit，触发二阶段提交2pc</text><text id="kity_text_7858" text-rendering="inherit" font-size="12" dy=".8em" y="142.70000004768372" x="537.5">8.事务结束</text></g></g><g id="minder_node366" display="none"><g id="node_expander361" display="none" style="cursor: pointer;"><path id="kity_path_21605" fill="white" stroke="gray" d="M553.5,87.5A6,6,0,1,1,541.5,87.5A6,6,0,1,1,553.5,87.5"></path><path id="kity_path_21606" fill="none" stroke="gray"></path></g><path id="node_outline362" fill="none" stroke="none" d="M553.5,78.5h193a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-193a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text362" fill="black"><text id="kity_text_7849" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="553.5">https://www.modb.pro/db/12484</text></g></g><g id="minder_node367" display="none"><g id="node_expander442" display="none" style="cursor: pointer;"><path id="kity_path_21848" fill="white" stroke="gray" d="M505.5,95.5A6,6,0,1,1,493.5,95.5A6,6,0,1,1,505.5,95.5"></path><path id="kity_path_21849" fill="none" stroke="gray"></path></g><path id="node_outline443" fill="none" stroke="none" d="M505.5,86.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text443" fill="black"><text id="kity_text_8071" text-rendering="inherit" font-size="12" dy=".8em" y="87.70000004768372" x="505.5">索引</text></g></g><g id="minder_node368" display="none"><g id="node_expander378" display="none" style="cursor: pointer;"><path id="kity_path_21656" fill="white" stroke="gray" d="M521.5,-72.5A6,6,0,1,1,509.5,-72.5A6,6,0,1,1,521.5,-72.5"></path><path id="kity_path_21657" fill="none" stroke="gray"></path></g><path id="node_outline379" fill="none" stroke="none" d="M521.5,-81.5h73a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-73a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text379" fill="black"><text id="kity_text_7897" text-rendering="inherit" font-size="12" dy=".8em" y="-80.29999995231628" x="521.5">索引底层结构</text></g></g><g id="minder_node369" display="none"><g id="node_expander366" display="none" style="cursor: pointer;"><path id="kity_path_21620" fill="white" stroke="gray" d="M537.5,-112.5A6,6,0,1,1,525.5,-112.5A6,6,0,1,1,537.5,-112.5"></path><path id="kity_path_21621" fill="none" stroke="gray"></path></g><path id="node_outline367" fill="none" stroke="none" d="M537.5,-121.5h119a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-119a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text367" fill="black"><text id="kity_text_7866" text-rendering="inherit" font-size="12" dy=".8em" y="-120.29999995231628" x="537.5">说说mysql的索引结构</text></g></g><g id="minder_node370" display="none"><g id="node_expander365" display="none" style="cursor: pointer;"><path id="kity_path_21617" fill="white" stroke="gray" d="M553.5,-112.5A6,6,0,1,1,541.5,-112.5A6,6,0,1,1,553.5,-112.5"></path><path id="kity_path_21618" fill="none" stroke="gray"></path></g><path id="node_outline366" fill="none" stroke="none" d="M553.5,-121.5h536a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-536a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text366" fill="black"><text id="kity_text_7864" text-rendering="inherit" font-size="12" dy=".8em" y="-120.29999995231628" x="553.5">MyISAM 和 InnoDB ，都使用了 B+Tree的数据结构索引。在mysql中索引主要是hash索引和B+索引</text></g></g><g id="minder_node371" display="none"><g id="node_expander368" display="none" style="cursor: pointer;"><path id="kity_path_21626" fill="white" stroke="gray" d="M537.5,-104.5A6,6,0,1,1,525.5,-104.5A6,6,0,1,1,537.5,-104.5"></path><path id="kity_path_21627" fill="none" stroke="gray"></path></g><path id="node_outline369" fill="none" stroke="none" d="M537.5,-113.5h102a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-102a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text369" fill="black"><text id="kity_text_7870" text-rendering="inherit" font-size="12" dy=".8em" y="-112.29999995231628" x="537.5">说说b+树的特点，</text></g></g><g id="minder_node372" display="none"><g id="node_expander367" display="none" style="cursor: pointer;"><path id="kity_path_21623" fill="white" stroke="gray" d="M553.5,-104.5A6,6,0,1,1,541.5,-104.5A6,6,0,1,1,553.5,-104.5"></path><path id="kity_path_21624" fill="none" stroke="gray"></path></g><path id="node_outline368" fill="none" stroke="none" d="M553.5,-113.5h540a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-540a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text368" fill="black"><text id="kity_text_7868" text-rendering="inherit" font-size="12" dy=".8em" y="-112.29999995231628" x="553.5">b+树是b树的变种，可以通过顺序访问来通过访问效率，提高区间访问的性能。叶子节点不存储指针。</text></g></g><g id="minder_node373" display="none"><g id="node_expander371" display="none" style="cursor: pointer;"><path id="kity_path_21635" fill="white" stroke="gray" d="M537.5,-96.5A6,6,0,1,1,525.5,-96.5A6,6,0,1,1,537.5,-96.5"></path><path id="kity_path_21636" fill="none" stroke="gray"></path></g><path id="node_outline372" fill="none" stroke="none" d="M537.5,-105.5h163a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-163a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text372" fill="black"><text id="kity_text_7881" text-rendering="inherit" font-size="12" dy=".8em" y="-104.29999995231628" x="537.5">mysql为什么要用b+树 你觉得</text></g></g><g id="minder_node374" display="none"><g id="node_expander370" display="none" style="cursor: pointer;"><path id="kity_path_21632" fill="white" stroke="gray" d="M553.5,-96.5A6,6,0,1,1,541.5,-96.5A6,6,0,1,1,553.5,-96.5"></path><path id="kity_path_21633" fill="none" stroke="gray"></path></g><path id="node_outline371" fill="none" stroke="none" d="M553.5,-150.5h1192a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1192a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text371" fill="black"><text id="kity_text_7874" text-rendering="inherit" font-size="12" dy=".8em" y="-149.29999995231628" x="553.5">1.</text><text id="kity_text_7875" text-rendering="inherit" font-size="12" dy=".8em" y="-131.29999995231628" x="553.5">mysql中b+树一般层高为3，3已经满足很大的数据量存储了，其次叶子节点不存储指针。</text><text id="kity_text_7876" text-rendering="inherit" font-size="12" dy=".8em" y="-113.29999995231628" x="553.5">而 B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少 这样B树 就增加层数 增加IO查询 访问效率没有b+树好</text><text id="kity_text_7877" text-rendering="inherit" font-size="12" dy=".8em" y="-95.29999995231628" x="553.5">2.</text><text id="kity_text_7878" text-rendering="inherit" font-size="12" dy=".8em" y="-77.29999995231628" x="553.5">磁盘查询IO少(B+树的中间结点只存放索引，数据都存在叶子结点中)，并且可以顺序访问，不需要全表扫描，查询速度快；所有叶子节点形成有序链表，便于范围查询。除了用于查找，还可以用于排序和分组。更少的检索次数</text><text id="kity_text_7879" text-rendering="inherit" font-size="12" dy=".8em" y="-59.299999952316284" x="553.5">3.性能稳定，无论匹配还是不匹配都定位到第三层，</text></g></g><g id="minder_node375" display="none"><g id="node_expander369" display="none" style="cursor: pointer;"><path id="kity_path_21629" fill="white" stroke="gray" d="M569.5,-96.5A6,6,0,1,1,557.5,-96.5A6,6,0,1,1,569.5,-96.5"></path><path id="kity_path_21630" fill="none" stroke="gray"></path></g><path id="node_outline370" fill="none" stroke="none" d="M489.5,-204.5h200a5,5,0,0,1,5,5v107a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-107a5,5,0,0,1,5,-5z"></path><g id="node_text370" fill="black"><text id="kity_text_7872" text-rendering="inherit" font-size="12" dy=".8em" y="-104.29999995231628" x="569.5">b+tree</text></g><image id="kity_image_17025" xlink:href="https://img-blog.csdnimg.cn/20200427111313781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L09vb29fbXVtdXhp,size_16,color_FFFFFF,t_70" x="489.5" y="-201.5" width="200" height="94" xlink:title="b+tree"></image></g><g id="minder_node376" display="none"><g id="node_expander373" display="none" style="cursor: pointer;"><path id="kity_path_21641" fill="white" stroke="gray" d="M537.5,-88.5A6,6,0,1,1,525.5,-88.5A6,6,0,1,1,537.5,-88.5"></path><path id="kity_path_21642" fill="none" stroke="gray"></path></g><path id="node_outline374" fill="none" stroke="none" d="M537.5,-97.5h253a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-253a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text374" fill="black"><text id="kity_text_7886" text-rendering="inherit" font-size="12" dy=".8em" y="-96.29999995231628" x="537.5">说说b树和b+树的区别，和平衡二叉树的区别？</text></g></g><g id="minder_node377" display="none"><g id="node_expander372" display="none" style="cursor: pointer;"><path id="kity_path_21638" fill="white" stroke="gray" d="M553.5,-88.5A6,6,0,1,1,541.5,-88.5A6,6,0,1,1,553.5,-88.5"></path><path id="kity_path_21639" fill="none" stroke="gray"></path></g><path id="node_outline373" fill="none" stroke="none" d="M553.5,-106.5h1167a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1167a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text373" fill="black"><text id="kity_text_7883" text-rendering="inherit" font-size="12" dy=".8em" y="-105.29999995231628" x="553.5">1.b树所有叶子节点位于同一层，是平衡树。b+树基于 B Tree 和叶子节点顺序访问指针进行实现，内节点不存储 data，只存储 key。B树只适合随机检索，而B+树同时支持随机检索和顺序检索。B+树的查询效率更加稳定</text><text id="kity_text_7884" text-rendering="inherit" font-size="12" dy=".8em" y="-87.29999995231628" x="553.5">2.平衡二叉树任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。严格维持平衡，</text></g></g><g id="minder_node378" display="none"><g id="node_expander375" display="none" style="cursor: pointer;"><path id="kity_path_21647" fill="white" stroke="gray" d="M537.5,-80.5A6,6,0,1,1,525.5,-80.5A6,6,0,1,1,537.5,-80.5"></path><path id="kity_path_21648" fill="none" stroke="gray"></path></g><path id="node_outline376" fill="none" stroke="none" d="M537.5,-89.5h180a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-180a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text376" fill="black"><text id="kity_text_7890" text-rendering="inherit" font-size="12" dy=".8em" y="-88.29999995231628" x="537.5">知道hash索引和b+索引的区别 吗</text></g></g><g id="minder_node379" display="none"><g id="node_expander374" display="none" style="cursor: pointer;"><path id="kity_path_21644" fill="white" stroke="gray" d="M553.5,-80.5A6,6,0,1,1,541.5,-80.5A6,6,0,1,1,553.5,-80.5"></path><path id="kity_path_21645" fill="none" stroke="gray"></path></g><path id="node_outline375" fill="none" stroke="none" d="M553.5,-89.5h1406a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1406a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text375" fill="black"><text id="kity_text_7888" text-rendering="inherit" font-size="12" dy=".8em" y="-88.29999995231628" x="553.5">b+索引支持innodb和myisam，默认索引类型，查找速度快，还可以用于排序和分组，可以指定多个列作为索引列。hash索引支持innodb，基于hash表，能以 O(1) 时间进行查找，没有有序性，无法用于排序与分组，只支持精确查找，无法用于部分查找和范围查找</text></g></g><g id="minder_node380" display="none"><g id="node_expander377" display="none" style="cursor: pointer;"><path id="kity_path_21653" fill="white" stroke="gray" d="M537.5,-72.5A6,6,0,1,1,525.5,-72.5A6,6,0,1,1,537.5,-72.5"></path><path id="kity_path_21654" fill="none" stroke="gray"></path></g><path id="node_outline378" fill="none" stroke="none" d="M537.5,-81.5h172a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-172a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text378" fill="black"><text id="kity_text_7895" text-rendering="inherit" font-size="12" dy=".8em" y="-80.29999995231628" x="537.5">说说 hash索引和b+索引的底层&#xa0;</text></g></g><g id="minder_node381" display="none"><g id="node_expander376" display="none" style="cursor: pointer;"><path id="kity_path_21650" fill="white" stroke="gray" d="M553.5,-72.5A6,6,0,1,1,541.5,-72.5A6,6,0,1,1,553.5,-72.5"></path><path id="kity_path_21651" fill="none" stroke="gray"></path></g><path id="node_outline377" fill="none" stroke="none" d="M553.5,-90.5h710a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-710a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text377" fill="black"><text id="kity_text_7892" text-rendering="inherit" font-size="12" dy=".8em" y="-89.29999995231628" x="553.5">哈希索引来说，底层的数据结构就是哈希表，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。</text><text id="kity_text_7893" text-rendering="inherit" font-size="12" dy=".8em" y="-71.29999995231628" x="553.5">b+索引底层是b+树，B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，</text></g></g><g id="minder_node382" display="none"><g id="node_expander399" display="none" style="cursor: pointer;"><path id="kity_path_21719" fill="white" stroke="gray" d="M521.5,-64.5A6,6,0,1,1,509.5,-64.5A6,6,0,1,1,521.5,-64.5"></path><path id="kity_path_21720" fill="none" stroke="gray"></path></g><path id="node_outline400" fill="none" stroke="none" d="M521.5,-73.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text400" fill="black"><text id="kity_text_7945" text-rendering="inherit" font-size="12" dy=".8em" y="-72.29999995231628" x="521.5">索引分类</text></g></g><g id="minder_node383" display="none"><g id="node_expander382" display="none" style="cursor: pointer;"><path id="kity_path_21668" fill="white" stroke="gray" d="M537.5,-112.5A6,6,0,1,1,525.5,-112.5A6,6,0,1,1,537.5,-112.5"></path><path id="kity_path_21669" fill="none" stroke="gray"></path></g><path id="node_outline383" fill="none" stroke="none" d="M537.5,-121.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text383" fill="black"><text id="kity_text_7906" text-rendering="inherit" font-size="12" dy=".8em" y="-120.29999995231628" x="537.5">知道聚簇索引和非聚簇索引吗</text></g></g><g id="minder_node384" display="none"><g id="node_expander381" display="none" style="cursor: pointer;"><path id="kity_path_21665" fill="white" stroke="gray" d="M553.5,-112.5A6,6,0,1,1,541.5,-112.5A6,6,0,1,1,553.5,-112.5"></path><path id="kity_path_21666" fill="none" stroke="gray"></path></g><path id="node_outline382" fill="none" stroke="none" d="M553.5,-130.5h1033a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1033a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text382" fill="black"><text id="kity_text_7903" text-rendering="inherit" font-size="12" dy=".8em" y="-129.29999995231628" x="553.5">聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据，一个表只能有一个聚簇索引，聚簇索引就是按照表中主键的顺序构建一颗 B+ 树，并在叶节点中存放表中的行记录完整数据。</text><text id="kity_text_7904" text-rendering="inherit" font-size="12" dy=".8em" y="-111.29999995231628" x="553.5">非聚簇索引：索引文件与数据文件分离,索引结构的叶子节点指向了数据的对应行。</text></g></g><g id="minder_node385" display="none"><g id="node_expander379" display="none" style="cursor: pointer;"><path id="kity_path_21659" fill="white" stroke="gray" d="M569.5,-120.5A6,6,0,1,1,557.5,-120.5A6,6,0,1,1,569.5,-120.5"></path><path id="kity_path_21660" fill="none" stroke="gray"></path></g><path id="node_outline380" fill="none" stroke="none" d="M516.5,-334.5h156a5,5,0,0,1,5,5v213a5,5,0,0,1,-5,5h-156a5,5,0,0,1,-5,-5v-213a5,5,0,0,1,5,-5z"></path><g id="node_text380" fill="black"><text id="kity_text_7899" text-rendering="inherit" font-size="12" dy=".8em" y="-128.29999995231628" x="569.5">分支主题</text></g><image id="kity_image_17026" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210430171032.png" x="516.5" y="-331.5" width="156" height="200"></image></g><g id="minder_node386" display="none"><g id="node_expander380" display="none" style="cursor: pointer;"><path id="kity_path_21662" fill="white" stroke="gray" d="M569.5,-112.5A6,6,0,1,1,557.5,-112.5A6,6,0,1,1,569.5,-112.5"></path><path id="kity_path_21663" fill="none" stroke="gray"></path></g><path id="node_outline381" fill="none" stroke="none" d="M569.5,-121.5h354a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-354a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text381" fill="black"><text id="kity_text_7901" text-rendering="inherit" font-size="12" dy=".8em" y="-120.29999995231628" x="569.5">https://blog.csdn.net/qq_15037231/article/details/107619834</text></g></g><g id="minder_node387" display="none"><g id="node_expander384" display="none" style="cursor: pointer;"><path id="kity_path_21674" fill="white" stroke="gray" d="M537.5,-104.5A6,6,0,1,1,525.5,-104.5A6,6,0,1,1,537.5,-104.5"></path><path id="kity_path_21675" fill="none" stroke="gray"></path></g><path id="node_outline385" fill="none" stroke="none" d="M537.5,-113.5h181a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-181a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text385" fill="black"><text id="kity_text_7912" text-rendering="inherit" font-size="12" dy=".8em" y="-112.29999995231628" x="537.5">知道唯一索引和主键索引的区别吗</text></g></g><g id="minder_node388" display="none"><g id="node_expander383" display="none" style="cursor: pointer;"><path id="kity_path_21671" fill="white" stroke="gray" d="M553.5,-104.5A6,6,0,1,1,541.5,-104.5A6,6,0,1,1,553.5,-104.5"></path><path id="kity_path_21672" fill="none" stroke="gray"></path></g><path id="node_outline384" fill="none" stroke="none" d="M553.5,-131.5h684a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-684a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text384" fill="black"><text id="kity_text_7908" text-rendering="inherit" font-size="12" dy=".8em" y="-130.29999995231628" x="553.5">唯一索引：不允许有俩行具有相同的值，主键自动建立唯一索引。</text><text id="kity_text_7909" text-rendering="inherit" font-size="12" dy=".8em" y="-112.29999995231628" x="553.5">主键索引：主键索引是一种特殊的唯一索引，不允许有空值，InnoDB 必须要有主键。</text><text id="kity_text_7910" text-rendering="inherit" font-size="12" dy=".8em" y="-94.29999995231628" x="553.5">主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键。一个表最多只能创建一个主键，但可以创建多个唯一索引。</text></g></g><g id="minder_node389" display="none"><g id="node_expander386" display="none" style="cursor: pointer;"><path id="kity_path_21680" fill="white" stroke="gray" d="M537.5,-96.5A6,6,0,1,1,525.5,-96.5A6,6,0,1,1,537.5,-96.5"></path><path id="kity_path_21681" fill="none" stroke="gray"></path></g><path id="node_outline387" fill="none" stroke="none" d="M537.5,-105.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text387" fill="black"><text id="kity_text_7916" text-rendering="inherit" font-size="12" dy=".8em" y="-104.29999995231628" x="537.5">知道覆盖索引吗</text></g></g><g id="minder_node390" display="none"><g id="node_expander385" display="none" style="cursor: pointer;"><path id="kity_path_21677" fill="white" stroke="gray" d="M553.5,-96.5A6,6,0,1,1,541.5,-96.5A6,6,0,1,1,553.5,-96.5"></path><path id="kity_path_21678" fill="none" stroke="gray"></path></g><path id="node_outline386" fill="none" stroke="none" d="M553.5,-105.5h594a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-594a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text386" fill="black"><text id="kity_text_7914" text-rendering="inherit" font-size="12" dy=".8em" y="-104.29999995231628" x="553.5">索引包含所有需要select查询的字段的值(查询列要被所建的索引覆盖。)。覆盖索引的时候不需要回表查询数据。</text></g></g><g id="minder_node391" display="none"><g id="node_expander388" display="none" style="cursor: pointer;"><path id="kity_path_21686" fill="white" stroke="gray" d="M537.5,-88.5A6,6,0,1,1,525.5,-88.5A6,6,0,1,1,537.5,-88.5"></path><path id="kity_path_21687" fill="none" stroke="gray"></path></g><path id="node_outline389" fill="none" stroke="none" d="M537.5,-97.5h97a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-97a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text389" fill="black"><text id="kity_text_7920" text-rendering="inherit" font-size="12" dy=".8em" y="-96.29999995231628" x="537.5">怎么判断覆盖索引</text></g></g><g id="minder_node392" display="none"><g id="node_expander387" display="none" style="cursor: pointer;"><path id="kity_path_21683" fill="white" stroke="gray" d="M553.5,-88.5A6,6,0,1,1,541.5,-88.5A6,6,0,1,1,553.5,-88.5"></path><path id="kity_path_21684" fill="none" stroke="gray"></path></g><path id="node_outline388" fill="none" stroke="none" d="M553.5,-97.5h813a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-813a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text388" fill="black"><text id="kity_text_7918" text-rendering="inherit" font-size="12" dy=".8em" y="-96.29999995231628" x="553.5">使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为using index，MySQL查询优化器在执行查询前会决定是否有索引覆盖查询</text></g></g><g id="minder_node393" display="none"><g id="node_expander392" display="none" style="cursor: pointer;"><path id="kity_path_21698" fill="white" stroke="gray" d="M537.5,-80.5A6,6,0,1,1,525.5,-80.5A6,6,0,1,1,537.5,-80.5"></path><path id="kity_path_21699" fill="none" stroke="gray"></path></g><path id="node_outline393" fill="none" stroke="none" d="M537.5,-89.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text393" fill="black"><text id="kity_text_7928" text-rendering="inherit" font-size="12" dy=".8em" y="-88.29999995231628" x="537.5">什么是联合索引，知道吗</text></g></g><g id="minder_node394" display="none"><g id="node_expander391" display="none" style="cursor: pointer;"><path id="kity_path_21695" fill="white" stroke="gray" d="M553.5,-80.5A6,6,0,1,1,541.5,-80.5A6,6,0,1,1,553.5,-80.5"></path><path id="kity_path_21696" fill="none" stroke="gray"></path></g><path id="node_outline392" fill="none" stroke="none" d="M553.5,-89.5h869a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-869a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text392" fill="black"><text id="kity_text_7926" text-rendering="inherit" font-size="12" dy=".8em" y="-88.29999995231628" x="553.5">联合索引就是多列索引，就是可以多个字段建立一个索引，并且是最左前缀匹配元素，需要注意顺序，如careate index a_b_c xxxxxx(a,b,c)&#xa0; 索引a 索引a b 索引abc</text></g></g><g id="minder_node395" display="none"><g id="node_expander389" display="none" style="cursor: pointer;"><path id="kity_path_21689" fill="white" stroke="gray" d="M569.5,-88.5A6,6,0,1,1,557.5,-88.5A6,6,0,1,1,569.5,-88.5"></path><path id="kity_path_21690" fill="none" stroke="gray"></path></g><path id="node_outline390" fill="none" stroke="none" d="M494.5,-193.5h200a5,5,0,0,1,5,5v104a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-104a5,5,0,0,1,5,-5z"></path><g id="node_text390" fill="black"><text id="kity_text_7922" text-rendering="inherit" font-size="12" dy=".8em" y="-96.29999995231628" x="569.5">分支主题</text></g><image id="kity_image_17027" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210430171707.png" x="494.5" y="-190.5" width="200" height="91"></image></g><g id="minder_node396" display="none"><g id="node_expander390" display="none" style="cursor: pointer;"><path id="kity_path_21692" fill="white" stroke="gray" d="M569.5,-80.5A6,6,0,1,1,557.5,-80.5A6,6,0,1,1,569.5,-80.5"></path><path id="kity_path_21693" fill="none" stroke="gray"></path></g><path id="node_outline391" fill="none" stroke="none" d="M569.5,-89.5h354a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-354a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text391" fill="black"><text id="kity_text_7924" text-rendering="inherit" font-size="12" dy=".8em" y="-88.29999995231628" x="569.5">https://blog.csdn.net/qq_15037231/article/details/107619834</text></g></g><g id="minder_node397" display="none"><g id="node_expander394" display="none" style="cursor: pointer;"><path id="kity_path_21704" fill="white" stroke="gray" d="M537.5,-72.5A6,6,0,1,1,525.5,-72.5A6,6,0,1,1,537.5,-72.5"></path><path id="kity_path_21705" fill="none" stroke="gray"></path></g><path id="node_outline395" fill="none" stroke="none" d="M537.5,-81.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text395" fill="black"><text id="kity_text_7932" text-rendering="inherit" font-size="12" dy=".8em" y="-80.29999995231628" x="537.5">知道全文索引吗</text></g></g><g id="minder_node398" display="none"><g id="node_expander393" display="none" style="cursor: pointer;"><path id="kity_path_21701" fill="white" stroke="gray" d="M553.5,-72.5A6,6,0,1,1,541.5,-72.5A6,6,0,1,1,553.5,-72.5"></path><path id="kity_path_21702" fill="none" stroke="gray"></path></g><path id="node_outline394" fill="none" stroke="none" d="M553.5,-81.5h874a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-874a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text394" fill="black"><text id="kity_text_7930" text-rendering="inherit" font-size="12" dy=".8em" y="-80.29999995231628" x="553.5">MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。InnoDB&#xa0;也支持</text></g></g><g id="minder_node399" display="none"><g id="node_expander398" display="none" style="cursor: pointer;"><path id="kity_path_21716" fill="white" stroke="gray" d="M537.5,-64.5A6,6,0,1,1,525.5,-64.5A6,6,0,1,1,537.5,-64.5"></path><path id="kity_path_21717" fill="none" stroke="gray"></path></g><path id="node_outline399" fill="none" stroke="none" d="M537.5,-73.5h60a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-60a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text399" fill="black"><text id="kity_text_7943" text-rendering="inherit" font-size="12" dy=".8em" y="-72.29999995231628" x="537.5">二级索引？</text></g></g><g id="minder_node400" display="none"><g id="node_expander397" display="none" style="cursor: pointer;"><path id="kity_path_21713" fill="white" stroke="gray" d="M553.5,-64.5A6,6,0,1,1,541.5,-64.5A6,6,0,1,1,553.5,-64.5"></path><path id="kity_path_21714" fill="none" stroke="gray"></path></g><path id="node_outline398" fill="none" stroke="none" d="M553.5,-100.5h754a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-754a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text398" fill="black"><text id="kity_text_7938" text-rendering="inherit" font-size="12" dy=".8em" y="-99.29999995231628" x="553.5">1.二级索引就是辅助索引，除了InnoDB中主键所建立的是聚簇索引，唯一索引、普通索引、前缀索引等都是二级索引。</text><text id="kity_text_7939" text-rendering="inherit" font-size="12" dy=".8em" y="-81.29999995231628" x="553.5">2.二级索引叶子节点中存储主键值，每次查找数据时，根据索引找到叶子节点中的主键值，根据主键值再到聚簇索引中得到完整的一行记录。</text><text id="kity_text_7940" text-rendering="inherit" font-size="12" dy=".8em" y="-63.299999952316284" x="553.5">3.二级索引只存储了主键值，相比于聚簇索引，占用的空间要少。当我们需要为表建立多个索引时，如果都是聚簇索引，那将占用大量内存空间</text><text id="kity_text_7941" text-rendering="inherit" font-size="12" dy=".8em" y="-45.299999952316284" x="553.5">4.如果是二级索引，data是记录的主键值，如果是主键索引的话，data的是包含事务ID、回滚ID、版本号以及行数据信息等。</text></g></g><g id="minder_node401" display="none"><g id="node_expander395" display="none" style="cursor: pointer;"><path id="kity_path_21707" fill="white" stroke="gray" d="M569.5,-72.5A6,6,0,1,1,557.5,-72.5A6,6,0,1,1,569.5,-72.5"></path><path id="kity_path_21708" fill="none" stroke="gray"></path></g><path id="node_outline396" fill="none" stroke="none" d="M569.5,-81.5h336a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-336a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text396" fill="black"><text id="kity_text_7934" text-rendering="inherit" font-size="12" dy=".8em" y="-80.29999995231628" x="569.5">https://www.cnblogs.com/gaoquanquan/p/11030999.html</text></g></g><g id="minder_node402" display="none"><g id="node_expander396" display="none" style="cursor: pointer;"><path id="kity_path_21710" fill="white" stroke="gray" d="M569.5,-64.5A6,6,0,1,1,557.5,-64.5A6,6,0,1,1,569.5,-64.5"></path><path id="kity_path_21711" fill="none" stroke="gray"></path></g><path id="node_outline397" fill="none" stroke="none" d="M494.5,-169.5h200a5,5,0,0,1,5,5v104a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-104a5,5,0,0,1,5,-5z"></path><g id="node_text397" fill="black"><text id="kity_text_7936" text-rendering="inherit" font-size="12" dy=".8em" y="-72.29999995231628" x="569.5">分支主题</text></g><image id="kity_image_17028" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210430171707.png" x="494.5" y="-166.5" width="200" height="91"></image></g><g id="minder_node403" display="none"><g id="node_expander401" display="none" style="cursor: pointer;"><path id="kity_path_21725" fill="white" stroke="gray" d="M521.5,-56.5A6,6,0,1,1,509.5,-56.5A6,6,0,1,1,521.5,-56.5"></path><path id="kity_path_21726" fill="none" stroke="gray"></path></g><path id="node_outline402" fill="none" stroke="none" d="M521.5,-65.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text402" fill="black"><text id="kity_text_7949" text-rendering="inherit" font-size="12" dy=".8em" y="-64.29999995231628" x="521.5">非聚簇索引会回表查询吗</text></g></g><g id="minder_node404" display="none"><g id="node_expander400" display="none" style="cursor: pointer;"><path id="kity_path_21722" fill="white" stroke="gray" d="M537.5,-56.5A6,6,0,1,1,525.5,-56.5A6,6,0,1,1,537.5,-56.5"></path><path id="kity_path_21723" fill="none" stroke="gray"></path></g><path id="node_outline401" fill="none" stroke="none" d="M537.5,-65.5h613a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-613a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text401" fill="black"><text id="kity_text_7947" text-rendering="inherit" font-size="12" dy=".8em" y="-64.29999995231628" x="537.5">不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</text></g></g><g id="minder_node405" display="none"><g id="node_expander403" display="none" style="cursor: pointer;"><path id="kity_path_21731" fill="white" stroke="gray" d="M521.5,-48.5A6,6,0,1,1,509.5,-48.5A6,6,0,1,1,521.5,-48.5"></path><path id="kity_path_21732" fill="none" stroke="gray"></path></g><path id="node_outline404" fill="none" stroke="none" d="M521.5,-57.5h146a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-146a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text404" fill="black"><text id="kity_text_7954" text-rendering="inherit" font-size="12" dy=".8em" y="-56.299999952316284" x="521.5">说说回表查询的原因有哪些</text></g></g><g id="minder_node406" display="none"><g id="node_expander402" display="none" style="cursor: pointer;"><path id="kity_path_21728" fill="white" stroke="gray" d="M537.5,-48.5A6,6,0,1,1,525.5,-48.5A6,6,0,1,1,537.5,-48.5"></path><path id="kity_path_21729" fill="none" stroke="gray"></path></g><path id="node_outline403" fill="none" stroke="none" d="M537.5,-66.5h914a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-914a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text403" fill="black"><text id="kity_text_7951" text-rendering="inherit" font-size="12" dy=".8em" y="-65.29999995231628" x="537.5">在mysql中InnoDB分主键索引与辅助索引(非主键索引)，如果创建非主键索引，查找的时侯需要先查辅助索引再回表查一次主键索引才能定位完整数据。这种也叫二级索引。</text><text id="kity_text_7952" text-rendering="inherit" font-size="12" dy=".8em" y="-47.299999952316284" x="537.5">按照非主键列建立的B+树需要一次回表操作才可以定位到完整的用户记录，这种B+树也被称为二级索引。</text></g></g><g id="minder_node407" display="none"><g id="node_expander405" display="none" style="cursor: pointer;"><path id="kity_path_21737" fill="white" stroke="gray" d="M521.5,-40.5A6,6,0,1,1,509.5,-40.5A6,6,0,1,1,521.5,-40.5"></path><path id="kity_path_21738" fill="none" stroke="gray"></path></g><path id="node_outline406" fill="none" stroke="none" d="M521.5,-49.5h134a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-134a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text406" fill="black"><text id="kity_text_7958" text-rendering="inherit" font-size="12" dy=".8em" y="-48.299999952316284" x="521.5">myisam和innodb的回表</text></g></g><g id="minder_node408" display="none"><g id="node_expander404" display="none" style="cursor: pointer;"><path id="kity_path_21734" fill="white" stroke="gray" d="M537.5,-40.5A6,6,0,1,1,525.5,-40.5A6,6,0,1,1,537.5,-40.5"></path><path id="kity_path_21735" fill="none" stroke="gray"></path></g><path id="node_outline405" fill="none" stroke="none" d="M537.5,-49.5h1015a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1015a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text405" fill="black"><text id="kity_text_7956" text-rendering="inherit" font-size="12" dy=".8em" y="-48.299999952316284" x="537.5">MyISAM的回表操作是十分快速的，因为是拿着地址偏移量直接到文件中取数据的，InnoDB是通过获取主键之后再去聚簇索引里边儿找记录，虽然说也不慢，但还是比不上直接用地址去访问。</text></g></g><g id="minder_node409" display="none"><g id="node_expander407" display="none" style="cursor: pointer;"><path id="kity_path_21743" fill="white" stroke="gray" d="M521.5,-32.5A6,6,0,1,1,509.5,-32.5A6,6,0,1,1,521.5,-32.5"></path><path id="kity_path_21744" fill="none" stroke="gray"></path></g><path id="node_outline408" fill="none" stroke="none" d="M521.5,-41.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text408" fill="black"><text id="kity_text_7964" text-rendering="inherit" font-size="12" dy=".8em" y="-40.299999952316284" x="521.5">什么情况下创建索引</text></g></g><g id="minder_node410" display="none"><g id="node_expander406" display="none" style="cursor: pointer;"><path id="kity_path_21740" fill="white" stroke="gray" d="M537.5,-32.5A6,6,0,1,1,525.5,-32.5A6,6,0,1,1,537.5,-32.5"></path><path id="kity_path_21741" fill="none" stroke="gray"></path></g><path id="node_outline407" fill="none" stroke="none" d="M537.5,-59.5h581a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-581a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text407" fill="black"><text id="kity_text_7960" text-rendering="inherit" font-size="12" dy=".8em" y="-58.299999952316284" x="537.5">主键自动建立唯一索引。频繁作为查询条件的字段。单键/组合索引的选择问题，高并发下倾向创建组合索引。</text><text id="kity_text_7961" text-rendering="inherit" font-size="12" dy=".8em" y="-40.299999952316284" x="537.5">查询中排序的字段，排序字段通过索引访问大幅提高排序速度。</text><text id="kity_text_7962" text-rendering="inherit" font-size="12" dy=".8em" y="-22.299999952316284" x="537.5">经常用作表连接 join 的属性上，建立索引。总之 ，只为用于搜索、排序或分组的列创建索引</text></g></g><g id="minder_node411" display="none"><g id="node_expander409" display="none" style="cursor: pointer;"><path id="kity_path_21749" fill="white" stroke="gray" d="M521.5,-24.5A6,6,0,1,1,509.5,-24.5A6,6,0,1,1,521.5,-24.5"></path><path id="kity_path_21750" fill="none" stroke="gray"></path></g><path id="node_outline410" fill="none" stroke="none" d="M521.5,-33.5h96a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-96a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text410" fill="black"><text id="kity_text_7968" text-rendering="inherit" font-size="12" dy=".8em" y="-32.299999952316284" x="521.5">为什么使用索引呢</text></g></g><g id="minder_node412" display="none"><g id="node_expander408" display="none" style="cursor: pointer;"><path id="kity_path_21746" fill="white" stroke="gray" d="M537.5,-24.5A6,6,0,1,1,525.5,-24.5A6,6,0,1,1,537.5,-24.5"></path><path id="kity_path_21747" fill="none" stroke="gray"></path></g><path id="node_outline409" fill="none" stroke="none" d="M537.5,-33.5h781a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-781a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text409" fill="black"><text id="kity_text_7966" text-rendering="inherit" font-size="12" dy=".8em" y="-32.299999952316284" x="537.5">创建唯一性索引，保证数据库表中每一行数据的唯一性。大大加快数据的检索速度。通过使用索引，可以在查询中使用优化隐藏器，提高系统的性能</text></g></g><g id="minder_node413" display="none"><g id="node_expander411" display="none" style="cursor: pointer;"><path id="kity_path_21755" fill="white" stroke="gray" d="M521.5,-16.5A6,6,0,1,1,509.5,-16.5A6,6,0,1,1,521.5,-16.5"></path><path id="kity_path_21756" fill="none" stroke="gray"></path></g><path id="node_outline412" fill="none" stroke="none" d="M521.5,-25.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text412" fill="black"><text id="kity_text_7972" text-rendering="inherit" font-size="12" dy=".8em" y="-24.299999952316284" x="521.5">什么情况不要建索引</text></g></g><g id="minder_node414" display="none"><g id="node_expander410" display="none" style="cursor: pointer;"><path id="kity_path_21752" fill="white" stroke="gray" d="M537.5,-16.5A6,6,0,1,1,525.5,-16.5A6,6,0,1,1,537.5,-16.5"></path><path id="kity_path_21753" fill="none" stroke="gray"></path></g><path id="node_outline411" fill="none" stroke="none" d="M537.5,-25.5h649a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-649a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text411" fill="black"><text id="kity_text_7970" text-rendering="inherit" font-size="12" dy=".8em" y="-24.299999952316284" x="537.5">表记录太少。经常增删改的表。频繁更新的字段不适合创建索引（会加重IO负担）。where条件里用不到的字段不创建索引</text></g></g><g id="minder_node415" display="none"><g id="node_expander413" display="none" style="cursor: pointer;"><path id="kity_path_21761" fill="white" stroke="gray" d="M521.5,-8.5A6,6,0,1,1,509.5,-8.5A6,6,0,1,1,521.5,-8.5"></path><path id="kity_path_21762" fill="none" stroke="gray"></path></g><path id="node_outline414" fill="none" stroke="none" d="M521.5,-17.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text414" fill="black"><text id="kity_text_7976" text-rendering="inherit" font-size="12" dy=".8em" y="-16.299999952316284" x="521.5">你觉得索引有缺点吗</text></g></g><g id="minder_node416" display="none"><g id="node_expander412" display="none" style="cursor: pointer;"><path id="kity_path_21758" fill="white" stroke="gray" d="M537.5,-8.5A6,6,0,1,1,525.5,-8.5A6,6,0,1,1,537.5,-8.5"></path><path id="kity_path_21759" fill="none" stroke="gray"></path></g><path id="node_outline413" fill="none" stroke="none" d="M537.5,-17.5h839a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-839a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text413" fill="black"><text id="kity_text_7974" text-rendering="inherit" font-size="12" dy=".8em" y="-16.299999952316284" x="537.5">索引也需要占物理空间。创建索引和维护索引要耗费时间，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</text></g></g><g id="minder_node417" display="none"><g id="node_expander415" display="none" style="cursor: pointer;"><path id="kity_path_21767" fill="white" stroke="gray" d="M521.5,-0.5A6,6,0,1,1,509.5,-0.5A6,6,0,1,1,521.5,-0.5"></path><path id="kity_path_21768" fill="none" stroke="gray"></path></g><path id="node_outline416" fill="none" stroke="none" d="M521.5,-9.5h110a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-110a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text416" fill="black"><text id="kity_text_7980" text-rendering="inherit" font-size="12" dy=".8em" y="-8.299999952316284" x="521.5">简单说说索引的原理</text></g></g><g id="minder_node418" display="none"><g id="node_expander414" display="none" style="cursor: pointer;"><path id="kity_path_21764" fill="white" stroke="gray" d="M537.5,-0.5A6,6,0,1,1,525.5,-0.5A6,6,0,1,1,537.5,-0.5"></path><path id="kity_path_21765" fill="none" stroke="gray"></path></g><path id="node_outline415" fill="none" stroke="none" d="M537.5,-9.5h469a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-469a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text415" fill="black"><text id="kity_text_7978" text-rendering="inherit" font-size="12" dy=".8em" y="-8.299999952316284" x="537.5">如果没有索引，一般来说执行查询时遍历整张表。原理就是把无序的数据变成有序的查询</text></g></g><g id="minder_node419" display="none"><g id="node_expander417" display="none" style="cursor: pointer;"><path id="kity_path_21773" fill="white" stroke="gray" d="M521.5,7.5A6,6,0,1,1,509.5,7.5A6,6,0,1,1,521.5,7.5"></path><path id="kity_path_21774" fill="none" stroke="gray"></path></g><path id="node_outline418" fill="none" stroke="none" d="M521.5,-1.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text418" fill="black"><text id="kity_text_7984" text-rendering="inherit" font-size="12" dy=".8em" y="-0.2999999523162842" x="521.5">怎么创建索引呢</text></g></g><g id="minder_node420" display="none"><g id="node_expander416" display="none" style="cursor: pointer;"><path id="kity_path_21770" fill="white" stroke="gray" d="M537.5,7.5A6,6,0,1,1,525.5,7.5A6,6,0,1,1,537.5,7.5"></path><path id="kity_path_21771" fill="none" stroke="gray"></path></g><path id="node_outline417" fill="none" stroke="none" d="M537.5,-1.5h860a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-860a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text417" fill="black"><text id="kity_text_7982" text-rendering="inherit" font-size="12" dy=".8em" y="-0.2999999523162842" x="537.5">1.CREATE TABLE时创建索引 。2.使用ALTER TABLE命令去增加索引(用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。)。 3.使用CREATE INDEX命令创建</text></g></g><g id="minder_node421" display="none"><g id="node_expander419" display="none" style="cursor: pointer;"><path id="kity_path_21779" fill="white" stroke="gray" d="M521.5,15.5A6,6,0,1,1,509.5,15.5A6,6,0,1,1,521.5,15.5"></path><path id="kity_path_21780" fill="none" stroke="gray"></path></g><path id="node_outline420" fill="none" stroke="none" d="M521.5,6.5h110a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-110a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text420" fill="black"><text id="kity_text_7994" text-rendering="inherit" font-size="12" dy=".8em" y="7.700000047683716" x="521.5">对索引的优化有哪些</text></g></g><g id="minder_node422" display="none"><g id="node_expander418" display="none" style="cursor: pointer;"><path id="kity_path_21776" fill="white" stroke="gray" d="M537.5,15.5A6,6,0,1,1,525.5,15.5A6,6,0,1,1,537.5,15.5"></path><path id="kity_path_21777" fill="none" stroke="gray"></path></g><path id="node_outline419" fill="none" stroke="none" d="M537.5,-47.5h651a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-651a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text419" fill="black"><text id="kity_text_7986" text-rendering="inherit" font-size="12" dy=".8em" y="-46.299999952316284" x="537.5">1.复合索引遵守「最左前缀」原则，选择性最强的索引&#xa0;</text><text id="kity_text_7987" text-rendering="inherit" font-size="12" dy=".8em" y="-28.299999952316284" x="537.5">2.不要在列上使用函数和进行运算</text><text id="kity_text_7988" text-rendering="inherit" font-size="12" dy=".8em" y="-10.299999952316284" x="537.5">3.避免强制类型转换，可能会导致索引失效4.索引列不允许为null </text><text id="kity_text_7989" text-rendering="inherit" font-size="12" dy=".8em" y="7.700000047683716" x="537.5">5.避免使用or来连接条件 </text><text id="kity_text_7990" text-rendering="inherit" font-size="12" dy=".8em" y="25.700000047683716" x="537.5">6.前置模糊查询不能使用索引，非前置查询可以。</text><text id="kity_text_7991" text-rendering="inherit" font-size="12" dy=".8em" y="43.700000047683716" x="537.5">7.对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</text><text id="kity_text_7992" text-rendering="inherit" font-size="12" dy=".8em" y="61.700000047683716" x="537.5">8.在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据 实际文本区分度决定索引长度即可。</text></g></g><g id="minder_node423" display="none"><g id="node_expander421" display="none" style="cursor: pointer;"><path id="kity_path_21785" fill="white" stroke="gray" d="M521.5,23.5A6,6,0,1,1,509.5,23.5A6,6,0,1,1,521.5,23.5"></path><path id="kity_path_21786" fill="none" stroke="gray"></path></g><path id="node_outline422" fill="none" stroke="none" d="M521.5,14.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text422" fill="black"><text id="kity_text_7998" text-rendering="inherit" font-size="12" dy=".8em" y="15.700000047683716" x="521.5">知道最左前缀原则吗</text></g></g><g id="minder_node424" display="none"><g id="node_expander420" display="none" style="cursor: pointer;"><path id="kity_path_21782" fill="white" stroke="gray" d="M537.5,23.5A6,6,0,1,1,525.5,23.5A6,6,0,1,1,537.5,23.5"></path><path id="kity_path_21783" fill="none" stroke="gray"></path></g><path id="node_outline421" fill="none" stroke="none" d="M537.5,14.5h528a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-528a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text421" fill="black"><text id="kity_text_7996" text-rendering="inherit" font-size="12" dy=".8em" y="15.700000047683716" x="537.5">就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</text></g></g><g id="minder_node425" display="none"><g id="node_expander423" display="none" style="cursor: pointer;"><path id="kity_path_21791" fill="white" stroke="gray" d="M521.5,31.5A6,6,0,1,1,509.5,31.5A6,6,0,1,1,521.5,31.5"></path><path id="kity_path_21792" fill="none" stroke="gray"></path></g><path id="node_outline424" fill="none" stroke="none" d="M521.5,22.5h96a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-96a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text424" fill="black"><text id="kity_text_8002" text-rendering="inherit" font-size="12" dy=".8em" y="23.700000047683716" x="521.5">那最左匹配原则呢</text></g></g><g id="minder_node426" display="none"><g id="node_expander422" display="none" style="cursor: pointer;"><path id="kity_path_21788" fill="white" stroke="gray" d="M537.5,31.5A6,6,0,1,1,525.5,31.5A6,6,0,1,1,537.5,31.5"></path><path id="kity_path_21789" fill="none" stroke="gray"></path></g><path id="node_outline423" fill="none" stroke="none" d="M537.5,22.5h756a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-756a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text423" fill="black"><text id="kity_text_8000" text-rendering="inherit" font-size="12" dy=".8em" y="23.700000047683716" x="537.5">就是创建索引 a b c&#xa0; 匹配 a&#xa0; ab&#xa0; abc，遇到范围查询(&gt;、&lt;、between、like)就停止匹配。=和in可以乱序，如a=1 &amp;&amp; b=2 和 b=2 &amp;&amp; a=1&#xa0;</text></g></g><g id="minder_node427" display="none"><g id="node_expander426" display="none" style="cursor: pointer;"><path id="kity_path_21800" fill="white" stroke="gray" d="M521.5,39.5A6,6,0,1,1,509.5,39.5A6,6,0,1,1,521.5,39.5"></path><path id="kity_path_21801" fill="none" stroke="gray"></path></g><path id="node_outline427" fill="none" stroke="none" d="M521.5,30.5h89a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-89a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text427" fill="black"><text id="kity_text_8010" text-rendering="inherit" font-size="12" dy=".8em" y="31.700000047683716" x="521.5">最左匹配 原理？</text></g></g><g id="minder_node428" display="none"><g id="node_expander425" display="none" style="cursor: pointer;"><path id="kity_path_21797" fill="white" stroke="gray" d="M537.5,39.5A6,6,0,1,1,525.5,39.5A6,6,0,1,1,537.5,39.5"></path><path id="kity_path_21798" fill="none" stroke="gray"></path></g><path id="node_outline426" fill="none" stroke="none" d="M537.5,12.5h674a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-674a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text426" fill="black"><text id="kity_text_8006" text-rendering="inherit" font-size="12" dy=".8em" y="13.700000047683716" x="537.5">1.索引的底层是一颗B+树，那么联合索引的底层也就是一颗B+树，只不过联合索引的B+树节点中存储的是键值。</text><text id="kity_text_8007" text-rendering="inherit" font-size="12" dy=".8em" y="31.700000047683716" x="537.5">比如说 (2,4) 底层可能是 类似于k-v&#xa0; 每一个k-v的k是有序的，每一个k-v中的v有序的&#xa0; (1,1)&#xa0; (1,2) (2,1)&#xa0; 然后 (2，2) (2,3) (3,4)&#xa0;&#xa0;</text><text id="kity_text_8008" text-rendering="inherit" font-size="12" dy=".8em" y="49.700000047683716" x="537.5">创建联合索引的规则是首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序</text></g></g><g id="minder_node429" display="none"><g id="node_expander424" display="none" style="cursor: pointer;"><path id="kity_path_21794" fill="white" stroke="gray" d="M553.5,39.5A6,6,0,1,1,541.5,39.5A6,6,0,1,1,553.5,39.5"></path><path id="kity_path_21795" fill="none" stroke="gray"></path></g><path id="node_outline425" fill="none" stroke="none" d="M478.5,-67.5h200a5,5,0,0,1,5,5v106a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-106a5,5,0,0,1,5,-5z"></path><g id="node_text425" fill="black"><text id="kity_text_8004" text-rendering="inherit" font-size="12" dy=".8em" y="31.700000047683716" x="553.5">分支主题</text></g><image id="kity_image_17029" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210428022513.png" x="478.5" y="-64.5" width="200" height="93"></image></g><g id="minder_node430" display="none"><g id="node_expander428" display="none" style="cursor: pointer;"><path id="kity_path_21806" fill="white" stroke="gray" d="M521.5,47.5A6,6,0,1,1,509.5,47.5A6,6,0,1,1,521.5,47.5"></path><path id="kity_path_21807" fill="none" stroke="gray"></path></g><path id="node_outline429" fill="none" stroke="none" d="M521.5,38.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text429" fill="black"><text id="kity_text_8017" text-rendering="inherit" font-size="12" dy=".8em" y="39.700000047683716" x="521.5">索引一定能加快查询速度吗</text></g></g><g id="minder_node431" display="none"><g id="node_expander427" display="none" style="cursor: pointer;"><path id="kity_path_21803" fill="white" stroke="gray" d="M537.5,47.5A6,6,0,1,1,525.5,47.5A6,6,0,1,1,537.5,47.5"></path><path id="kity_path_21804" fill="none" stroke="gray"></path></g><path id="node_outline428" fill="none" stroke="none" d="M537.5,11.5h886a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-886a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text428" fill="black"><text id="kity_text_8012" text-rendering="inherit" font-size="12" dy=".8em" y="12.700000047683716" x="537.5">不一定。首先索引肯定是比全比扫描快的。</text><text id="kity_text_8013" text-rendering="inherit" font-size="12" dy=".8em" y="30.700000047683716" x="537.5">索引是需要空间存储的，每创建一个索引都是需要为创建b+树，树的每一个节点都是一页，一页是16kb，所以树大的话很占内存，那么使用索引也是需要占处理时间。</text><text id="kity_text_8014" text-rendering="inherit" font-size="12" dy=".8em" y="48.700000047683716" x="537.5">其次如果表的数据我们经常有其他操作，那么索引也是需要重新维护，而这些操作还需要加上索引的处理时间，不一定更快。</text><text id="kity_text_8015" text-rendering="inherit" font-size="12" dy=".8em" y="66.70000004768372" x="537.5">如果数据量少 还不如不建索引。</text></g></g><g id="minder_node432" display="none"><g id="node_expander430" display="none" style="cursor: pointer;"><path id="kity_path_21812" fill="white" stroke="gray" d="M521.5,55.5A6,6,0,1,1,509.5,55.5A6,6,0,1,1,521.5,55.5"></path><path id="kity_path_21813" fill="none" stroke="gray"></path></g><path id="node_outline431" fill="none" stroke="none" d="M521.5,46.5h170a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-170a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text431" fill="black"><text id="kity_text_8030" text-rendering="inherit" font-size="12" dy=".8em" y="47.700000047683716" x="521.5">索引为什么可能失效，简单说说</text></g></g><g id="minder_node433" display="none"><g id="node_expander429" display="none" style="cursor: pointer;"><path id="kity_path_21809" fill="white" stroke="gray" d="M537.5,55.5A6,6,0,1,1,525.5,55.5A6,6,0,1,1,537.5,55.5"></path><path id="kity_path_21810" fill="none" stroke="gray"></path></g><path id="node_outline430" fill="none" stroke="none" d="M537.5,-34.5h653a5,5,0,0,1,5,5v170a5,5,0,0,1,-5,5h-653a5,5,0,0,1,-5,-5v-170a5,5,0,0,1,5,-5z"></path><g id="node_text430" fill="black"><text id="kity_text_8019" text-rendering="inherit" font-size="12" dy=".8em" y="-33.299999952316284" x="537.5">1.以“%(表示任意0个或多个字符)”开头的LIKE语句；</text><text id="kity_text_8020" text-rendering="inherit" font-size="12" dy=".8em" y="-15.299999952316284" x="537.5">2.OR语句前后没有同时使用索引；</text><text id="kity_text_8021" text-rendering="inherit" font-size="12" dy=".8em" y="2.700000047683716" x="537.5">3.数据类型出现隐式转化；</text><text id="kity_text_8022" text-rendering="inherit" font-size="12" dy=".8em" y="20.700000047683716" x="537.5">4.对于多列索引，必须满足 最左匹配原则 </text><text id="kity_text_8023" text-rendering="inherit" font-size="12" dy=".8em" y="38.700000047683716" x="537.5">5.避免在 where 子句中使用 != 或 &lt;&gt; 操作符；</text><text id="kity_text_8024" text-rendering="inherit" font-size="12" dy=".8em" y="56.700000047683716" x="537.5">6.列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不会使用索引；</text><text id="kity_text_8025" text-rendering="inherit" font-size="12" dy=".8em" y="74.70000004768372" x="537.5">7.避免在 where 子句中对字段进行函数操作；</text><text id="kity_text_8026" text-rendering="inherit" font-size="12" dy=".8em" y="92.70000004768372" x="537.5">8.重复数据较多的列；</text><text id="kity_text_8027" text-rendering="inherit" font-size="12" dy=".8em" y="110.70000004768372" x="537.5">9.如果查询条件里面包含 col=null 则此列的索引不生效。并且也查询不出数据，必须使用 col is null 语句才能使索引生效。</text><text id="kity_text_8028" text-rendering="inherit" font-size="12" dy=".8em" y="128.70000004768372" x="537.5">10.如果mysql查询优化器估计使用全表扫描要比使用索引快，则不使用索引。</text></g></g><g id="minder_node434" display="none"><g id="node_expander432" display="none" style="cursor: pointer;"><path id="kity_path_21818" fill="white" stroke="gray" d="M521.5,63.5A6,6,0,1,1,509.5,63.5A6,6,0,1,1,521.5,63.5"></path><path id="kity_path_21819" fill="none" stroke="gray"></path></g><path id="node_outline433" fill="none" stroke="none" d="M521.5,54.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text433" fill="black"><text id="kity_text_8036" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="521.5">联合索引失效的原因知道吗</text></g></g><g id="minder_node435" display="none"><g id="node_expander431" display="none" style="cursor: pointer;"><path id="kity_path_21815" fill="white" stroke="gray" d="M537.5,63.5A6,6,0,1,1,525.5,63.5A6,6,0,1,1,537.5,63.5"></path><path id="kity_path_21816" fill="none" stroke="gray"></path></g><path id="node_outline432" fill="none" stroke="none" d="M537.5,36.5h498a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-498a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text432" fill="black"><text id="kity_text_8032" text-rendering="inherit" font-size="12" dy=".8em" y="37.700000047683716" x="537.5">1.查询条件使用不等式，查询脚本，只要有一个条件含有不等式，都不会走索引(使用!会走)</text><text id="kity_text_8033" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="537.5">2.查询条件类型不一致，从第一个查询条件开始，第N个参数类型不一致，索引能使用前N-1列</text><text id="kity_text_8034" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="537.5">3.查询条件使用函数计算和不使用索引首列当查询条件</text></g></g><g id="minder_node436" display="none"><g id="node_expander434" display="none" style="cursor: pointer;"><path id="kity_path_21824" fill="white" stroke="gray" d="M521.5,71.5A6,6,0,1,1,509.5,71.5A6,6,0,1,1,521.5,71.5"></path><path id="kity_path_21825" fill="none" stroke="gray"></path></g><path id="node_outline435" fill="none" stroke="none" d="M521.5,62.5h258a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-258a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text435" fill="black"><text id="kity_text_8040" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="521.5">mysql&#xa0;的sql本身没问题的情况下，没走索引原因</text></g></g><g id="minder_node437" display="none"><g id="node_expander433" display="none" style="cursor: pointer;"><path id="kity_path_21821" fill="white" stroke="gray" d="M537.5,71.5A6,6,0,1,1,525.5,71.5A6,6,0,1,1,537.5,71.5"></path><path id="kity_path_21822" fill="none" stroke="gray"></path></g><path id="node_outline434" fill="none" stroke="none" d="M537.5,62.5h404a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-404a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text434" fill="black"><text id="kity_text_8038" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="537.5">1.如果mysql查询优化器估计使用全表扫描要比使用索引快，则不使用索引。</text></g></g><g id="minder_node438" display="none"><g id="node_expander437" display="none" style="cursor: pointer;"><path id="kity_path_21833" fill="white" stroke="gray" d="M521.5,79.5A6,6,0,1,1,509.5,79.5A6,6,0,1,1,521.5,79.5"></path><path id="kity_path_21834" fill="none" stroke="gray"></path></g><path id="node_outline438" fill="none" stroke="none" d="M521.5,70.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text438" fill="black"><text id="kity_text_8055" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="521.5">索引下推？什么时候发生？</text></g></g><g id="minder_node439" display="none"><g id="node_expander436" display="none" style="cursor: pointer;"><path id="kity_path_21830" fill="white" stroke="gray" d="M537.5,79.5A6,6,0,1,1,525.5,79.5A6,6,0,1,1,537.5,79.5"></path><path id="kity_path_21831" fill="none" stroke="gray"></path></g><path id="node_outline437" fill="none" stroke="none" d="M537.5,-10.5h1239a5,5,0,0,1,5,5v170a5,5,0,0,1,-5,5h-1239a5,5,0,0,1,-5,-5v-170a5,5,0,0,1,5,-5z"></path><g id="node_text437" fill="black"><text id="kity_text_8044" text-rendering="inherit" font-size="12" dy=".8em" y="-9.299999952316284" x="537.5">索引下推是mysql5.6做的一个优化，索引下推可以减少在有like查询情况下的回表。默认开启</text><text id="kity_text_8045" text-rendering="inherit" font-size="12" dy=".8em" y="8.700000047683716" x="537.5">1.</text><text id="kity_text_8046" text-rendering="inherit" font-size="12" dy=".8em" y="26.700000047683716" x="537.5">如果没有使用索引下推技术，则MySQL会通过zipcode='95054'从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastname LIKE '%etrunia%'和address LIKE '%Main Street%'来判断数据是否符合条件。&#xa0;</text><text id="kity_text_8047" text-rendering="inherit" font-size="12" dy=".8em" y="44.700000047683716" x="537.5">如果使用了索引下推技术，则MYSQL首先会返回符合zipcode='95054'的索引，然后根据lastname LIKE '%etrunia%'和address LIKE '%Main Street%'来判断索引是否符合条件。</text><text id="kity_text_8048" text-rendering="inherit" font-size="12" dy=".8em" y="62.700000047683716" x="537.5">如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。 有了索引下推优化，可以在有like条件查询的情况下，减少回表次数。</text><text id="kity_text_8049" text-rendering="inherit" font-size="12" dy=".8em" y="80.70000004768372" x="537.5">2.</text><text id="kity_text_8050" text-rendering="inherit" font-size="12" dy=".8em" y="98.70000004768372" x="537.5">(a,b)组成联合索引 a='23' and b like '%eqw%'</text><text id="kity_text_8051" text-rendering="inherit" font-size="12" dy=".8em" y="116.70000004768372" x="537.5">(1)如果没有索引下推原则，mysql会通过a='23' 先查询出行对应的数据。然后返回到mysql服务端。mysql服务端再基于like模糊查询来校验查询出的数据是否符合条件。这个过程就涉及到一开始的回表操作。</text><text id="kity_text_8052" text-rendering="inherit" font-size="12" dy=".8em" y="134.70000004768372" x="537.5">(2)如果使用了索引下推技术，则mysql会首先返回返回条件a='23'的数据的索引，然后根据like的条件来校验索引行数据是否符合条件，如果符合条件，则直接根据索引来定位对应的数据，如果不符合直接reject掉，</text><text id="kity_text_8053" text-rendering="inherit" font-size="12" dy=".8em" y="152.70000004768372" x="537.5">有了索引下推优化，可以在有like条件的情况下，减少回表的次数。</text></g></g><g id="minder_node440" display="none"><g id="node_expander435" display="none" style="cursor: pointer;"><path id="kity_path_21827" fill="white" stroke="gray" d="M553.5,79.5A6,6,0,1,1,541.5,79.5A6,6,0,1,1,553.5,79.5"></path><path id="kity_path_21828" fill="none" stroke="gray"></path></g><path id="node_outline436" fill="none" stroke="none" d="M553.5,70.5h333a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text436" fill="black"><text id="kity_text_8042" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="553.5">https://juejin.cn/post/6844904126585765902#heading-15</text></g></g><g id="minder_node441" display="none"><g id="node_expander439" display="none" style="cursor: pointer;"><path id="kity_path_21839" fill="white" stroke="gray" d="M521.5,87.5A6,6,0,1,1,509.5,87.5A6,6,0,1,1,521.5,87.5"></path><path id="kity_path_21840" fill="none" stroke="gray"></path></g><path id="node_outline440" fill="none" stroke="none" d="M521.5,78.5h241a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-241a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text440" fill="black"><text id="kity_text_8062" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="521.5">全索引扫描，全表扫描，覆盖索引三个区别？</text></g></g><g id="minder_node442" display="none"><g id="node_expander438" display="none" style="cursor: pointer;"><path id="kity_path_21836" fill="white" stroke="gray" d="M537.5,87.5A6,6,0,1,1,525.5,87.5A6,6,0,1,1,537.5,87.5"></path><path id="kity_path_21837" fill="none" stroke="gray"></path></g><path id="node_outline439" fill="none" stroke="none" d="M537.5,51.5h599a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-599a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text439" fill="black"><text id="kity_text_8057" text-rendering="inherit" font-size="12" dy=".8em" y="52.700000047683716" x="537.5">1.全索引扫描，查询时，遍历索引树来获取数据行。如果数据不是密集的会产生随机IO explain中的类型是index</text><text id="kity_text_8058" text-rendering="inherit" font-size="12" dy=".8em" y="70.70000004768372" x="537.5">2.全表扫描，通过读物理表获取数据，顺序读磁盘上的文件。这种情况会顺序读磁盘上的文件。&#xa0; explain类型是all</text><text id="kity_text_8059" text-rendering="inherit" font-size="12" dy=".8em" y="88.70000004768372" x="537.5">3.覆盖索引,如果where条件的列和返回的数据在一个索引中，那么不需要回查表， explain类型是using index</text><text id="kity_text_8060" text-rendering="inherit" font-size="12" dy=".8em" y="106.70000004768372" x="537.5">如果在磁盘，全索引扫描可能随机io&#xa0; 全表扫描 顺序io&#xa0; 性能更好</text></g></g><g id="minder_node443" display="none"><g id="node_expander441" display="none" style="cursor: pointer;"><path id="kity_path_21845" fill="white" stroke="gray" d="M521.5,95.5A6,6,0,1,1,509.5,95.5A6,6,0,1,1,521.5,95.5"></path><path id="kity_path_21846" fill="none" stroke="gray"></path></g><path id="node_outline442" fill="none" stroke="none" d="M521.5,86.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text442" fill="black"><text id="kity_text_8069" text-rendering="inherit" font-size="12" dy=".8em" y="87.70000004768372" x="521.5">查询优化器的过程？</text></g></g><g id="minder_node444" display="none"><g id="node_expander440" display="none" style="cursor: pointer;"><path id="kity_path_21842" fill="white" stroke="gray" d="M537.5,95.5A6,6,0,1,1,525.5,95.5A6,6,0,1,1,537.5,95.5"></path><path id="kity_path_21843" fill="none" stroke="gray"></path></g><path id="node_outline441" fill="none" stroke="none" d="M537.5,59.5h284a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-284a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text441" fill="black"><text id="kity_text_8064" text-rendering="inherit" font-size="12" dy=".8em" y="60.700000047683716" x="537.5">1：根据搜索条件，找出可能使用的索引。</text><text id="kity_text_8065" text-rendering="inherit" font-size="12" dy=".8em" y="78.70000004768372" x="537.5">2：计算全表扫描的代价。</text><text id="kity_text_8066" text-rendering="inherit" font-size="12" dy=".8em" y="96.70000004768372" x="537.5">3：计算使用不同索引执行查询的代价。</text><text id="kity_text_8067" text-rendering="inherit" font-size="12" dy=".8em" y="114.70000004768372" x="537.5">4：对比各种执行方案的代价，找出成本最低的一个。</text></g></g><g id="minder_node445" display="none"><g id="node_expander503" display="none" style="cursor: pointer;"><path id="kity_path_22031" fill="white" stroke="gray" d="M505.5,103.5A6,6,0,1,1,493.5,103.5A6,6,0,1,1,505.5,103.5"></path><path id="kity_path_22032" fill="none" stroke="gray"></path></g><path id="node_outline504" fill="none" stroke="none" d="M505.5,94.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text504" fill="black"><text id="kity_text_8236" text-rendering="inherit" font-size="12" dy=".8em" y="95.70000004768372" x="505.5">数据库锁</text></g></g><g id="minder_node446" display="none"><g id="node_expander445" display="none" style="cursor: pointer;"><path id="kity_path_21857" fill="white" stroke="gray" d="M521.5,-96.5A6,6,0,1,1,509.5,-96.5A6,6,0,1,1,521.5,-96.5"></path><path id="kity_path_21858" fill="none" stroke="gray"></path></g><path id="node_outline446" fill="none" stroke="none" d="M521.5,-105.5h108a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-108a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text446" fill="black"><text id="kity_text_8077" text-rendering="inherit" font-size="12" dy=".8em" y="-104.29999995231628" x="521.5">说说mysql有哪些锁</text></g></g><g id="minder_node447" display="none"><g id="node_expander444" display="none" style="cursor: pointer;"><path id="kity_path_21854" fill="white" stroke="gray" d="M537.5,-96.5A6,6,0,1,1,525.5,-96.5A6,6,0,1,1,537.5,-96.5"></path><path id="kity_path_21855" fill="none" stroke="gray"></path></g><path id="node_outline445" fill="none" stroke="none" d="M537.5,-105.5h356a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-356a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text445" fill="black"><text id="kity_text_8075" text-rendering="inherit" font-size="12" dy=".8em" y="-104.29999995231628" x="537.5">主要是分为共享锁和排它锁(独占锁)，按锁粒度分表级锁和行级锁，</text></g></g><g id="minder_node448" display="none"><g id="node_expander443" display="none" style="cursor: pointer;"><path id="kity_path_21851" fill="white" stroke="gray" d="M553.5,-96.5A6,6,0,1,1,541.5,-96.5A6,6,0,1,1,553.5,-96.5"></path><path id="kity_path_21852" fill="none" stroke="gray"></path></g><path id="node_outline444" fill="none" stroke="none" d="M454.5,-217.5h200a5,5,0,0,1,5,5v120a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-120a5,5,0,0,1,5,-5z"></path><g id="node_text444" fill="black"><text id="kity_text_8073" text-rendering="inherit" font-size="12" dy=".8em" y="-104.29999995231628" x="553.5"> </text></g><image id="kity_image_17030" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210318162436.png" x="454.5" y="-214.5" width="200" height="107"></image></g><g id="minder_node449" display="none"><g id="node_expander447" display="none" style="cursor: pointer;"><path id="kity_path_21863" fill="white" stroke="gray" d="M521.5,-88.5A6,6,0,1,1,509.5,-88.5A6,6,0,1,1,521.5,-88.5"></path><path id="kity_path_21864" fill="none" stroke="gray"></path></g><path id="node_outline448" fill="none" stroke="none" d="M521.5,-97.5h114a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-114a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text448" fill="black"><text id="kity_text_8081" text-rendering="inherit" font-size="12" dy=".8em" y="-96.29999995231628" x="521.5">innodb中支持什么锁</text></g></g><g id="minder_node450" display="none"><g id="node_expander446" display="none" style="cursor: pointer;"><path id="kity_path_21860" fill="white" stroke="gray" d="M537.5,-88.5A6,6,0,1,1,525.5,-88.5A6,6,0,1,1,537.5,-88.5"></path><path id="kity_path_21861" fill="none" stroke="gray"></path></g><path id="node_outline447" fill="none" stroke="none" d="M537.5,-97.5h261a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-261a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text447" fill="black"><text id="kity_text_8079" text-rendering="inherit" font-size="12" dy=".8em" y="-96.29999995231628" x="537.5">innodb表锁 行锁都支持，MyISAM支持表级锁。</text></g></g><g id="minder_node451" display="none"><g id="node_expander450" display="none" style="cursor: pointer;"><path id="kity_path_21872" fill="white" stroke="gray" d="M521.5,-80.5A6,6,0,1,1,509.5,-80.5A6,6,0,1,1,521.5,-80.5"></path><path id="kity_path_21873" fill="none" stroke="gray"></path></g><path id="node_outline451" fill="none" stroke="none" d="M521.5,-89.5h144a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-144a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text451" fill="black"><text id="kity_text_8089" text-rendering="inherit" font-size="12" dy=".8em" y="-88.29999995231628" x="521.5">Mysql乐观锁和悲观锁说说</text></g></g><g id="minder_node452" display="none"><g id="node_expander449" display="none" style="cursor: pointer;"><path id="kity_path_21869" fill="white" stroke="gray" d="M537.5,-80.5A6,6,0,1,1,525.5,-80.5A6,6,0,1,1,537.5,-80.5"></path><path id="kity_path_21870" fill="none" stroke="gray"></path></g><path id="node_outline450" fill="none" stroke="none" d="M537.5,-107.5h584a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-584a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text450" fill="black"><text id="kity_text_8085" text-rendering="inherit" font-size="12" dy=".8em" y="-106.29999995231628" x="537.5">首先乐观锁悲观锁都是一种思想，不是事实锁。mysql中没有乐观锁，需要自己实现，mysql的锁都是悲观锁。</text><text id="kity_text_8086" text-rendering="inherit" font-size="12" dy=".8em" y="-88.29999995231628" x="537.5">乐观锁认为同一数据的并发操作不会总发生，可以采用版本号机制或者时间戳机制实现；</text><text id="kity_text_8087" text-rendering="inherit" font-size="12" dy=".8em" y="-70.29999995231628" x="537.5">悲观锁会对数据修改操作排它，认为数据随时会被修改，会借助数据库的锁来处理。</text></g></g><g id="minder_node453" display="none"><g id="node_expander448" display="none" style="cursor: pointer;"><path id="kity_path_21866" fill="white" stroke="gray" d="M553.5,-80.5A6,6,0,1,1,541.5,-80.5A6,6,0,1,1,553.5,-80.5"></path><path id="kity_path_21867" fill="none" stroke="gray"></path></g><path id="node_outline449" fill="none" stroke="none" d="M553.5,-89.5h300a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-300a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text449" fill="black"><text id="kity_text_8083" text-rendering="inherit" font-size="12" dy=".8em" y="-88.29999995231628" x="553.5">https://www.cnblogs.com/kismetv/p/10787228.html</text></g></g><g id="minder_node454" display="none"><g id="node_expander452" display="none" style="cursor: pointer;"><path id="kity_path_21878" fill="white" stroke="gray" d="M521.5,-72.5A6,6,0,1,1,509.5,-72.5A6,6,0,1,1,521.5,-72.5"></path><path id="kity_path_21879" fill="none" stroke="gray"></path></g><path id="node_outline453" fill="none" stroke="none" d="M521.5,-81.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text453" fill="black"><text id="kity_text_8093" text-rendering="inherit" font-size="12" dy=".8em" y="-80.29999995231628" x="521.5">说说乐观锁和悲观锁的场景</text></g></g><g id="minder_node455" display="none"><g id="node_expander451" display="none" style="cursor: pointer;"><path id="kity_path_21875" fill="white" stroke="gray" d="M537.5,-72.5A6,6,0,1,1,525.5,-72.5A6,6,0,1,1,537.5,-72.5"></path><path id="kity_path_21876" fill="none" stroke="gray"></path></g><path id="node_outline452" fill="none" stroke="none" d="M537.5,-81.5h409a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-409a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text452" fill="black"><text id="kity_text_8091" text-rendering="inherit" font-size="12" dy=".8em" y="-80.29999995231628" x="537.5">悲观锁：应用于数据更新比较频繁的场景；乐观锁：适用于读多写少的场景。</text></g></g><g id="minder_node456" display="none"><g id="node_expander454" display="none" style="cursor: pointer;"><path id="kity_path_21884" fill="white" stroke="gray" d="M521.5,-64.5A6,6,0,1,1,509.5,-64.5A6,6,0,1,1,521.5,-64.5"></path><path id="kity_path_21885" fill="none" stroke="gray"></path></g><path id="node_outline455" fill="none" stroke="none" d="M521.5,-73.5h62a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-62a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text455" fill="black"><text id="kity_text_8098" text-rendering="inherit" font-size="12" dy=".8em" y="-72.29999995231628" x="521.5">说说共享锁</text></g></g><g id="minder_node457" display="none"><g id="node_expander453" display="none" style="cursor: pointer;"><path id="kity_path_21881" fill="white" stroke="gray" d="M537.5,-64.5A6,6,0,1,1,525.5,-64.5A6,6,0,1,1,537.5,-64.5"></path><path id="kity_path_21882" fill="none" stroke="gray"></path></g><path id="node_outline454" fill="none" stroke="none" d="M537.5,-82.5h738a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-738a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text454" fill="black"><text id="kity_text_8095" text-rendering="inherit" font-size="12" dy=".8em" y="-81.29999995231628" x="537.5">在事务要读取一条记录时，需要先获取该记录的S锁。该事务只能对数据进行读取而不能修改，并且其它事务只能加S锁。S锁和X锁不兼容。</text><text id="kity_text_8096" text-rendering="inherit" font-size="12" dy=".8em" y="-63.299999952316284" x="537.5">select * from table lock in share mode。</text></g></g><g id="minder_node458" display="none"><g id="node_expander456" display="none" style="cursor: pointer;"><path id="kity_path_21890" fill="white" stroke="gray" d="M521.5,-56.5A6,6,0,1,1,509.5,-56.5A6,6,0,1,1,521.5,-56.5"></path><path id="kity_path_21891" fill="none" stroke="gray"></path></g><path id="node_outline457" fill="none" stroke="none" d="M521.5,-65.5h62a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-62a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text457" fill="black"><text id="kity_text_8103" text-rendering="inherit" font-size="12" dy=".8em" y="-64.29999995231628" x="521.5">说说排它锁</text></g></g><g id="minder_node459" display="none"><g id="node_expander455" display="none" style="cursor: pointer;"><path id="kity_path_21887" fill="white" stroke="gray" d="M537.5,-56.5A6,6,0,1,1,525.5,-56.5A6,6,0,1,1,537.5,-56.5"></path><path id="kity_path_21888" fill="none" stroke="gray"></path></g><path id="node_outline456" fill="none" stroke="none" d="M537.5,-74.5h785a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-785a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text456" fill="black"><text id="kity_text_8100" text-rendering="inherit" font-size="12" dy=".8em" y="-73.29999995231628" x="537.5">在事务要改动一条记录时，需要先获取该记录的X锁。事务对数据加上X锁时，只允许此事务读取和修改此数据，并且其它事务不能对该数据加任何锁</text><text id="kity_text_8101" text-rendering="inherit" font-size="12" dy=".8em" y="-55.299999952316284" x="537.5">select * from table for update。</text></g></g><g id="minder_node460" display="none"><g id="node_expander458" display="none" style="cursor: pointer;"><path id="kity_path_21896" fill="white" stroke="gray" d="M521.5,-48.5A6,6,0,1,1,509.5,-48.5A6,6,0,1,1,521.5,-48.5"></path><path id="kity_path_21897" fill="none" stroke="gray"></path></g><path id="node_outline459" fill="none" stroke="none" d="M521.5,-57.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text459" fill="black"><text id="kity_text_8111" text-rendering="inherit" font-size="12" dy=".8em" y="-56.299999952316284" x="521.5">什么是意向锁？作用？</text></g></g><g id="minder_node461" display="none"><g id="node_expander457" display="none" style="cursor: pointer;"><path id="kity_path_21893" fill="white" stroke="gray" d="M537.5,-48.5A6,6,0,1,1,525.5,-48.5A6,6,0,1,1,537.5,-48.5"></path><path id="kity_path_21894" fill="none" stroke="gray"></path></g><path id="node_outline458" fill="none" stroke="none" d="M537.5,-93.5h538a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-538a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text458" fill="black"><text id="kity_text_8105" text-rendering="inherit" font-size="12" dy=".8em" y="-92.29999995231628" x="537.5">1.就是在表级别快速判断加S,X锁之前表有没有已加锁。</text><text id="kity_text_8106" text-rendering="inherit" font-size="12" dy=".8em" y="-74.29999995231628" x="537.5">分意向X锁(IX)和意向S锁(IS)。</text><text id="kity_text_8107" text-rendering="inherit" font-size="12" dy=".8em" y="-56.299999952316284" x="537.5">IS就是在事务准备加S锁之前在表加IS，IX锁就是事务准备加X锁之前在表上加IX锁。意向锁是表级锁。</text><text id="kity_text_8108" text-rendering="inherit" font-size="12" dy=".8em" y="-38.299999952316284" x="537.5">2.</text><text id="kity_text_8109" text-rendering="inherit" font-size="12" dy=".8em" y="-20.299999952316284" x="537.5">如果没有意向锁存储引擎需要遍历所有整个表判断是否有行锁的存在</text></g></g><g id="minder_node462" display="none"><g id="node_expander460" display="none" style="cursor: pointer;"><path id="kity_path_21902" fill="white" stroke="gray" d="M521.5,-40.5A6,6,0,1,1,509.5,-40.5A6,6,0,1,1,521.5,-40.5"></path><path id="kity_path_21903" fill="none" stroke="gray"></path></g><path id="node_outline461" fill="none" stroke="none" d="M521.5,-49.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text461" fill="black"><text id="kity_text_8116" text-rendering="inherit" font-size="12" dy=".8em" y="-48.299999952316284" x="521.5">说说意向锁是怎么快速判断的</text></g></g><g id="minder_node463" display="none"><g id="node_expander459" display="none" style="cursor: pointer;"><path id="kity_path_21899" fill="white" stroke="gray" d="M537.5,-40.5A6,6,0,1,1,525.5,-40.5A6,6,0,1,1,537.5,-40.5"></path><path id="kity_path_21900" fill="none" stroke="gray"></path></g><path id="node_outline460" fill="none" stroke="none" d="M537.5,-58.5h453a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-453a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text460" fill="black"><text id="kity_text_8113" text-rendering="inherit" font-size="12" dy=".8em" y="-57.299999952316284" x="537.5">一个事务在获得某个数据行对象的 S 锁之前，必须先获得整个表的 IS 锁或更强的锁；</text><text id="kity_text_8114" text-rendering="inherit" font-size="12" dy=".8em" y="-39.299999952316284" x="537.5">一个事务在获得某个数据行对象的 X 锁之前，必须先获得整个表的 IX 锁；</text></g></g><g id="minder_node464" display="none"><g id="node_expander462" display="none" style="cursor: pointer;"><path id="kity_path_21908" fill="white" stroke="gray" d="M521.5,-32.5A6,6,0,1,1,509.5,-32.5A6,6,0,1,1,521.5,-32.5"></path><path id="kity_path_21909" fill="none" stroke="gray"></path></g><path id="node_outline463" fill="none" stroke="none" d="M521.5,-41.5h111a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-111a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text463" fill="black"><text id="kity_text_8122" text-rendering="inherit" font-size="12" dy=".8em" y="-40.299999952316284" x="521.5">知道mysql 锁强度吗</text></g></g><g id="minder_node465" display="none"><g id="node_expander461" display="none" style="cursor: pointer;"><path id="kity_path_21905" fill="white" stroke="gray" d="M537.5,-32.5A6,6,0,1,1,525.5,-32.5A6,6,0,1,1,537.5,-32.5"></path><path id="kity_path_21906" fill="none" stroke="gray"></path></g><path id="node_outline462" fill="none" stroke="none" d="M537.5,-59.5h417a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-417a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text462" fill="black"><text id="kity_text_8118" text-rendering="inherit" font-size="12" dy=".8em" y="-58.299999952316284" x="537.5">行级锁(锁数据量少，锁的竞争小，并发高。但是加锁释放锁开销大，会死锁)。</text><text id="kity_text_8119" text-rendering="inherit" font-size="12" dy=".8em" y="-40.299999952316284" x="537.5">表级锁(开销小，并发程度小，消耗小，加锁快，不会发生死锁)。</text><text id="kity_text_8120" text-rendering="inherit" font-size="12" dy=".8em" y="-22.299999952316284" x="537.5">页级锁(界于他们之间，也会死锁)</text></g></g><g id="minder_node466" display="none"><g id="node_expander464" display="none" style="cursor: pointer;"><path id="kity_path_21914" fill="white" stroke="gray" d="M521.5,-24.5A6,6,0,1,1,509.5,-24.5A6,6,0,1,1,521.5,-24.5"></path><path id="kity_path_21915" fill="none" stroke="gray"></path></g><path id="node_outline465" fill="none" stroke="none" d="M521.5,-33.5h162a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-162a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text465" fill="black"><text id="kity_text_8127" text-rendering="inherit" font-size="12" dy=".8em" y="-32.299999952316284" x="521.5">说说行锁和表锁 和它们的问题</text></g></g><g id="minder_node467" display="none"><g id="node_expander463" display="none" style="cursor: pointer;"><path id="kity_path_21911" fill="white" stroke="gray" d="M537.5,-24.5A6,6,0,1,1,525.5,-24.5A6,6,0,1,1,537.5,-24.5"></path><path id="kity_path_21912" fill="none" stroke="gray"></path></g><path id="node_outline464" fill="none" stroke="none" d="M537.5,-42.5h517a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-517a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text464" fill="black"><text id="kity_text_8124" text-rendering="inherit" font-size="12" dy=".8em" y="-41.299999952316284" x="537.5">行锁封锁粒度小，好处：锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高；</text><text id="kity_text_8125" text-rendering="inherit" font-size="12" dy=".8em" y="-23.299999952316284" x="537.5">坏处：系统开销大（加锁、释放锁、检查锁的状态都需要消耗资源）</text></g></g><g id="minder_node468" display="none"><g id="node_expander466" display="none" style="cursor: pointer;"><path id="kity_path_21920" fill="white" stroke="gray" d="M521.5,-16.5A6,6,0,1,1,509.5,-16.5A6,6,0,1,1,521.5,-16.5"></path><path id="kity_path_21921" fill="none" stroke="gray"></path></g><path id="node_outline467" fill="none" stroke="none" d="M521.5,-25.5h146a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-146a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text467" fill="black"><text id="kity_text_8131" text-rendering="inherit" font-size="12" dy=".8em" y="-24.299999952316284" x="521.5">知道两段锁协议吗，你说说</text></g></g><g id="minder_node469" display="none"><g id="node_expander465" display="none" style="cursor: pointer;"><path id="kity_path_21917" fill="white" stroke="gray" d="M537.5,-16.5A6,6,0,1,1,525.5,-16.5A6,6,0,1,1,537.5,-16.5"></path><path id="kity_path_21918" fill="none" stroke="gray"></path></g><path id="node_outline466" fill="none" stroke="none" d="M537.5,-25.5h793a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-793a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text466" fill="black"><text id="kity_text_8129" text-rendering="inherit" font-size="12" dy=".8em" y="-24.299999952316284" x="537.5">也就是说事务必须严格分为两个阶段对数据进行加锁和解锁的操作，第一阶段加锁，第二阶段解锁。一个事务一旦释放了锁就不能马上重新再申请锁。</text></g></g><g id="minder_node470" display="none"><g id="node_expander468" display="none" style="cursor: pointer;"><path id="kity_path_21926" fill="white" stroke="gray" d="M521.5,-8.5A6,6,0,1,1,509.5,-8.5A6,6,0,1,1,521.5,-8.5"></path><path id="kity_path_21927" fill="none" stroke="gray"></path></g><path id="node_outline469" fill="none" stroke="none" d="M521.5,-17.5h168a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-168a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text469" fill="black"><text id="kity_text_8136" text-rendering="inherit" font-size="12" dy=".8em" y="-16.299999952316284" x="521.5">了解三级封锁协议吗，能说说吗</text></g></g><g id="minder_node471" display="none"><g id="node_expander467" display="none" style="cursor: pointer;"><path id="kity_path_21923" fill="white" stroke="gray" d="M537.5,-8.5A6,6,0,1,1,525.5,-8.5A6,6,0,1,1,537.5,-8.5"></path><path id="kity_path_21924" fill="none" stroke="gray"></path></g><path id="node_outline468" fill="none" stroke="none" d="M537.5,-26.5h1414a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1414a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text468" fill="black"><text id="kity_text_8133" text-rendering="inherit" font-size="12" dy=".8em" y="-25.299999952316284" x="537.5">一级封锁协议：事务修改数据之前必须先加X锁，直到事务结束才释放。可以解决丢失修改问题（两个事务不能同时对一个数据加X锁，避免了修改被覆盖）；</text><text id="kity_text_8134" text-rendering="inherit" font-size="12" dy=".8em" y="-7.299999952316284" x="537.5">二级封锁协议：在一级的基础上，事务在读取数据之前必须先加S锁，读完后释放。可以解决脏读问题（如果已经有事务在修改数据，就意味着已经加了X锁，此时想要读取数据的事务并不能加S锁，也就无法进行读取，避免了读取脏数据）；可以解决不可重复读问题；</text></g></g><g id="minder_node472" display="none"><g id="node_expander470" display="none" style="cursor: pointer;"><path id="kity_path_21932" fill="white" stroke="gray" d="M521.5,-0.5A6,6,0,1,1,509.5,-0.5A6,6,0,1,1,521.5,-0.5"></path><path id="kity_path_21933" fill="none" stroke="gray"></path></g><path id="node_outline471" fill="none" stroke="none" d="M521.5,-9.5h61a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-61a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text471" fill="black"><text id="kity_text_8141" text-rendering="inherit" font-size="12" dy=".8em" y="-8.299999952316284" x="521.5">知道死锁吗</text></g></g><g id="minder_node473" display="none"><g id="node_expander469" display="none" style="cursor: pointer;"><path id="kity_path_21929" fill="white" stroke="gray" d="M537.5,-0.5A6,6,0,1,1,525.5,-0.5A6,6,0,1,1,537.5,-0.5"></path><path id="kity_path_21930" fill="none" stroke="gray"></path></g><path id="node_outline470" fill="none" stroke="none" d="M537.5,-18.5h862a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-862a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text470" fill="black"><text id="kity_text_8138" text-rendering="inherit" font-size="12" dy=".8em" y="-17.299999952316284" x="537.5">表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB。</text><text id="kity_text_8139" text-rendering="inherit" font-size="12" dy=".8em" y="0.7000000476837158" x="537.5">锁的等待时间默认是 50 秒。死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。若无外力作用，事务都将无法推进下去。</text></g></g><g id="minder_node474" display="none"><g id="node_expander473" display="none" style="cursor: pointer;"><path id="kity_path_21941" fill="white" stroke="gray" d="M521.5,7.5A6,6,0,1,1,509.5,7.5A6,6,0,1,1,521.5,7.5"></path><path id="kity_path_21942" fill="none" stroke="gray"></path></g><path id="node_outline474" fill="none" stroke="none" d="M521.5,-1.5h134a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-134a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text474" fill="black"><text id="kity_text_8151" text-rendering="inherit" font-size="12" dy=".8em" y="-0.2999999523162842" x="521.5">说说什么情况会造成死锁</text></g></g><g id="minder_node475" display="none"><g id="node_expander472" display="none" style="cursor: pointer;"><path id="kity_path_21938" fill="white" stroke="gray" d="M537.5,7.5A6,6,0,1,1,525.5,7.5A6,6,0,1,1,537.5,7.5"></path><path id="kity_path_21939" fill="none" stroke="gray"></path></g><path id="node_outline473" fill="none" stroke="none" d="M537.5,-37.5h639a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-639a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text473" fill="black"><text id="kity_text_8145" text-rendering="inherit" font-size="12" dy=".8em" y="-36.299999952316284" x="537.5">1.死锁的关键是事务加锁顺序出问题不一致。</text><text id="kity_text_8146" text-rendering="inherit" font-size="12" dy=".8em" y="-18.299999952316284" x="537.5">如：当有一个session持有了X锁，然后又有多个session同时去插入相同行的时候可能会导致死锁，</text><text id="kity_text_8147" text-rendering="inherit" font-size="12" dy=".8em" y="-0.2999999523162842" x="537.5">2.RC情况下&#xa0;唯一索引 S 锁与 X 锁的死锁</text><text id="kity_text_8148" text-rendering="inherit" font-size="12" dy=".8em" y="17.700000047683716" x="537.5">(1)事务A 获取S锁，修改数据，还没有提交，事务B 获取同一行S锁</text><text id="kity_text_8149" text-rendering="inherit" font-size="12" dy=".8em" y="35.700000047683716" x="537.5">(2)A再获取X锁时无法成功获取，因为事务B获取到了S锁，进入锁等待状态， 如果B去获取X锁 就互相对待 就产生了死锁&#xa0;</text></g></g><g id="minder_node476" display="none"><g id="node_expander471" display="none" style="cursor: pointer;"><path id="kity_path_21935" fill="white" stroke="gray" d="M553.5,7.5A6,6,0,1,1,541.5,7.5A6,6,0,1,1,553.5,7.5"></path><path id="kity_path_21936" fill="none" stroke="gray"></path></g><path id="node_outline472" fill="none" stroke="none" d="M553.5,-1.5h326a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text472" fill="black"><text id="kity_text_8143" text-rendering="inherit" font-size="12" dy=".8em" y="-0.2999999523162842" x="553.5">https://juejin.cn/post/6844903848176435207#heading-1</text></g></g><g id="minder_node477" display="none"><g id="node_expander476" display="none" style="cursor: pointer;"><path id="kity_path_21950" fill="white" stroke="gray" d="M521.5,15.5A6,6,0,1,1,509.5,15.5A6,6,0,1,1,521.5,15.5"></path><path id="kity_path_21951" fill="none" stroke="gray"></path></g><path id="node_outline477" fill="none" stroke="none" d="M521.5,6.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text477" fill="black"><text id="kity_text_8160" text-rendering="inherit" font-size="12" dy=".8em" y="7.700000047683716" x="521.5">你怎么排查解决死锁的</text></g></g><g id="minder_node478" display="none"><g id="node_expander475" display="none" style="cursor: pointer;"><path id="kity_path_21947" fill="white" stroke="gray" d="M537.5,15.5A6,6,0,1,1,525.5,15.5A6,6,0,1,1,537.5,15.5"></path><path id="kity_path_21948" fill="none" stroke="gray"></path></g><path id="node_outline476" fill="none" stroke="none" d="M537.5,-11.5h514a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-514a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text476" fill="black"><text id="kity_text_8156" text-rendering="inherit" font-size="12" dy=".8em" y="-10.299999952316284" x="537.5">1.查看锁日志show status like 'innodb_row_lock_%';</text><text id="kity_text_8157" text-rendering="inherit" font-size="12" dy=".8em" y="7.700000047683716" x="537.5">show engine innodb status，来查看死锁的日志，看看是否可以看出，是执行哪几个SQL引起的</text><text id="kity_text_8158" text-rendering="inherit" font-size="12" dy=".8em" y="25.700000047683716" x="537.5">2.MAC下IDEA&#xa0; mysql 源码打断点</text></g></g><g id="minder_node479" display="none"><g id="node_expander474" display="none" style="cursor: pointer;"><path id="kity_path_21944" fill="white" stroke="gray" d="M553.5,15.5A6,6,0,1,1,541.5,15.5A6,6,0,1,1,553.5,15.5"></path><path id="kity_path_21945" fill="none" stroke="gray"></path></g><path id="node_outline475" fill="none" stroke="none" d="M553.5,-2.5h326a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text475" fill="black"><text id="kity_text_8153" text-rendering="inherit" font-size="12" dy=".8em" y="-1.2999999523162842" x="553.5">https://juejin.cn/post/6844903898101055496#heading-2</text><text id="kity_text_8154" text-rendering="inherit" font-size="12" dy=".8em" y="16.700000047683716" x="553.5">https://juejin.cn/post/6844903848385970189</text></g></g><g id="minder_node480" display="none"><g id="node_expander478" display="none" style="cursor: pointer;"><path id="kity_path_21956" fill="white" stroke="gray" d="M521.5,23.5A6,6,0,1,1,509.5,23.5A6,6,0,1,1,521.5,23.5"></path><path id="kity_path_21957" fill="none" stroke="gray"></path></g><path id="node_outline479" fill="none" stroke="none" d="M521.5,14.5h84a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-84a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text479" fill="black"><text id="kity_text_8164" text-rendering="inherit" font-size="12" dy=".8em" y="15.700000047683716" x="521.5">死锁怎么解锁？</text></g></g><g id="minder_node481" display="none"><g id="node_expander477" display="none" style="cursor: pointer;"><path id="kity_path_21953" fill="white" stroke="gray" d="M537.5,23.5A6,6,0,1,1,525.5,23.5A6,6,0,1,1,537.5,23.5"></path><path id="kity_path_21954" fill="none" stroke="gray"></path></g><path id="node_outline478" fill="none" stroke="none" d="M537.5,14.5h254a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-254a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text478" fill="black"><text id="kity_text_8162" text-rendering="inherit" font-size="12" dy=".8em" y="15.700000047683716" x="537.5">InnoDB存储引擎会选择回滚undo量最小的事务</text></g></g><g id="minder_node482" display="none"><g id="node_expander480" display="none" style="cursor: pointer;"><path id="kity_path_21962" fill="white" stroke="gray" d="M521.5,31.5A6,6,0,1,1,509.5,31.5A6,6,0,1,1,521.5,31.5"></path><path id="kity_path_21963" fill="none" stroke="gray"></path></g><path id="node_outline481" fill="none" stroke="none" d="M521.5,22.5h74a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-74a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text481" fill="black"><text id="kity_text_8168" text-rendering="inherit" font-size="12" dy=".8em" y="23.700000047683716" x="521.5">怎么避免死锁</text></g></g><g id="minder_node483" display="none"><g id="node_expander479" display="none" style="cursor: pointer;"><path id="kity_path_21959" fill="white" stroke="gray" d="M537.5,31.5A6,6,0,1,1,525.5,31.5A6,6,0,1,1,537.5,31.5"></path><path id="kity_path_21960" fill="none" stroke="gray"></path></g><path id="node_outline480" fill="none" stroke="none" d="M537.5,22.5h191a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-191a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text480" fill="black"><text id="kity_text_8166" text-rendering="inherit" font-size="12" dy=".8em" y="23.700000047683716" x="537.5">1.操作表的时侯注意顺序，避免环路</text></g></g><g id="minder_node484" display="none"><g id="node_expander482" display="none" style="cursor: pointer;"><path id="kity_path_21968" fill="white" stroke="gray" d="M521.5,39.5A6,6,0,1,1,509.5,39.5A6,6,0,1,1,521.5,39.5"></path><path id="kity_path_21969" fill="none" stroke="gray"></path></g><path id="node_outline483" fill="none" stroke="none" d="M521.5,30.5h119a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-119a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text483" fill="black"><text id="kity_text_8172" text-rendering="inherit" font-size="12" dy=".8em" y="31.700000047683716" x="521.5">mysql怎么实现乐观锁</text></g></g><g id="minder_node485" display="none"><g id="node_expander481" display="none" style="cursor: pointer;"><path id="kity_path_21965" fill="white" stroke="gray" d="M537.5,39.5A6,6,0,1,1,525.5,39.5A6,6,0,1,1,537.5,39.5"></path><path id="kity_path_21966" fill="none" stroke="gray"></path></g><path id="node_outline482" fill="none" stroke="none" d="M537.5,30.5h842a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-842a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text482" fill="black"><text id="kity_text_8170" text-rendering="inherit" font-size="12" dy=".8em" y="31.700000047683716" x="537.5">加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段；先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新</text></g></g><g id="minder_node486" display="none"><g id="node_expander484" display="none" style="cursor: pointer;"><path id="kity_path_21974" fill="white" stroke="gray" d="M521.5,47.5A6,6,0,1,1,509.5,47.5A6,6,0,1,1,521.5,47.5"></path><path id="kity_path_21975" fill="none" stroke="gray"></path></g><path id="node_outline485" fill="none" stroke="none" d="M521.5,38.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text485" fill="black"><text id="kity_text_8180" text-rendering="inherit" font-size="12" dy=".8em" y="39.700000047683716" x="521.5">你知道有哪些行锁？表锁？</text></g></g><g id="minder_node487" display="none"><g id="node_expander483" display="none" style="cursor: pointer;"><path id="kity_path_21971" fill="white" stroke="gray" d="M537.5,47.5A6,6,0,1,1,525.5,47.5A6,6,0,1,1,537.5,47.5"></path><path id="kity_path_21972" fill="none" stroke="gray"></path></g><path id="node_outline484" fill="none" stroke="none" d="M537.5,2.5h616a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-616a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text484" fill="black"><text id="kity_text_8174" text-rendering="inherit" font-size="12" dy=".8em" y="3.700000047683716" x="537.5">1.共享锁(S锁)，排它锁(X锁)，都是行锁</text><text id="kity_text_8175" text-rendering="inherit" font-size="12" dy=".8em" y="21.700000047683716" x="537.5">共享锁（S Lock）：允许事务读取一行数据，多个事务可以拿到一把S锁（即读读并行）；</text><text id="kity_text_8176" text-rendering="inherit" font-size="12" dy=".8em" y="39.700000047683716" x="537.5">排它锁（X Lock）：允许事务删除或更新一行数据，多个事务有且只有一个事务可以拿到X锁（即写写/写读互斥）；</text><text id="kity_text_8177" text-rendering="inherit" font-size="12" dy=".8em" y="57.700000047683716" x="537.5">2.意向共享锁(IS)和意向排它锁(IX)都是表锁</text><text id="kity_text_8178" text-rendering="inherit" font-size="12" dy=".8em" y="75.70000004768372" x="537.5">事务获得共享锁前要先获得意向共享锁，获得排它锁前要先获得意向排它锁。</text></g></g><g id="minder_node488" display="none"><g id="node_expander487" display="none" style="cursor: pointer;"><path id="kity_path_21983" fill="white" stroke="gray" d="M521.5,55.5A6,6,0,1,1,509.5,55.5A6,6,0,1,1,521.5,55.5"></path><path id="kity_path_21984" fill="none" stroke="gray"></path></g><path id="node_outline488" fill="none" stroke="none" d="M521.5,46.5h142a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-142a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text488" fill="black"><text id="kity_text_8191" text-rendering="inherit" font-size="12" dy=".8em" y="47.700000047683716" x="521.5">知道 innodb上锁的算法吗</text></g></g><g id="minder_node489" display="none"><g id="node_expander486" display="none" style="cursor: pointer;"><path id="kity_path_21980" fill="white" stroke="gray" d="M537.5,55.5A6,6,0,1,1,525.5,55.5A6,6,0,1,1,537.5,55.5"></path><path id="kity_path_21981" fill="none" stroke="gray"></path></g><path id="node_outline487" fill="none" stroke="none" d="M537.5,1.5h882a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-882a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text487" fill="black"><text id="kity_text_8184" text-rendering="inherit" font-size="12" dy=".8em" y="2.700000047683716" x="537.5">innodb锁有三种算法，</text><text id="kity_text_8185" text-rendering="inherit" font-size="12" dy=".8em" y="20.700000047683716" x="537.5">1.Record Lock：行锁，单个行记录上的锁。总去锁住索引记录，如果表没有设置任何索引，会使用隐式的主键来进行锁定；</text><text id="kity_text_8186" text-rendering="inherit" font-size="12" dy=".8em" y="38.700000047683716" x="537.5">2.Gap Lock：间隙锁，锁定一个范围，但不包含记录本身；（Gap Lock的作用是为了阻止多个事务将记录插入到同一范围内，而这会产生导致幻读问题。）</text><text id="kity_text_8187" text-rendering="inherit" font-size="12" dy=".8em" y="56.700000047683716" x="537.5">比如 主键索引 1 3 8，给8加gap lock ，(3,8)之间在事务没提交之前是阻塞的</text><text id="kity_text_8188" text-rendering="inherit" font-size="12" dy=".8em" y="74.70000004768372" x="537.5">3.Next-Key Lock：Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身。行的查询采用这种锁定算法。（目的是为了解决幻读）</text><text id="kity_text_8189" text-rendering="inherit" font-size="12" dy=".8em" y="92.70000004768372" x="537.5">比如 主键索引 1 3 8 我想锁8这一条记录 也想 锁 （3，8]之间的间隔，就可以用next key,既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的间隙。</text></g></g><g id="minder_node490" display="none"><g id="node_expander485" display="none" style="cursor: pointer;"><path id="kity_path_21977" fill="white" stroke="gray" d="M553.5,55.5A6,6,0,1,1,541.5,55.5A6,6,0,1,1,553.5,55.5"></path><path id="kity_path_21978" fill="none" stroke="gray"></path></g><path id="node_outline486" fill="none" stroke="none" d="M553.5,46.5h238a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-238a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text486" fill="black"><text id="kity_text_8182" text-rendering="inherit" font-size="12" dy=".8em" y="47.700000047683716" x="553.5">https://zhuanlan.zhihu.com/p/141862443</text></g></g><g id="minder_node491" display="none"><g id="node_expander489" display="none" style="cursor: pointer;"><path id="kity_path_21989" fill="white" stroke="gray" d="M521.5,63.5A6,6,0,1,1,509.5,63.5A6,6,0,1,1,521.5,63.5"></path><path id="kity_path_21990" fill="none" stroke="gray"></path></g><path id="node_outline490" fill="none" stroke="none" d="M521.5,54.5h110a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-110a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text490" fill="black"><text id="kity_text_8200" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="521.5">怎么查看锁日志信息</text></g></g><g id="minder_node492" display="none"><g id="node_expander488" display="none" style="cursor: pointer;"><path id="kity_path_21986" fill="white" stroke="gray" d="M537.5,63.5A6,6,0,1,1,525.5,63.5A6,6,0,1,1,537.5,63.5"></path><path id="kity_path_21987" fill="none" stroke="gray"></path></g><path id="node_outline489" fill="none" stroke="none" d="M537.5,9.5h345a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-345a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text489" fill="black"><text id="kity_text_8193" text-rendering="inherit" font-size="12" dy=".8em" y="10.700000047683716" x="537.5">1.可以看innodb事务id，事务开始时间，锁id，事务的权重</text><text id="kity_text_8194" text-rendering="inherit" font-size="12" dy=".8em" y="28.700000047683716" x="537.5">SHOW FULL PROCESSLIST;</text><text id="kity_text_8195" text-rendering="inherit" font-size="12" dy=".8em" y="46.700000047683716" x="537.5">SHOW ENGINE INNODB STATUS;</text><text id="kity_text_8196" text-rendering="inherit" font-size="12" dy=".8em" y="64.70000004768372" x="537.5">SELECT * FROM information_schema.INNODB_TRX;</text><text id="kity_text_8197" text-rendering="inherit" font-size="12" dy=".8em" y="82.70000004768372" x="537.5">SELECT * FROM information_schema.INNODB_LOCKS;</text><text id="kity_text_8198" text-rendering="inherit" font-size="12" dy=".8em" y="100.70000004768372" x="537.5">SELECT * FROM information_schema.INNODB_LOCK_WAITS;</text></g></g><g id="minder_node493" display="none"><g id="node_expander491" display="none" style="cursor: pointer;"><path id="kity_path_21995" fill="white" stroke="gray" d="M521.5,71.5A6,6,0,1,1,509.5,71.5A6,6,0,1,1,521.5,71.5"></path><path id="kity_path_21996" fill="none" stroke="gray"></path></g><path id="node_outline492" fill="none" stroke="none" d="M521.5,62.5h146a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-146a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text492" fill="black"><text id="kity_text_8209" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="521.5">Record Locks?Gap Locks?</text></g></g><g id="minder_node494" display="none"><g id="node_expander490" display="none" style="cursor: pointer;"><path id="kity_path_21992" fill="white" stroke="gray" d="M537.5,71.5A6,6,0,1,1,525.5,71.5A6,6,0,1,1,537.5,71.5"></path><path id="kity_path_21993" fill="none" stroke="gray"></path></g><path id="node_outline491" fill="none" stroke="none" d="M537.5,17.5h1017a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1017a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text491" fill="black"><text id="kity_text_8202" text-rendering="inherit" font-size="12" dy=".8em" y="18.700000047683716" x="537.5">1.行锁已经在上面说了，</text><text id="kity_text_8203" text-rendering="inherit" font-size="12" dy=".8em" y="36.700000047683716" x="537.5">2.Gap Lock：使用范围条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁。对于键值在条件范围内但并不存在的记录InnoDB 也会对这个“间隙”加锁</text><text id="kity_text_8204" text-rendering="inherit" font-size="12" dy=".8em" y="54.700000047683716" x="537.5">对索引项之间的“间隙”加锁，锁定记录的范围(1,9)不包括1和9。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。</text><text id="kity_text_8205" text-rendering="inherit" font-size="12" dy=".8em" y="72.70000004768372" x="537.5">间隙锁基于非唯一索引，它锁定一段范围内的索引区间记录。而不仅仅是这个区间中的每一条数据。</text><text id="kity_text_8206" text-rendering="inherit" font-size="12" dy=".8em" y="90.70000004768372" x="537.5">3.不能明确锁定某个索引、或者某个索引值是可重复的，那么就会触发间隙锁，也是幻读的问题。</text><text id="kity_text_8207" text-rendering="inherit" font-size="12" dy=".8em" y="108.70000004768372" x="537.5">4.当查询的索引含有唯一属性时，将next-key lock降级为record key</text></g></g><g id="minder_node495" display="none"><g id="node_expander493" display="none" style="cursor: pointer;"><path id="kity_path_22001" fill="white" stroke="gray" d="M521.5,79.5A6,6,0,1,1,509.5,79.5A6,6,0,1,1,521.5,79.5"></path><path id="kity_path_22002" fill="none" stroke="gray"></path></g><path id="node_outline494" fill="none" stroke="none" d="M521.5,70.5h125a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-125a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text494" fill="black"><text id="kity_text_8213" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="521.5">Next-Key Locks知道吗</text></g></g><g id="minder_node496" display="none"><g id="node_expander492" display="none" style="cursor: pointer;"><path id="kity_path_21998" fill="white" stroke="gray" d="M537.5,79.5A6,6,0,1,1,525.5,79.5A6,6,0,1,1,537.5,79.5"></path><path id="kity_path_21999" fill="none" stroke="gray"></path></g><path id="node_outline493" fill="none" stroke="none" d="M537.5,70.5h676a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-676a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text493" fill="black"><text id="kity_text_8211" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="537.5">1.临键锁=间隙锁+行锁，于是临键锁的区域是一个左开右闭的区间。既包含索引记录，又包含索引区间，主要是为了解决幻读。</text></g></g><g id="minder_node497" display="none"><g id="node_expander496" display="none" style="cursor: pointer;"><path id="kity_path_22010" fill="white" stroke="gray" d="M521.5,87.5A6,6,0,1,1,509.5,87.5A6,6,0,1,1,521.5,87.5"></path><path id="kity_path_22011" fill="none" stroke="gray"></path></g><path id="node_outline497" fill="none" stroke="none" d="M521.5,78.5h192a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-192a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text497" fill="black"><text id="kity_text_8220" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="521.5">你知道mysql隐式锁是个什么情况不</text></g></g><g id="minder_node498" display="none"><g id="node_expander495" display="none" style="cursor: pointer;"><path id="kity_path_22007" fill="white" stroke="gray" d="M537.5,87.5A6,6,0,1,1,525.5,87.5A6,6,0,1,1,537.5,87.5"></path><path id="kity_path_22008" fill="none" stroke="gray"></path></g><path id="node_outline496" fill="none" stroke="none" d="M537.5,69.5h691a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-691a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text496" fill="black"><text id="kity_text_8217" text-rendering="inherit" font-size="12" dy=".8em" y="70.70000004768372" x="537.5">1.当事务需要加锁的时，如果这个锁不可能发生冲突，InnoDB会跳过加锁环节，这种机制称为隐式锁。</text><text id="kity_text_8218" text-rendering="inherit" font-size="12" dy=".8em" y="88.70000004768372" x="537.5">隐式锁是InnoDB实现的一种延迟加锁机制，其特点是只有在可能发生冲突时才加锁，从而减少了锁的数量，提高了系统整体性能。</text></g></g><g id="minder_node499" display="none"><g id="node_expander494" display="none" style="cursor: pointer;"><path id="kity_path_22004" fill="white" stroke="gray" d="M553.5,87.5A6,6,0,1,1,541.5,87.5A6,6,0,1,1,553.5,87.5"></path><path id="kity_path_22005" fill="none" stroke="gray"></path></g><path id="node_outline495" fill="none" stroke="none" d="M553.5,78.5h268a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-268a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text495" fill="black"><text id="kity_text_8215" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="553.5">http://mysql.taobao.org/monthly/2020/09/06/</text></g></g><g id="minder_node500" display="none"><g id="node_expander499" display="none" style="cursor: pointer;"><path id="kity_path_22019" fill="white" stroke="gray" d="M521.5,95.5A6,6,0,1,1,509.5,95.5A6,6,0,1,1,521.5,95.5"></path><path id="kity_path_22020" fill="none" stroke="gray"></path></g><path id="node_outline500" fill="none" stroke="none" d="M521.5,86.5h146a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-146a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text500" fill="black"><text id="kity_text_8226" text-rendering="inherit" font-size="12" dy=".8em" y="87.70000004768372" x="521.5">mysql加间隙锁的sql怎么写</text></g></g><g id="minder_node501" display="none"><g id="node_expander498" display="none" style="cursor: pointer;"><path id="kity_path_22016" fill="white" stroke="gray" d="M537.5,95.5A6,6,0,1,1,525.5,95.5A6,6,0,1,1,537.5,95.5"></path><path id="kity_path_22017" fill="none" stroke="gray"></path></g><path id="node_outline499" fill="none" stroke="none" d="M537.5,86.5h767a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-767a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text499" fill="black"><text id="kity_text_8224" text-rendering="inherit" font-size="12" dy=".8em" y="87.70000004768372" x="537.5">1.&#xa0; 比如id是索引，已有id = 1 3 5 8，然后 select xxx where id=3 for update ，再开个会话 去 insert xxx where id=4 阻塞， (1,5)是 gap lock</text></g></g><g id="minder_node502" display="none"><g id="node_expander497" display="none" style="cursor: pointer;"><path id="kity_path_22013" fill="white" stroke="gray" d="M553.5,95.5A6,6,0,1,1,541.5,95.5A6,6,0,1,1,553.5,95.5"></path><path id="kity_path_22014" fill="none" stroke="gray"></path></g><path id="node_outline498" fill="none" stroke="none" d="M553.5,86.5h240a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-240a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text498" fill="black"><text id="kity_text_8222" text-rendering="inherit" font-size="12" dy=".8em" y="87.70000004768372" x="553.5">https://www.jianshu.com/p/0f3d45c645ac</text></g></g><g id="minder_node503" display="none"><g id="node_expander502" display="none" style="cursor: pointer;"><path id="kity_path_22028" fill="white" stroke="gray" d="M521.5,103.5A6,6,0,1,1,509.5,103.5A6,6,0,1,1,521.5,103.5"></path><path id="kity_path_22029" fill="none" stroke="gray"></path></g><path id="node_outline503" fill="none" stroke="none" d="M521.5,94.5h142a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-142a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text503" fill="black"><text id="kity_text_8234" text-rendering="inherit" font-size="12" dy=".8em" y="95.70000004768372" x="521.5">mysql行锁是怎么实现的，</text></g></g><g id="minder_node504" display="none"><g id="node_expander501" display="none" style="cursor: pointer;"><path id="kity_path_22025" fill="white" stroke="gray" d="M537.5,103.5A6,6,0,1,1,525.5,103.5A6,6,0,1,1,537.5,103.5"></path><path id="kity_path_22026" fill="none" stroke="gray"></path></g><path id="node_outline502" fill="none" stroke="none" d="M537.5,76.5h625a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-625a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text502" fill="black"><text id="kity_text_8230" text-rendering="inherit" font-size="12" dy=".8em" y="77.70000004768372" x="537.5">1.Innodb行锁是通过 索引加锁实现行锁,所以通过索引检索数据时才会使用行锁,否则会使用表级锁</text><text id="kity_text_8231" text-rendering="inherit" font-size="12" dy=".8em" y="95.70000004768372" x="537.5">2.如果查询时出现相同索引项 多行数据的情况，非同行数据会出现锁冲突，索引对应的所有行都会被加上锁，影响性能</text><text id="kity_text_8232" text-rendering="inherit" font-size="12" dy=".8em" y="113.70000004768372" x="537.5">3.next-key是间隙锁+行锁，锁范围也锁自己，范围外的查询也锁，防止幻读和新增数据事务失败回滚</text></g></g><g id="minder_node505" display="none"><g id="node_expander500" display="none" style="cursor: pointer;"><path id="kity_path_22022" fill="white" stroke="gray" d="M553.5,103.5A6,6,0,1,1,541.5,103.5A6,6,0,1,1,553.5,103.5"></path><path id="kity_path_22023" fill="none" stroke="gray"></path></g><path id="node_outline501" fill="none" stroke="none" d="M553.5,94.5h335a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-335a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text501" fill="black"><text id="kity_text_8228" text-rendering="inherit" font-size="12" dy=".8em" y="95.70000004768372" x="553.5">https://blog.csdn.net/xts5701046/article/details/81395958</text></g></g><g id="minder_node506" display="none"><g id="node_expander519" display="none" style="cursor: pointer;"><path id="kity_path_22079" fill="white" stroke="gray" d="M505.5,111.5A6,6,0,1,1,493.5,111.5A6,6,0,1,1,505.5,111.5"></path><path id="kity_path_22080" fill="none" stroke="gray"></path></g><path id="node_outline520" fill="none" stroke="none" d="M505.5,102.5h110a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-110a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text520" fill="black"><text id="kity_text_8288" text-rendering="inherit" font-size="12" dy=".8em" y="103.70000004768372" x="505.5">底层和微进阶和设计</text></g></g><g id="minder_node507" display="none"><g id="node_expander505" display="none" style="cursor: pointer;"><path id="kity_path_22037" fill="white" stroke="gray" d="M521.5,55.5A6,6,0,1,1,509.5,55.5A6,6,0,1,1,521.5,55.5"></path><path id="kity_path_22038" fill="none" stroke="gray"></path></g><path id="node_outline506" fill="none" stroke="none" d="M521.5,46.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text506" fill="black"><text id="kity_text_8245" text-rendering="inherit" font-size="12" dy=".8em" y="47.700000047683716" x="521.5">说说设计表有什么需要注意的</text></g></g><g id="minder_node508" display="none"><g id="node_expander504" display="none" style="cursor: pointer;"><path id="kity_path_22034" fill="white" stroke="gray" d="M537.5,55.5A6,6,0,1,1,525.5,55.5A6,6,0,1,1,537.5,55.5"></path><path id="kity_path_22035" fill="none" stroke="gray"></path></g><path id="node_outline505" fill="none" stroke="none" d="M537.5,1.5h637a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-637a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text505" fill="black"><text id="kity_text_8238" text-rendering="inherit" font-size="12" dy=".8em" y="2.700000047683716" x="537.5">1.应该避免，太多的列这种宽表模式设计。太多的关联。</text><text id="kity_text_8239" text-rendering="inherit" font-size="12" dy=".8em" y="20.700000047683716" x="537.5">2.表达是与否概念的字段，使用 is_xxx的方式命名，数据类型是 unsigned tinyint（ 1表示是，0表示否）</text><text id="kity_text_8240" text-rendering="inherit" font-size="12" dy=".8em" y="38.700000047683716" x="537.5">3.唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。</text><text id="kity_text_8241" text-rendering="inherit" font-size="12" dy=".8em" y="56.700000047683716" x="537.5">4.表必备三字段：id, gmt_create, gmt_modified。</text><text id="kity_text_8242" text-rendering="inherit" font-size="12" dy=".8em" y="74.70000004768372" x="537.5">5.varchar是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，</text><text id="kity_text_8243" text-rendering="inherit" font-size="12" dy=".8em" y="92.70000004768372" x="537.5">独立出来一张表，用主键来对应，避免影响其它字段索引效率。</text></g></g><g id="minder_node509" display="none"><g id="node_expander507" display="none" style="cursor: pointer;"><path id="kity_path_22043" fill="white" stroke="gray" d="M521.5,63.5A6,6,0,1,1,509.5,63.5A6,6,0,1,1,521.5,63.5"></path><path id="kity_path_22044" fill="none" stroke="gray"></path></g><path id="node_outline508" fill="none" stroke="none" d="M521.5,54.5h98a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-98a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text508" fill="black"><text id="kity_text_8252" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="521.5">字段设计注意事项</text></g></g><g id="minder_node510" display="none"><g id="node_expander506" display="none" style="cursor: pointer;"><path id="kity_path_22040" fill="white" stroke="gray" d="M537.5,63.5A6,6,0,1,1,525.5,63.5A6,6,0,1,1,537.5,63.5"></path><path id="kity_path_22041" fill="none" stroke="gray"></path></g><path id="node_outline507" fill="none" stroke="none" d="M537.5,27.5h811a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-811a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text507" fill="black"><text id="kity_text_8247" text-rendering="inherit" font-size="12" dy=".8em" y="28.700000047683716" x="537.5">1.列字段不能太多,关联字段保证关联唯一性。为查询效率可增加冗余字段。业务表留几个预留字段</text><text id="kity_text_8248" text-rendering="inherit" font-size="12" dy=".8em" y="46.700000047683716" x="537.5">2.字段尽量设置默认值，也减少业务上查询出来的判空操作或者空指针错误。空值是不占用空间的,但是NULL占用内存空间,并且NULL值还会造成索引失效</text><text id="kity_text_8249" text-rendering="inherit" font-size="12" dy=".8em" y="64.70000004768372" x="537.5">3.使用innondb引擎。不在表上定义外键约束,减少维护难度。使用逻辑删除,物理删除其实记录还是在表上存在的.但是会产生大量碎片,影响连续读取效率.</text><text id="kity_text_8250" text-rendering="inherit" font-size="12" dy=".8em" y="82.70000004768372" x="537.5">4.必须添加注释</text></g></g><g id="minder_node511" display="none"><g id="node_expander509" display="none" style="cursor: pointer;"><path id="kity_path_22049" fill="white" stroke="gray" d="M521.5,71.5A6,6,0,1,1,509.5,71.5A6,6,0,1,1,521.5,71.5"></path><path id="kity_path_22050" fill="none" stroke="gray"></path></g><path id="node_outline510" fill="none" stroke="none" d="M521.5,62.5h166a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-166a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text510" fill="black"><text id="kity_text_8261" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="521.5">mysql脏页是什么？什么场景？</text></g></g><g id="minder_node512" display="none"><g id="node_expander508" display="none" style="cursor: pointer;"><path id="kity_path_22046" fill="white" stroke="gray" d="M537.5,71.5A6,6,0,1,1,525.5,71.5A6,6,0,1,1,537.5,71.5"></path><path id="kity_path_22047" fill="none" stroke="gray"></path></g><path id="node_outline509" fill="none" stroke="none" d="M537.5,17.5h382a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-382a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text509" fill="black"><text id="kity_text_8254" text-rendering="inherit" font-size="12" dy=".8em" y="18.700000047683716" x="537.5">1.内存中的数据页跟磁盘中的数据页不一致的时候，这些数据页就是脏页</text><text id="kity_text_8255" text-rendering="inherit" font-size="12" dy=".8em" y="36.700000047683716" x="537.5">2.场景</text><text id="kity_text_8256" text-rendering="inherit" font-size="12" dy=".8em" y="54.700000047683716" x="537.5">InnoDB的redo log写满了</text><text id="kity_text_8257" text-rendering="inherit" font-size="12" dy=".8em" y="72.70000004768372" x="537.5">系统内存不足</text><text id="kity_text_8258" text-rendering="inherit" font-size="12" dy=".8em" y="90.70000004768372" x="537.5">系统空闲时（不影响性能）</text><text id="kity_text_8259" text-rendering="inherit" font-size="12" dy=".8em" y="108.70000004768372" x="537.5">MySQL正常关闭过程（不影响性能）</text></g></g><g id="minder_node513" display="none"><g id="node_expander511" display="none" style="cursor: pointer;"><path id="kity_path_22055" fill="white" stroke="gray" d="M521.5,79.5A6,6,0,1,1,509.5,79.5A6,6,0,1,1,521.5,79.5"></path><path id="kity_path_22056" fill="none" stroke="gray"></path></g><path id="node_outline512" fill="none" stroke="none" d="M521.5,70.5h158a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-158a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text512" fill="black"><text id="kity_text_8271" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="521.5">脏页会有什么影响？怎么解决</text></g></g><g id="minder_node514" display="none"><g id="node_expander510" display="none" style="cursor: pointer;"><path id="kity_path_22052" fill="white" stroke="gray" d="M537.5,79.5A6,6,0,1,1,525.5,79.5A6,6,0,1,1,537.5,79.5"></path><path id="kity_path_22053" fill="none" stroke="gray"></path></g><path id="node_outline511" fill="none" stroke="none" d="M537.5,16.5h1159a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-1159a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text511" fill="black"><text id="kity_text_8263" text-rendering="inherit" font-size="12" dy=".8em" y="17.700000047683716" x="537.5">影响：</text><text id="kity_text_8264" text-rendering="inherit" font-size="12" dy=".8em" y="35.700000047683716" x="537.5">1.InnoDB的redo log写满了，整个系统就不能再接受更新了，所有更新都将被阻塞</text><text id="kity_text_8265" text-rendering="inherit" font-size="12" dy=".8em" y="53.700000047683716" x="537.5">2.内存不足(buffer pool的剩余内存不足)。数据页从磁盘读入内存时，需要向buffer_pool申请一个数据页，buffer_pool会根据LRU(InnoDB加载冷数据的同时，可以保持buffer_pool的内存命中率)算法淘汰一个数据页，</text><text id="kity_text_8266" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="537.5">如果淘汰的数据页是脏页，那么会先将脏页数据刷新到磁盘中，然后才复用数据页；如果一个查询要淘汰掉的脏页太多了，会导致查询的响应时间变长</text><text id="kity_text_8267" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="537.5">解决：</text><text id="kity_text_8268" text-rendering="inherit" font-size="12" dy=".8em" y="107.70000004768372" x="537.5">1.设置innodb_io_capacity参数，指定InnoDB刷新脏页的速度上限</text><text id="kity_text_8269" text-rendering="inherit" font-size="12" dy=".8em" y="125.70000004768372" x="537.5">2.刷脏页的额时候，如果发现脏页旁边的数据页（邻居）也是脏页，就会将这个邻居也一并刷掉，减少随机器IO，设置innodb_flush_neighbors</text></g></g><g id="minder_node515" display="none"><g id="node_expander513" display="none" style="cursor: pointer;"><path id="kity_path_22061" fill="white" stroke="gray" d="M521.5,87.5A6,6,0,1,1,509.5,87.5A6,6,0,1,1,521.5,87.5"></path><path id="kity_path_22062" fill="none" stroke="gray"></path></g><path id="node_outline514" fill="none" stroke="none" d="M521.5,78.5h265a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-265a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text514" fill="black"><text id="kity_text_8276" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="521.5">MySQL不建议使用NULL作为列默认值到底为什么</text></g></g><g id="minder_node516" display="none"><g id="node_expander512" display="none" style="cursor: pointer;"><path id="kity_path_22058" fill="white" stroke="gray" d="M537.5,87.5A6,6,0,1,1,525.5,87.5A6,6,0,1,1,537.5,87.5"></path><path id="kity_path_22059" fill="none" stroke="gray"></path></g><path id="node_outline513" fill="none" stroke="none" d="M537.5,69.5h431a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-431a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text513" fill="black"><text id="kity_text_8273" text-rendering="inherit" font-size="12" dy=".8em" y="70.70000004768372" x="537.5">1.列中使用NULL值容易引发不受控制的事情发生,有时候还会严重托慢系统的性能.</text><text id="kity_text_8274" text-rendering="inherit" font-size="12" dy=".8em" y="88.70000004768372" x="537.5">2.可以使用NOT NULL消除默认设置,使用0或者''空字符串来代替NULL.</text></g></g><g id="minder_node517" display="none"><g id="node_expander515" display="none" style="cursor: pointer;"><path id="kity_path_22067" fill="white" stroke="gray" d="M521.5,95.5A6,6,0,1,1,509.5,95.5A6,6,0,1,1,521.5,95.5"></path><path id="kity_path_22068" fill="none" stroke="gray"></path></g><path id="node_outline516" fill="none" stroke="none" d="M521.5,86.5h123a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-123a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text516" fill="black"><text id="kity_text_8280" text-rendering="inherit" font-size="12" dy=".8em" y="87.70000004768372" x="521.5">mysql数据页 和页分裂</text></g></g><g id="minder_node518" display="none"><g id="node_expander514" display="none" style="cursor: pointer;"><path id="kity_path_22064" fill="white" stroke="gray" d="M537.5,95.5A6,6,0,1,1,525.5,95.5A6,6,0,1,1,537.5,95.5"></path><path id="kity_path_22065" fill="none" stroke="gray"></path></g><path id="node_outline515" fill="none" stroke="none" d="M537.5,86.5h332a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-332a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text515" fill="black"><text id="kity_text_8278" text-rendering="inherit" font-size="12" dy=".8em" y="87.70000004768372" x="537.5">https://www.cnblogs.com/ZhuChangwu/p/14041410.html</text></g></g><g id="minder_node519" display="none"><g id="node_expander517" display="none" style="cursor: pointer;"><path id="kity_path_22073" fill="white" stroke="gray" d="M521.5,103.5A6,6,0,1,1,509.5,103.5A6,6,0,1,1,521.5,103.5"></path><path id="kity_path_22074" fill="none" stroke="gray"></path></g><path id="node_outline518" fill="none" stroke="none" d="M521.5,94.5h162a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-162a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text518" fill="black"><text id="kity_text_8284" text-rendering="inherit" font-size="12" dy=".8em" y="95.70000004768372" x="521.5">mysql 查询缓存和buffer pool</text></g></g><g id="minder_node520" display="none"><g id="node_expander516" display="none" style="cursor: pointer;"><path id="kity_path_22070" fill="white" stroke="gray" d="M537.5,103.5A6,6,0,1,1,525.5,103.5A6,6,0,1,1,537.5,103.5"></path><path id="kity_path_22071" fill="none" stroke="gray"></path></g><path id="node_outline517" fill="none" stroke="none" d="M537.5,94.5h329a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-329a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text517" fill="black"><text id="kity_text_8282" text-rendering="inherit" font-size="12" dy=".8em" y="95.70000004768372" x="537.5">https://mp.weixin.qq.com/s/GB1OVQc8Cwv5Qpy329PIaA</text></g></g><g id="minder_node521" display="none"><g id="node_expander518" display="none" style="cursor: pointer;"><path id="kity_path_22076" fill="white" stroke="gray" d="M521.5,111.5A6,6,0,1,1,509.5,111.5A6,6,0,1,1,521.5,111.5"></path><path id="kity_path_22077" fill="none" stroke="gray"></path></g><path id="node_outline519" fill="none" stroke="none" d="M521.5,102.5h131a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-131a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text519" fill="black"><text id="kity_text_8286" text-rendering="inherit" font-size="12" dy=".8em" y="103.70000004768372" x="521.5">mysql insert的执行过程</text></g></g><g id="minder_node522" display="none"><g id="node_expander589" display="none" style="cursor: pointer;"><path id="kity_path_22289" fill="white" stroke="gray" d="M505.5,119.5A6,6,0,1,1,493.5,119.5A6,6,0,1,1,505.5,119.5"></path><path id="kity_path_22290" fill="none" stroke="gray"></path></g><path id="node_outline590" fill="none" stroke="none" d="M505.5,110.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text590" fill="black"><text id="kity_text_8483" text-rendering="inherit" font-size="12" dy=".8em" y="111.70000004768372" x="505.5">日志</text></g></g><g id="minder_node523" display="none"><g id="node_expander522" display="none" style="cursor: pointer;"><path id="kity_path_22088" fill="white" stroke="gray" d="M521.5,23.5A6,6,0,1,1,509.5,23.5A6,6,0,1,1,521.5,23.5"></path><path id="kity_path_22089" fill="none" stroke="gray"></path></g><path id="node_outline523" fill="none" stroke="none" d="M521.5,14.5h156a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-156a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text523" fill="black"><text id="kity_text_8298" text-rendering="inherit" font-size="12" dy=".8em" y="15.700000047683716" x="521.5">简单说说mysql日志的有哪些</text></g></g><g id="minder_node524" display="none"><g id="node_expander521" display="none" style="cursor: pointer;"><path id="kity_path_22085" fill="white" stroke="gray" d="M537.5,23.5A6,6,0,1,1,525.5,23.5A6,6,0,1,1,537.5,23.5"></path><path id="kity_path_22086" fill="none" stroke="gray"></path></g><path id="node_outline522" fill="none" stroke="none" d="M537.5,-21.5h110a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-110a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text522" fill="black"><text id="kity_text_8292" text-rendering="inherit" font-size="12" dy=".8em" y="-20.299999952316284" x="537.5">最主要的是下面三类</text><text id="kity_text_8293" text-rendering="inherit" font-size="12" dy=".8em" y="-2.299999952316284" x="537.5">1.undo log</text><text id="kity_text_8294" text-rendering="inherit" font-size="12" dy=".8em" y="15.700000047683716" x="537.5">2.bin log</text><text id="kity_text_8295" text-rendering="inherit" font-size="12" dy=".8em" y="33.700000047683716" x="537.5">3.redo log</text><text id="kity_text_8296" text-rendering="inherit" font-size="12" dy=".8em" y="51.700000047683716" x="537.5">4.relay log</text></g></g><g id="minder_node525" display="none"><g id="node_expander520" display="none" style="cursor: pointer;"><path id="kity_path_22082" fill="white" stroke="gray" d="M553.5,23.5A6,6,0,1,1,541.5,23.5A6,6,0,1,1,553.5,23.5"></path><path id="kity_path_22083" fill="none" stroke="gray"></path></g><path id="node_outline521" fill="none" stroke="none" d="M478.5,-49.5h200a5,5,0,0,1,5,5v72a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-72a5,5,0,0,1,5,-5z"></path><g id="node_text521" fill="black"><text id="kity_text_8290" text-rendering="inherit" font-size="12" dy=".8em" y="15.700000047683716" x="553.5">分支主题</text></g><image id="kity_image_17031" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210318015440.png" x="478.5" y="-46.5" width="200" height="59"></image></g><g id="minder_node526" display="none"><g id="node_expander543" display="none" style="cursor: pointer;"><path id="kity_path_22151" fill="white" stroke="gray" d="M521.5,31.5A6,6,0,1,1,509.5,31.5A6,6,0,1,1,521.5,31.5"></path><path id="kity_path_22152" fill="none" stroke="gray"></path></g><path id="node_outline544" fill="none" stroke="none" d="M521.5,22.5h45a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-45a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text544" fill="black"><text id="kity_text_8356" text-rendering="inherit" font-size="12" dy=".8em" y="23.700000047683716" x="521.5">redolog</text></g></g><g id="minder_node527" display="none"><g id="node_expander525" display="none" style="cursor: pointer;"><path id="kity_path_22097" fill="white" stroke="gray" d="M537.5,-32.5A6,6,0,1,1,525.5,-32.5A6,6,0,1,1,537.5,-32.5"></path><path id="kity_path_22098" fill="none" stroke="gray"></path></g><path id="node_outline526" fill="none" stroke="none" d="M537.5,-41.5h154a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-154a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text526" fill="black"><text id="kity_text_8308" text-rendering="inherit" font-size="12" dy=".8em" y="-40.299999952316284" x="537.5">知道redolog吗？干什么的？</text></g></g><g id="minder_node528" display="none"><g id="node_expander524" display="none" style="cursor: pointer;"><path id="kity_path_22094" fill="white" stroke="gray" d="M553.5,-32.5A6,6,0,1,1,541.5,-32.5A6,6,0,1,1,553.5,-32.5"></path><path id="kity_path_22095" fill="none" stroke="gray"></path></g><path id="node_outline525" fill="none" stroke="none" d="M553.5,-77.5h997a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-997a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text525" fill="black"><text id="kity_text_8302" text-rendering="inherit" font-size="12" dy=".8em" y="-76.29999995231628" x="553.5">1.redo log叫做恢复(重做)日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。</text><text id="kity_text_8303" text-rendering="inherit" font-size="12" dy=".8em" y="-58.299999952316284" x="553.5">当事务提交之后会把所有修改信息都会存到该日志中</text><text id="kity_text_8304" text-rendering="inherit" font-size="12" dy=".8em" y="-40.299999952316284" x="553.5">2.确保事务的持久性。</text><text id="kity_text_8305" text-rendering="inherit" font-size="12" dy=".8em" y="-22.299999952316284" x="553.5">mysql 为了提升性能不会把每次的修改都实时同步到磁盘，会先存到Boffer Pool里头，当作缓存来用。然后使用后台线程去做缓冲池和磁盘之间的同步。而同步时防止宕机出现数据丢失</text><text id="kity_text_8306" text-rendering="inherit" font-size="12" dy=".8em" y="-4.299999952316284" x="553.5">引入redo log来记录已成功提交事务的修改信息，并且会把redo log持久化到磁盘，系统重启之后在读取redo log恢复最新数据。</text></g></g><g id="minder_node529" display="none"><g id="node_expander523" display="none" style="cursor: pointer;"><path id="kity_path_22091" fill="white" stroke="gray" d="M569.5,-32.5A6,6,0,1,1,557.5,-32.5A6,6,0,1,1,569.5,-32.5"></path><path id="kity_path_22092" fill="none" stroke="gray"></path></g><path id="node_outline524" fill="none" stroke="none" d="M494.5,-140.5h200a5,5,0,0,1,5,5v107a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-107a5,5,0,0,1,5,-5z"></path><g id="node_text524" fill="black"><text id="kity_text_8300" text-rendering="inherit" font-size="12" dy=".8em" y="-40.299999952316284" x="569.5">分支主题</text></g><image id="kity_image_17032" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210318225127.png" x="494.5" y="-137.5" width="200" height="94"></image></g><g id="minder_node530" display="none"><g id="node_expander528" display="none" style="cursor: pointer;"><path id="kity_path_22106" fill="white" stroke="gray" d="M537.5,-24.5A6,6,0,1,1,525.5,-24.5A6,6,0,1,1,537.5,-24.5"></path><path id="kity_path_22107" fill="none" stroke="gray"></path></g><path id="node_outline529" fill="none" stroke="none" d="M537.5,-33.5h184a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-184a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text529" fill="black"><text id="kity_text_8316" text-rendering="inherit" font-size="12" dy=".8em" y="-32.299999952316284" x="537.5">说一下为什么有redo log buffer？</text></g></g><g id="minder_node531" display="none"><g id="node_expander527" display="none" style="cursor: pointer;"><path id="kity_path_22103" fill="white" stroke="gray" d="M553.5,-24.5A6,6,0,1,1,541.5,-24.5A6,6,0,1,1,553.5,-24.5"></path><path id="kity_path_22104" fill="none" stroke="gray"></path></g><path id="node_outline528" fill="none" stroke="none" d="M553.5,-51.5h769a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-769a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text528" fill="black"><text id="kity_text_8312" text-rendering="inherit" font-size="12" dy=".8em" y="-50.299999952316284" x="553.5">1.mysql每执行一条DML语句，先将记录写入redo log buffer，后续某个时间点再一次性将多个操作记录写到redo log file。先写日志，再写磁盘</text><text id="kity_text_8313" text-rendering="inherit" font-size="12" dy=".8em" y="-32.299999952316284" x="553.5">2.用户空间(user space)下的缓冲区数据一般情况下是无法直接写入磁盘的，中间须经过操作系统内核空间(kernel space)缓冲区(OS Buffer)。</text><text id="kity_text_8314" text-rendering="inherit" font-size="12" dy=".8em" y="-14.299999952316284" x="553.5">因此，redo log buffer写入redo log file实际上是先写入OS Buffer，然后再通过系统调用fsync()将其刷到redo log</text></g></g><g id="minder_node532" display="none"><g id="node_expander526" display="none" style="cursor: pointer;"><path id="kity_path_22100" fill="white" stroke="gray" d="M569.5,-24.5A6,6,0,1,1,557.5,-24.5A6,6,0,1,1,569.5,-24.5"></path><path id="kity_path_22101" fill="none" stroke="gray"></path></g><path id="node_outline527" fill="none" stroke="none" d="M494.5,-203.5h200a5,5,0,0,1,5,5v178a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-178a5,5,0,0,1,5,-5z"></path><g id="node_text527" fill="black"><text id="kity_text_8310" text-rendering="inherit" font-size="12" dy=".8em" y="-32.299999952316284" x="569.5">分支主题</text></g><image id="kity_image_17033" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210319093806.png" x="494.5" y="-200.5" width="200" height="165"></image></g><g id="minder_node533" display="none"><g id="node_expander530" display="none" style="cursor: pointer;"><path id="kity_path_22112" fill="white" stroke="gray" d="M537.5,-16.5A6,6,0,1,1,525.5,-16.5A6,6,0,1,1,537.5,-16.5"></path><path id="kity_path_22113" fill="none" stroke="gray"></path></g><path id="node_outline531" fill="none" stroke="none" d="M537.5,-25.5h113a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-113a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text531" fill="black"><text id="kity_text_8323" text-rendering="inherit" font-size="12" dy=".8em" y="-24.299999952316284" x="537.5">redo log 刷盘的时机</text></g></g><g id="minder_node534" display="none"><g id="node_expander529" display="none" style="cursor: pointer;"><path id="kity_path_22109" fill="white" stroke="gray" d="M553.5,-16.5A6,6,0,1,1,541.5,-16.5A6,6,0,1,1,553.5,-16.5"></path><path id="kity_path_22110" fill="none" stroke="gray"></path></g><path id="node_outline530" fill="none" stroke="none" d="M553.5,-52.5h800a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-800a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text530" fill="black"><text id="kity_text_8318" text-rendering="inherit" font-size="12" dy=".8em" y="-51.299999952316284" x="553.5">1.log buffer空间不足时&#xa0;log buffer的redo日志量已经占满了log buffer总容量的大约一半左右，就需要把这些日志刷新到磁盘上。</text><text id="kity_text_8319" text-rendering="inherit" font-size="12" dy=".8em" y="-33.299999952316284" x="553.5">2.事务提交时:在事务提交时可以不把修改过的Buffer Pool页面刷新到磁盘，但是为了保证持久性，必须要把修改这些页面对应的redo日志刷新到磁盘。</text><text id="kity_text_8320" text-rendering="inherit" font-size="12" dy=".8em" y="-15.299999952316284" x="553.5">3.后台有一个线程，大约每秒都会刷新一次log buffer中的redo日志到磁盘。</text><text id="kity_text_8321" text-rendering="inherit" font-size="12" dy=".8em" y="2.700000047683716" x="553.5">4.正常关闭服务器时</text></g></g><g id="minder_node535" display="none"><g id="node_expander532" display="none" style="cursor: pointer;"><path id="kity_path_22118" fill="white" stroke="gray" d="M537.5,-8.5A6,6,0,1,1,525.5,-8.5A6,6,0,1,1,537.5,-8.5"></path><path id="kity_path_22119" fill="none" stroke="gray"></path></g><path id="node_outline533" fill="none" stroke="none" d="M537.5,-17.5h118a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-118a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text533" fill="black"><text id="kity_text_8327" text-rendering="inherit" font-size="12" dy=".8em" y="-16.299999952316284" x="537.5">知道redolog的原理吗</text></g></g><g id="minder_node536" display="none"><g id="node_expander531" display="none" style="cursor: pointer;"><path id="kity_path_22115" fill="white" stroke="gray" d="M553.5,-8.5A6,6,0,1,1,541.5,-8.5A6,6,0,1,1,553.5,-8.5"></path><path id="kity_path_22116" fill="none" stroke="gray"></path></g><path id="node_outline532" fill="none" stroke="none" d="M553.5,-17.5h719a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-719a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text532" fill="black"><text id="kity_text_8325" text-rendering="inherit" font-size="12" dy=".8em" y="-16.299999952316284" x="553.5">1.redo log会把事务在执行过程中对数据库所做的所有修改都记录下来，在之后系统崩溃重启后可以把事务所做的任何修改都恢复出来。</text></g></g><g id="minder_node537" display="none"><g id="node_expander534" display="none" style="cursor: pointer;"><path id="kity_path_22124" fill="white" stroke="gray" d="M537.5,-0.5A6,6,0,1,1,525.5,-0.5A6,6,0,1,1,537.5,-0.5"></path><path id="kity_path_22125" fill="none" stroke="gray"></path></g><path id="node_outline535" fill="none" stroke="none" d="M537.5,-9.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text535" fill="black"><text id="kity_text_8333" text-rendering="inherit" font-size="12" dy=".8em" y="-8.299999952316284" x="537.5">redo log有什么好处？</text></g></g><g id="minder_node538" display="none"><g id="node_expander533" display="none" style="cursor: pointer;"><path id="kity_path_22121" fill="white" stroke="gray" d="M553.5,-0.5A6,6,0,1,1,541.5,-0.5A6,6,0,1,1,553.5,-0.5"></path><path id="kity_path_22122" fill="none" stroke="gray"></path></g><path id="node_outline534" fill="none" stroke="none" d="M553.5,-27.5h697a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-697a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text534" fill="black"><text id="kity_text_8329" text-rendering="inherit" font-size="12" dy=".8em" y="-26.299999952316284" x="553.5">1.与在事务提交时将所有修改过的内存中的页面刷新到磁盘中相比，只将该事务执行过程中产生的redo日志刷新到磁盘的好处如下：</text><text id="kity_text_8330" text-rendering="inherit" font-size="12" dy=".8em" y="-8.299999952316284" x="553.5">redo日志占用的空间非常小</text><text id="kity_text_8331" text-rendering="inherit" font-size="12" dy=".8em" y="9.700000047683716" x="553.5">redo日志是顺序写入磁盘的(随机IO刷起来比较慢)</text></g></g><g id="minder_node539" display="none"><g id="node_expander536" display="none" style="cursor: pointer;"><path id="kity_path_22130" fill="white" stroke="gray" d="M537.5,7.5A6,6,0,1,1,525.5,7.5A6,6,0,1,1,537.5,7.5"></path><path id="kity_path_22131" fill="none" stroke="gray"></path></g><path id="node_outline537" fill="none" stroke="none" d="M537.5,-1.5h231a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-231a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text537" fill="black"><text id="kity_text_8337" text-rendering="inherit" font-size="12" dy=".8em" y="-0.2999999523162842" x="537.5">redo log发生了覆盖写数据 mysql怎么处理</text></g></g><g id="minder_node540" display="none"><g id="node_expander535" display="none" style="cursor: pointer;"><path id="kity_path_22127" fill="white" stroke="gray" d="M553.5,7.5A6,6,0,1,1,541.5,7.5A6,6,0,1,1,553.5,7.5"></path><path id="kity_path_22128" fill="none" stroke="gray"></path></g><path id="node_outline536" fill="none" stroke="none" d="M553.5,-1.5h913a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-913a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text536" fill="black"><text id="kity_text_8335" text-rendering="inherit" font-size="12" dy=".8em" y="-0.2999999523162842" x="553.5">1.checkpoint：随着时间的积累，Redo Log会变的很大很大。如果每次都从第一条记录开始恢复，恢复的过程就会很慢。为了减少恢复的时间，就引入了Checkpoint机制。</text></g></g><g id="minder_node541" display="none"><g id="node_expander538" display="none" style="cursor: pointer;"><path id="kity_path_22136" fill="white" stroke="gray" d="M537.5,15.5A6,6,0,1,1,525.5,15.5A6,6,0,1,1,537.5,15.5"></path><path id="kity_path_22137" fill="none" stroke="gray"></path></g><path id="node_outline539" fill="none" stroke="none" d="M537.5,6.5h123a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-123a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text539" fill="black"><text id="kity_text_8341" text-rendering="inherit" font-size="12" dy=".8em" y="7.700000047683716" x="537.5">为什么有checkpoint？</text></g></g><g id="minder_node542" display="none"><g id="node_expander537" display="none" style="cursor: pointer;"><path id="kity_path_22133" fill="white" stroke="gray" d="M553.5,15.5A6,6,0,1,1,541.5,15.5A6,6,0,1,1,553.5,15.5"></path><path id="kity_path_22134" fill="none" stroke="gray"></path></g><path id="node_outline538" fill="none" stroke="none" d="M553.5,6.5h682a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-682a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text538" fill="black"><text id="kity_text_8339" text-rendering="inherit" font-size="12" dy=".8em" y="7.700000047683716" x="553.5">1.redo日志文件组容量是有限的，选择循环使用redo日志文件组中的文件，会造成最后写的redo日志与最开始写的redo日志追尾</text></g></g><g id="minder_node543" display="none"><g id="node_expander540" display="none" style="cursor: pointer;"><path id="kity_path_22142" fill="white" stroke="gray" d="M537.5,23.5A6,6,0,1,1,525.5,23.5A6,6,0,1,1,537.5,23.5"></path><path id="kity_path_22143" fill="none" stroke="gray"></path></g><path id="node_outline541" fill="none" stroke="none" d="M537.5,14.5h160a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-160a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text541" fill="black"><text id="kity_text_8349" text-rendering="inherit" font-size="12" dy=".8em" y="15.700000047683716" x="537.5">那你说说简单说说checkpoint</text></g></g><g id="minder_node544" display="none"><g id="node_expander539" display="none" style="cursor: pointer;"><path id="kity_path_22139" fill="white" stroke="gray" d="M553.5,23.5A6,6,0,1,1,541.5,23.5A6,6,0,1,1,553.5,23.5"></path><path id="kity_path_22140" fill="none" stroke="gray"></path></g><path id="node_outline540" fill="none" stroke="none" d="M553.5,-21.5h1105a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1105a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text540" fill="black"><text id="kity_text_8343" text-rendering="inherit" font-size="12" dy=".8em" y="-20.299999952316284" x="553.5">1.在某个时间点，所有的脏页都被刷新到了磁盘上.这个时间点之前的所有Redo Log就不需要重做了。</text><text id="kity_text_8344" text-rendering="inherit" font-size="12" dy=".8em" y="-2.299999952316284" x="553.5">2.系统记录下这个时间点时redo log的结尾位置作为checkpoint. 在进行恢复时，从这个checkpoint的位置开始即可。Checkpoint点之前的日志也就不再需要了，可以被删除掉。</text><text id="kity_text_8345" text-rendering="inherit" font-size="12" dy=".8em" y="15.700000047683716" x="553.5">也就是checkpoint会把一部分redo log标记为可覆盖</text><text id="kity_text_8346" text-rendering="inherit" font-size="12" dy=".8em" y="33.700000047683716" x="553.5">3.InnoDB以redolog环形缓存的方式来更好利用日志空间。</text><text id="kity_text_8347" text-rendering="inherit" font-size="12" dy=".8em" y="51.700000047683716" x="553.5">4.如果随着系统运行，Buffer Pool 的脏页刷新到了磁盘中，那么redo log 对应的记录也就没用了。 一次checkpoint 的过程就是脏页刷新到磁盘中变成干净页，然后标记redo log 哪些记录可以被覆盖的过程。</text></g></g><g id="minder_node545" display="none"><g id="node_expander542" display="none" style="cursor: pointer;"><path id="kity_path_22148" fill="white" stroke="gray" d="M537.5,31.5A6,6,0,1,1,525.5,31.5A6,6,0,1,1,537.5,31.5"></path><path id="kity_path_22149" fill="none" stroke="gray"></path></g><path id="node_outline543" fill="none" stroke="none" d="M537.5,22.5h136a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-136a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text543" fill="black"><text id="kity_text_8354" text-rendering="inherit" font-size="12" dy=".8em" y="23.700000047683716" x="537.5">checkpoint的目的是什么</text></g></g><g id="minder_node546" display="none"><g id="node_expander541" display="none" style="cursor: pointer;"><path id="kity_path_22145" fill="white" stroke="gray" d="M553.5,31.5A6,6,0,1,1,541.5,31.5A6,6,0,1,1,553.5,31.5"></path><path id="kity_path_22146" fill="none" stroke="gray"></path></g><path id="node_outline542" fill="none" stroke="none" d="M553.5,13.5h151a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-151a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text542" fill="black"><text id="kity_text_8351" text-rendering="inherit" font-size="12" dy=".8em" y="14.700000047683716" x="553.5">1、确保数据一致性。</text><text id="kity_text_8352" text-rendering="inherit" font-size="12" dy=".8em" y="32.700000047683716" x="553.5">2、使数据库能快速地恢复。</text></g></g><g id="minder_node547" display="none"><g id="node_expander552" display="none" style="cursor: pointer;"><path id="kity_path_22178" fill="white" stroke="gray" d="M521.5,39.5A6,6,0,1,1,509.5,39.5A6,6,0,1,1,521.5,39.5"></path><path id="kity_path_22179" fill="none" stroke="gray"></path></g><path id="node_outline553" fill="none" stroke="none" d="M521.5,30.5h37a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-37a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text553" fill="black"><text id="kity_text_8375" text-rendering="inherit" font-size="12" dy=".8em" y="31.700000047683716" x="521.5">binlog</text></g></g><g id="minder_node548" display="none"><g id="node_expander545" display="none" style="cursor: pointer;"><path id="kity_path_22157" fill="white" stroke="gray" d="M537.5,15.5A6,6,0,1,1,525.5,15.5A6,6,0,1,1,537.5,15.5"></path><path id="kity_path_22158" fill="none" stroke="gray"></path></g><path id="node_outline546" fill="none" stroke="none" d="M537.5,6.5h171a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-171a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text546" fill="black"><text id="kity_text_8360" text-rendering="inherit" font-size="12" dy=".8em" y="7.700000047683716" x="537.5">知道binlog吗，什么是binlog呢</text></g></g><g id="minder_node549" display="none"><g id="node_expander544" display="none" style="cursor: pointer;"><path id="kity_path_22154" fill="white" stroke="gray" d="M553.5,15.5A6,6,0,1,1,541.5,15.5A6,6,0,1,1,553.5,15.5"></path><path id="kity_path_22155" fill="none" stroke="gray"></path></g><path id="node_outline545" fill="none" stroke="none" d="M553.5,6.5h702a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-702a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text545" fill="black"><text id="kity_text_8358" text-rendering="inherit" font-size="12" dy=".8em" y="7.700000047683716" x="553.5">1.binlog记录了数据库表结构和表数据变更,存储着每条变更的SQL语句，如update/delete/insert/truncate/create。不会记录select</text></g></g><g id="minder_node550" display="none"><g id="node_expander547" display="none" style="cursor: pointer;"><path id="kity_path_22163" fill="white" stroke="gray" d="M537.5,23.5A6,6,0,1,1,525.5,23.5A6,6,0,1,1,537.5,23.5"></path><path id="kity_path_22164" fill="none" stroke="gray"></path></g><path id="node_outline548" fill="none" stroke="none" d="M537.5,14.5h182a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-182a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text548" fill="black"><text id="kity_text_8365" text-rendering="inherit" font-size="12" dy=".8em" y="15.700000047683716" x="537.5">bin log有三种格式？row的优点？</text></g></g><g id="minder_node551" display="none"><g id="node_expander546" display="none" style="cursor: pointer;"><path id="kity_path_22160" fill="white" stroke="gray" d="M553.5,23.5A6,6,0,1,1,541.5,23.5A6,6,0,1,1,553.5,23.5"></path><path id="kity_path_22161" fill="none" stroke="gray"></path></g><path id="node_outline547" fill="none" stroke="none" d="M553.5,5.5h326a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text547" fill="black"><text id="kity_text_8362" text-rendering="inherit" font-size="12" dy=".8em" y="6.700000047683716" x="553.5">1.分别为Statement,MiXED,以及ROW</text><text id="kity_text_8363" text-rendering="inherit" font-size="12" dy=".8em" y="24.700000047683716" x="553.5">2.Statement：每一条会修改数据的sql都会记录在binlog中。</text></g></g><g id="minder_node552" display="none"><g id="node_expander549" display="none" style="cursor: pointer;"><path id="kity_path_22169" fill="white" stroke="gray" d="M537.5,31.5A6,6,0,1,1,525.5,31.5A6,6,0,1,1,537.5,31.5"></path><path id="kity_path_22170" fill="none" stroke="gray"></path></g><path id="node_outline550" fill="none" stroke="none" d="M537.5,22.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text550" fill="black"><text id="kity_text_8369" text-rendering="inherit" font-size="12" dy=".8em" y="23.700000047683716" x="537.5">binlog是哪些作用呢</text></g></g><g id="minder_node553" display="none"><g id="node_expander548" display="none" style="cursor: pointer;"><path id="kity_path_22166" fill="white" stroke="gray" d="M553.5,31.5A6,6,0,1,1,541.5,31.5A6,6,0,1,1,553.5,31.5"></path><path id="kity_path_22167" fill="none" stroke="gray"></path></g><path id="node_outline549" fill="none" stroke="none" d="M553.5,22.5h745a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-745a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text549" fill="black"><text id="kity_text_8367" text-rendering="inherit" font-size="12" dy=".8em" y="23.700000047683716" x="553.5">1.主要是复制和恢复数据。如主从服务之间IO就是传输binlog来复制数据。数据库的数据被干掉了，我们可以通过binlog来对数据进行恢复。</text></g></g><g id="minder_node554" display="none"><g id="node_expander551" display="none" style="cursor: pointer;"><path id="kity_path_22175" fill="white" stroke="gray" d="M537.5,39.5A6,6,0,1,1,525.5,39.5A6,6,0,1,1,537.5,39.5"></path><path id="kity_path_22176" fill="none" stroke="gray"></path></g><path id="node_outline552" fill="none" stroke="none" d="M537.5,30.5h252a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-252a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text552" fill="black"><text id="kity_text_8373" text-rendering="inherit" font-size="12" dy=".8em" y="31.700000047683716" x="537.5">binlog日志是 master推来的 还是salver 来拉的</text></g></g><g id="minder_node555" display="none"><g id="node_expander550" display="none" style="cursor: pointer;"><path id="kity_path_22172" fill="white" stroke="gray" d="M553.5,39.5A6,6,0,1,1,541.5,39.5A6,6,0,1,1,553.5,39.5"></path><path id="kity_path_22173" fill="none" stroke="gray"></path></g><path id="node_outline551" fill="none" stroke="none" d="M553.5,30.5h244a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-244a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text551" fill="black"><text id="kity_text_8371" text-rendering="inherit" font-size="12" dy=".8em" y="31.700000047683716" x="553.5">1.在主从复制中，是由master 提供io线程推的</text></g></g><g id="minder_node556" display="none"><g id="node_expander559" display="none" style="cursor: pointer;"><path id="kity_path_22199" fill="white" stroke="gray" d="M521.5,47.5A6,6,0,1,1,509.5,47.5A6,6,0,1,1,521.5,47.5"></path><path id="kity_path_22200" fill="none" stroke="gray"></path></g><path id="node_outline560" fill="none" stroke="none" d="M521.5,38.5h52a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-52a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text560" fill="black"><text id="kity_text_8392" text-rendering="inherit" font-size="12" dy=".8em" y="39.700000047683716" x="521.5">undo log</text></g></g><g id="minder_node557" display="none"><g id="node_expander554" display="none" style="cursor: pointer;"><path id="kity_path_22184" fill="white" stroke="gray" d="M537.5,31.5A6,6,0,1,1,525.5,31.5A6,6,0,1,1,537.5,31.5"></path><path id="kity_path_22185" fill="none" stroke="gray"></path></g><path id="node_outline555" fill="none" stroke="none" d="M537.5,22.5h173a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-173a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text555" fill="black"><text id="kity_text_8381" text-rendering="inherit" font-size="12" dy=".8em" y="23.700000047683716" x="537.5">知道undo log吗？是干什么的？</text></g></g><g id="minder_node558" display="none"><g id="node_expander553" display="none" style="cursor: pointer;"><path id="kity_path_22181" fill="white" stroke="gray" d="M553.5,31.5A6,6,0,1,1,541.5,31.5A6,6,0,1,1,553.5,31.5"></path><path id="kity_path_22182" fill="none" stroke="gray"></path></g><path id="node_outline554" fill="none" stroke="none" d="M553.5,4.5h1000a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1000a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text554" fill="black"><text id="kity_text_8377" text-rendering="inherit" font-size="12" dy=".8em" y="5.700000047683716" x="553.5">1.每当要对一条记录做改动时INSERT、DELETE、UPDATE，都需要留一手 把回滚时所需的东西都给记下来，在发生错误时回滚之前的操作。这些为了回滚而记录的东西称撤销日志undo log</text><text id="kity_text_8378" text-rendering="inherit" font-size="12" dy=".8em" y="23.700000047683716" x="553.5">3.作用：用来回滚数据的用于保障 未提交事务的原子性</text><text id="kity_text_8379" text-rendering="inherit" font-size="12" dy=".8em" y="41.700000047683716" x="553.5">undo log 记录事务修改之前版本的数据信息，因此假如由于系统错误或者rollback操作而回滚的话可以根据undo log的信息来进行回滚到没被修改前的状态。</text></g></g><g id="minder_node559" display="none"><g id="node_expander556" display="none" style="cursor: pointer;"><path id="kity_path_22190" fill="white" stroke="gray" d="M537.5,39.5A6,6,0,1,1,525.5,39.5A6,6,0,1,1,537.5,39.5"></path><path id="kity_path_22191" fill="none" stroke="gray"></path></g><path id="node_outline557" fill="none" stroke="none" d="M537.5,30.5h124a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-124a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text557" fill="black"><text id="kity_text_8385" text-rendering="inherit" font-size="12" dy=".8em" y="31.700000047683716" x="537.5">undo log日志的格式？</text></g></g><g id="minder_node560" display="none"><g id="node_expander555" display="none" style="cursor: pointer;"><path id="kity_path_22187" fill="white" stroke="gray" d="M553.5,39.5A6,6,0,1,1,541.5,39.5A6,6,0,1,1,553.5,39.5"></path><path id="kity_path_22188" fill="none" stroke="gray"></path></g><path id="node_outline556" fill="none" stroke="none" d="M553.5,30.5h846a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-846a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text556" fill="black"><text id="kity_text_8383" text-rendering="inherit" font-size="12" dy=".8em" y="31.700000047683716" x="553.5">1.为了实现事务的原子性，InnoDB在实际进行增删改一条记录时，都需要先把对应的undo日志记下来。一般每对一条记录做一次改动，就对应着一条undo日志</text></g></g><g id="minder_node561" display="none"><g id="node_expander558" display="none" style="cursor: pointer;"><path id="kity_path_22196" fill="white" stroke="gray" d="M537.5,47.5A6,6,0,1,1,525.5,47.5A6,6,0,1,1,537.5,47.5"></path><path id="kity_path_22197" fill="none" stroke="gray"></path></g><path id="node_outline559" fill="none" stroke="none" d="M537.5,38.5h172a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-172a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text559" fill="black"><text id="kity_text_8390" text-rendering="inherit" font-size="12" dy=".8em" y="39.700000047683716" x="537.5">undo log写在什么地方？分类？</text></g></g><g id="minder_node562" display="none"><g id="node_expander557" display="none" style="cursor: pointer;"><path id="kity_path_22193" fill="white" stroke="gray" d="M553.5,47.5A6,6,0,1,1,541.5,47.5A6,6,0,1,1,553.5,47.5"></path><path id="kity_path_22194" fill="none" stroke="gray"></path></g><path id="node_outline558" fill="none" stroke="none" d="M553.5,29.5h718a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-718a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text558" fill="black"><text id="kity_text_8387" text-rendering="inherit" font-size="12" dy=".8em" y="30.700000047683716" x="553.5">1.写入undo日志的过程中会使用到链表，很多链表都有同样的节点结构。</text><text id="kity_text_8388" text-rendering="inherit" font-size="12" dy=".8em" y="48.700000047683716" x="553.5">2.undo日志分成两个大类，一类在事务提交后可以直接删除掉，而其他类型的undo日志还需要为所谓的MVCC服务，不能直接删除掉。</text></g></g><g id="minder_node563" display="none"><g id="node_expander561" display="none" style="cursor: pointer;"><path id="kity_path_22205" fill="white" stroke="gray" d="M521.5,55.5A6,6,0,1,1,509.5,55.5A6,6,0,1,1,521.5,55.5"></path><path id="kity_path_22206" fill="none" stroke="gray"></path></g><path id="node_outline562" fill="none" stroke="none" d="M521.5,46.5h179a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-179a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text562" fill="black"><text id="kity_text_8399" text-rendering="inherit" font-size="12" dy=".8em" y="47.700000047683716" x="521.5">说说redo log 和bin log的区别吧</text></g></g><g id="minder_node564" display="none"><g id="node_expander560" display="none" style="cursor: pointer;"><path id="kity_path_22202" fill="white" stroke="gray" d="M537.5,55.5A6,6,0,1,1,525.5,55.5A6,6,0,1,1,537.5,55.5"></path><path id="kity_path_22203" fill="none" stroke="gray"></path></g><path id="node_outline561" fill="none" stroke="none" d="M537.5,19.5h950a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-950a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text561" fill="black"><text id="kity_text_8394" text-rendering="inherit" font-size="12" dy=".8em" y="20.700000047683716" x="537.5">1.作redo log 是用于&#xa0; 的，保证 MySQL 宕机也不会影响持久性；binlog 是用于 point-in-time recovery 的，保证服务器可以基于时间点恢复数据，此外 binlog 还用于主从复制。</text><text id="kity_text_8395" text-rendering="inherit" font-size="12" dy=".8em" y="38.700000047683716" x="537.5">2.redo log 是 InnoDB 存储引擎实现的，binlog 同时支持 InnoDB 和其他存储引擎。</text><text id="kity_text_8396" text-rendering="inherit" font-size="12" dy=".8em" y="56.700000047683716" x="537.5">3.redo log 是物理日志，内容基于磁盘的 Page。binlog 是逻辑日志，内容是一条条 sql。</text><text id="kity_text_8397" text-rendering="inherit" font-size="12" dy=".8em" y="74.70000004768372" x="537.5">4.redo log 的写入时机默认情况下的策略，当事务提交时会调用 fsync 对 redo log 进行刷盘；binlog 在事务提交时写入。</text></g></g><g id="minder_node565" display="none"><g id="node_expander564" display="none" style="cursor: pointer;"><path id="kity_path_22214" fill="white" stroke="gray" d="M521.5,63.5A6,6,0,1,1,509.5,63.5A6,6,0,1,1,521.5,63.5"></path><path id="kity_path_22215" fill="none" stroke="gray"></path></g><path id="node_outline565" fill="none" stroke="none" d="M521.5,54.5h158a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-158a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text565" fill="black"><text id="kity_text_8410" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="521.5">binlog跟redo log先后顺序？</text></g></g><g id="minder_node566" display="none"><g id="node_expander563" display="none" style="cursor: pointer;"><path id="kity_path_22211" fill="white" stroke="gray" d="M537.5,63.5A6,6,0,1,1,525.5,63.5A6,6,0,1,1,537.5,63.5"></path><path id="kity_path_22212" fill="none" stroke="gray"></path></g><path id="node_outline564" fill="none" stroke="none" d="M537.5,9.5h863a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-863a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text564" fill="black"><text id="kity_text_8403" text-rendering="inherit" font-size="12" dy=".8em" y="10.700000047683716" x="537.5">1.binlog和redolog执行顺序就是事务的执行顺序</text><text id="kity_text_8404" text-rendering="inherit" font-size="12" dy=".8em" y="28.700000047683716" x="537.5">2.</text><text id="kity_text_8405" text-rendering="inherit" font-size="12" dy=".8em" y="46.700000047683716" x="537.5">prepare预备阶段：sql执行完成，设置redo和undo日志信息，redo持久化到磁盘（redo group commit），并将回滚段置为prepared状态，此时binlog不做操作</text><text id="kity_text_8406" text-rendering="inherit" font-size="12" dy=".8em" y="64.70000004768372" x="537.5">commit阶段：如果prepare成功，innodb释放锁，释放回滚段，设置undo log提交状态，binlog写缓存再持久化到磁盘，然后存储引擎层提交</text><text id="kity_text_8407" text-rendering="inherit" font-size="12" dy=".8em" y="82.70000004768372" x="537.5">记录Binlog是在Redo Log写入磁盘之后</text><text id="kity_text_8408" text-rendering="inherit" font-size="12" dy=".8em" y="100.70000004768372" x="537.5">3.redo和binlog数据一致性靠两段式提交来完成的，如果关闭会造成事务数据的丢失。开启innodb_support_xa=true</text></g></g><g id="minder_node567" display="none"><g id="node_expander562" display="none" style="cursor: pointer;"><path id="kity_path_22208" fill="white" stroke="gray" d="M553.5,63.5A6,6,0,1,1,541.5,63.5A6,6,0,1,1,553.5,63.5"></path><path id="kity_path_22209" fill="none" stroke="gray"></path></g><path id="node_outline563" fill="none" stroke="none" d="M553.5,54.5h339a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-339a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text563" fill="black"><text id="kity_text_8401" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="553.5">https://blog.csdn.net/LYK_for_dba/article/details/79565570</text></g></g><g id="minder_node568" display="none"><g id="node_expander566" display="none" style="cursor: pointer;"><path id="kity_path_22220" fill="white" stroke="gray" d="M521.5,71.5A6,6,0,1,1,509.5,71.5A6,6,0,1,1,521.5,71.5"></path><path id="kity_path_22221" fill="none" stroke="gray"></path></g><path id="node_outline567" fill="none" stroke="none" d="M521.5,62.5h214a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-214a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text567" fill="black"><text id="kity_text_8419" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="521.5">binlog和redolog数据一致问题有考虑吗</text></g></g><g id="minder_node569" display="none"><g id="node_expander565" display="none" style="cursor: pointer;"><path id="kity_path_22217" fill="white" stroke="gray" d="M537.5,71.5A6,6,0,1,1,525.5,71.5A6,6,0,1,1,537.5,71.5"></path><path id="kity_path_22218" fill="none" stroke="gray"></path></g><path id="node_outline566" fill="none" stroke="none" d="M537.5,17.5h1213a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1213a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text566" fill="black"><text id="kity_text_8412" text-rendering="inherit" font-size="12" dy=".8em" y="18.700000047683716" x="537.5">1.MySQL通过两阶段提交来保证redo log和binlog的数据是一致的。</text><text id="kity_text_8413" text-rendering="inherit" font-size="12" dy=".8em" y="36.700000047683716" x="537.5">2.如果redo log写失败了，而binlog写成功了。那假设内存的数据还没来得及落磁盘，机器就挂掉了。那主从服务器的数据就不一致了。（从服务器通过binlog得到最新的数据，而主服务器由于redo log没有记载，没法恢复数据）</text><text id="kity_text_8414" text-rendering="inherit" font-size="12" dy=".8em" y="54.700000047683716" x="537.5">如果redo log写成功了，而binlog写失败了。那从服务器就拿不到最新的数据了。</text><text id="kity_text_8415" text-rendering="inherit" font-size="12" dy=".8em" y="72.70000004768372" x="537.5">3.</text><text id="kity_text_8416" text-rendering="inherit" font-size="12" dy=".8em" y="90.70000004768372" x="537.5">阶段1：InnoDBredo log 写盘，InnoDB 事务进入 prepare 状态</text><text id="kity_text_8417" text-rendering="inherit" font-size="12" dy=".8em" y="108.70000004768372" x="537.5">阶段2：binlog 写盘，InooDB 事务进入 commit 状态</text></g></g><g id="minder_node570" display="none"><g id="node_expander569" display="none" style="cursor: pointer;"><path id="kity_path_22229" fill="white" stroke="gray" d="M521.5,79.5A6,6,0,1,1,509.5,79.5A6,6,0,1,1,521.5,79.5"></path><path id="kity_path_22230" fill="none" stroke="gray"></path></g><path id="node_outline570" fill="none" stroke="none" d="M521.5,70.5h241a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-241a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text570" fill="black"><text id="kity_text_8425" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="521.5">说一下binlog和redolog和undolog整体流程</text></g></g><g id="minder_node571" display="none"><g id="node_expander568" display="none" style="cursor: pointer;"><path id="kity_path_22226" fill="white" stroke="gray" d="M537.5,79.5A6,6,0,1,1,525.5,79.5A6,6,0,1,1,537.5,79.5"></path><path id="kity_path_22227" fill="none" stroke="gray"></path></g><path id="node_outline569" fill="none" stroke="none" d="M462.5,-29.5h200a5,5,0,0,1,5,5v108a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-108a5,5,0,0,1,5,-5z"></path><g id="node_text569" fill="black"><text id="kity_text_8423" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="537.5">分支主题</text></g><image id="kity_image_17035" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210319095428.png" x="462.5" y="-26.5" width="200" height="95"></image></g><g id="minder_node572" display="none"><g id="node_expander567" display="none" style="cursor: pointer;"><path id="kity_path_22223" fill="white" stroke="gray" d="M553.5,79.5A6,6,0,1,1,541.5,79.5A6,6,0,1,1,553.5,79.5"></path><path id="kity_path_22224" fill="none" stroke="gray"></path></g><path id="node_outline568" fill="none" stroke="none" d="M454.5,-66.5h200a5,5,0,0,1,5,5v145a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-145a5,5,0,0,1,5,-5z"></path><g id="node_text568" fill="black"><text id="kity_text_8421" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="553.5">                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </text></g><image id="kity_image_17034" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210318162032.png" x="454.5" y="-63.5" width="200" height="132"></image></g><g id="minder_node573" display="none"><g id="node_expander571" display="none" style="cursor: pointer;"><path id="kity_path_22235" fill="white" stroke="gray" d="M521.5,87.5A6,6,0,1,1,509.5,87.5A6,6,0,1,1,521.5,87.5"></path><path id="kity_path_22236" fill="none" stroke="gray"></path></g><path id="node_outline572" fill="none" stroke="none" d="M521.5,78.5h101a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-101a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text572" fill="black"><text id="kity_text_8434" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="521.5">说一下buffer pool</text></g></g><g id="minder_node574" display="none"><g id="node_expander570" display="none" style="cursor: pointer;"><path id="kity_path_22232" fill="white" stroke="gray" d="M537.5,87.5A6,6,0,1,1,525.5,87.5A6,6,0,1,1,537.5,87.5"></path><path id="kity_path_22233" fill="none" stroke="gray"></path></g><path id="node_outline571" fill="none" stroke="none" d="M537.5,33.5h612a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-612a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text571" fill="black"><text id="kity_text_8427" text-rendering="inherit" font-size="12" dy=".8em" y="34.700000047683716" x="537.5">1.是什么</text><text id="kity_text_8428" text-rendering="inherit" font-size="12" dy=".8em" y="52.700000047683716" x="537.5">InnoDB提供了缓存(Buffer Pool)，Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：</text><text id="kity_text_8429" text-rendering="inherit" font-size="12" dy=".8em" y="70.70000004768372" x="537.5">当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；</text><text id="kity_text_8430" text-rendering="inherit" font-size="12" dy=".8em" y="88.70000004768372" x="537.5">当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中</text><text id="kity_text_8431" text-rendering="inherit" font-size="12" dy=".8em" y="106.70000004768372" x="537.5">2.作用：</text><text id="kity_text_8432" text-rendering="inherit" font-size="12" dy=".8em" y="124.70000004768372" x="537.5">Buffer Pool的使用大大提高了读写数据的效率</text></g></g><g id="minder_node575" display="none"><g id="node_expander573" display="none" style="cursor: pointer;"><path id="kity_path_22241" fill="white" stroke="gray" d="M521.5,95.5A6,6,0,1,1,509.5,95.5A6,6,0,1,1,521.5,95.5"></path><path id="kity_path_22242" fill="none" stroke="gray"></path></g><path id="node_outline574" fill="none" stroke="none" d="M521.5,86.5h110a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-110a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text574" fill="black"><text id="kity_text_8440" text-rendering="inherit" font-size="12" dy=".8em" y="87.70000004768372" x="521.5">怎么记录慢查询日志</text></g></g><g id="minder_node576" display="none"><g id="node_expander572" display="none" style="cursor: pointer;"><path id="kity_path_22238" fill="white" stroke="gray" d="M537.5,95.5A6,6,0,1,1,525.5,95.5A6,6,0,1,1,537.5,95.5"></path><path id="kity_path_22239" fill="none" stroke="gray"></path></g><path id="node_outline573" fill="none" stroke="none" d="M537.5,68.5h1168a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1168a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text573" fill="black"><text id="kity_text_8436" text-rendering="inherit" font-size="12" dy=".8em" y="69.70000004768372" x="537.5">1.慢查询日志用来记录在 MySQL 中执行时间超过指定时间的查询语句。可以排查问题 SQL ，检查当前 MySQL 性能的。如果不是调优需要，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。</text><text id="kity_text_8437" text-rendering="inherit" font-size="12" dy=".8em" y="87.70000004768372" x="537.5">2.SHOW VARIABLES LIKE 'slow_query%';查看是否开启，慢查询日志存放的位置，查询超过多少秒才记录</text><text id="kity_text_8438" text-rendering="inherit" font-size="12" dy=".8em" y="105.70000004768372" x="537.5">3.开启以后我们可以得到执行时间，等待锁时间，返回的行数</text></g></g><g id="minder_node577" display="none"><g id="node_expander575" display="none" style="cursor: pointer;"><path id="kity_path_22247" fill="white" stroke="gray" d="M521.5,103.5A6,6,0,1,1,509.5,103.5A6,6,0,1,1,521.5,103.5"></path><path id="kity_path_22248" fill="none" stroke="gray"></path></g><path id="node_outline576" fill="none" stroke="none" d="M521.5,94.5h110a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-110a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text576" fill="black"><text id="kity_text_8444" text-rendering="inherit" font-size="12" dy=".8em" y="95.70000004768372" x="521.5">慢查询日志可以干嘛</text></g></g><g id="minder_node578" display="none"><g id="node_expander574" display="none" style="cursor: pointer;"><path id="kity_path_22244" fill="white" stroke="gray" d="M537.5,103.5A6,6,0,1,1,525.5,103.5A6,6,0,1,1,537.5,103.5"></path><path id="kity_path_22245" fill="none" stroke="gray"></path></g><path id="node_outline575" fill="none" stroke="none" d="M537.5,94.5h1162a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1162a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text575" fill="black"><text id="kity_text_8442" text-rendering="inherit" font-size="12" dy=".8em" y="95.70000004768372" x="537.5">1.MySQL语句查询性能的方法除了使用 EXPLAIN 输出执行计划，还可以让MySQL记录下查询超过指定时间的语句，将超过指定时间的SQL语句查询称为“慢查询”。也可以通过set global long_query_time=1;修改阈值</text></g></g><g id="minder_node579" display="none"><g id="node_expander577" display="none" style="cursor: pointer;"><path id="kity_path_22253" fill="white" stroke="gray" d="M521.5,111.5A6,6,0,1,1,509.5,111.5A6,6,0,1,1,521.5,111.5"></path><path id="kity_path_22254" fill="none" stroke="gray"></path></g><path id="node_outline578" fill="none" stroke="none" d="M521.5,102.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text578" fill="black"><text id="kity_text_8448" text-rendering="inherit" font-size="12" dy=".8em" y="103.70000004768372" x="521.5">一个写不成功怎么处理？</text></g></g><g id="minder_node580" display="none"><g id="node_expander576" display="none" style="cursor: pointer;"><path id="kity_path_22250" fill="white" stroke="gray" d="M537.5,111.5A6,6,0,1,1,525.5,111.5A6,6,0,1,1,537.5,111.5"></path><path id="kity_path_22251" fill="none" stroke="gray"></path></g><path id="node_outline577" fill="none" stroke="none" d="M537.5,102.5h420a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-420a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text577" fill="black"><text id="kity_text_8446" text-rendering="inherit" font-size="12" dy=".8em" y="103.70000004768372" x="537.5">1.是否是sql问题，是否和mysql关键字冲突，是否是连接关闭，是否是字段超长</text></g></g><g id="minder_node581" display="none"><g id="node_expander588" display="none" style="cursor: pointer;"><path id="kity_path_22286" fill="white" stroke="gray" d="M521.5,119.5A6,6,0,1,1,509.5,119.5A6,6,0,1,1,521.5,119.5"></path><path id="kity_path_22287" fill="none" stroke="gray"></path></g><path id="node_outline589" fill="none" stroke="none" d="M521.5,110.5h134a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-134a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text589" fill="black"><text id="kity_text_8481" text-rendering="inherit" font-size="12" dy=".8em" y="111.70000004768372" x="521.5">ACID的实现原理？(日志)</text></g></g><g id="minder_node582" display="none"><g id="node_expander579" display="none" style="cursor: pointer;"><path id="kity_path_22259" fill="white" stroke="gray" d="M537.5,87.5A6,6,0,1,1,525.5,87.5A6,6,0,1,1,537.5,87.5"></path><path id="kity_path_22260" fill="none" stroke="gray"></path></g><path id="node_outline580" fill="none" stroke="none" d="M537.5,51.5h263a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-263a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text580" fill="black"><text id="kity_text_8452" text-rendering="inherit" font-size="12" dy=".8em" y="52.700000047683716" x="537.5">1.事务的原子性是通过 undo log 来实现的</text><text id="kity_text_8453" text-rendering="inherit" font-size="12" dy=".8em" y="70.70000004768372" x="537.5">2.事务的持久性性是通过 redo log 来实现的</text><text id="kity_text_8454" text-rendering="inherit" font-size="12" dy=".8em" y="88.70000004768372" x="537.5">3.事务的隔离性是通过 (读写锁+MVCC)来实现的</text><text id="kity_text_8455" text-rendering="inherit" font-size="12" dy=".8em" y="106.70000004768372" x="537.5"> 4.一致性是通过原子性，持久性，隔离性来实现的</text></g></g><g id="minder_node583" display="none"><g id="node_expander578" display="none" style="cursor: pointer;"><path id="kity_path_22256" fill="white" stroke="gray" d="M553.5,87.5A6,6,0,1,1,541.5,87.5A6,6,0,1,1,553.5,87.5"></path><path id="kity_path_22257" fill="none" stroke="gray"></path></g><path id="node_outline579" fill="none" stroke="none" d="M553.5,78.5h300a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-300a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text579" fill="black"><text id="kity_text_8450" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="553.5">https://www.cnblogs.com/kismetv/p/10331633.html</text></g></g><g id="minder_node584" display="none"><g id="node_expander581" display="none" style="cursor: pointer;"><path id="kity_path_22265" fill="white" stroke="gray" d="M537.5,95.5A6,6,0,1,1,525.5,95.5A6,6,0,1,1,537.5,95.5"></path><path id="kity_path_22266" fill="none" stroke="gray"></path></g><path id="node_outline582" fill="none" stroke="none" d="M537.5,86.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text582" fill="black"><text id="kity_text_8462" text-rendering="inherit" font-size="12" dy=".8em" y="87.70000004768372" x="537.5">原子性？</text></g></g><g id="minder_node585" display="none"><g id="node_expander580" display="none" style="cursor: pointer;"><path id="kity_path_22262" fill="white" stroke="gray" d="M553.5,95.5A6,6,0,1,1,541.5,95.5A6,6,0,1,1,553.5,95.5"></path><path id="kity_path_22263" fill="none" stroke="gray"></path></g><path id="node_outline581" fill="none" stroke="none" d="M553.5,59.5h974a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-974a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text581" fill="black"><text id="kity_text_8457" text-rendering="inherit" font-size="12" dy=".8em" y="60.700000047683716" x="553.5">1.先说原子性：一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做；如果事务中一个sql语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。</text><text id="kity_text_8458" text-rendering="inherit" font-size="12" dy=".8em" y="78.70000004768372" x="553.5">2.实现原理：实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的sql语句。</text><text id="kity_text_8459" text-rendering="inherit" font-size="12" dy=".8em" y="96.70000004768372" x="553.5">InnoDB实现回滚，靠的是undo log：当事务对数据库进行修改时，InnoDB会生成对应的undo log；</text><text id="kity_text_8460" text-rendering="inherit" font-size="12" dy=".8em" y="114.70000004768372" x="553.5">如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。</text></g></g><g id="minder_node586" display="none"><g id="node_expander583" display="none" style="cursor: pointer;"><path id="kity_path_22271" fill="white" stroke="gray" d="M537.5,103.5A6,6,0,1,1,525.5,103.5A6,6,0,1,1,537.5,103.5"></path><path id="kity_path_22272" fill="none" stroke="gray"></path></g><path id="node_outline584" fill="none" stroke="none" d="M537.5,94.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text584" fill="black"><text id="kity_text_8469" text-rendering="inherit" font-size="12" dy=".8em" y="95.70000004768372" x="537.5">持久性？</text></g></g><g id="minder_node587" display="none"><g id="node_expander582" display="none" style="cursor: pointer;"><path id="kity_path_22268" fill="white" stroke="gray" d="M553.5,103.5A6,6,0,1,1,541.5,103.5A6,6,0,1,1,553.5,103.5"></path><path id="kity_path_22269" fill="none" stroke="gray"></path></g><path id="node_outline583" fill="none" stroke="none" d="M553.5,67.5h806a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-806a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text583" fill="black"><text id="kity_text_8464" text-rendering="inherit" font-size="12" dy=".8em" y="68.70000004768372" x="553.5">1.持久性：持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</text><text id="kity_text_8465" text-rendering="inherit" font-size="12" dy=".8em" y="86.70000004768372" x="553.5">2.原理(redolog)：当数据修改时，会修改Buffer Pool中的数据，还会在redo log记录这次操作；当事务提交时，会调用fsync接口对redo log进行刷盘。</text><text id="kity_text_8466" text-rendering="inherit" font-size="12" dy=".8em" y="104.70000004768372" x="553.5">如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。</text><text id="kity_text_8467" text-rendering="inherit" font-size="12" dy=".8em" y="122.70000004768372" x="553.5">redo log采用的是WAL（预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。</text></g></g><g id="minder_node588" display="none"><g id="node_expander585" display="none" style="cursor: pointer;"><path id="kity_path_22277" fill="white" stroke="gray" d="M537.5,111.5A6,6,0,1,1,525.5,111.5A6,6,0,1,1,537.5,111.5"></path><path id="kity_path_22278" fill="none" stroke="gray"></path></g><path id="node_outline586" fill="none" stroke="none" d="M537.5,102.5h48a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-48a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text586" fill="black"><text id="kity_text_8475" text-rendering="inherit" font-size="12" dy=".8em" y="103.70000004768372" x="537.5">隔离性？</text></g></g><g id="minder_node589" display="none"><g id="node_expander584" display="none" style="cursor: pointer;"><path id="kity_path_22274" fill="white" stroke="gray" d="M553.5,111.5A6,6,0,1,1,541.5,111.5A6,6,0,1,1,553.5,111.5"></path><path id="kity_path_22275" fill="none" stroke="gray"></path></g><path id="node_outline585" fill="none" stroke="none" d="M553.5,84.5h516a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-516a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text585" fill="black"><text id="kity_text_8471" text-rendering="inherit" font-size="12" dy=".8em" y="85.70000004768372" x="553.5">1.隔离性是要管理多个并发读写请求的访问顺序</text><text id="kity_text_8472" text-rendering="inherit" font-size="12" dy=".8em" y="103.70000004768372" x="553.5">2.主要实现是 锁+隔离级别+MVCC实现事务的隔离性。如写写通过加锁，写读通过MVCC</text><text id="kity_text_8473" text-rendering="inherit" font-size="12" dy=".8em" y="121.70000004768372" x="553.5">解决脏读、不可重复读、幻读，方案1：读MVCC+写锁。方案2：读、写操作都采用加锁的方式。</text></g></g><g id="minder_node590" display="none"><g id="node_expander587" display="none" style="cursor: pointer;"><path id="kity_path_22283" fill="white" stroke="gray" d="M537.5,119.5A6,6,0,1,1,525.5,119.5A6,6,0,1,1,537.5,119.5"></path><path id="kity_path_22284" fill="none" stroke="gray"></path></g><path id="node_outline588" fill="none" stroke="none" d="M537.5,110.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text588" fill="black"><text id="kity_text_8479" text-rendering="inherit" font-size="12" dy=".8em" y="111.70000004768372" x="537.5">一致性？</text></g></g><g id="minder_node591" display="none"><g id="node_expander586" display="none" style="cursor: pointer;"><path id="kity_path_22280" fill="white" stroke="gray" d="M553.5,119.5A6,6,0,1,1,541.5,119.5A6,6,0,1,1,553.5,119.5"></path><path id="kity_path_22281" fill="none" stroke="gray"></path></g><path id="node_outline587" fill="none" stroke="none" d="M553.5,110.5h574a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-574a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text587" fill="black"><text id="kity_text_8477" text-rendering="inherit" font-size="12" dy=".8em" y="111.70000004768372" x="553.5">1.一致性是事务追求的最终目标：前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性。</text></g></g><g id="minder_node592" display="none"><g id="node_expander666" display="none" style="cursor: pointer;"><path id="kity_path_22520" fill="white" stroke="gray" d="M505.5,127.5A6,6,0,1,1,493.5,127.5A6,6,0,1,1,505.5,127.5"></path><path id="kity_path_22521" fill="none" stroke="gray"></path></g><path id="node_outline667" fill="none" stroke="none" d="M505.5,118.5h62a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-62a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text667" fill="black"><text id="kity_text_8713" text-rendering="inherit" font-size="12" dy=".8em" y="119.70000004768372" x="505.5">优化和分析</text></g></g><g id="minder_node593" display="none"><g id="node_expander592" display="none" style="cursor: pointer;"><path id="kity_path_22298" fill="white" stroke="gray" d="M521.5,87.5A6,6,0,1,1,509.5,87.5A6,6,0,1,1,521.5,87.5"></path><path id="kity_path_22299" fill="none" stroke="gray"></path></g><path id="node_outline593" fill="none" stroke="none" d="M521.5,78.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text593" fill="black"><text id="kity_text_8490" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="521.5">索引优化</text></g></g><g id="minder_node594" display="none"><g id="node_expander591" display="none" style="cursor: pointer;"><path id="kity_path_22295" fill="white" stroke="gray" d="M537.5,87.5A6,6,0,1,1,525.5,87.5A6,6,0,1,1,537.5,87.5"></path><path id="kity_path_22296" fill="none" stroke="gray"></path></g><path id="node_outline592" fill="none" stroke="none" d="M537.5,78.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text592" fill="black"><text id="kity_text_8488" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="537.5">你说说你怎么优化索引的</text></g></g><g id="minder_node595" display="none"><g id="node_expander590" display="none" style="cursor: pointer;"><path id="kity_path_22292" fill="white" stroke="gray" d="M553.5,87.5A6,6,0,1,1,541.5,87.5A6,6,0,1,1,553.5,87.5"></path><path id="kity_path_22293" fill="none" stroke="gray"></path></g><path id="node_outline591" fill="none" stroke="none" d="M553.5,69.5h218a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-218a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text591" fill="black"><text id="kity_text_8485" text-rendering="inherit" font-size="12" dy=".8em" y="70.70000004768372" x="553.5">索引优化其实也就是索引失效的注意事项</text><text id="kity_text_8486" text-rendering="inherit" font-size="12" dy=".8em" y="88.70000004768372" x="553.5">1.上面已经分析过。</text></g></g><g id="minder_node596" display="none"><g id="node_expander605" display="none" style="cursor: pointer;"><path id="kity_path_22337" fill="white" stroke="gray" d="M521.5,95.5A6,6,0,1,1,509.5,95.5A6,6,0,1,1,521.5,95.5"></path><path id="kity_path_22338" fill="none" stroke="gray"></path></g><path id="node_outline606" fill="none" stroke="none" d="M521.5,86.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text606" fill="black"><text id="kity_text_8529" text-rendering="inherit" font-size="12" dy=".8em" y="87.70000004768372" x="521.5">查询优化</text></g></g><g id="minder_node597" display="none"><g id="node_expander594" display="none" style="cursor: pointer;"><path id="kity_path_22304" fill="white" stroke="gray" d="M537.5,55.5A6,6,0,1,1,525.5,55.5A6,6,0,1,1,537.5,55.5"></path><path id="kity_path_22305" fill="none" stroke="gray"></path></g><path id="node_outline595" fill="none" stroke="none" d="M537.5,46.5h210a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-210a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text595" fill="black"><text id="kity_text_8500" text-rendering="inherit" font-size="12" dy=".8em" y="47.700000047683716" x="537.5">如果一条sql查询很慢，你怎么分析解决</text></g></g><g id="minder_node598" display="none"><g id="node_expander593" display="none" style="cursor: pointer;"><path id="kity_path_22301" fill="white" stroke="gray" d="M553.5,55.5A6,6,0,1,1,541.5,55.5A6,6,0,1,1,553.5,55.5"></path><path id="kity_path_22302" fill="none" stroke="gray"></path></g><path id="node_outline594" fill="none" stroke="none" d="M553.5,-7.5h945a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-945a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text594" fill="black"><text id="kity_text_8492" text-rendering="inherit" font-size="12" dy=".8em" y="-6.299999952316284" x="553.5">0.先运行看看是否真的很慢，设置SQL_NO_CACHE </text><text id="kity_text_8493" text-rendering="inherit" font-size="12" dy=".8em" y="11.700000047683716" x="553.5">1.where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高 </text><text id="kity_text_8494" text-rendering="inherit" font-size="12" dy=".8em" y="29.700000047683716" x="553.5">2.explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询） </text><text id="kity_text_8495" text-rendering="inherit" font-size="12" dy=".8em" y="47.700000047683716" x="553.5">3.order by limit 形式的sql语句让排序的表优先查 </text><text id="kity_text_8496" text-rendering="inherit" font-size="12" dy=".8em" y="65.70000004768372" x="553.5">4.了解业务方使用场景(不加载额外字段，)</text><text id="kity_text_8497" text-rendering="inherit" font-size="12" dy=".8em" y="83.70000004768372" x="553.5">5.加索引时参照建索引的几大原则</text><text id="kity_text_8498" text-rendering="inherit" font-size="12" dy=".8em" y="101.70000004768372" x="553.5">6.观察结果，不符合预期继续从0分析</text></g></g><g id="minder_node599" display="none"><g id="node_expander596" display="none" style="cursor: pointer;"><path id="kity_path_22310" fill="white" stroke="gray" d="M537.5,63.5A6,6,0,1,1,525.5,63.5A6,6,0,1,1,537.5,63.5"></path><path id="kity_path_22311" fill="none" stroke="gray"></path></g><path id="node_outline597" fill="none" stroke="none" d="M537.5,54.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text597" fill="black"><text id="kity_text_8504" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="537.5">怎么优化数据访问呢</text></g></g><g id="minder_node600" display="none"><g id="node_expander595" display="none" style="cursor: pointer;"><path id="kity_path_22307" fill="white" stroke="gray" d="M553.5,63.5A6,6,0,1,1,541.5,63.5A6,6,0,1,1,553.5,63.5"></path><path id="kity_path_22308" fill="none" stroke="gray"></path></g><path id="node_outline596" fill="none" stroke="none" d="M553.5,54.5h192a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-192a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text596" fill="black"><text id="kity_text_8502" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="553.5">1.减少数据的请求量 2.减少扫描行数</text></g></g><g id="minder_node601" display="none"><g id="node_expander598" display="none" style="cursor: pointer;"><path id="kity_path_22316" fill="white" stroke="gray" d="M537.5,71.5A6,6,0,1,1,525.5,71.5A6,6,0,1,1,537.5,71.5"></path><path id="kity_path_22317" fill="none" stroke="gray"></path></g><path id="node_outline599" fill="none" stroke="none" d="M537.5,62.5h134a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-134a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text599" fill="black"><text id="kity_text_8510" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="537.5">大表查询你怎么入手优化</text></g></g><g id="minder_node602" display="none"><g id="node_expander597" display="none" style="cursor: pointer;"><path id="kity_path_22313" fill="white" stroke="gray" d="M553.5,71.5A6,6,0,1,1,541.5,71.5A6,6,0,1,1,553.5,71.5"></path><path id="kity_path_22314" fill="none" stroke="gray"></path></g><path id="node_outline598" fill="none" stroke="none" d="M553.5,44.5h531a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-531a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text598" fill="black"><text id="kity_text_8506" text-rendering="inherit" font-size="12" dy=".8em" y="45.700000047683716" x="553.5">1.首先大表多大，单表超过500万可以考虑分库分表</text><text id="kity_text_8507" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="553.5">2.避免全表扫描，创建使用合适索引，业务层减少一次性查询扫描行数，编写合理的sql防止索引失效</text><text id="kity_text_8508" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="553.5">3.避免大事务操作，</text></g></g><g id="minder_node603" display="none"><g id="node_expander600" display="none" style="cursor: pointer;"><path id="kity_path_22322" fill="white" stroke="gray" d="M537.5,79.5A6,6,0,1,1,525.5,79.5A6,6,0,1,1,537.5,79.5"></path><path id="kity_path_22323" fill="none" stroke="gray"></path></g><path id="node_outline601" fill="none" stroke="none" d="M537.5,70.5h98a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-98a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text601" fill="black"><text id="kity_text_8519" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="537.5">超大分页你怎么办</text></g></g><g id="minder_node604" display="none"><g id="node_expander599" display="none" style="cursor: pointer;"><path id="kity_path_22319" fill="white" stroke="gray" d="M553.5,79.5A6,6,0,1,1,541.5,79.5A6,6,0,1,1,553.5,79.5"></path><path id="kity_path_22320" fill="none" stroke="gray"></path></g><path id="node_outline600" fill="none" stroke="none" d="M553.5,25.5h684a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-684a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text600" fill="black"><text id="kity_text_8512" text-rendering="inherit" font-size="12" dy=".8em" y="26.700000047683716" x="553.5">1.可以通过书签的形式，记录上一次查询的id最大值和最小值，然后根据id遍历获取</text><text id="kity_text_8513" text-rendering="inherit" font-size="12" dy=".8em" y="44.700000047683716" x="553.5">2.延迟关联，子查询 + 覆盖索引：mysql的查询完全命中索引的时候,称为覆盖索引,是非常快的,因为查询只需要在索引上进行查找,</text><text id="kity_text_8514" text-rendering="inherit" font-size="12" dy=".8em" y="62.700000047683716" x="553.5">之后可以直接返回,而不用再回数据表拿数据.因此我们可以先查出索引的ID,然后根据Id拿数据.</text><text id="kity_text_8515" text-rendering="inherit" font-size="12" dy=".8em" y="80.70000004768372" x="553.5">3.最后可以通过explain+mysql自带query分析是否走索引，耗时长在哪。</text><text id="kity_text_8516" text-rendering="inherit" font-size="12" dy=".8em" y="98.70000004768372" x="553.5">show profiles;</text><text id="kity_text_8517" text-rendering="inherit" font-size="12" dy=".8em" y="116.70000004768372" x="553.5">show profile for query query_id;</text></g></g><g id="minder_node605" display="none"><g id="node_expander602" display="none" style="cursor: pointer;"><path id="kity_path_22328" fill="white" stroke="gray" d="M537.5,87.5A6,6,0,1,1,525.5,87.5A6,6,0,1,1,537.5,87.5"></path><path id="kity_path_22329" fill="none" stroke="gray"></path></g><path id="node_outline603" fill="none" stroke="none" d="M537.5,78.5h129a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-129a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text603" fill="black"><text id="kity_text_8523" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="537.5">limit 20000很慢 怎么办</text></g></g><g id="minder_node606" display="none"><g id="node_expander601" display="none" style="cursor: pointer;"><path id="kity_path_22325" fill="white" stroke="gray" d="M553.5,87.5A6,6,0,1,1,541.5,87.5A6,6,0,1,1,553.5,87.5"></path><path id="kity_path_22326" fill="none" stroke="gray"></path></g><path id="node_outline602" fill="none" stroke="none" d="M553.5,78.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text602" fill="black"><text id="kity_text_8521" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="553.5">和上面一样的步骤。</text></g></g><g id="minder_node607" display="none"><g id="node_expander604" display="none" style="cursor: pointer;"><path id="kity_path_22334" fill="white" stroke="gray" d="M537.5,95.5A6,6,0,1,1,525.5,95.5A6,6,0,1,1,537.5,95.5"></path><path id="kity_path_22335" fill="none" stroke="gray"></path></g><path id="node_outline605" fill="none" stroke="none" d="M537.5,86.5h192a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-192a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text605" fill="black"><text id="kity_text_8527" text-rendering="inherit" font-size="12" dy=".8em" y="87.70000004768372" x="537.5">也就是mysql深度分页遇到怎么优化</text></g></g><g id="minder_node608" display="none"><g id="node_expander603" display="none" style="cursor: pointer;"><path id="kity_path_22331" fill="white" stroke="gray" d="M553.5,95.5A6,6,0,1,1,541.5,95.5A6,6,0,1,1,553.5,95.5"></path><path id="kity_path_22332" fill="none" stroke="gray"></path></g><path id="node_outline604" fill="none" stroke="none" d="M553.5,86.5h122a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-122a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text604" fill="black"><text id="kity_text_8525" text-rendering="inherit" font-size="12" dy=".8em" y="87.70000004768372" x="553.5">还是和上面一样的步骤</text></g></g><g id="minder_node609" display="none"><g id="node_expander612" display="none" style="cursor: pointer;"><path id="kity_path_22358" fill="white" stroke="gray" d="M521.5,103.5A6,6,0,1,1,509.5,103.5A6,6,0,1,1,521.5,103.5"></path><path id="kity_path_22359" fill="none" stroke="gray"></path></g><path id="node_outline613" fill="none" stroke="none" d="M521.5,94.5h62a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-62a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text613" fill="black"><text id="kity_text_8551" text-rendering="inherit" font-size="12" dy=".8em" y="95.70000004768372" x="521.5">数据库优化</text></g></g><g id="minder_node610" display="none"><g id="node_expander608" display="none" style="cursor: pointer;"><path id="kity_path_22346" fill="white" stroke="gray" d="M537.5,87.5A6,6,0,1,1,525.5,87.5A6,6,0,1,1,537.5,87.5"></path><path id="kity_path_22347" fill="none" stroke="gray"></path></g><path id="node_outline609" fill="none" stroke="none" d="M537.5,78.5h169a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-169a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text609" fill="black"><text id="kity_text_8538" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="537.5">你对数据库层面做过什么优化？</text></g></g><g id="minder_node611" display="none"><g id="node_expander607" display="none" style="cursor: pointer;"><path id="kity_path_22343" fill="white" stroke="gray" d="M553.5,87.5A6,6,0,1,1,541.5,87.5A6,6,0,1,1,553.5,87.5"></path><path id="kity_path_22344" fill="none" stroke="gray"></path></g><path id="node_outline608" fill="none" stroke="none" d="M553.5,51.5h993a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-993a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text608" fill="black"><text id="kity_text_8533" text-rendering="inherit" font-size="12" dy=".8em" y="52.700000047683716" x="553.5">1.数据库配置层面优化，调整影响数据库性能的参数。innodb中的，调整过mysql日志刷盘，日志缓冲区大小，由于日志最长每秒钟刷新一次，所以一般不用超过16M，默认8M可以调整下</text><text id="kity_text_8534" text-rendering="inherit" font-size="12" dy=".8em" y="70.70000004768372" x="553.5">还有索引和数据缓冲区大小，一般设置物理内存的60%-70%</text><text id="kity_text_8535" text-rendering="inherit" font-size="12" dy=".8em" y="88.70000004768372" x="553.5">2.对linux内核层面优化，如TIME_WAIT超时时间，复用tcp连接。</text><text id="kity_text_8536" text-rendering="inherit" font-size="12" dy=".8em" y="106.70000004768372" x="553.5">3.升级硬件</text></g></g><g id="minder_node612" display="none"><g id="node_expander606" display="none" style="cursor: pointer;"><path id="kity_path_22340" fill="white" stroke="gray" d="M569.5,87.5A6,6,0,1,1,557.5,87.5A6,6,0,1,1,569.5,87.5"></path><path id="kity_path_22341" fill="none" stroke="gray"></path></g><path id="node_outline607" fill="none" stroke="none" d="M569.5,78.5h192a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-192a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text607" fill="black"><text id="kity_text_8531" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="569.5">https://www.modb.pro/db/43522</text></g></g><g id="minder_node613" display="none"><g id="node_expander610" display="none" style="cursor: pointer;"><path id="kity_path_22352" fill="white" stroke="gray" d="M537.5,95.5A6,6,0,1,1,525.5,95.5A6,6,0,1,1,537.5,95.5"></path><path id="kity_path_22353" fill="none" stroke="gray"></path></g><path id="node_outline611" fill="none" stroke="none" d="M537.5,86.5h193a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-193a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text611" fill="black"><text id="kity_text_8547" text-rendering="inherit" font-size="12" dy=".8em" y="87.70000004768372" x="537.5">继续上面的问题说说系统调优参数？</text></g></g><g id="minder_node614" display="none"><g id="node_expander609" display="none" style="cursor: pointer;"><path id="kity_path_22349" fill="white" stroke="gray" d="M553.5,95.5A6,6,0,1,1,541.5,95.5A6,6,0,1,1,553.5,95.5"></path><path id="kity_path_22350" fill="none" stroke="gray"></path></g><path id="node_outline610" fill="none" stroke="none" d="M553.5,41.5h1131a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1131a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text610" fill="black"><text id="kity_text_8540" text-rendering="inherit" font-size="12" dy=".8em" y="42.700000047683716" x="553.5">1.可以使用iibench-mysql工具来测试mysql插入性能</text><text id="kity_text_8541" text-rendering="inherit" font-size="12" dy=".8em" y="60.700000047683716" x="553.5">2.back_log：back_log 值指出在 MySQL 暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。新来的请求将会被存在堆栈中，以等待某一连接释放资源，</text><text id="kity_text_8542" text-rendering="inherit" font-size="12" dy=".8em" y="78.70000004768372" x="553.5">3.max_user_connection: 最大连接数，默认为 0 无上限，最好设一个合理上限</text><text id="kity_text_8543" text-rendering="inherit" font-size="12" dy=".8em" y="96.70000004768372" x="553.5">4.key_buffer_size：索引块的缓存大小，增加会提升索引处理速度。对于内存 4G 左右，可设为 256M 或 384M，通过查询show status like 'key_read%'，保证key_reads / key_read_requests在 0.1% 以下最好；</text><text id="kity_text_8544" text-rendering="inherit" font-size="12" dy=".8em" y="114.70000004768372" x="553.5">5.innodb_buffer_pool_size：缓存数据块和索引块，对 InnoDB 表性能影响最大</text><text id="kity_text_8545" text-rendering="inherit" font-size="12" dy=".8em" y="132.70000004768372" x="553.5">6.innodb_log_buffer_size：InnoDB 存储引擎的事务日志所使用的缓冲区，一般来说不建议超过 32MB；</text></g></g><g id="minder_node615" display="none"><g id="node_expander611" display="none" style="cursor: pointer;"><path id="kity_path_22355" fill="white" stroke="gray" d="M537.5,103.5A6,6,0,1,1,525.5,103.5A6,6,0,1,1,537.5,103.5"></path><path id="kity_path_22356" fill="none" stroke="gray"></path></g><path id="node_outline612" fill="none" stroke="none" d="M537.5,94.5h132a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-132a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text612" fill="black"><text id="kity_text_8549" text-rendering="inherit" font-size="12" dy=".8em" y="95.70000004768372" x="537.5">了解优化数据库结构吗？</text></g></g><g id="minder_node616" display="none"><g id="node_expander625" display="none" style="cursor: pointer;"><path id="kity_path_22397" fill="white" stroke="gray" d="M521.5,111.5A6,6,0,1,1,509.5,111.5A6,6,0,1,1,521.5,111.5"></path><path id="kity_path_22398" fill="none" stroke="gray"></path></g><path id="node_outline626" fill="none" stroke="none" d="M521.5,102.5h41a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-41a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text626" fill="black"><text id="kity_text_8594" text-rendering="inherit" font-size="12" dy=".8em" y="103.70000004768372" x="521.5">sql优化</text></g></g><g id="minder_node617" display="none"><g id="node_expander622" display="none" style="cursor: pointer;"><path id="kity_path_22388" fill="white" stroke="gray" d="M537.5,103.5A6,6,0,1,1,525.5,103.5A6,6,0,1,1,537.5,103.5"></path><path id="kity_path_22389" fill="none" stroke="gray"></path></g><path id="node_outline623" fill="none" stroke="none" d="M537.5,94.5h161a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-161a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text623" fill="black"><text id="kity_text_8588" text-rendering="inherit" font-size="12" dy=".8em" y="95.70000004768372" x="537.5">你有什么写高质量sql的建议吗</text></g></g><g id="minder_node618" display="none"><g id="node_expander613" display="none" style="cursor: pointer;"><path id="kity_path_22361" fill="white" stroke="gray" d="M553.5,71.5A6,6,0,1,1,541.5,71.5A6,6,0,1,1,553.5,71.5"></path><path id="kity_path_22362" fill="none" stroke="gray"></path></g><path id="node_outline614" fill="none" stroke="none" d="M553.5,62.5h284a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-284a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text614" fill="black"><text id="kity_text_8553" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="553.5">1.编写合理的sql，从字段，索引，查询sql，引擎入手</text></g></g><g id="minder_node619" display="none"><g id="node_expander615" display="none" style="cursor: pointer;"><path id="kity_path_22367" fill="white" stroke="gray" d="M553.5,79.5A6,6,0,1,1,541.5,79.5A6,6,0,1,1,553.5,79.5"></path><path id="kity_path_22368" fill="none" stroke="gray"></path></g><path id="node_outline616" fill="none" stroke="none" d="M553.5,70.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text616" fill="black"><text id="kity_text_8563" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="553.5">字段</text></g></g><g id="minder_node620" display="none"><g id="node_expander614" display="none" style="cursor: pointer;"><path id="kity_path_22364" fill="white" stroke="gray" d="M569.5,79.5A6,6,0,1,1,557.5,79.5A6,6,0,1,1,569.5,79.5"></path><path id="kity_path_22365" fill="none" stroke="gray"></path></g><path id="node_outline615" fill="none" stroke="none" d="M569.5,16.5h533a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-533a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text615" fill="black"><text id="kity_text_8555" text-rendering="inherit" font-size="12" dy=".8em" y="17.700000047683716" x="569.5">尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED</text><text id="kity_text_8556" text-rendering="inherit" font-size="12" dy=".8em" y="35.700000047683716" x="569.5">VARCHAR的长度只分配真正需要的空间</text><text id="kity_text_8557" text-rendering="inherit" font-size="12" dy=".8em" y="53.700000047683716" x="569.5">使用枚举或整数代替字符串类型</text><text id="kity_text_8558" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="569.5">尽量使用TIMESTAMP而非DATETIME，</text><text id="kity_text_8559" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="569.5">单表不要有太多字段，建议在20以内</text><text id="kity_text_8560" text-rendering="inherit" font-size="12" dy=".8em" y="107.70000004768372" x="569.5">避免使用NULL字段，很难查询优化且占用额外索引空间</text><text id="kity_text_8561" text-rendering="inherit" font-size="12" dy=".8em" y="125.70000004768372" x="569.5">用整型来存IP</text></g></g><g id="minder_node621" display="none"><g id="node_expander617" display="none" style="cursor: pointer;"><path id="kity_path_22373" fill="white" stroke="gray" d="M553.5,87.5A6,6,0,1,1,541.5,87.5A6,6,0,1,1,553.5,87.5"></path><path id="kity_path_22374" fill="none" stroke="gray"></path></g><path id="node_outline618" fill="none" stroke="none" d="M553.5,78.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text618" fill="black"><text id="kity_text_8567" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="553.5">索引</text></g></g><g id="minder_node622" display="none"><g id="node_expander616" display="none" style="cursor: pointer;"><path id="kity_path_22370" fill="white" stroke="gray" d="M569.5,87.5A6,6,0,1,1,557.5,87.5A6,6,0,1,1,569.5,87.5"></path><path id="kity_path_22371" fill="none" stroke="gray"></path></g><path id="node_outline617" fill="none" stroke="none" d="M569.5,78.5h194a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-194a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text617" fill="black"><text id="kity_text_8565" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="569.5">索引就是索引优化和索引的注意事项</text></g></g><g id="minder_node623" display="none"><g id="node_expander619" display="none" style="cursor: pointer;"><path id="kity_path_22379" fill="white" stroke="gray" d="M553.5,95.5A6,6,0,1,1,541.5,95.5A6,6,0,1,1,553.5,95.5"></path><path id="kity_path_22380" fill="none" stroke="gray"></path></g><path id="node_outline620" fill="none" stroke="none" d="M553.5,86.5h41a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-41a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text620" fill="black"><text id="kity_text_8582" text-rendering="inherit" font-size="12" dy=".8em" y="87.70000004768372" x="553.5">查询sql</text></g></g><g id="minder_node624" display="none"><g id="node_expander618" display="none" style="cursor: pointer;"><path id="kity_path_22376" fill="white" stroke="gray" d="M569.5,95.5A6,6,0,1,1,557.5,95.5A6,6,0,1,1,569.5,95.5"></path><path id="kity_path_22377" fill="none" stroke="gray"></path></g><path id="node_outline619" fill="none" stroke="none" d="M569.5,-12.5h810a5,5,0,0,1,5,5v206a5,5,0,0,1,-5,5h-810a5,5,0,0,1,-5,-5v-206a5,5,0,0,1,5,-5z"></path><g id="node_text619" fill="black"><text id="kity_text_8569" text-rendering="inherit" font-size="12" dy=".8em" y="-11.299999952316284" x="569.5">可通过开启慢查询日志来找出较慢的SQL和explain分析</text><text id="kity_text_8570" text-rendering="inherit" font-size="12" dy=".8em" y="6.700000047683716" x="569.5">不做列运算： WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边</text><text id="kity_text_8571" text-rendering="inherit" font-size="12" dy=".8em" y="24.700000047683716" x="569.5">sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库</text><text id="kity_text_8572" text-rendering="inherit" font-size="12" dy=".8em" y="42.700000047683716" x="569.5">不用SELECT *</text><text id="kity_text_8573" text-rendering="inherit" font-size="12" dy=".8em" y="60.700000047683716" x="569.5">OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内</text><text id="kity_text_8574" text-rendering="inherit" font-size="12" dy=".8em" y="78.70000004768372" x="569.5">不用函数和触发器，在应用程序实现</text><text id="kity_text_8575" text-rendering="inherit" font-size="12" dy=".8em" y="96.70000004768372" x="569.5">避免%xxx式查询</text><text id="kity_text_8576" text-rendering="inherit" font-size="12" dy=".8em" y="114.70000004768372" x="569.5">少用JOIN</text><text id="kity_text_8577" text-rendering="inherit" font-size="12" dy=".8em" y="132.70000004768372" x="569.5">使用同类型进行比较，比如用'123'和'123'比，123和123比</text><text id="kity_text_8578" text-rendering="inherit" font-size="12" dy=".8em" y="150.70000004768372" x="569.5">尽量避免在WHERE子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</text><text id="kity_text_8579" text-rendering="inherit" font-size="12" dy=".8em" y="168.70000004768372" x="569.5">对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5</text><text id="kity_text_8580" text-rendering="inherit" font-size="12" dy=".8em" y="186.70000004768372" x="569.5">列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大</text></g></g><g id="minder_node625" display="none"><g id="node_expander621" display="none" style="cursor: pointer;"><path id="kity_path_22385" fill="white" stroke="gray" d="M553.5,103.5A6,6,0,1,1,541.5,103.5A6,6,0,1,1,553.5,103.5"></path><path id="kity_path_22386" fill="none" stroke="gray"></path></g><path id="node_outline622" fill="none" stroke="none" d="M553.5,94.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text622" fill="black"><text id="kity_text_8586" text-rendering="inherit" font-size="12" dy=".8em" y="95.70000004768372" x="553.5">引擎</text></g></g><g id="minder_node626" display="none"><g id="node_expander620" display="none" style="cursor: pointer;"><path id="kity_path_22382" fill="white" stroke="gray" d="M569.5,103.5A6,6,0,1,1,557.5,103.5A6,6,0,1,1,569.5,103.5"></path><path id="kity_path_22383" fill="none" stroke="gray"></path></g><path id="node_outline621" fill="none" stroke="none" d="M569.5,94.5h143a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-143a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text621" fill="black"><text id="kity_text_8584" text-rendering="inherit" font-size="12" dy=".8em" y="95.70000004768372" x="569.5">就是mysql主流引擎的区别</text></g></g><g id="minder_node627" display="none"><g id="node_expander624" display="none" style="cursor: pointer;"><path id="kity_path_22394" fill="white" stroke="gray" d="M537.5,111.5A6,6,0,1,1,525.5,111.5A6,6,0,1,1,537.5,111.5"></path><path id="kity_path_22395" fill="none" stroke="gray"></path></g><path id="node_outline625" fill="none" stroke="none" d="M537.5,102.5h137a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-137a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text625" fill="black"><text id="kity_text_8592" text-rendering="inherit" font-size="12" dy=".8em" y="103.70000004768372" x="537.5">知道一条sql的生命周期吗</text></g></g><g id="minder_node628" display="none"><g id="node_expander623" display="none" style="cursor: pointer;"><path id="kity_path_22391" fill="white" stroke="gray" d="M553.5,111.5A6,6,0,1,1,541.5,111.5A6,6,0,1,1,553.5,111.5"></path><path id="kity_path_22392" fill="none" stroke="gray"></path></g><path id="node_outline624" fill="none" stroke="none" d="M553.5,102.5h126a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-126a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text624" fill="black"><text id="kity_text_8590" text-rendering="inherit" font-size="12" dy=".8em" y="103.70000004768372" x="553.5">就是一条sql的执行流程</text></g></g><g id="minder_node629" display="none"><g id="node_expander661" display="none" style="cursor: pointer;"><path id="kity_path_22505" fill="white" stroke="gray" d="M521.5,119.5A6,6,0,1,1,509.5,119.5A6,6,0,1,1,521.5,119.5"></path><path id="kity_path_22506" fill="none" stroke="gray"></path></g><path id="node_outline662" fill="none" stroke="none" d="M521.5,110.5h73a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-73a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text662" fill="black"><text id="kity_text_8694" text-rendering="inherit" font-size="12" dy=".8em" y="111.70000004768372" x="521.5">性能分析计划</text></g></g><g id="minder_node630" display="none"><g id="node_expander658" display="none" style="cursor: pointer;"><path id="kity_path_22496" fill="white" stroke="gray" d="M537.5,111.5A6,6,0,1,1,525.5,111.5A6,6,0,1,1,537.5,111.5"></path><path id="kity_path_22497" fill="none" stroke="gray"></path></g><path id="node_outline659" fill="none" stroke="none" d="M537.5,102.5h66a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-66a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text659" fill="black"><text id="kity_text_8683" text-rendering="inherit" font-size="12" dy=".8em" y="103.70000004768372" x="537.5">explain相关</text></g></g><g id="minder_node631" display="none"><g id="node_expander627" display="none" style="cursor: pointer;"><path id="kity_path_22403" fill="white" stroke="gray" d="M553.5,79.5A6,6,0,1,1,541.5,79.5A6,6,0,1,1,553.5,79.5"></path><path id="kity_path_22404" fill="none" stroke="gray"></path></g><path id="node_outline628" fill="none" stroke="none" d="M553.5,70.5h378a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-378a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text628" fill="black"><text id="kity_text_8601" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="553.5">知道explain关键字吗，说说有什么作用？怎么使用？还知道其他的吗？</text></g></g><g id="minder_node632" display="none"><g id="node_expander626" display="none" style="cursor: pointer;"><path id="kity_path_22400" fill="white" stroke="gray" d="M569.5,79.5A6,6,0,1,1,557.5,79.5A6,6,0,1,1,569.5,79.5"></path><path id="kity_path_22401" fill="none" stroke="gray"></path></g><path id="node_outline627" fill="none" stroke="none" d="M569.5,43.5h607a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-607a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text627" fill="black"><text id="kity_text_8596" text-rendering="inherit" font-size="12" dy=".8em" y="44.700000047683716" x="569.5">1.当数据量增长的特别大的时候就需要用到索引来优化SQL语句，</text><text id="kity_text_8597" text-rendering="inherit" font-size="12" dy=".8em" y="62.700000047683716" x="569.5">判断当前 SQL 是否使用了索引？如何检验修改后的 SQL 确实有优化效果？都可以使用explain</text><text id="kity_text_8598" text-rendering="inherit" font-size="12" dy=".8em" y="80.70000004768372" x="569.5">2.select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询时，会返回执行计划的信息，</text><text id="kity_text_8599" text-rendering="inherit" font-size="12" dy=".8em" y="98.70000004768372" x="569.5">而不是执行这条SQL（如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中）</text></g></g><g id="minder_node633" display="none"><g id="node_expander630" display="none" style="cursor: pointer;"><path id="kity_path_22412" fill="white" stroke="gray" d="M553.5,87.5A6,6,0,1,1,541.5,87.5A6,6,0,1,1,553.5,87.5"></path><path id="kity_path_22413" fill="none" stroke="gray"></path></g><path id="node_outline631" fill="none" stroke="none" d="M553.5,78.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text631" fill="black"><text id="kity_text_8608" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="553.5">explaion能得到什么？</text></g></g><g id="minder_node634" display="none"><g id="node_expander629" display="none" style="cursor: pointer;"><path id="kity_path_22409" fill="white" stroke="gray" d="M569.5,87.5A6,6,0,1,1,557.5,87.5A6,6,0,1,1,569.5,87.5"></path><path id="kity_path_22410" fill="none" stroke="gray"></path></g><path id="node_outline630" fill="none" stroke="none" d="M569.5,69.5h445a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-445a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text630" fill="black"><text id="kity_text_8605" text-rendering="inherit" font-size="12" dy=".8em" y="70.70000004768372" x="569.5">表的读取顺序，数据读取操作的操作类型，哪些索引可以使用，哪些索引被实际使用</text><text id="kity_text_8606" text-rendering="inherit" font-size="12" dy=".8em" y="88.70000004768372" x="569.5">表之间的引用，每张表有多少行被优化器查询</text></g></g><g id="minder_node635" display="none"><g id="node_expander628" display="none" style="cursor: pointer;"><path id="kity_path_22406" fill="white" stroke="gray" d="M585.5,87.5A6,6,0,1,1,573.5,87.5A6,6,0,1,1,585.5,87.5"></path><path id="kity_path_22407" fill="none" stroke="gray"></path></g><path id="node_outline629" fill="none" stroke="none" d="M510.5,61.5h200a5,5,0,0,1,5,5v25a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-25a5,5,0,0,1,5,-5z"></path><g id="node_text629" fill="black"><text id="kity_text_8603" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="585.5">分支主题</text></g><image id="kity_image_17036" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210320111040.png" x="510.5" y="64.5" width="200" height="12"></image></g><g id="minder_node636" display="none"><g id="node_expander652" display="none" style="cursor: pointer;"><path id="kity_path_22478" fill="white" stroke="gray" d="M553.5,95.5A6,6,0,1,1,541.5,95.5A6,6,0,1,1,553.5,95.5"></path><path id="kity_path_22479" fill="none" stroke="gray"></path></g><path id="node_outline653" fill="none" stroke="none" d="M553.5,86.5h193a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-193a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text653" fill="black"><text id="kity_text_8662" text-rendering="inherit" font-size="12" dy=".8em" y="87.70000004768372" x="553.5">你重点关注explain的哪些column列</text></g></g><g id="minder_node637" display="none"><g id="node_expander631" display="none" style="cursor: pointer;"><path id="kity_path_22415" fill="white" stroke="gray" d="M569.5,23.5A6,6,0,1,1,557.5,23.5A6,6,0,1,1,569.5,23.5"></path><path id="kity_path_22416" fill="none" stroke="gray"></path></g><path id="node_outline632" fill="none" stroke="none" d="M569.5,14.5h617a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-617a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text632" fill="black"><text id="kity_text_8610" text-rendering="inherit" font-size="12" dy=".8em" y="15.700000047683716" x="569.5">id:表示查询中执行select子句或操作表的顺序,id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行</text></g></g><g id="minder_node638" display="none"><g id="node_expander636" display="none" style="cursor: pointer;"><path id="kity_path_22430" fill="white" stroke="gray" d="M569.5,31.5A6,6,0,1,1,557.5,31.5A6,6,0,1,1,569.5,31.5"></path><path id="kity_path_22431" fill="none" stroke="gray"></path></g><path id="node_outline637" fill="none" stroke="none" d="M569.5,22.5h412a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-412a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text637" fill="black"><text id="kity_text_8620" text-rendering="inherit" font-size="12" dy=".8em" y="23.700000047683716" x="569.5">select_type（查询类型，用于区别普通查询、联合查询、子查询等复杂查询）</text></g></g><g id="minder_node639" display="none"><g id="node_expander632" display="none" style="cursor: pointer;"><path id="kity_path_22418" fill="white" stroke="gray" d="M585.5,7.5A6,6,0,1,1,573.5,7.5A6,6,0,1,1,585.5,7.5"></path><path id="kity_path_22419" fill="none" stroke="gray"></path></g><path id="node_outline633" fill="none" stroke="none" d="M585.5,-1.5h249a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-249a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text633" fill="black"><text id="kity_text_8612" text-rendering="inherit" font-size="12" dy=".8em" y="-0.2999999523162842" x="585.5">1.simple简单查询。查询不包含子查询和union</text></g></g><g id="minder_node640" display="none"><g id="node_expander633" display="none" style="cursor: pointer;"><path id="kity_path_22421" fill="white" stroke="gray" d="M585.5,15.5A6,6,0,1,1,573.5,15.5A6,6,0,1,1,585.5,15.5"></path><path id="kity_path_22422" fill="none" stroke="gray"></path></g><path id="node_outline634" fill="none" stroke="none" d="M585.5,6.5h211a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-211a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text634" fill="black"><text id="kity_text_8614" text-rendering="inherit" font-size="12" dy=".8em" y="7.700000047683716" x="585.5">2.primary：复杂查询中最外层的 select</text></g></g><g id="minder_node641" display="none"><g id="node_expander634" display="none" style="cursor: pointer;"><path id="kity_path_22424" fill="white" stroke="gray" d="M585.5,23.5A6,6,0,1,1,573.5,23.5A6,6,0,1,1,585.5,23.5"></path><path id="kity_path_22425" fill="none" stroke="gray"></path></g><path id="node_outline635" fill="none" stroke="none" d="M585.5,14.5h286a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-286a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text635" fill="black"><text id="kity_text_8616" text-rendering="inherit" font-size="12" dy=".8em" y="15.700000047683716" x="585.5">3.SUBQUERY：在select或where列表中包含了子查询</text></g></g><g id="minder_node642" display="none"><g id="node_expander635" display="none" style="cursor: pointer;"><path id="kity_path_22427" fill="white" stroke="gray" d="M585.5,31.5A6,6,0,1,1,573.5,31.5A6,6,0,1,1,585.5,31.5"></path><path id="kity_path_22428" fill="none" stroke="gray"></path></g><path id="node_outline636" fill="none" stroke="none" d="M585.5,22.5h614a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-614a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text636" fill="black"><text id="kity_text_8618" text-rendering="inherit" font-size="12" dy=".8em" y="23.700000047683716" x="585.5">4.DERIVED：在from列表中包含的子查询被标记为DERIVED，MySQL会递归执行这些子查询，把结果放在临时表里</text></g></g><g id="minder_node643" display="none"><g id="node_expander637" display="none" style="cursor: pointer;"><path id="kity_path_22433" fill="white" stroke="gray" d="M569.5,39.5A6,6,0,1,1,557.5,39.5A6,6,0,1,1,569.5,39.5"></path><path id="kity_path_22434" fill="none" stroke="gray"></path></g><path id="node_outline638" fill="none" stroke="none" d="M569.5,30.5h234a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-234a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text638" fill="black"><text id="kity_text_8622" text-rendering="inherit" font-size="12" dy=".8em" y="31.700000047683716" x="569.5">table（显示这一行的数据是关于哪张表的）</text></g></g><g id="minder_node644" display="none"><g id="node_expander644" display="none" style="cursor: pointer;"><path id="kity_path_22454" fill="white" stroke="gray" d="M569.5,47.5A6,6,0,1,1,557.5,47.5A6,6,0,1,1,569.5,47.5"></path><path id="kity_path_22455" fill="none" stroke="gray"></path></g><path id="node_outline645" fill="none" stroke="none" d="M569.5,29.5h601a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-601a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text645" fill="black"><text id="kity_text_8640" text-rendering="inherit" font-size="12" dy=".8em" y="30.700000047683716" x="569.5">type:表示关联类型或访问类型，从最好到最差依次排列&#xa0;system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL </text><text id="kity_text_8641" text-rendering="inherit" font-size="12" dy=".8em" y="48.700000047683716" x="569.5">一般来说，得保证查询达到range级别，最好达到ref</text></g></g><g id="minder_node645" display="none"><g id="node_expander638" display="none" style="cursor: pointer;"><path id="kity_path_22436" fill="white" stroke="gray" d="M585.5,7.5A6,6,0,1,1,573.5,7.5A6,6,0,1,1,585.5,7.5"></path><path id="kity_path_22437" fill="none" stroke="gray"></path></g><path id="node_outline639" fill="none" stroke="none" d="M585.5,-1.5h428a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-428a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text639" fill="black"><text id="kity_text_8624" text-rendering="inherit" font-size="12" dy=".8em" y="-0.2999999523162842" x="585.5">NULL:mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。</text></g></g><g id="minder_node646" display="none"><g id="node_expander639" display="none" style="cursor: pointer;"><path id="kity_path_22439" fill="white" stroke="gray" d="M585.5,15.5A6,6,0,1,1,573.5,15.5A6,6,0,1,1,585.5,15.5"></path><path id="kity_path_22440" fill="none" stroke="gray"></path></g><path id="node_outline640" fill="none" stroke="none" d="M585.5,6.5h379a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-379a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text640" fill="black"><text id="kity_text_8626" text-rendering="inherit" font-size="12" dy=".8em" y="7.700000047683716" x="585.5">const, system:mysql能对查询的某部分进行优化并将其转化成一个常量</text></g></g><g id="minder_node647" display="none"><g id="node_expander640" display="none" style="cursor: pointer;"><path id="kity_path_22442" fill="white" stroke="gray" d="M585.5,23.5A6,6,0,1,1,573.5,23.5A6,6,0,1,1,585.5,23.5"></path><path id="kity_path_22443" fill="none" stroke="gray"></path></g><path id="node_outline641" fill="none" stroke="none" d="M585.5,5.5h1027a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1027a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text641" fill="black"><text id="kity_text_8628" text-rendering="inherit" font-size="12" dy=".8em" y="6.700000047683716" x="585.5">eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描</text><text id="kity_text_8629" text-rendering="inherit" font-size="12" dy=".8em" y="24.700000047683716" x="585.5">ref：非唯一性索引扫描，范围匹配某个单独值得所有行。相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。</text></g></g><g id="minder_node648" display="none"><g id="node_expander641" display="none" style="cursor: pointer;"><path id="kity_path_22445" fill="white" stroke="gray" d="M585.5,31.5A6,6,0,1,1,573.5,31.5A6,6,0,1,1,585.5,31.5"></path><path id="kity_path_22446" fill="none" stroke="gray"></path></g><path id="node_outline642" fill="none" stroke="none" d="M585.5,13.5h805a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-805a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text642" fill="black"><text id="kity_text_8631" text-rendering="inherit" font-size="12" dy=".8em" y="14.700000047683716" x="585.5">range:只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询，</text><text id="kity_text_8632" text-rendering="inherit" font-size="12" dy=".8em" y="32.700000047683716" x="585.5">这种范围扫描索引比全表扫描要好，因为它只需开始于索引的某一点，而结束于另一点，不用扫描全部索引</text></g></g><g id="minder_node649" display="none"><g id="node_expander642" display="none" style="cursor: pointer;"><path id="kity_path_22448" fill="white" stroke="gray" d="M585.5,39.5A6,6,0,1,1,573.5,39.5A6,6,0,1,1,585.5,39.5"></path><path id="kity_path_22449" fill="none" stroke="gray"></path></g><path id="node_outline643" fill="none" stroke="none" d="M585.5,21.5h474a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-474a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text643" fill="black"><text id="kity_text_8634" text-rendering="inherit" font-size="12" dy=".8em" y="22.700000047683716" x="585.5">index</text><text id="kity_text_8635" text-rendering="inherit" font-size="12" dy=".8em" y="40.700000047683716" x="585.5">扫描全表索引，这通常比ALL快一些。（index是从索引中读取的，而all是从硬盘中读取）</text></g></g><g id="minder_node650" display="none"><g id="node_expander643" display="none" style="cursor: pointer;"><path id="kity_path_22451" fill="white" stroke="gray" d="M585.5,47.5A6,6,0,1,1,573.5,47.5A6,6,0,1,1,585.5,47.5"></path><path id="kity_path_22452" fill="none" stroke="gray"></path></g><path id="node_outline644" fill="none" stroke="none" d="M585.5,29.5h538a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-538a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text644" fill="black"><text id="kity_text_8637" text-rendering="inherit" font-size="12" dy=".8em" y="30.700000047683716" x="585.5">ALL</text><text id="kity_text_8638" text-rendering="inherit" font-size="12" dy=".8em" y="48.700000047683716" x="585.5">即全表扫描，意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索引来进行优化了</text></g></g><g id="minder_node651" display="none"><g id="node_expander645" display="none" style="cursor: pointer;"><path id="kity_path_22457" fill="white" stroke="gray" d="M569.5,55.5A6,6,0,1,1,557.5,55.5A6,6,0,1,1,569.5,55.5"></path><path id="kity_path_22458" fill="none" stroke="gray"></path></g><path id="node_outline646" fill="none" stroke="none" d="M569.5,37.5h1061a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1061a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text646" fill="black"><text id="kity_text_8643" text-rendering="inherit" font-size="12" dy=".8em" y="38.700000047683716" x="569.5">possible_keys列</text><text id="kity_text_8644" text-rendering="inherit" font-size="12" dy=".8em" y="56.700000047683716" x="569.5">这一列显示查询可能使用哪些索引来查找。 explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。</text></g></g><g id="minder_node652" display="none"><g id="node_expander646" display="none" style="cursor: pointer;"><path id="kity_path_22460" fill="white" stroke="gray" d="M569.5,63.5A6,6,0,1,1,557.5,63.5A6,6,0,1,1,569.5,63.5"></path><path id="kity_path_22461" fill="none" stroke="gray"></path></g><path id="node_outline647" fill="none" stroke="none" d="M569.5,54.5h551a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-551a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text647" fill="black"><text id="kity_text_8646" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="569.5">key列 这一列显示mysql实际采用哪个索引来优化对该表的访问。 如果没有使用索引，则该列是 NULL。</text></g></g><g id="minder_node653" display="none"><g id="node_expander648" display="none" style="cursor: pointer;"><path id="kity_path_22466" fill="white" stroke="gray" d="M569.5,71.5A6,6,0,1,1,557.5,71.5A6,6,0,1,1,569.5,71.5"></path><path id="kity_path_22467" fill="none" stroke="gray"></path></g><path id="node_outline649" fill="none" stroke="none" d="M569.5,62.5h560a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-560a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text649" fill="black"><text id="kity_text_8654" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="569.5">key_len列 这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。</text></g></g><g id="minder_node654" display="none"><g id="node_expander647" display="none" style="cursor: pointer;"><path id="kity_path_22463" fill="white" stroke="gray" d="M585.5,71.5A6,6,0,1,1,573.5,71.5A6,6,0,1,1,585.5,71.5"></path><path id="kity_path_22464" fill="none" stroke="gray"></path></g><path id="node_outline648" fill="none" stroke="none" d="M585.5,26.5h473a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-473a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text648" fill="black"><text id="kity_text_8648" text-rendering="inherit" font-size="12" dy=".8em" y="27.700000047683716" x="585.5">key_len计算规则如下：</text><text id="kity_text_8649" text-rendering="inherit" font-size="12" dy=".8em" y="45.700000047683716" x="585.5">字符串</text><text id="kity_text_8650" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="585.5">char(n)：n字节长度 。varchar(n)：2字节存储字符串长度，如果是utf-8，则长度 3n + 2</text><text id="kity_text_8651" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="585.5">数值类型 tinyint：1字节。smallint：2字节。int：4字节。bigint：8字节　　</text><text id="kity_text_8652" text-rendering="inherit" font-size="12" dy=".8em" y="99.70000004768372" x="585.5">时间类型　date：3字节。timestamp：4字节。datetime：8字节</text></g></g><g id="minder_node655" display="none"><g id="node_expander649" display="none" style="cursor: pointer;"><path id="kity_path_22469" fill="white" stroke="gray" d="M569.5,79.5A6,6,0,1,1,557.5,79.5A6,6,0,1,1,569.5,79.5"></path><path id="kity_path_22470" fill="none" stroke="gray"></path></g><path id="node_outline650" fill="none" stroke="none" d="M569.5,70.5h387a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-387a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text650" fill="black"><text id="kity_text_8656" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="569.5">ref列 这一列显示了在key列记录的索引中，表查找值所用到的列或常量，</text></g></g><g id="minder_node656" display="none"><g id="node_expander650" display="none" style="cursor: pointer;"><path id="kity_path_22472" fill="white" stroke="gray" d="M569.5,87.5A6,6,0,1,1,557.5,87.5A6,6,0,1,1,569.5,87.5"></path><path id="kity_path_22473" fill="none" stroke="gray"></path></g><path id="node_outline651" fill="none" stroke="none" d="M569.5,78.5h437a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-437a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text651" fill="black"><text id="kity_text_8658" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="569.5">rows列 这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。</text></g></g><g id="minder_node657" display="none"><g id="node_expander651" display="none" style="cursor: pointer;"><path id="kity_path_22475" fill="white" stroke="gray" d="M569.5,95.5A6,6,0,1,1,557.5,95.5A6,6,0,1,1,569.5,95.5"></path><path id="kity_path_22476" fill="none" stroke="gray"></path></g><path id="node_outline652" fill="none" stroke="none" d="M569.5,86.5h188a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-188a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text652" fill="black"><text id="kity_text_8660" text-rendering="inherit" font-size="12" dy=".8em" y="87.70000004768372" x="569.5">Extra列 这一列展示的是额外信息。</text></g></g><g id="minder_node658" display="none"><g id="node_expander655" display="none" style="cursor: pointer;"><path id="kity_path_22487" fill="white" stroke="gray" d="M553.5,103.5A6,6,0,1,1,541.5,103.5A6,6,0,1,1,553.5,103.5"></path><path id="kity_path_22488" fill="none" stroke="gray"></path></g><path id="node_outline656" fill="none" stroke="none" d="M553.5,94.5h198a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-198a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text656" fill="black"><text id="kity_text_8671" text-rendering="inherit" font-size="12" dy=".8em" y="95.70000004768372" x="553.5">你怎么用explain来定位解决慢查询的</text></g></g><g id="minder_node659" display="none"><g id="node_expander654" display="none" style="cursor: pointer;"><path id="kity_path_22484" fill="white" stroke="gray" d="M569.5,103.5A6,6,0,1,1,557.5,103.5A6,6,0,1,1,569.5,103.5"></path><path id="kity_path_22485" fill="none" stroke="gray"></path></g><path id="node_outline655" fill="none" stroke="none" d="M569.5,67.5h1087a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1087a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text655" fill="black"><text id="kity_text_8666" text-rendering="inherit" font-size="12" dy=".8em" y="68.70000004768372" x="569.5">1.explain和慢查询日志分析优化单表查询sql的关键，</text><text id="kity_text_8667" text-rendering="inherit" font-size="12" dy=".8em" y="86.70000004768372" x="569.5">我一般会首先看慢查询日志超时时间和日志路径是否是自己需要的，然后做修改。</text><text id="kity_text_8668" text-rendering="inherit" font-size="12" dy=".8em" y="104.70000004768372" x="569.5">然后先执行一次，看看时间，然后利用explain再测试，然后看描述消息，重点看看有没有利用索引，用了多少索引，语句执行顺序，是否是小表驱动大表，额外信息，还有访问类型等，是否是全表扫描等等</text><text id="kity_text_8669" text-rendering="inherit" font-size="12" dy=".8em" y="122.70000004768372" x="569.5">然后可以创建合理的索引或者组合索引等&#xa0; create index 索引名 on 表名(字段名); 查看索引show index from 表名;</text></g></g><g id="minder_node660" display="none"><g id="node_expander653" display="none" style="cursor: pointer;"><path id="kity_path_22481" fill="white" stroke="gray" d="M585.5,103.5A6,6,0,1,1,573.5,103.5A6,6,0,1,1,585.5,103.5"></path><path id="kity_path_22482" fill="none" stroke="gray"></path></g><path id="node_outline654" fill="none" stroke="none" d="M585.5,89.5h126a5,5,0,0,1,5,5v18a5,5,0,0,1,-5,5h-126a5,5,0,0,1,-5,-5v-18a5,5,0,0,1,5,-5z"></path><g id="node_text654" fill="black"><text id="kity_text_8664" text-rendering="inherit" font-size="12" dy=".8em" y="95.70000004768372" x="585.5">参考分析优化实战</text></g><a id="kity_a_16889" xlink:href="https://github.com/h2pl/Java-Tutorial/blob/master/docs/database/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0MySQL%E6%95%B0%E6%8D%AE%E5%BA%9312%EF%BC%9A%E4%BB%8E%E5%AE%9E%E8%B7%B5sql%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96%E5%BC%80%E5%A7%8B.md#0%E3%80%81%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AEsql%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5" target="_blank" xlink:title="https://github.com/h2pl/Java-Tutorial/blob/master/docs/database/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0MySQL%E6%95%B0%E6%8D%AE%E5%BA%9312%EF%BC%9A%E4%BB%8E%E5%AE%9E%E8%B7%B5sql%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96%E5%BC%80%E5%A7%8B.md#0%E3%80%81%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AEsql%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5" style="cursor: pointer;"><path id="kity_path_16891" fill="rgba(255, 255, 255, 0)" stroke="none" d="M691.5,92.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16890" fill="#666" stroke="none" d="M706.114,108.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V102.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C701.766,99.571,703.168,98.5,704.836,98.5h1.278c2.116,0,3.834,1.716,3.834,3.834V104.89C709.948,107.008,708.23,108.724,706.114,108.724zM694.612,103.612c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S704.265,104.89,703.558,104.89H695.89C695.185,104.89,694.612,104.319,694.612,103.612zM692.056,102.334V104.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H693.334C691.216,108.724,689.5,107.008,689.5,104.89V102.334C689.5,100.216,691.216,98.5,693.334,98.5h1.278c1.667,0,3.071,1.071,3.599,2.556H693.334C692.629,101.056,692.056,101.627,692.056,102.334z"></path></a></g><g id="minder_node661" display="none"><g id="node_expander657" display="none" style="cursor: pointer;"><path id="kity_path_22493" fill="white" stroke="gray" d="M553.5,111.5A6,6,0,1,1,541.5,111.5A6,6,0,1,1,553.5,111.5"></path><path id="kity_path_22494" fill="none" stroke="gray"></path></g><path id="node_outline658" fill="none" stroke="none" d="M553.5,102.5h203a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-203a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text658" fill="black"><text id="kity_text_8681" text-rendering="inherit" font-size="12" dy=".8em" y="103.70000004768372" x="553.5">explain的extra有关注过吗？简单说说</text></g></g><g id="minder_node662" display="none"><g id="node_expander656" display="none" style="cursor: pointer;"><path id="kity_path_22490" fill="white" stroke="gray" d="M569.5,111.5A6,6,0,1,1,557.5,111.5A6,6,0,1,1,569.5,111.5"></path><path id="kity_path_22491" fill="none" stroke="gray"></path></g><path id="node_outline657" fill="none" stroke="none" d="M569.5,48.5h963a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-963a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text657" fill="black"><text id="kity_text_8673" text-rendering="inherit" font-size="12" dy=".8em" y="49.700000047683716" x="569.5">1.Using index查询的列被索引覆盖，并且where筛选条件是索引的列，是性能高的表现。一般是使用了覆盖索引(索引包含了所有查询的字段)。</text><text id="kity_text_8674" text-rendering="inherit" font-size="12" dy=".8em" y="67.70000004768372" x="569.5">2.Using where查询的列未被索引覆盖，where筛选条件非索引的前导列</text><text id="kity_text_8675" text-rendering="inherit" font-size="12" dy=".8em" y="85.70000004768372" x="569.5">3.Using where Using index查询的列被索引覆盖，并且where筛选条件是索引列之一但是不是索引的前导列，</text><text id="kity_text_8676" text-rendering="inherit" font-size="12" dy=".8em" y="103.70000004768372" x="569.5">4.NULL查询的列未被索引覆盖，并且where筛选条件是索引的前导列，意味着用到了索引，但是部分字段未被索引覆盖，必须通过“回表”来实现，</text><text id="kity_text_8677" text-rendering="inherit" font-size="12" dy=".8em" y="121.70000004768372" x="569.5">5.Using index condition与Using where类似，查询的列不完全被索引覆盖</text><text id="kity_text_8678" text-rendering="inherit" font-size="12" dy=".8em" y="139.70000004768372" x="569.5">6.Using temporarymysql需要创建一张临时表来处理查询，一般出现于排序, 分组和多表 join 的情况。出现这种情况一般是要进行优化的，首先是想到用索引来优化。</text><text id="kity_text_8679" text-rendering="inherit" font-size="12" dy=".8em" y="157.70000004768372" x="569.5">7.using filesort: 说明mysql会对数据使用一个外部的索引排序，不是按照表内的索引顺序进行读取。mysql中无法利用索引完成的排序操作称为“文件排序”。这种一般也是要优化的</text></g></g><g id="minder_node663" display="none"><g id="node_expander660" display="none" style="cursor: pointer;"><path id="kity_path_22502" fill="white" stroke="gray" d="M537.5,119.5A6,6,0,1,1,525.5,119.5A6,6,0,1,1,537.5,119.5"></path><path id="kity_path_22503" fill="none" stroke="gray"></path></g><path id="node_outline661" fill="none" stroke="none" d="M537.5,110.5h182a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-182a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text661" fill="black"><text id="kity_text_8692" text-rendering="inherit" font-size="12" dy=".8em" y="111.70000004768372" x="537.5">mysql怎么查看一条sql的执行时间</text></g></g><g id="minder_node664" display="none"><g id="node_expander659" display="none" style="cursor: pointer;"><path id="kity_path_22499" fill="white" stroke="gray" d="M553.5,119.5A6,6,0,1,1,541.5,119.5A6,6,0,1,1,553.5,119.5"></path><path id="kity_path_22500" fill="none" stroke="gray"></path></g><path id="node_outline660" fill="none" stroke="none" d="M553.5,65.5h932a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-932a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text660" fill="black"><text id="kity_text_8685" text-rendering="inherit" font-size="12" dy=".8em" y="66.70000004768372" x="553.5">1.</text><text id="kity_text_8686" text-rendering="inherit" font-size="12" dy=".8em" y="84.70000004768372" x="553.5">profiling 是否开启，set profiling=1;</text><text id="kity_text_8687" text-rendering="inherit" font-size="12" dy=".8em" y="102.70000004768372" x="553.5">查看执行时间show profiles;</text><text id="kity_text_8688" text-rendering="inherit" font-size="12" dy=".8em" y="120.70000004768372" x="553.5">查看具体某一条Sql执行时间show profile for query Query_ID</text><text id="kity_text_8689" text-rendering="inherit" font-size="12" dy=".8em" y="138.70000004768372" x="553.5">2.慢查询日志</text><text id="kity_text_8690" text-rendering="inherit" font-size="12" dy=".8em" y="156.70000004768372" x="553.5">开启慢查询日志，设置超时时间，再通过&#xa0;mysqldumpslow查看；语法为：得到访问次数最多的 10 个 SQL：mysqldumpslow -s c -t 10 /database/mysql/mysql06_slow.log</text></g></g><g id="minder_node665" display="none"><g id="node_expander665" display="none" style="cursor: pointer;"><path id="kity_path_22517" fill="white" stroke="gray" d="M521.5,127.5A6,6,0,1,1,509.5,127.5A6,6,0,1,1,521.5,127.5"></path><path id="kity_path_22518" fill="none" stroke="gray"></path></g><path id="node_outline666" fill="none" stroke="none" d="M521.5,118.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text666" fill="black"><text id="kity_text_8711" text-rendering="inherit" font-size="12" dy=".8em" y="119.70000004768372" x="521.5">优化实战</text></g></g><g id="minder_node666" display="none"><g id="node_expander664" display="none" style="cursor: pointer;"><path id="kity_path_22514" fill="white" stroke="gray" d="M537.5,127.5A6,6,0,1,1,525.5,127.5A6,6,0,1,1,537.5,127.5"></path><path id="kity_path_22515" fill="none" stroke="gray"></path></g><path id="node_outline665" fill="none" stroke="none" d="M537.5,118.5h143a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-143a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text665" fill="black"><text id="kity_text_8709" text-rendering="inherit" font-size="12" dy=".8em" y="119.70000004768372" x="537.5">1.你在项目中用过什么优化</text></g></g><g id="minder_node667" display="none"><g id="node_expander663" display="none" style="cursor: pointer;"><path id="kity_path_22511" fill="white" stroke="gray" d="M553.5,127.5A6,6,0,1,1,541.5,127.5A6,6,0,1,1,553.5,127.5"></path><path id="kity_path_22512" fill="none" stroke="gray"></path></g><path id="node_outline664" fill="none" stroke="none" d="M553.5,55.5h744a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-744a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text664" fill="black"><text id="kity_text_8700" text-rendering="inherit" font-size="12" dy=".8em" y="56.700000047683716" x="553.5">1.唯一索引改成普通索引，</text><text id="kity_text_8701" text-rendering="inherit" font-size="12" dy=".8em" y="74.70000004768372" x="553.5">主要是和数据页有更新，我们和磁盘之间的 存取数据都是先经过数据页，</text><text id="kity_text_8702" text-rendering="inherit" font-size="12" dy=".8em" y="92.70000004768372" x="553.5">2.对于查询来说 他们的效率是差不多的，唯一索引 是定位的第一个满足条件的就返回，普通索引是找到了 以后 还要找第一个不满足的就返回</text><text id="kity_text_8703" text-rendering="inherit" font-size="12" dy=".8em" y="110.70000004768372" x="553.5">3.区别主要是 更新操作 时，数据页 没有数据，需要去硬盘读，而唯一索引 需要将数据页读入内存 然后判断是否唯一，然后 做操作，</text><text id="kity_text_8704" text-rendering="inherit" font-size="12" dy=".8em" y="128.70000004768372" x="553.5">普通索引只是将更新记录保存在change buffer 语句执行就结束了，后续merge就行了，少了读取磁盘的一步</text><text id="kity_text_8705" text-rendering="inherit" font-size="12" dy=".8em" y="146.70000004768372" x="553.5">4.而merge就是把磁盘数据读取数据页到内存，然后把新的依次应用到原数据页 然后写redo log</text><text id="kity_text_8706" text-rendering="inherit" font-size="12" dy=".8em" y="164.70000004768372" x="553.5">5.如果数据更新比较多 就有普通索引，查询的话都可以</text><text id="kity_text_8707" text-rendering="inherit" font-size="12" dy=".8em" y="182.70000004768372" x="553.5">6.将数据从磁盘读入内存涉及随机IO的访问；如果能够将更新操作先记录在change buffer，减少读磁盘，语句的执行速度会得到明显的提升</text></g></g><g id="minder_node668" display="none"><g id="node_expander662" display="none" style="cursor: pointer;"><path id="kity_path_22508" fill="white" stroke="gray" d="M569.5,127.5A6,6,0,1,1,557.5,127.5A6,6,0,1,1,569.5,127.5"></path><path id="kity_path_22509" fill="none" stroke="gray"></path></g><path id="node_outline663" fill="none" stroke="none" d="M569.5,100.5h589a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-589a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text663" fill="black"><text id="kity_text_8696" text-rendering="inherit" font-size="12" dy=".8em" y="101.70000004768372" x="569.5">https://blog.csdn.net/xioayu96/article/details/107918407</text><text id="kity_text_8697" text-rendering="inherit" font-size="12" dy=".8em" y="119.70000004768372" x="569.5">https://blog.csdn.net/sayoko06/article/details/90258189</text><text id="kity_text_8698" text-rendering="inherit" font-size="12" dy=".8em" y="137.70000004768372" x="569.5">https://jeromememory.github.io/2020/07/29/%E7%A7%8B%E6%8B%9B%E7%BB%8F%E5%8E%86.html</text></g></g><g id="minder_node669" display="none"><g id="node_expander704" display="none" style="cursor: pointer;"><path id="kity_path_22634" fill="white" stroke="gray" d="M505.5,135.5A6,6,0,1,1,493.5,135.5A6,6,0,1,1,505.5,135.5"></path><path id="kity_path_22635" fill="none" stroke="gray"></path></g><path id="node_outline705" fill="none" stroke="none" d="M505.5,126.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text705" fill="black"><text id="kity_text_8847" text-rendering="inherit" font-size="12" dy=".8em" y="127.70000004768372" x="505.5">分库分表</text></g></g><g id="minder_node670" display="none"><g id="node_expander679" display="none" style="cursor: pointer;"><path id="kity_path_22559" fill="white" stroke="gray" d="M521.5,103.5A6,6,0,1,1,509.5,103.5A6,6,0,1,1,521.5,103.5"></path><path id="kity_path_22560" fill="none" stroke="gray"></path></g><path id="node_outline680" fill="none" stroke="none" d="M521.5,94.5h74a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-74a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text680" fill="black"><text id="kity_text_8769" text-rendering="inherit" font-size="12" dy=".8em" y="95.70000004768372" x="521.5">分库分表策略</text></g></g><g id="minder_node671" display="none"><g id="node_expander669" display="none" style="cursor: pointer;"><path id="kity_path_22529" fill="white" stroke="gray" d="M537.5,71.5A6,6,0,1,1,525.5,71.5A6,6,0,1,1,537.5,71.5"></path><path id="kity_path_22530" fill="none" stroke="gray"></path></g><path id="node_outline670" fill="none" stroke="none" d="M537.5,62.5h122a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-122a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text670" fill="black"><text id="kity_text_8726" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="537.5">说说分表的方式有什么</text></g></g><g id="minder_node672" display="none"><g id="node_expander668" display="none" style="cursor: pointer;"><path id="kity_path_22526" fill="white" stroke="gray" d="M553.5,71.5A6,6,0,1,1,541.5,71.5A6,6,0,1,1,553.5,71.5"></path><path id="kity_path_22527" fill="none" stroke="gray"></path></g><path id="node_outline669" fill="none" stroke="none" d="M553.5,-0.5h922a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-922a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text669" fill="black"><text id="kity_text_8717" text-rendering="inherit" font-size="12" dy=".8em" y="0.7000000476837158" x="553.5">1.分表的策略有水平分表和垂直分表，根据库内 还是分库可以说 库内分 还是分库分</text><text id="kity_text_8718" text-rendering="inherit" font-size="12" dy=".8em" y="18.700000047683716" x="553.5">垂直分表是基于数据库中的"列"进行，某个表字段较多，将不经常用或字段长度较大的字段拆分出去到扩展表中。每个表的字段至少有一列交集，一般是主键，用于关联数据；</text><text id="kity_text_8719" text-rendering="inherit" font-size="12" dy=".8em" y="36.700000047683716" x="553.5">"大表拆小表"，便于开发与维护，避免跨页，MySQL底层是通过数据页存储的，一条记录占用空间过大会导致跨页，造成额外的性能开销。</text><text id="kity_text_8720" text-rendering="inherit" font-size="12" dy=".8em" y="54.700000047683716" x="553.5">数据库以行为单位将数据加载到内存中，表中字段长度较短且访问频率较高，内存加载更多的数据，命中率更高，减少磁盘IO，提升性能。</text><text id="kity_text_8721" text-rendering="inherit" font-size="12" dy=".8em" y="72.70000004768372" x="553.5">水平分表</text><text id="kity_text_8722" text-rendering="inherit" font-size="12" dy=".8em" y="90.70000004768372" x="553.5">以字段为依据，按照一定规则策略，将一个表中的数据拆分到多个表中。每个库的数据都不一样，没有交集；表的并集是全量数据；</text><text id="kity_text_8723" text-rendering="inherit" font-size="12" dy=".8em" y="108.70000004768372" x="553.5">场景：系统绝对并发量并没有上来，只是单表的数据量太多，影响了SQL效率，加重了CPU负担，以至于成为瓶颈。</text><text id="kity_text_8724" text-rendering="inherit" font-size="12" dy=".8em" y="126.70000004768372" x="553.5">为什么：表的数据量少了，单次SQL执行效率高，自然减轻了CPU的负担。</text></g></g><g id="minder_node673" display="none"><g id="node_expander667" display="none" style="cursor: pointer;"><path id="kity_path_22523" fill="white" stroke="gray" d="M569.5,71.5A6,6,0,1,1,557.5,71.5A6,6,0,1,1,569.5,71.5"></path><path id="kity_path_22524" fill="none" stroke="gray"></path></g><path id="node_outline668" fill="none" stroke="none" d="M569.5,57.5h53a5,5,0,0,1,5,5v18a5,5,0,0,1,-5,5h-53a5,5,0,0,1,-5,-5v-18a5,5,0,0,1,5,-5z"></path><g id="node_text668" fill="black"><text id="kity_text_8715" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="569.5">参考</text></g><a id="kity_a_16892" xlink:href="https://www.modb.pro/db/37736" target="_blank" xlink:title="https://www.modb.pro/db/37736" style="cursor: pointer;"><path id="kity_path_16894" fill="rgba(255, 255, 255, 0)" stroke="none" d="M602.5,60.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16893" fill="#666" stroke="none" d="M617.114,76.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V70.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C612.766,67.571,614.168,66.5,615.836,66.5h1.278c2.116,0,3.834,1.716,3.834,3.834V72.89C620.948,75.008,619.23,76.724,617.114,76.724zM605.612,71.612c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S615.265,72.89,614.558,72.89H606.89C606.185,72.89,605.612,72.319,605.612,71.612zM603.056,70.334V72.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H604.334C602.216,76.724,600.5,75.008,600.5,72.89V70.334C600.5,68.216,602.216,66.5,604.334,66.5h1.278c1.667,0,3.071,1.071,3.599,2.556H604.334C603.629,69.056,603.056,69.627,603.056,70.334z"></path></a></g><g id="minder_node674" display="none"><g id="node_expander671" display="none" style="cursor: pointer;"><path id="kity_path_22535" fill="white" stroke="gray" d="M537.5,79.5A6,6,0,1,1,525.5,79.5A6,6,0,1,1,537.5,79.5"></path><path id="kity_path_22536" fill="none" stroke="gray"></path></g><path id="node_outline672" fill="none" stroke="none" d="M537.5,70.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text672" fill="black"><text id="kity_text_8735" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="537.5">说说分库的方式有哪些？</text></g></g><g id="minder_node675" display="none"><g id="node_expander670" display="none" style="cursor: pointer;"><path id="kity_path_22532" fill="white" stroke="gray" d="M553.5,79.5A6,6,0,1,1,541.5,79.5A6,6,0,1,1,553.5,79.5"></path><path id="kity_path_22533" fill="none" stroke="gray"></path></g><path id="node_outline671" fill="none" stroke="none" d="M553.5,25.5h961a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-961a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text671" fill="black"><text id="kity_text_8728" text-rendering="inherit" font-size="12" dy=".8em" y="26.700000047683716" x="553.5">1.分库和分表的策略大体是一样的。分表实质上还是在同一个库中操作的，要有真正的提升还是要从库上考虑。可以按业务分库</text><text id="kity_text_8729" text-rendering="inherit" font-size="12" dy=".8em" y="44.700000047683716" x="553.5">2.分库：一个库里表太多了，导致了海量数据，系统性能下降，把原本存储于一个库的表拆分存储到多个库上， 通常是将表按照功能模块、关系密切程度划分出来，部署到不同库上。</text><text id="kity_text_8730" text-rendering="inherit" font-size="12" dy=".8em" y="62.700000047683716" x="553.5">3.水平分：以字段为依据，和分表策略一样，将一个库中的数据拆分到多个库中。每个库的结构都一样；数据都不一样，没有交集；库的并集是全量数据；</text><text id="kity_text_8731" text-rendering="inherit" font-size="12" dy=".8em" y="80.70000004768372" x="553.5">场景：系统绝对并发量上来了，分表难以根本上解决问题，并且还没有明显的业务归属来垂直分库。库多了，io和cpu的压力自然可以成倍缓解。</text><text id="kity_text_8732" text-rendering="inherit" font-size="12" dy=".8em" y="98.70000004768372" x="553.5">4.垂直分：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。每个库的数据不一样，没有交集；所有库的并集是全量数据；</text><text id="kity_text_8733" text-rendering="inherit" font-size="12" dy=".8em" y="116.70000004768372" x="553.5">场景：系统绝对并发量上来了，并且可以抽象出单独的业务模块。</text></g></g><g id="minder_node676" display="none"><g id="node_expander674" display="none" style="cursor: pointer;"><path id="kity_path_22544" fill="white" stroke="gray" d="M537.5,87.5A6,6,0,1,1,525.5,87.5A6,6,0,1,1,537.5,87.5"></path><path id="kity_path_22545" fill="none" stroke="gray"></path></g><path id="node_outline675" fill="none" stroke="none" d="M537.5,78.5h195a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-195a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text675" fill="black"><text id="kity_text_8754" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="537.5">说说sharding的规则策略和优缺点？</text></g></g><g id="minder_node677" display="none"><g id="node_expander673" display="none" style="cursor: pointer;"><path id="kity_path_22541" fill="white" stroke="gray" d="M553.5,87.5A6,6,0,1,1,541.5,87.5A6,6,0,1,1,553.5,87.5"></path><path id="kity_path_22542" fill="none" stroke="gray"></path></g><path id="node_outline674" fill="none" stroke="none" d="M553.5,-38.5h1065a5,5,0,0,1,5,5v242a5,5,0,0,1,-5,5h-1065a5,5,0,0,1,-5,-5v-242a5,5,0,0,1,5,-5z"></path><g id="node_text674" fill="black"><text id="kity_text_8739" text-rendering="inherit" font-size="12" dy=".8em" y="-37.299999952316284" x="553.5">1.哈希取模：hash(key) % N；解决RANGE方式分表有IO瓶颈的问题，采用根据用户ID HASG取模的方式进行分库分表</text><text id="kity_text_8740" text-rendering="inherit" font-size="12" dy=".8em" y="-19.299999952316284" x="553.5">优点： 能保证数据较均匀的分散落在不同的库、表中，减轻了数据库压力</text><text id="kity_text_8741" text-rendering="inherit" font-size="12" dy=".8em" y="-1.2999999523162842" x="553.5">缺点： 扩容麻烦、迁移数据时每次都需要重新计算hash值分配到不同的库和表,容易面临跨分片查询的复杂问题。</text><text id="kity_text_8742" text-rendering="inherit" font-size="12" dy=".8em" y="16.700000047683716" x="553.5">如用到的查询条件中不带指定参数时，将会导致无法定位数据库，从而需要同时向多个库发起查询，再在内存中合并数据，取最小集返回给应用，分库反而成为拖累。</text><text id="kity_text_8743" text-rendering="inherit" font-size="12" dy=".8em" y="34.700000047683716" x="553.5">2.范围：可以是 ID 范围也可以是时间范围；</text><text id="kity_text_8744" text-rendering="inherit" font-size="12" dy=".8em" y="52.700000047683716" x="553.5">需要维护表的ID。</text><text id="kity_text_8745" text-rendering="inherit" font-size="12" dy=".8em" y="70.70000004768372" x="553.5">优点：扩容简单，单表大小可控，便于水平扩展，后期如果整个分片集群扩容时，只需要添加节点即可，无需对其他分片的数据进行迁移，提前建好库、表就好</text><text id="kity_text_8746" text-rendering="inherit" font-size="12" dy=".8em" y="88.70000004768372" x="553.5">缺点：大部分读和写都访会问新的数据，有IO瓶颈，这样子造成新库压力过大，不建议采用。</text><text id="kity_text_8747" text-rendering="inherit" font-size="12" dy=".8em" y="106.70000004768372" x="553.5">3.映射表：使用单独的一个数据库来存储映射关系。</text><text id="kity_text_8748" text-rendering="inherit" font-size="12" dy=".8em" y="124.70000004768372" x="553.5">4.一致性hash：按照常用的hash算法来将对应的key哈希到一个具有2^32次方个节点的空间中，可以将这些数字头尾相连成一个闭合的环形。</text><text id="kity_text_8749" text-rendering="inherit" font-size="12" dy=".8em" y="142.70000004768372" x="553.5">可以解决hash的扩容问题，如节点新增和删除问题。一致性hash需要解决数据平衡性问题，防止请求节点少时，某一个节点数据偏多。</text><text id="kity_text_8750" text-rendering="inherit" font-size="12" dy=".8em" y="160.70000004768372" x="553.5">利用虚拟节点解决，如node1,node2,可以引入node1-1,node1-2,node2-1,node2-2，一共是六个节点，但是实际上只有node1和node2是真正有数据，查询定位虚拟节点的都让指向各自的真实节点，</text><text id="kity_text_8751" text-rendering="inherit" font-size="12" dy=".8em" y="178.70000004768372" x="553.5">一致性HASH方法优点： 通过虚拟节点方式能保证数据较均匀的分散落在不同的库、表中，并且新增、删除节点不影响其他节点的数据，高可用、容灾性强。</text><text id="kity_text_8752" text-rendering="inherit" font-size="12" dy=".8em" y="196.70000004768372" x="553.5">一致性取模方法缺点： 比起以上两种，可以认为没有。</text></g></g><g id="minder_node678" display="none"><g id="node_expander672" display="none" style="cursor: pointer;"><path id="kity_path_22538" fill="white" stroke="gray" d="M569.5,87.5A6,6,0,1,1,557.5,87.5A6,6,0,1,1,569.5,87.5"></path><path id="kity_path_22539" fill="none" stroke="gray"></path></g><path id="node_outline673" fill="none" stroke="none" d="M496.5,-63.5h200a5,5,0,0,1,5,5v155a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-155a5,5,0,0,1,5,-5z"></path><g id="node_text673" fill="black"><text id="kity_text_8737" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="569.5">参考</text></g><a id="kity_a_16895" xlink:href="https://juejin.cn/post/6923898244304994317#comment" target="_blank" xlink:title="https://juejin.cn/post/6923898244304994317#comment" style="cursor: pointer;"><path id="kity_path_16897" fill="rgba(255, 255, 255, 0)" stroke="none" d="M602.5,76.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16896" fill="#666" stroke="none" d="M617.114,92.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V86.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C612.766,83.571,614.168,82.5,615.836,82.5h1.278c2.116,0,3.834,1.716,3.834,3.834V88.89C620.948,91.008,619.23,92.724,617.114,92.724zM605.612,87.612c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S615.265,88.89,614.558,88.89H606.89C606.185,88.89,605.612,88.319,605.612,87.612zM603.056,86.334V88.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H604.334C602.216,92.724,600.5,91.008,600.5,88.89V86.334C600.5,84.216,602.216,82.5,604.334,82.5h1.278c1.667,0,3.071,1.071,3.599,2.556H604.334C603.629,85.056,603.056,85.627,603.056,86.334z"></path></a><image id="kity_image_17037" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210320171717.png" x="496.5" y="-60.5" width="200" height="132" xlink:title="hash"></image></g><g id="minder_node679" display="none"><g id="node_expander676" display="none" style="cursor: pointer;"><path id="kity_path_22550" fill="white" stroke="gray" d="M537.5,95.5A6,6,0,1,1,525.5,95.5A6,6,0,1,1,537.5,95.5"></path><path id="kity_path_22551" fill="none" stroke="gray"></path></g><path id="node_outline677" fill="none" stroke="none" d="M537.5,86.5h184a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-184a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text677" fill="black"><text id="kity_text_8758" text-rendering="inherit" font-size="12" dy=".8em" y="87.70000004768372" x="537.5">&#xa0;分库分表是以什么维度来划分的？</text></g></g><g id="minder_node680" display="none"><g id="node_expander675" display="none" style="cursor: pointer;"><path id="kity_path_22547" fill="white" stroke="gray" d="M553.5,95.5A6,6,0,1,1,541.5,95.5A6,6,0,1,1,553.5,95.5"></path><path id="kity_path_22548" fill="none" stroke="gray"></path></g><path id="node_outline676" fill="none" stroke="none" d="M553.5,86.5h214a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-214a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text676" fill="black"><text id="kity_text_8756" text-rendering="inherit" font-size="12" dy=".8em" y="87.70000004768372" x="553.5">1.水平分和垂直分。根据实际情况来分。</text></g></g><g id="minder_node681" display="none"><g id="node_expander678" display="none" style="cursor: pointer;"><path id="kity_path_22556" fill="white" stroke="gray" d="M537.5,103.5A6,6,0,1,1,525.5,103.5A6,6,0,1,1,537.5,103.5"></path><path id="kity_path_22557" fill="none" stroke="gray"></path></g><path id="node_outline679" fill="none" stroke="none" d="M537.5,94.5h289a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-289a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text679" fill="black"><text id="kity_text_8767" text-rendering="inherit" font-size="12" dy=".8em" y="95.70000004768372" x="537.5">数据量多大你觉得需要分库分表？为什么要分库分表？</text></g></g><g id="minder_node682" display="none"><g id="node_expander677" display="none" style="cursor: pointer;"><path id="kity_path_22553" fill="white" stroke="gray" d="M553.5,103.5A6,6,0,1,1,541.5,103.5A6,6,0,1,1,553.5,103.5"></path><path id="kity_path_22554" fill="none" stroke="gray"></path></g><path id="node_outline678" fill="none" stroke="none" d="M553.5,49.5h963a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-963a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text678" fill="black"><text id="kity_text_8760" text-rendering="inherit" font-size="12" dy=".8em" y="50.700000047683716" x="553.5">1.500-1000万，没有明确的数字。</text><text id="kity_text_8761" text-rendering="inherit" font-size="12" dy=".8em" y="68.70000004768372" x="553.5">2.虽然说分库分表，但是能不切分尽量不要切分，</text><text id="kity_text_8762" text-rendering="inherit" font-size="12" dy=".8em" y="86.70000004768372" x="553.5">(1)当数据量达到单表的瓶颈时候，再考虑分库分表。(2)数据量过大，正常运维影响业务访问(3)随着业务发展，需要对某些字段垂直拆分</text><text id="kity_text_8763" text-rendering="inherit" font-size="12" dy=".8em" y="104.70000004768372" x="553.5">(4)数据量快速增长,单表中的数据量会持续增长，当性能接近瓶颈时，就需要考虑水平切分，做分库分表了。要提前预估好数据容量</text><text id="kity_text_8764" text-rendering="inherit" font-size="12" dy=".8em" y="122.70000004768372" x="553.5">(5)安全性和可用性。在业务层面上垂直切分。避免服务之间互相影响。利用水平切分，当一个数据库出现问题时，不会影响全部用户，每个库只承担业务的一部分数据，提高可用性。</text><text id="kity_text_8765" text-rendering="inherit" font-size="12" dy=".8em" y="140.70000004768372" x="553.5"> </text></g></g><g id="minder_node683" display="none"><g id="node_expander684" display="none" style="cursor: pointer;"><path id="kity_path_22574" fill="white" stroke="gray" d="M521.5,111.5A6,6,0,1,1,509.5,111.5A6,6,0,1,1,521.5,111.5"></path><path id="kity_path_22575" fill="none" stroke="gray"></path></g><path id="node_outline685" fill="none" stroke="none" d="M521.5,102.5h75a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-75a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text685" fill="black"><text id="kity_text_8794" text-rendering="inherit" font-size="12" dy=".8em" y="103.70000004768372" x="521.5">sharding问题</text></g></g><g id="minder_node684" display="none"><g id="node_expander681" display="none" style="cursor: pointer;"><path id="kity_path_22565" fill="white" stroke="gray" d="M537.5,103.5A6,6,0,1,1,525.5,103.5A6,6,0,1,1,537.5,103.5"></path><path id="kity_path_22566" fill="none" stroke="gray"></path></g><path id="node_outline682" fill="none" stroke="none" d="M537.5,94.5h119a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-119a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text682" fill="black"><text id="kity_text_8788" text-rendering="inherit" font-size="12" dy=".8em" y="95.70000004768372" x="537.5">shrandnig有哪些问题</text></g></g><g id="minder_node685" display="none"><g id="node_expander680" display="none" style="cursor: pointer;"><path id="kity_path_22562" fill="white" stroke="gray" d="M553.5,103.5A6,6,0,1,1,541.5,103.5A6,6,0,1,1,553.5,103.5"></path><path id="kity_path_22563" fill="none" stroke="gray"></path></g><path id="node_outline681" fill="none" stroke="none" d="M553.5,-40.5h1314a5,5,0,0,1,5,5v278a5,5,0,0,1,-5,5h-1314a5,5,0,0,1,-5,-5v-278a5,5,0,0,1,5,-5z"></path><g id="node_text681" fill="black"><text id="kity_text_8771" text-rendering="inherit" font-size="12" dy=".8em" y="-39.299999952316284" x="553.5">1.分布式事务问题，对强一致性的可以用TCC和XA协议，弱一致性用最终一致性。可以做事务补偿，通过记录日志+和数据对帐 ，还有做数据同步。事务补偿还要结合业务系统来考虑。</text><text id="kity_text_8772" text-rendering="inherit" font-size="12" dy=".8em" y="-21.299999952316284" x="553.5">2.跨库Join问题</text><text id="kity_text_8773" text-rendering="inherit" font-size="12" dy=".8em" y="-3.299999952316284" x="553.5">(1)全局表，也可看做是"数据字典表"，就是系统中所有模块都可能依赖的一些表，为了避免跨库join查询，可以将这类表在每个数据库中都保存一份。这些数据通常很少会进行修改，所以也不担心一致性的问题。</text><text id="kity_text_8774" text-rendering="inherit" font-size="12" dy=".8em" y="14.700000047683716" x="553.5">(2)一种典型的反范式设计，利用空间换时间，为了性能而避免join查询。但是需要考虑数据同步</text><text id="kity_text_8775" text-rendering="inherit" font-size="12" dy=".8em" y="32.700000047683716" x="553.5">(3)在系统层面，分两次查询，第一次查询的结果集中找出关联数据id，然后根据id发起第二次请求得到关联数据。最后将获得到的数据进行字段拼装。</text><text id="kity_text_8776" text-rendering="inherit" font-size="12" dy=".8em" y="50.700000047683716" x="553.5">3.跨节点分页、排序、函数问题</text><text id="kity_text_8777" text-rendering="inherit" font-size="12" dy=".8em" y="68.70000004768372" x="553.5">与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。</text><text id="kity_text_8778" text-rendering="inherit" font-size="12" dy=".8em" y="86.70000004768372" x="553.5">4.全局主键避重问题</text><text id="kity_text_8779" text-rendering="inherit" font-size="12" dy=".8em" y="104.70000004768372" x="553.5">(1)UUID(2)结合数据库维护主键ID表</text><text id="kity_text_8780" text-rendering="inherit" font-size="12" dy=".8em" y="122.70000004768372" x="553.5">(3)Snowflake分布式自增ID算法 优点：毫秒数在高位，生成的ID整体上按时间趋势递增；不依赖第三方系统，稳定性和效率较高，理论上QPS约为409.6w/s（1000*2^12），并且整个分布式系统内不会产生ID碰撞；可根据自身业务灵活分配bit位。</text><text id="kity_text_8781" text-rendering="inherit" font-size="12" dy=".8em" y="140.70000004768372" x="553.5">缺点：强依赖机器时钟，如果时钟回拨，则可能导致生成ID重复。</text><text id="kity_text_8782" text-rendering="inherit" font-size="12" dy=".8em" y="158.70000004768372" x="553.5">(4)Leaf——美团点评分布式ID生成系统 https://tech.meituan.com/2017/04/21/mt-leaf.html</text><text id="kity_text_8783" text-rendering="inherit" font-size="12" dy=".8em" y="176.70000004768372" x="553.5">5.数据迁移、扩容问题</text><text id="kity_text_8784" text-rendering="inherit" font-size="12" dy=".8em" y="194.70000004768372" x="553.5">如果采用数值范围分片，只需要添加节点就可以进行扩容了，不需要对分片数据迁移。</text><text id="kity_text_8785" text-rendering="inherit" font-size="12" dy=".8em" y="212.70000004768372" x="553.5">如果采用的是数值取模分片，则考虑后期的扩容问题就相对比较麻烦。</text><text id="kity_text_8786" text-rendering="inherit" font-size="12" dy=".8em" y="230.70000004768372" x="553.5"> </text></g></g><g id="minder_node686" display="none"><g id="node_expander683" display="none" style="cursor: pointer;"><path id="kity_path_22571" fill="white" stroke="gray" d="M537.5,111.5A6,6,0,1,1,525.5,111.5A6,6,0,1,1,537.5,111.5"></path><path id="kity_path_22572" fill="none" stroke="gray"></path></g><path id="node_outline684" fill="none" stroke="none" d="M537.5,102.5h181a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-181a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text684" fill="black"><text id="kity_text_8792" text-rendering="inherit" font-size="12" dy=".8em" y="103.70000004768372" x="537.5">分库分表以后怎么保证id全局唯一</text></g></g><g id="minder_node687" display="none"><g id="node_expander682" display="none" style="cursor: pointer;"><path id="kity_path_22568" fill="white" stroke="gray" d="M553.5,111.5A6,6,0,1,1,541.5,111.5A6,6,0,1,1,553.5,111.5"></path><path id="kity_path_22569" fill="none" stroke="gray"></path></g><path id="node_outline683" fill="none" stroke="none" d="M553.5,102.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text683" fill="black"><text id="kity_text_8790" text-rendering="inherit" font-size="12" dy=".8em" y="103.70000004768372" x="553.5">和上一样</text></g></g><g id="minder_node688" display="none"><g id="node_expander687" display="none" style="cursor: pointer;"><path id="kity_path_22583" fill="white" stroke="gray" d="M521.5,119.5A6,6,0,1,1,509.5,119.5A6,6,0,1,1,521.5,119.5"></path><path id="kity_path_22584" fill="none" stroke="gray"></path></g><path id="node_outline688" fill="none" stroke="none" d="M521.5,110.5h98a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-98a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text688" fill="black"><text id="kity_text_8800" text-rendering="inherit" font-size="12" dy=".8em" y="111.70000004768372" x="521.5">sharding设计方面</text></g></g><g id="minder_node689" display="none"><g id="node_expander686" display="none" style="cursor: pointer;"><path id="kity_path_22580" fill="white" stroke="gray" d="M537.5,119.5A6,6,0,1,1,525.5,119.5A6,6,0,1,1,537.5,119.5"></path><path id="kity_path_22581" fill="none" stroke="gray"></path></g><path id="node_outline687" fill="none" stroke="none" d="M537.5,110.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text687" fill="black"><text id="kity_text_8798" text-rendering="inherit" font-size="12" dy=".8em" y="111.70000004768372" x="537.5">分库分表为什么这么设计？</text></g></g><g id="minder_node690" display="none"><g id="node_expander685" display="none" style="cursor: pointer;"><path id="kity_path_22577" fill="white" stroke="gray" d="M553.5,119.5A6,6,0,1,1,541.5,119.5A6,6,0,1,1,553.5,119.5"></path><path id="kity_path_22578" fill="none" stroke="gray"></path></g><path id="node_outline686" fill="none" stroke="none" d="M553.5,110.5h98a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-98a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text686" fill="black"><text id="kity_text_8796" text-rendering="inherit" font-size="12" dy=".8em" y="111.70000004768372" x="553.5">结合项目场景吹牛</text></g></g><g id="minder_node691" display="none"><g id="node_expander702" display="none" style="cursor: pointer;"><path id="kity_path_22628" fill="white" stroke="gray" d="M521.5,127.5A6,6,0,1,1,509.5,127.5A6,6,0,1,1,521.5,127.5"></path><path id="kity_path_22629" fill="none" stroke="gray"></path></g><path id="node_outline703" fill="none" stroke="none" d="M521.5,118.5h98a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-98a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text703" fill="black"><text id="kity_text_8843" text-rendering="inherit" font-size="12" dy=".8em" y="119.70000004768372" x="521.5">sharding实际场景</text></g></g><g id="minder_node692" display="none"><g id="node_expander689" display="none" style="cursor: pointer;"><path id="kity_path_22589" fill="white" stroke="gray" d="M537.5,55.5A6,6,0,1,1,525.5,55.5A6,6,0,1,1,537.5,55.5"></path><path id="kity_path_22590" fill="none" stroke="gray"></path></g><path id="node_outline690" fill="none" stroke="none" d="M537.5,46.5h331a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-331a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text690" fill="black"><text id="kity_text_8804" text-rendering="inherit" font-size="12" dy=".8em" y="47.700000047683716" x="537.5">sharding之后的数据查询怎么做， 比如说我要查询最近的订单</text></g></g><g id="minder_node693" display="none"><g id="node_expander688" display="none" style="cursor: pointer;"><path id="kity_path_22586" fill="white" stroke="gray" d="M553.5,55.5A6,6,0,1,1,541.5,55.5A6,6,0,1,1,553.5,55.5"></path><path id="kity_path_22587" fill="none" stroke="gray"></path></g><path id="node_outline689" fill="none" stroke="none" d="M553.5,46.5h219a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-219a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text689" fill="black"><text id="kity_text_8802" text-rendering="inherit" font-size="12" dy=".8em" y="47.700000047683716" x="553.5">和上面sharding的问题一样结合项目场景</text></g></g><g id="minder_node694" display="none"><g id="node_expander691" display="none" style="cursor: pointer;"><path id="kity_path_22595" fill="white" stroke="gray" d="M537.5,63.5A6,6,0,1,1,525.5,63.5A6,6,0,1,1,537.5,63.5"></path><path id="kity_path_22596" fill="none" stroke="gray"></path></g><path id="node_outline692" fill="none" stroke="none" d="M537.5,54.5h146a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-146a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text692" fill="black"><text id="kity_text_8816" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="537.5">sharding具体实施怎么做？</text></g></g><g id="minder_node695" display="none"><g id="node_expander690" display="none" style="cursor: pointer;"><path id="kity_path_22592" fill="white" stroke="gray" d="M553.5,63.5A6,6,0,1,1,541.5,63.5A6,6,0,1,1,553.5,63.5"></path><path id="kity_path_22593" fill="none" stroke="gray"></path></g><path id="node_outline691" fill="none" stroke="none" d="M553.5,-17.5h541a5,5,0,0,1,5,5v152a5,5,0,0,1,-5,5h-541a5,5,0,0,1,-5,-5v-152a5,5,0,0,1,5,-5z"></path><g id="node_text691" fill="black"><text id="kity_text_8806" text-rendering="inherit" font-size="12" dy=".8em" y="-16.299999952316284" x="553.5">1.数据库双写（事务成功以老模型为准），查询走老模型</text><text id="kity_text_8807" text-rendering="inherit" font-size="12" dy=".8em" y="1.7000000476837158" x="553.5">每日job数据对账（通过DW），并将差异补平</text><text id="kity_text_8808" text-rendering="inherit" font-size="12" dy=".8em" y="19.700000047683716" x="553.5">通过job导历史数据</text><text id="kity_text_8809" text-rendering="inherit" font-size="12" dy=".8em" y="37.700000047683716" x="553.5">2.历史数据导入完毕并且数据对账无误</text><text id="kity_text_8810" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="553.5">依然是数据库双写，但是事务成功与否以新模型为准，在线查询切换新模型</text><text id="kity_text_8811" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="553.5">每日job数据对账，将差异补平</text><text id="kity_text_8812" text-rendering="inherit" font-size="12" dy=".8em" y="91.70000004768372" x="553.5">3.老模型不同步写入，仅当订单有终态时才会异步补上。</text><text id="kity_text_8813" text-rendering="inherit" font-size="12" dy=".8em" y="109.70000004768372" x="553.5">此阶段只有离线数据依然依赖老的模型，并且下游的依赖非常多，待改造完就可以完全废除老模型了。</text><text id="kity_text_8814" text-rendering="inherit" font-size="12" dy=".8em" y="127.70000004768372" x="553.5">还有其他的方法，如停机迁移，通过消费信息来迁移，通过mq的订阅模式来迁移</text></g></g><g id="minder_node696" display="none"><g id="node_expander692" display="none" style="cursor: pointer;"><path id="kity_path_22598" fill="white" stroke="gray" d="M537.5,71.5A6,6,0,1,1,525.5,71.5A6,6,0,1,1,537.5,71.5"></path><path id="kity_path_22599" fill="none" stroke="gray"></path></g><path id="node_outline693" fill="none" stroke="none" d="M537.5,62.5h97a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-97a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text693" fill="black"><text id="kity_text_8818" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="537.5">数据增长怎么做？</text></g></g><g id="minder_node697" display="none"><g id="node_expander694" display="none" style="cursor: pointer;"><path id="kity_path_22604" fill="white" stroke="gray" d="M537.5,79.5A6,6,0,1,1,525.5,79.5A6,6,0,1,1,537.5,79.5"></path><path id="kity_path_22605" fill="none" stroke="gray"></path></g><path id="node_outline695" fill="none" stroke="none" d="M537.5,70.5h97a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-97a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text695" fill="black"><text id="kity_text_8827" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="537.5">跨库分页怎么做？</text></g></g><g id="minder_node698" display="none"><g id="node_expander693" display="none" style="cursor: pointer;"><path id="kity_path_22601" fill="white" stroke="gray" d="M553.5,79.5A6,6,0,1,1,541.5,79.5A6,6,0,1,1,553.5,79.5"></path><path id="kity_path_22602" fill="none" stroke="gray"></path></g><path id="node_outline694" fill="none" stroke="none" d="M553.5,25.5h709a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-709a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text694" fill="black"><text id="kity_text_8820" text-rendering="inherit" font-size="12" dy=".8em" y="26.700000047683716" x="553.5">1.全局视野法:就是例如要查询第三页的数据，那么把每个库里面前三页的数据都查询出来，然后排序，</text><text id="kity_text_8821" text-rendering="inherit" font-size="12" dy=".8em" y="44.700000047683716" x="553.5">2.最大时间法:禁止跳页查询，就是如果业务不需要跳页查询的话，一开始查第一页的时候，从每个库取一页数据回来进行排序后返回。</text><text id="kity_text_8822" text-rendering="inherit" font-size="12" dy=".8em" y="62.700000047683716" x="553.5">3.Zset记录法:像百度贴吧，假设一个贴吧里面允许跳页查询的页数为前100页，每页为20个，，每次顶贴都会把贴子顶到最前面，</text><text id="kity_text_8823" text-rendering="inherit" font-size="12" dy=".8em" y="80.70000004768372" x="553.5">那么可以使用一个Zset来存储最近的2000个帖子的基本信息(id,标题，图片，等足够贴吧列表页展示的信息)，</text><text id="kity_text_8824" text-rendering="inherit" font-size="12" dy=".8em" y="98.70000004768372" x="553.5">每个帖子的score就是最近更新时间，帖子在Zset中按照更新时间排序。然后每次顶贴都来维护这个Zset就可以了。</text><text id="kity_text_8825" text-rendering="inherit" font-size="12" dy=".8em" y="116.70000004768372" x="553.5">4.二次查询法</text></g></g><g id="minder_node699" display="none"><g id="node_expander695" display="none" style="cursor: pointer;"><path id="kity_path_22607" fill="white" stroke="gray" d="M537.5,87.5A6,6,0,1,1,525.5,87.5A6,6,0,1,1,537.5,87.5"></path><path id="kity_path_22608" fill="none" stroke="gray"></path></g><path id="node_outline696" fill="none" stroke="none" d="M537.5,78.5h169a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-169a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text696" fill="black"><text id="kity_text_8829" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="537.5">跨库聚合怎么做，查询怎么做？</text></g></g><g id="minder_node700" display="none"><g id="node_expander696" display="none" style="cursor: pointer;"><path id="kity_path_22610" fill="white" stroke="gray" d="M537.5,95.5A6,6,0,1,1,525.5,95.5A6,6,0,1,1,537.5,95.5"></path><path id="kity_path_22611" fill="none" stroke="gray"></path></g><path id="node_outline697" fill="none" stroke="none" d="M537.5,86.5h61a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-61a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text697" fill="black"><text id="kity_text_8831" text-rendering="inherit" font-size="12" dy=".8em" y="87.70000004768372" x="537.5">怎么扩容？</text></g></g><g id="minder_node701" display="none"><g id="node_expander697" display="none" style="cursor: pointer;"><path id="kity_path_22613" fill="white" stroke="gray" d="M537.5,103.5A6,6,0,1,1,525.5,103.5A6,6,0,1,1,537.5,103.5"></path><path id="kity_path_22614" fill="none" stroke="gray"></path></g><path id="node_outline698" fill="none" stroke="none" d="M537.5,94.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text698" fill="black"><text id="kity_text_8833" text-rendering="inherit" font-size="12" dy=".8em" y="95.70000004768372" x="537.5">数据不均匀怎么办？</text></g></g><g id="minder_node702" display="none"><g id="node_expander698" display="none" style="cursor: pointer;"><path id="kity_path_22616" fill="white" stroke="gray" d="M537.5,111.5A6,6,0,1,1,525.5,111.5A6,6,0,1,1,537.5,111.5"></path><path id="kity_path_22617" fill="none" stroke="gray"></path></g><path id="node_outline699" fill="none" stroke="none" d="M537.5,102.5h313a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-313a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text699" fill="black"><text id="kity_text_8835" text-rendering="inherit" font-size="12" dy=".8em" y="103.70000004768372" x="537.5">划分的算法是怎样的，会不会出现数据分配不均衡的情况。</text></g></g><g id="minder_node703" display="none"><g id="node_expander699" display="none" style="cursor: pointer;"><path id="kity_path_22619" fill="white" stroke="gray" d="M537.5,119.5A6,6,0,1,1,525.5,119.5A6,6,0,1,1,537.5,119.5"></path><path id="kity_path_22620" fill="none" stroke="gray"></path></g><path id="node_outline700" fill="none" stroke="none" d="M537.5,110.5h361a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-361a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text700" fill="black"><text id="kity_text_8837" text-rendering="inherit" font-size="12" dy=".8em" y="111.70000004768372" x="537.5">不停机扩容？分表避免冷热？不停机扩库？不停机扩表？跨库事务？</text></g></g><g id="minder_node704" display="none"><g id="node_expander701" display="none" style="cursor: pointer;"><path id="kity_path_22625" fill="white" stroke="gray" d="M537.5,127.5A6,6,0,1,1,525.5,127.5A6,6,0,1,1,537.5,127.5"></path><path id="kity_path_22626" fill="none" stroke="gray"></path></g><path id="node_outline702" fill="none" stroke="none" d="M537.5,118.5h97a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-97a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text702" fill="black"><text id="kity_text_8841" text-rendering="inherit" font-size="12" dy=".8em" y="119.70000004768372" x="537.5">用过怎么中间件吗</text></g></g><g id="minder_node705" display="none"><g id="node_expander700" display="none" style="cursor: pointer;"><path id="kity_path_22622" fill="white" stroke="gray" d="M553.5,127.5A6,6,0,1,1,541.5,127.5A6,6,0,1,1,553.5,127.5"></path><path id="kity_path_22623" fill="none" stroke="gray"></path></g><path id="node_outline701" fill="none" stroke="none" d="M553.5,118.5h288a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-288a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text701" fill="black"><text id="kity_text_8839" text-rendering="inherit" font-size="12" dy=".8em" y="119.70000004768372" x="553.5">用过mycat和360的atlas，阿里云的RDS分库分表方案</text></g></g><g id="minder_node706" display="none"><g id="node_expander703" display="none" style="cursor: pointer;"><path id="kity_path_22631" fill="white" stroke="gray" d="M521.5,135.5A6,6,0,1,1,509.5,135.5A6,6,0,1,1,521.5,135.5"></path><path id="kity_path_22632" fill="none" stroke="gray"></path></g><path id="node_outline704" fill="none" stroke="none" d="M521.5,126.5h108a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-108a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text704" fill="black"><text id="kity_text_8845" text-rendering="inherit" font-size="12" dy=".8em" y="127.70000004768372" x="521.5">冷热数据怎么分离？</text></g></g><g id="minder_node707" display="none"><g id="node_expander729" display="none" style="cursor: pointer;"><path id="kity_path_22709" fill="white" stroke="gray" d="M505.5,143.5A6,6,0,1,1,493.5,143.5A6,6,0,1,1,505.5,143.5"></path><path id="kity_path_22710" fill="none" stroke="gray"></path></g><path id="node_outline730" fill="none" stroke="none" d="M505.5,134.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text730" fill="black"><text id="kity_text_8952" text-rendering="inherit" font-size="12" dy=".8em" y="135.70000004768372" x="505.5">主从</text></g></g><g id="minder_node708" display="none"><g id="node_expander706" display="none" style="cursor: pointer;"><path id="kity_path_22640" fill="white" stroke="gray" d="M521.5,63.5A6,6,0,1,1,509.5,63.5A6,6,0,1,1,521.5,63.5"></path><path id="kity_path_22641" fill="none" stroke="gray"></path></g><path id="node_outline707" fill="none" stroke="none" d="M521.5,54.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text707" fill="black"><text id="kity_text_8852" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="521.5">知道主从复制吗</text></g></g><g id="minder_node709" display="none"><g id="node_expander705" display="none" style="cursor: pointer;"><path id="kity_path_22637" fill="white" stroke="gray" d="M537.5,63.5A6,6,0,1,1,525.5,63.5A6,6,0,1,1,537.5,63.5"></path><path id="kity_path_22638" fill="none" stroke="gray"></path></g><path id="node_outline706" fill="none" stroke="none" d="M537.5,45.5h935a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-935a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text706" fill="black"><text id="kity_text_8849" text-rendering="inherit" font-size="12" dy=".8em" y="46.700000047683716" x="537.5">1.知道。是将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</text><text id="kity_text_8850" text-rendering="inherit" font-size="12" dy=".8em" y="64.70000004768372" x="537.5">2.一般是主写从读，一主多从</text></g></g><g id="minder_node710" display="none"><g id="node_expander708" display="none" style="cursor: pointer;"><path id="kity_path_22646" fill="white" stroke="gray" d="M521.5,71.5A6,6,0,1,1,509.5,71.5A6,6,0,1,1,521.5,71.5"></path><path id="kity_path_22647" fill="none" stroke="gray"></path></g><path id="node_outline709" fill="none" stroke="none" d="M521.5,62.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text709" fill="black"><text id="kity_text_8858" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="521.5">知道主从复制的作用吗</text></g></g><g id="minder_node711" display="none"><g id="node_expander707" display="none" style="cursor: pointer;"><path id="kity_path_22643" fill="white" stroke="gray" d="M537.5,71.5A6,6,0,1,1,525.5,71.5A6,6,0,1,1,537.5,71.5"></path><path id="kity_path_22644" fill="none" stroke="gray"></path></g><path id="node_outline708" fill="none" stroke="none" d="M537.5,44.5h832a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-832a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text708" fill="black"><text id="kity_text_8854" text-rendering="inherit" font-size="12" dy=".8em" y="45.700000047683716" x="537.5">1.做数据的热备2.实时灾备，用于故障切换</text><text id="kity_text_8855" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="537.5">3.降低主库磁盘I/O访问的频率，提高单个机器的I/O性能</text><text id="kity_text_8856" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="537.5">4.防止sql语句需要锁表，导致暂时不能使用读的服务，影响运行中的业务，使用主从复制即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作</text></g></g><g id="minder_node712" display="none"><g id="node_expander710" display="none" style="cursor: pointer;"><path id="kity_path_22652" fill="white" stroke="gray" d="M521.5,79.5A6,6,0,1,1,509.5,79.5A6,6,0,1,1,521.5,79.5"></path><path id="kity_path_22653" fill="none" stroke="gray"></path></g><path id="node_outline711" fill="none" stroke="none" d="M521.5,70.5h120a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-120a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text711" fill="black"><text id="kity_text_8864" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="521.5">主从复制的两种格式？</text></g></g><g id="minder_node713" display="none"><g id="node_expander709" display="none" style="cursor: pointer;"><path id="kity_path_22649" fill="white" stroke="gray" d="M537.5,79.5A6,6,0,1,1,525.5,79.5A6,6,0,1,1,537.5,79.5"></path><path id="kity_path_22650" fill="none" stroke="gray"></path></g><path id="node_outline710" fill="none" stroke="none" d="M537.5,52.5h740a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-740a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text710" fill="black"><text id="kity_text_8860" text-rendering="inherit" font-size="12" dy=".8em" y="53.700000047683716" x="537.5">1.语句：传输效率高，减少延迟；一条sql更新了大量数据，基于语句的复制仅需要发送一条sql，而基于行的复制需要发送一百万条更新记录</text><text id="kity_text_8861" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="537.5">2.行：不需要执行查询计划。数据更新记录直接执行，不管你执行的是什么，可能因为延迟而失败，可以发现延迟；</text><text id="kity_text_8862" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="537.5">3.mysql两种模式动态切换</text></g></g><g id="minder_node714" display="none"><g id="node_expander712" display="none" style="cursor: pointer;"><path id="kity_path_22658" fill="white" stroke="gray" d="M521.5,87.5A6,6,0,1,1,509.5,87.5A6,6,0,1,1,521.5,87.5"></path><path id="kity_path_22659" fill="none" stroke="gray"></path></g><path id="node_outline713" fill="none" stroke="none" d="M521.5,78.5h216a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-216a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text713" fill="black"><text id="kity_text_8881" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="521.5">主从不一致为什么？怎么办？如何避免？</text></g></g><g id="minder_node715" display="none"><g id="node_expander711" display="none" style="cursor: pointer;"><path id="kity_path_22655" fill="white" stroke="gray" d="M537.5,87.5A6,6,0,1,1,525.5,87.5A6,6,0,1,1,537.5,87.5"></path><path id="kity_path_22656" fill="none" stroke="gray"></path></g><path id="node_outline712" fill="none" stroke="none" d="M537.5,-38.5h933a5,5,0,0,1,5,5v242a5,5,0,0,1,-5,5h-933a5,5,0,0,1,-5,-5v-242a5,5,0,0,1,5,-5z"></path><g id="node_text712" fill="black"><text id="kity_text_8866" text-rendering="inherit" font-size="12" dy=".8em" y="-37.299999952316284" x="537.5">原因：</text><text id="kity_text_8867" text-rendering="inherit" font-size="12" dy=".8em" y="-19.299999952316284" x="537.5">1.binlog非row格式 ，同步到从库执行后可能造成主从不一致。2.主从复制过程中，主库或从库意外宕机，宕机可能会造成binlog或者relaylog文件出现损坏，导致主从不一致。</text><text id="kity_text_8868" text-rendering="inherit" font-size="12" dy=".8em" y="-1.2999999523162842" x="537.5">3.从库启用了诸如存储过程，从库禁用存储过程等。4.配置文件信息有错误 5.MySQL自增列 主从不一致。6.从库中断很久，binlog应用不连续，</text><text id="kity_text_8869" text-rendering="inherit" font-size="12" dy=".8em" y="16.700000047683716" x="537.5">解决：</text><text id="kity_text_8870" text-rendering="inherit" font-size="12" dy=".8em" y="34.700000047683716" x="537.5">1.set sql_log_bin=0。先停掉主从复制，然后手动在从库执行下这个脚本，最后开启主从复制即可。</text><text id="kity_text_8871" text-rendering="inherit" font-size="12" dy=".8em" y="52.700000047683716" x="537.5">2.可能你的从库并未设置只读</text><text id="kity_text_8872" text-rendering="inherit" font-size="12" dy=".8em" y="70.70000004768372" x="537.5">3.主从两个实例已经运行很久了，某日进行一致性检验发现主从不一致了，&#xa0;</text><text id="kity_text_8873" text-rendering="inherit" font-size="12" dy=".8em" y="88.70000004768372" x="537.5">解决办法是 ：(1)使用percona-toolkit工具辅助。（https://www.cnblogs.com/feiren/p/7777218.html）</text><text id="kity_text_8874" text-rendering="inherit" font-size="12" dy=".8em" y="106.70000004768372" x="537.5">(2)从库停止Slave复制。在主库上dump这三张表，并记录下同步的binlog和POS点。查看dump下的xxx.sql文件，找出记录的binlog和POS点</text><text id="kity_text_8875" text-rendering="inherit" font-size="12" dy=".8em" y="124.70000004768372" x="537.5">把xxx.sql拷贝到Slave机器上，并做Change master to指向。在Slave机器上导入xxx.sql (若从库开启了binlog 为使导入加快，可以先执行set sql_log_bin=0)</text><text id="kity_text_8876" text-rendering="inherit" font-size="12" dy=".8em" y="142.70000004768372" x="537.5">导入完毕后，从库开启同步即可。</text><text id="kity_text_8877" text-rendering="inherit" font-size="12" dy=".8em" y="160.70000004768372" x="537.5">避免：</text><text id="kity_text_8878" text-rendering="inherit" font-size="12" dy=".8em" y="178.70000004768372" x="537.5">1.主库binlog采用ROW格式(会将每一条数据的变化写到binlog中)。2.主从实例数据库版本保持一致。3.主库做好账号权限把控，不可以执行set sql_log_bin=0。</text><text id="kity_text_8879" text-rendering="inherit" font-size="12" dy=".8em" y="196.70000004768372" x="537.5">4.从库开启只读，不允许人为写入。5.定期进行主从一致性检验。6.业务强一致性的去读主库</text></g></g><g id="minder_node716" display="none"><g id="node_expander714" display="none" style="cursor: pointer;"><path id="kity_path_22664" fill="white" stroke="gray" d="M521.5,95.5A6,6,0,1,1,509.5,95.5A6,6,0,1,1,521.5,95.5"></path><path id="kity_path_22665" fill="none" stroke="gray"></path></g><path id="node_outline715" fill="none" stroke="none" d="M521.5,86.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text715" fill="black"><text id="kity_text_8889" text-rendering="inherit" font-size="12" dy=".8em" y="87.70000004768372" x="521.5">数据库主从复制时如何做的？</text></g></g><g id="minder_node717" display="none"><g id="node_expander713" display="none" style="cursor: pointer;"><path id="kity_path_22661" fill="white" stroke="gray" d="M537.5,95.5A6,6,0,1,1,525.5,95.5A6,6,0,1,1,537.5,95.5"></path><path id="kity_path_22662" fill="none" stroke="gray"></path></g><path id="node_outline714" fill="none" stroke="none" d="M537.5,50.5h663a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-663a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text714" fill="black"><text id="kity_text_8883" text-rendering="inherit" font-size="12" dy=".8em" y="51.700000047683716" x="537.5">1.</text><text id="kity_text_8884" text-rendering="inherit" font-size="12" dy=".8em" y="69.70000004768372" x="537.5">简单来说就是，修改主配置，实例化，开启binlog，其他配置选配，修改从，配置从上实例化，中继日志，关binlog，开只读</text><text id="kity_text_8885" text-rendering="inherit" font-size="12" dy=".8em" y="87.70000004768372" x="537.5">执行命令启动主从，验证</text><text id="kity_text_8886" text-rendering="inherit" font-size="12" dy=".8em" y="105.70000004768372" x="537.5">2.</text><text id="kity_text_8887" text-rendering="inherit" font-size="12" dy=".8em" y="123.70000004768372" x="537.5">https://mp.weixin.qq.com/s/eEWMSTAUF1H-gFBx26jujw</text></g></g><g id="minder_node718" display="none"><g id="node_expander716" display="none" style="cursor: pointer;"><path id="kity_path_22670" fill="white" stroke="gray" d="M521.5,103.5A6,6,0,1,1,509.5,103.5A6,6,0,1,1,521.5,103.5"></path><path id="kity_path_22671" fill="none" stroke="gray"></path></g><path id="node_outline717" fill="none" stroke="none" d="M521.5,94.5h252a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-252a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text717" fill="black"><text id="kity_text_8906" text-rendering="inherit" font-size="12" dy=".8em" y="95.70000004768372" x="521.5">主从的延迟问题知道吗？怎么解决？怎么查看？</text></g></g><g id="minder_node719" display="none"><g id="node_expander715" display="none" style="cursor: pointer;"><path id="kity_path_22667" fill="white" stroke="gray" d="M537.5,103.5A6,6,0,1,1,525.5,103.5A6,6,0,1,1,537.5,103.5"></path><path id="kity_path_22668" fill="none" stroke="gray"></path></g><path id="node_outline716" fill="none" stroke="none" d="M537.5,-22.5h1047a5,5,0,0,1,5,5v242a5,5,0,0,1,-5,5h-1047a5,5,0,0,1,-5,-5v-242a5,5,0,0,1,5,-5z"></path><g id="node_text716" fill="black"><text id="kity_text_8891" text-rendering="inherit" font-size="12" dy=".8em" y="-21.299999952316284" x="537.5">1.</text><text id="kity_text_8892" text-rendering="inherit" font-size="12" dy=".8em" y="-3.299999952316284" x="537.5">当主库的TPS并发较高时，由于主库上面是多线程写入的，而从库的SQL线程是单线程的，导致从库SQL可能会跟不上主库的处理速度</text><text id="kity_text_8893" text-rendering="inherit" font-size="12" dy=".8em" y="14.700000047683716" x="537.5">主节点保存到二进制日志文件需要花时间。对中继日志进行读取、解析、执行也需要花时间，还有大查询的锁等待</text><text id="kity_text_8894" text-rendering="inherit" font-size="12" dy=".8em" y="32.700000047683716" x="537.5">2.</text><text id="kity_text_8895" text-rendering="inherit" font-size="12" dy=".8em" y="50.700000047683716" x="537.5">网络方面优化.硬件方面优化.架构方面优化。加redis的cache层，可以降低从库的读压力。</text><text id="kity_text_8896" text-rendering="inherit" font-size="12" dy=".8em" y="68.70000004768372" x="537.5">使用代理中间件 如mysql-proxy 中的 ro-balance.lua 脚本,启用后,默认情况下,延迟10s以上,或者10K binlog以上,就会被踢出,直到延迟恢复正常.如果是一主一从的配置,从库延迟的话,也会路由给主库.</text><text id="kity_text_8897" text-rendering="inherit" font-size="12" dy=".8em" y="86.70000004768372" x="537.5">用canal也解决MySQL主从同步延迟的问题，canal就监听binlog的更新，监听到表级别，canal捕捉到更改的SQL后立即在slave节点执行</text><text id="kity_text_8898" text-rendering="inherit" font-size="12" dy=".8em" y="104.70000004768372" x="537.5">MySQL 5.6 版本后，提供了一种并行复制的方式，将 SQL 线程转换为多个 work 线程，</text><text id="kity_text_8899" text-rendering="inherit" font-size="12" dy=".8em" y="122.70000004768372" x="537.5">如果实在要求强一致性，当前事务某一些就走master去查询，延迟大了就路由给master</text><text id="kity_text_8900" text-rendering="inherit" font-size="12" dy=".8em" y="140.70000004768372" x="537.5">3.</text><text id="kity_text_8901" text-rendering="inherit" font-size="12" dy=".8em" y="158.70000004768372" x="537.5">show slave status中Seconds_Behind_Master不为0，就是延迟了。</text><text id="kity_text_8902" text-rendering="inherit" font-size="12" dy=".8em" y="176.70000004768372" x="537.5">参数Relay_Master_Log_File和Master_Log_File显示bin-log的编号相差很大，说明bin-log在从库上没有及时同步，所以近期执行的bin-log和当前IO线程所读的bin-log相差很大</text><text id="kity_text_8903" text-rendering="inherit" font-size="12" dy=".8em" y="194.70000004768372" x="537.5">从库数据目录下存在大量mysql-relay-log日志</text><text id="kity_text_8904" text-rendering="inherit" font-size="12" dy=".8em" y="212.70000004768372" x="537.5"> </text></g></g><g id="minder_node720" display="none"><g id="node_expander719" display="none" style="cursor: pointer;"><path id="kity_path_22679" fill="white" stroke="gray" d="M521.5,111.5A6,6,0,1,1,509.5,111.5A6,6,0,1,1,521.5,111.5"></path><path id="kity_path_22680" fill="none" stroke="gray"></path></g><path id="node_outline720" fill="none" stroke="none" d="M521.5,102.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text720" fill="black"><text id="kity_text_8916" text-rendering="inherit" font-size="12" dy=".8em" y="103.70000004768372" x="521.5">主从的工作流程简单说说</text></g></g><g id="minder_node721" display="none"><g id="node_expander718" display="none" style="cursor: pointer;"><path id="kity_path_22676" fill="white" stroke="gray" d="M537.5,111.5A6,6,0,1,1,525.5,111.5A6,6,0,1,1,537.5,111.5"></path><path id="kity_path_22677" fill="none" stroke="gray"></path></g><path id="node_outline719" fill="none" stroke="none" d="M537.5,66.5h806a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-806a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text719" fill="black"><text id="kity_text_8910" text-rendering="inherit" font-size="12" dy=".8em" y="67.70000004768372" x="537.5">1.在备库B上通过change master命令，设置主库A的IP、端口、用户名、密码，以及要从哪个位置开始请求binlog，这个位置包含文件名和日志偏移量。</text><text id="kity_text_8911" text-rendering="inherit" font-size="12" dy=".8em" y="85.70000004768372" x="537.5">2.在备库B上执行start slave命令，这时候备库会启动两个线程，io_thread和sql_thread。其中io_thread负责与主库建立连接。</text><text id="kity_text_8912" text-rendering="inherit" font-size="12" dy=".8em" y="103.70000004768372" x="537.5">3.主库A校验完用户名、密码后，开始按照备库B传过来的位置，从本地读取binlog，发给B。</text><text id="kity_text_8913" text-rendering="inherit" font-size="12" dy=".8em" y="121.70000004768372" x="537.5">4.备库B拿到binlog后，写到本地文件，称为中转日志（relay log）。</text><text id="kity_text_8914" text-rendering="inherit" font-size="12" dy=".8em" y="139.70000004768372" x="537.5">5.sql_thread读取中转日志，解析出日志里的命令，并执行。</text></g></g><g id="minder_node722" display="none"><g id="node_expander717" display="none" style="cursor: pointer;"><path id="kity_path_22673" fill="white" stroke="gray" d="M553.5,111.5A6,6,0,1,1,541.5,111.5A6,6,0,1,1,553.5,111.5"></path><path id="kity_path_22674" fill="none" stroke="gray"></path></g><path id="node_outline718" fill="none" stroke="none" d="M490.5,-2.5h200a5,5,0,0,1,5,5v113a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-113a5,5,0,0,1,5,-5z"></path><g id="node_text718" fill="black"><text id="kity_text_8908" text-rendering="inherit" font-size="12" dy=".8em" y="103.70000004768372" x="553.5">主从复制流程</text></g><image id="kity_image_17038" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210320223235.png" x="490.5" y="0.5" width="200" height="100"></image></g><g id="minder_node723" display="none"><g id="node_expander722" display="none" style="cursor: pointer;"><path id="kity_path_22688" fill="white" stroke="gray" d="M521.5,119.5A6,6,0,1,1,509.5,119.5A6,6,0,1,1,521.5,119.5"></path><path id="kity_path_22689" fill="none" stroke="gray"></path></g><path id="node_outline723" fill="none" stroke="none" d="M521.5,110.5h175a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-175a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text723" fill="black"><text id="kity_text_8926" text-rendering="inherit" font-size="12" dy=".8em" y="111.70000004768372" x="521.5">知道什么是读写分离?怎么实现？</text></g></g><g id="minder_node724" display="none"><g id="node_expander721" display="none" style="cursor: pointer;"><path id="kity_path_22685" fill="white" stroke="gray" d="M537.5,119.5A6,6,0,1,1,525.5,119.5A6,6,0,1,1,537.5,119.5"></path><path id="kity_path_22686" fill="none" stroke="gray"></path></g><path id="node_outline722" fill="none" stroke="none" d="M537.5,74.5h575a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-575a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text722" fill="black"><text id="kity_text_8920" text-rendering="inherit" font-size="12" dy=".8em" y="75.70000004768372" x="537.5">1.</text><text id="kity_text_8921" text-rendering="inherit" font-size="12" dy=".8em" y="93.70000004768372" x="537.5">主负责增删改。从负责查。减轻主压力。</text><text id="kity_text_8922" text-rendering="inherit" font-size="12" dy=".8em" y="111.70000004768372" x="537.5">2.</text><text id="kity_text_8923" text-rendering="inherit" font-size="12" dy=".8em" y="129.70000004768372" x="537.5">需要先配置主从复制的参数</text><text id="kity_text_8924" text-rendering="inherit" font-size="12" dy=".8em" y="147.70000004768372" x="537.5">可以使用中间件和代理，如mysqlPorxy,myCat，ShardingSphere 都可以实现主从复制读写分离，比较方便</text></g></g><g id="minder_node725" display="none"><g id="node_expander720" display="none" style="cursor: pointer;"><path id="kity_path_22682" fill="white" stroke="gray" d="M553.5,119.5A6,6,0,1,1,541.5,119.5A6,6,0,1,1,553.5,119.5"></path><path id="kity_path_22683" fill="none" stroke="gray"></path></g><path id="node_outline721" fill="none" stroke="none" d="M553.5,110.5h238a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-238a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text721" fill="black"><text id="kity_text_8918" text-rendering="inherit" font-size="12" dy=".8em" y="111.70000004768372" x="553.5">https://zhuanlan.zhihu.com/p/199217698</text></g></g><g id="minder_node726" display="none"><g id="node_expander724" display="none" style="cursor: pointer;"><path id="kity_path_22694" fill="white" stroke="gray" d="M521.5,127.5A6,6,0,1,1,509.5,127.5A6,6,0,1,1,521.5,127.5"></path><path id="kity_path_22695" fill="none" stroke="gray"></path></g><path id="node_outline725" fill="none" stroke="none" d="M521.5,118.5h266a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-266a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text725" fill="black"><text id="kity_text_8931" text-rendering="inherit" font-size="12" dy=".8em" y="119.70000004768372" x="521.5">读写分离怎么分配，怎么确认读的是从，写的是主</text></g></g><g id="minder_node727" display="none"><g id="node_expander723" display="none" style="cursor: pointer;"><path id="kity_path_22691" fill="white" stroke="gray" d="M537.5,127.5A6,6,0,1,1,525.5,127.5A6,6,0,1,1,537.5,127.5"></path><path id="kity_path_22692" fill="none" stroke="gray"></path></g><path id="node_outline724" fill="none" stroke="none" d="M537.5,109.5h392a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-392a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text724" fill="black"><text id="kity_text_8928" text-rendering="inherit" font-size="12" dy=".8em" y="110.70000004768372" x="537.5">1.可以编程实现，查询进从，增删改进主</text><text id="kity_text_8929" text-rendering="inherit" font-size="12" dy=".8em" y="128.70000004768372" x="537.5">2.通过第三方代理，如mycat，这样就先进入mysql代理服务，再判断转发</text></g></g><g id="minder_node728" display="none"><g id="node_expander726" display="none" style="cursor: pointer;"><path id="kity_path_22700" fill="white" stroke="gray" d="M521.5,135.5A6,6,0,1,1,509.5,135.5A6,6,0,1,1,521.5,135.5"></path><path id="kity_path_22701" fill="none" stroke="gray"></path></g><path id="node_outline727" fill="none" stroke="none" d="M521.5,126.5h173a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-173a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text727" fill="black"><text id="kity_text_8946" text-rendering="inherit" font-size="12" dy=".8em" y="127.70000004768372" x="521.5">如果我有新机器加到从 你怎么加</text></g></g><g id="minder_node729" display="none"><g id="node_expander725" display="none" style="cursor: pointer;"><path id="kity_path_22697" fill="white" stroke="gray" d="M537.5,135.5A6,6,0,1,1,525.5,135.5A6,6,0,1,1,537.5,135.5"></path><path id="kity_path_22698" fill="none" stroke="gray"></path></g><path id="node_outline726" fill="none" stroke="none" d="M537.5,27.5h566a5,5,0,0,1,5,5v206a5,5,0,0,1,-5,5h-566a5,5,0,0,1,-5,-5v-206a5,5,0,0,1,5,-5z"></path><g id="node_text726" fill="black"><text id="kity_text_8933" text-rendering="inherit" font-size="12" dy=".8em" y="28.700000047683716" x="537.5">1.可以不停机增加从节点，还可以顺便解决某一个从数据不一致问题，</text><text id="kity_text_8934" text-rendering="inherit" font-size="12" dy=".8em" y="46.700000047683716" x="537.5">备份主库:</text><text id="kity_text_8935" text-rendering="inherit" font-size="12" dy=".8em" y="64.70000004768372" x="537.5">(1)mysqldump(2)第三方工具</text><text id="kity_text_8936" text-rendering="inherit" font-size="12" dy=".8em" y="82.70000004768372" x="537.5">还原数据:</text><text id="kity_text_8937" text-rendering="inherit" font-size="12" dy=".8em" y="100.70000004768372" x="537.5">还原之前prepare一下，验证数据的一致性</text><text id="kity_text_8938" text-rendering="inherit" font-size="12" dy=".8em" y="118.70000004768372" x="537.5">创建新的主从关系:</text><text id="kity_text_8939" text-rendering="inherit" font-size="12" dy=".8em" y="136.70000004768372" x="537.5">2.停机复制从库：</text><text id="kity_text_8940" text-rendering="inherit" font-size="12" dy=".8em" y="154.70000004768372" x="537.5">停止从库slave01：mysql&gt; stop slave；</text><text id="kity_text_8941" text-rendering="inherit" font-size="12" dy=".8em" y="172.70000004768372" x="537.5">看当前从库的状态，mysql&gt; show slave status;记下 Relay_Master_Log_file 和 Exec_Master_Log_Pos；</text><text id="kity_text_8942" text-rendering="inherit" font-size="12" dy=".8em" y="190.70000004768372" x="537.5">备份从库数据</text><text id="kity_text_8943" text-rendering="inherit" font-size="12" dy=".8em" y="208.70000004768372" x="537.5">将备份传送到slave02，在slave2上同步数据；</text><text id="kity_text_8944" text-rendering="inherit" font-size="12" dy=".8em" y="226.70000004768372" x="537.5">slave02上设置相应的master_log_file和master-log_pos。</text></g></g><g id="minder_node730" display="none"><g id="node_expander728" display="none" style="cursor: pointer;"><path id="kity_path_22706" fill="white" stroke="gray" d="M521.5,143.5A6,6,0,1,1,509.5,143.5A6,6,0,1,1,521.5,143.5"></path><path id="kity_path_22707" fill="none" stroke="gray"></path></g><path id="node_outline729" fill="none" stroke="none" d="M521.5,134.5h289a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-289a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text729" fill="black"><text id="kity_text_8950" text-rendering="inherit" font-size="12" dy=".8em" y="135.70000004768372" x="521.5">但是如果突然挂掉了，如何保证挂掉那段时间的数据？</text></g></g><g id="minder_node731" display="none"><g id="node_expander727" display="none" style="cursor: pointer;"><path id="kity_path_22703" fill="white" stroke="gray" d="M537.5,143.5A6,6,0,1,1,525.5,143.5A6,6,0,1,1,537.5,143.5"></path><path id="kity_path_22704" fill="none" stroke="gray"></path></g><path id="node_outline728" fill="none" stroke="none" d="M537.5,134.5h715a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-715a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text728" fill="black"><text id="kity_text_8948" text-rendering="inherit" font-size="12" dy=".8em" y="135.70000004768372" x="537.5">1.如果只是挂了一小部分，我们可以mysqldump恢复，或者用工具比较差异化数据，进行恢复，或者再开一个从，全量复制主，都可以</text></g></g><g id="minder_node732" display="none"><g id="node_expander737" display="none" style="cursor: pointer;"><path id="kity_path_22733" fill="white" stroke="gray" d="M505.5,151.5A6,6,0,1,1,493.5,151.5A6,6,0,1,1,505.5,151.5"></path><path id="kity_path_22734" fill="none" stroke="gray"></path></g><path id="node_outline738" fill="none" stroke="none" d="M505.5,142.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text738" fill="black"><text id="kity_text_8969" text-rendering="inherit" font-size="12" dy=".8em" y="143.70000004768372" x="505.5">集群</text></g></g><g id="minder_node733" display="none"><g id="node_expander730" display="none" style="cursor: pointer;"><path id="kity_path_22712" fill="white" stroke="gray" d="M521.5,119.5A6,6,0,1,1,509.5,119.5A6,6,0,1,1,521.5,119.5"></path><path id="kity_path_22713" fill="none" stroke="gray"></path></g><path id="node_outline731" fill="none" stroke="none" d="M521.5,110.5h206a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-206a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text731" fill="black"><text id="kity_text_8954" text-rendering="inherit" font-size="12" dy=".8em" y="111.70000004768372" x="521.5">如何解决秒杀的性能问题和超卖的讨论</text></g></g><g id="minder_node734" display="none"><g id="node_expander731" display="none" style="cursor: pointer;"><path id="kity_path_22715" fill="white" stroke="gray" d="M521.5,127.5A6,6,0,1,1,509.5,127.5A6,6,0,1,1,521.5,127.5"></path><path id="kity_path_22716" fill="none" stroke="gray"></path></g><path id="node_outline732" fill="none" stroke="none" d="M521.5,118.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text732" fill="black"><text id="kity_text_8956" text-rendering="inherit" font-size="12" dy=".8em" y="119.70000004768372" x="521.5">为什么项目要搭建集群</text></g></g><g id="minder_node735" display="none"><g id="node_expander732" display="none" style="cursor: pointer;"><path id="kity_path_22718" fill="white" stroke="gray" d="M521.5,135.5A6,6,0,1,1,509.5,135.5A6,6,0,1,1,521.5,135.5"></path><path id="kity_path_22719" fill="none" stroke="gray"></path></g><path id="node_outline733" fill="none" stroke="none" d="M521.5,126.5h134a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-134a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text733" fill="black"><text id="kity_text_8958" text-rendering="inherit" font-size="12" dy=".8em" y="127.70000004768372" x="521.5">mysql 线上的集群模式？</text></g></g><g id="minder_node736" display="none"><g id="node_expander733" display="none" style="cursor: pointer;"><path id="kity_path_22721" fill="white" stroke="gray" d="M521.5,143.5A6,6,0,1,1,509.5,143.5A6,6,0,1,1,521.5,143.5"></path><path id="kity_path_22722" fill="none" stroke="gray"></path></g><path id="node_outline734" fill="none" stroke="none" d="M521.5,134.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text734" fill="black"><text id="kity_text_8960" text-rendering="inherit" font-size="12" dy=".8em" y="135.70000004768372" x="521.5">为什么使用一主多从</text></g></g><g id="minder_node737" display="none"><g id="node_expander736" display="none" style="cursor: pointer;"><path id="kity_path_22730" fill="white" stroke="gray" d="M521.5,151.5A6,6,0,1,1,509.5,151.5A6,6,0,1,1,521.5,151.5"></path><path id="kity_path_22731" fill="none" stroke="gray"></path></g><path id="node_outline737" fill="none" stroke="none" d="M521.5,142.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text737" fill="black"><text id="kity_text_8967" text-rendering="inherit" font-size="12" dy=".8em" y="143.70000004768372" x="521.5">强一致性如何保证？</text></g></g><g id="minder_node738" display="none"><g id="node_expander735" display="none" style="cursor: pointer;"><path id="kity_path_22727" fill="white" stroke="gray" d="M537.5,151.5A6,6,0,1,1,525.5,151.5A6,6,0,1,1,537.5,151.5"></path><path id="kity_path_22728" fill="none" stroke="gray"></path></g><path id="node_outline736" fill="none" stroke="none" d="M537.5,142.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text736" fill="black"><text id="kity_text_8965" text-rendering="inherit" font-size="12" dy=".8em" y="143.70000004768372" x="537.5">1.PXC+中间件 集群 强同步</text></g></g><g id="minder_node739" display="none"><g id="node_expander734" display="none" style="cursor: pointer;"><path id="kity_path_22724" fill="white" stroke="gray" d="M553.5,151.5A6,6,0,1,1,541.5,151.5A6,6,0,1,1,553.5,151.5"></path><path id="kity_path_22725" fill="none" stroke="gray"></path></g><path id="node_outline735" fill="none" stroke="none" d="M553.5,133.5h346a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-346a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text735" fill="black"><text id="kity_text_8962" text-rendering="inherit" font-size="12" dy=".8em" y="134.70000004768372" x="553.5">https://blog.csdn.net/a772304419/article/details/104036695</text><text id="kity_text_8963" text-rendering="inherit" font-size="12" dy=".8em" y="152.70000004768372" x="553.5">https://blog.csdn.net/u011207553/article/details/96487090</text></g></g><g id="minder_node740" display="none"><g id="node_expander763" display="none" style="cursor: pointer;"><path id="kity_path_22811" fill="white" stroke="gray" d="M505.5,159.5A6,6,0,1,1,493.5,159.5A6,6,0,1,1,505.5,159.5"></path><path id="kity_path_22812" fill="none" stroke="gray"></path></g><path id="node_outline764" fill="none" stroke="none" d="M505.5,150.5h110a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-110a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text764" fill="black"><text id="kity_text_9044" text-rendering="inherit" font-size="12" dy=".8em" y="151.70000004768372" x="505.5">性能排查和问题解决</text></g></g><g id="minder_node741" display="none"><g id="node_expander739" display="none" style="cursor: pointer;"><path id="kity_path_22739" fill="white" stroke="gray" d="M521.5,71.5A6,6,0,1,1,509.5,71.5A6,6,0,1,1,521.5,71.5"></path><path id="kity_path_22740" fill="none" stroke="gray"></path></g><path id="node_outline740" fill="none" stroke="none" d="M521.5,62.5h240a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-240a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text740" fill="black"><text id="kity_text_8979" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="521.5">数据库cpu突然占内存很高 甚至100，怎么办</text></g></g><g id="minder_node742" display="none"><g id="node_expander738" display="none" style="cursor: pointer;"><path id="kity_path_22736" fill="white" stroke="gray" d="M537.5,71.5A6,6,0,1,1,525.5,71.5A6,6,0,1,1,537.5,71.5"></path><path id="kity_path_22737" fill="none" stroke="gray"></path></g><path id="node_outline739" fill="none" stroke="none" d="M537.5,8.5h1075a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-1075a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text739" fill="black"><text id="kity_text_8971" text-rendering="inherit" font-size="12" dy=".8em" y="9.700000047683716" x="537.5">1.需要注意 有大事务；大查询；慢查询；大结果集sql；大结果集sql,超过临时内存,需拷贝到磁盘中；大结果集排序；非索引的列内存快速排序.最后会回表取查询列值；锁等待 等等 及时kill掉异常连接线程</text><text id="kity_text_8972" text-rendering="inherit" font-size="12" dy=".8em" y="27.700000047683716" x="537.5">通过pidstat 来查看当前MYSQL的线程中那个CPU的使用率比较高</text><text id="kity_text_8973" text-rendering="inherit" font-size="12" dy=".8em" y="45.700000047683716" x="537.5">拿到这些线程的ID 直接回到MYSQL 内部 通过performance_schema.thread 查看是哪个线程（连接）使用了大量的cpu资源</text><text id="kity_text_8974" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="537.5">2.通过 show full processlist;查看sql执行线程(连接)的状态。</text><text id="kity_text_8975" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="537.5">3.如果是慢sql show variables like '%slowquerylog%';查看慢sql,分析sql慢的原因</text><text id="kity_text_8976" text-rendering="inherit" font-size="12" dy=".8em" y="99.70000004768372" x="537.5">4.关注 buffer pool相关的参数 是否设置合理 如innodb_buffer_pool_size 。Innodb在mysql启动的时候一次性分配整个内存给bufferpool</text><text id="kity_text_8977" text-rendering="inherit" font-size="12" dy=".8em" y="117.70000004768372" x="537.5">5.如果是连接线程是 Java服务则先看是否是频繁FULLGC造成的,打印查看下线程信息 日志,查看是否有方法出现问题</text></g></g><g id="minder_node743" display="none"><g id="node_expander741" display="none" style="cursor: pointer;"><path id="kity_path_22745" fill="white" stroke="gray" d="M521.5,79.5A6,6,0,1,1,509.5,79.5A6,6,0,1,1,521.5,79.5"></path><path id="kity_path_22746" fill="none" stroke="gray"></path></g><path id="node_outline742" fill="none" stroke="none" d="M521.5,70.5h184a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-184a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text742" fill="black"><text id="kity_text_8985" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="521.5">sql注入怎么解决和避免有关注吗？</text></g></g><g id="minder_node744" display="none"><g id="node_expander740" display="none" style="cursor: pointer;"><path id="kity_path_22742" fill="white" stroke="gray" d="M537.5,79.5A6,6,0,1,1,525.5,79.5A6,6,0,1,1,537.5,79.5"></path><path id="kity_path_22743" fill="none" stroke="gray"></path></g><path id="node_outline741" fill="none" stroke="none" d="M537.5,52.5h730a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-730a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text741" fill="black"><text id="kity_text_8981" text-rendering="inherit" font-size="12" dy=".8em" y="53.700000047683716" x="537.5">1.&#xa0;</text><text id="kity_text_8982" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="537.5">代码层防止sql注入攻击的最佳方案就是sql预编译，确认每种数据的类型，比如是数字，数据库则必须使用int类型来存储</text><text id="kity_text_8983" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="537.5">规定数据长度，能在一定程度上防止sql注入，严格限制数据库权限，能最大程度减少sql注入的危害，过滤参数中含有的一些数据库关键词</text></g></g><g id="minder_node745" display="none"><g id="node_expander743" display="none" style="cursor: pointer;"><path id="kity_path_22751" fill="white" stroke="gray" d="M521.5,87.5A6,6,0,1,1,509.5,87.5A6,6,0,1,1,521.5,87.5"></path><path id="kity_path_22752" fill="none" stroke="gray"></path></g><path id="node_outline744" fill="none" stroke="none" d="M521.5,78.5h552a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-552a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text744" fill="black"><text id="kity_text_8989" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="521.5">你们创建的那么多索引，到底有没有生效，或者说你们的SQL语句有没有使用索引查询你们有统计过吗？</text></g></g><g id="minder_node746" display="none"><g id="node_expander742" display="none" style="cursor: pointer;"><path id="kity_path_22748" fill="white" stroke="gray" d="M537.5,87.5A6,6,0,1,1,525.5,87.5A6,6,0,1,1,537.5,87.5"></path><path id="kity_path_22749" fill="none" stroke="gray"></path></g><path id="node_outline743" fill="none" stroke="none" d="M537.5,78.5h640a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-640a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text743" fill="black"><text id="kity_text_8987" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="537.5">1.使用explain分析统计过，小表都走索引，不合理的索引，都会删除重新创建合理的索引，如何重复测试，避免全表扫描</text></g></g><g id="minder_node747" display="none"><g id="node_expander745" display="none" style="cursor: pointer;"><path id="kity_path_22757" fill="white" stroke="gray" d="M521.5,95.5A6,6,0,1,1,509.5,95.5A6,6,0,1,1,521.5,95.5"></path><path id="kity_path_22758" fill="none" stroke="gray"></path></g><path id="node_outline746" fill="none" stroke="none" d="M521.5,86.5h353a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-353a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text746" fill="black"><text id="kity_text_8993" text-rendering="inherit" font-size="12" dy=".8em" y="87.70000004768372" x="521.5">接上问 那排查的时候，有什么手段可以知道有没有走索引查询呢？</text></g></g><g id="minder_node748" display="none"><g id="node_expander744" display="none" style="cursor: pointer;"><path id="kity_path_22754" fill="white" stroke="gray" d="M537.5,95.5A6,6,0,1,1,525.5,95.5A6,6,0,1,1,537.5,95.5"></path><path id="kity_path_22755" fill="none" stroke="gray"></path></g><path id="node_outline745" fill="none" stroke="none" d="M537.5,86.5h138a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-138a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text745" fill="black"><text id="kity_text_8991" text-rendering="inherit" font-size="12" dy=".8em" y="87.70000004768372" x="537.5">1.explain 在上面分析过了</text></g></g><g id="minder_node749" display="none"><g id="node_expander747" display="none" style="cursor: pointer;"><path id="kity_path_22763" fill="white" stroke="gray" d="M521.5,103.5A6,6,0,1,1,509.5,103.5A6,6,0,1,1,521.5,103.5"></path><path id="kity_path_22764" fill="none" stroke="gray"></path></g><path id="node_outline748" fill="none" stroke="none" d="M521.5,94.5h241a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-241a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text748" fill="black"><text id="kity_text_8997" text-rendering="inherit" font-size="12" dy=".8em" y="95.70000004768372" x="521.5">跨库聚合怎么实现？分页？第几页？下一页？</text></g></g><g id="minder_node750" display="none"><g id="node_expander746" display="none" style="cursor: pointer;"><path id="kity_path_22760" fill="white" stroke="gray" d="M537.5,103.5A6,6,0,1,1,525.5,103.5A6,6,0,1,1,537.5,103.5"></path><path id="kity_path_22761" fill="none" stroke="gray"></path></g><path id="node_outline747" fill="none" stroke="none" d="M537.5,94.5h118a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-118a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text747" fill="black"><text id="kity_text_8995" text-rendering="inherit" font-size="12" dy=".8em" y="95.70000004768372" x="537.5">1.在分库分表有分析，</text></g></g><g id="minder_node751" display="none"><g id="node_expander749" display="none" style="cursor: pointer;"><path id="kity_path_22769" fill="white" stroke="gray" d="M521.5,111.5A6,6,0,1,1,509.5,111.5A6,6,0,1,1,521.5,111.5"></path><path id="kity_path_22770" fill="none" stroke="gray"></path></g><path id="node_outline750" fill="none" stroke="none" d="M521.5,102.5h341a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-341a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text750" fill="black"><text id="kity_text_9001" text-rendering="inherit" font-size="12" dy=".8em" y="103.70000004768372" x="521.5">mysql如果A数据库数据需要联合查询B数据库,应该如何实现呢？</text></g></g><g id="minder_node752" display="none"><g id="node_expander748" display="none" style="cursor: pointer;"><path id="kity_path_22766" fill="white" stroke="gray" d="M537.5,111.5A6,6,0,1,1,525.5,111.5A6,6,0,1,1,537.5,111.5"></path><path id="kity_path_22767" fill="none" stroke="gray"></path></g><path id="node_outline749" fill="none" stroke="none" d="M537.5,102.5h164a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-164a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text749" fill="black"><text id="kity_text_8999" text-rendering="inherit" font-size="12" dy=".8em" y="103.70000004768372" x="537.5">1.相同实例不同库。2.不同实例</text></g></g><g id="minder_node753" display="none"><g id="node_expander751" display="none" style="cursor: pointer;"><path id="kity_path_22775" fill="white" stroke="gray" d="M521.5,119.5A6,6,0,1,1,509.5,119.5A6,6,0,1,1,521.5,119.5"></path><path id="kity_path_22776" fill="none" stroke="gray"></path></g><path id="node_outline752" fill="none" stroke="none" d="M521.5,110.5h275a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-275a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text752" fill="black"><text id="kity_text_9011" text-rendering="inherit" font-size="12" dy=".8em" y="111.70000004768372" x="521.5">mysql数据库连接池满了怎么办，大量无用连接占满</text></g></g><g id="minder_node754" display="none"><g id="node_expander750" display="none" style="cursor: pointer;"><path id="kity_path_22772" fill="white" stroke="gray" d="M537.5,119.5A6,6,0,1,1,525.5,119.5A6,6,0,1,1,537.5,119.5"></path><path id="kity_path_22773" fill="none" stroke="gray"></path></g><path id="node_outline751" fill="none" stroke="none" d="M537.5,56.5h822a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-822a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text751" fill="black"><text id="kity_text_9003" text-rendering="inherit" font-size="12" dy=".8em" y="57.700000047683716" x="537.5">1.使用数据库连接池</text><text id="kity_text_9004" text-rendering="inherit" font-size="12" dy=".8em" y="75.70000004768372" x="537.5">（1）&#xa0; 程序初始化时创建连接池（2） 使用时向连接池申请可用连接（3） 使用完毕，将连接返还给连接池（4） 程序退出时，断开所有连接，并释放资源</text><text id="kity_text_9005" text-rendering="inherit" font-size="12" dy=".8em" y="93.70000004768372" x="537.5">2.需要考虑的点和连接池关键参数</text><text id="kity_text_9006" text-rendering="inherit" font-size="12" dy=".8em" y="111.70000004768372" x="537.5">&#xa0;最小连接数。最大连接数。最大空闲连接。最小空闲连接。超时等待时间。</text><text id="kity_text_9007" text-rendering="inherit" font-size="12" dy=".8em" y="129.70000004768372" x="537.5">3.mysql连接池满了的处理方法</text><text id="kity_text_9008" text-rendering="inherit" font-size="12" dy=".8em" y="147.70000004768372" x="537.5">(1)查看是否真的是大量长连接僵尸进程长时间等待， show processlist。设置超时时间(一定时间没有返回就结束连接)和使用短连接，编写脚本kill僵尸进程</text><text id="kity_text_9009" text-rendering="inherit" font-size="12" dy=".8em" y="165.70000004768372" x="537.5">(2)查看代码是否关闭了连接，(3)查询sql是否可以优化，消耗大量时间(4)业务场景实在需要就调大max_connections=[值]</text></g></g><g id="minder_node755" display="none"><g id="node_expander753" display="none" style="cursor: pointer;"><path id="kity_path_22781" fill="white" stroke="gray" d="M521.5,127.5A6,6,0,1,1,509.5,127.5A6,6,0,1,1,521.5,127.5"></path><path id="kity_path_22782" fill="none" stroke="gray"></path></g><path id="node_outline754" fill="none" stroke="none" d="M521.5,118.5h134a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-134a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text754" fill="black"><text id="kity_text_9015" text-rendering="inherit" font-size="12" dy=".8em" y="119.70000004768372" x="521.5">连接池连接设置多少合适</text></g></g><g id="minder_node756" display="none"><g id="node_expander752" display="none" style="cursor: pointer;"><path id="kity_path_22778" fill="white" stroke="gray" d="M537.5,127.5A6,6,0,1,1,525.5,127.5A6,6,0,1,1,537.5,127.5"></path><path id="kity_path_22779" fill="none" stroke="gray"></path></g><path id="node_outline753" fill="none" stroke="none" d="M537.5,118.5h201a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-201a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text753" fill="black"><text id="kity_text_9013" text-rendering="inherit" font-size="12" dy=".8em" y="119.70000004768372" x="537.5">连接数 = ((核心数 * 2) + 有效磁盘数)</text></g></g><g id="minder_node757" display="none"><g id="node_expander755" display="none" style="cursor: pointer;"><path id="kity_path_22787" fill="white" stroke="gray" d="M521.5,135.5A6,6,0,1,1,509.5,135.5A6,6,0,1,1,521.5,135.5"></path><path id="kity_path_22788" fill="none" stroke="gray"></path></g><path id="node_outline756" fill="none" stroke="none" d="M521.5,126.5h170a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-170a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text756" fill="black"><text id="kity_text_9024" text-rendering="inherit" font-size="12" dy=".8em" y="127.70000004768372" x="521.5">数据库中如何查看当前的连接数</text></g></g><g id="minder_node758" display="none"><g id="node_expander754" display="none" style="cursor: pointer;"><path id="kity_path_22784" fill="white" stroke="gray" d="M537.5,135.5A6,6,0,1,1,525.5,135.5A6,6,0,1,1,537.5,135.5"></path><path id="kity_path_22785" fill="none" stroke="gray"></path></g><path id="node_outline755" fill="none" stroke="none" d="M537.5,81.5h793a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-793a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text755" fill="black"><text id="kity_text_9017" text-rendering="inherit" font-size="12" dy=".8em" y="82.70000004768372" x="537.5">1.使用status【mysqladmin -uroot -proot status】命令也能获得thread连接数以及当前连接的id或者用show full processlist看一下所有连接进程，</text><text id="kity_text_9018" text-rendering="inherit" font-size="12" dy=".8em" y="100.70000004768372" x="537.5">2.</text><text id="kity_text_9019" text-rendering="inherit" font-size="12" dy=".8em" y="118.70000004768372" x="537.5">管理员用户登录 show processlist; 可以显示前100条连接信息 show full processlist; 可以显示全部。</text><text id="kity_text_9020" text-rendering="inherit" font-size="12" dy=".8em" y="136.70000004768372" x="537.5">如果我们想查看这台服务器设置。 #vi /etc/my.cnf</text><text id="kity_text_9021" text-rendering="inherit" font-size="12" dy=".8em" y="154.70000004768372" x="537.5">set-variable=max_user_connections=30 这个就是单用户的连接数</text><text id="kity_text_9022" text-rendering="inherit" font-size="12" dy=".8em" y="172.70000004768372" x="537.5">set-variable=max_connections=800 这个是全局的限制连接数</text></g></g><g id="minder_node759" display="none"><g id="node_expander757" display="none" style="cursor: pointer;"><path id="kity_path_22793" fill="white" stroke="gray" d="M521.5,143.5A6,6,0,1,1,509.5,143.5A6,6,0,1,1,521.5,143.5"></path><path id="kity_path_22794" fill="none" stroke="gray"></path></g><path id="node_outline758" fill="none" stroke="none" d="M521.5,134.5h240a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-240a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text758" fill="black"><text id="kity_text_9028" text-rendering="inherit" font-size="12" dy=".8em" y="135.70000004768372" x="521.5">当数据库进行版本升级时，如何进行数据迁移</text></g></g><g id="minder_node760" display="none"><g id="node_expander756" display="none" style="cursor: pointer;"><path id="kity_path_22790" fill="white" stroke="gray" d="M537.5,143.5A6,6,0,1,1,525.5,143.5A6,6,0,1,1,537.5,143.5"></path><path id="kity_path_22791" fill="none" stroke="gray"></path></g><path id="node_outline757" fill="none" stroke="none" d="M537.5,134.5h107a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-107a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text757" fill="black"><text id="kity_text_9026" text-rendering="inherit" font-size="12" dy=".8em" y="135.70000004768372" x="537.5">1.在分库分表有分析</text></g></g><g id="minder_node761" display="none"><g id="node_expander760" display="none" style="cursor: pointer;"><path id="kity_path_22802" fill="white" stroke="gray" d="M521.5,151.5A6,6,0,1,1,509.5,151.5A6,6,0,1,1,521.5,151.5"></path><path id="kity_path_22803" fill="none" stroke="gray"></path></g><path id="node_outline761" fill="none" stroke="none" d="M521.5,142.5h395a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-395a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text761" fill="black"><text id="kity_text_9036" text-rendering="inherit" font-size="12" dy=".8em" y="143.70000004768372" x="521.5">为什么一般情况下，建表的时候都会使用一个自增的id来作为我们的主键？</text></g></g><g id="minder_node762" display="none"><g id="node_expander759" display="none" style="cursor: pointer;"><path id="kity_path_22799" fill="white" stroke="gray" d="M537.5,151.5A6,6,0,1,1,525.5,151.5A6,6,0,1,1,537.5,151.5"></path><path id="kity_path_22800" fill="none" stroke="gray"></path></g><path id="node_outline760" fill="none" stroke="none" d="M537.5,133.5h1147a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1147a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text760" fill="black"><text id="kity_text_9033" text-rendering="inherit" font-size="12" dy=".8em" y="134.70000004768372" x="537.5">1.主键是顺序的，只需要把新增的一条记录存储在上一条记录的后面，当页达到最大填充因子(一页16kb)的时候，下一跳记录就会写入新的页中 防止页分裂会导致大量的内存碎片。</text><text id="kity_text_9034" text-rendering="inherit" font-size="12" dy=".8em" y="152.70000004768372" x="537.5">2.而主键无规律数据，InnoDB需要找一个合适的位置（已有数据的中间位置）产生大量的页分裂并且移动大量数据，在寻找合适位置进行插入时，目标页可能不在内存中，这就导致了大量的随机IO操作，影响插入效率</text></g></g><g id="minder_node763" display="none"><g id="node_expander758" display="none" style="cursor: pointer;"><path id="kity_path_22796" fill="white" stroke="gray" d="M553.5,151.5A6,6,0,1,1,541.5,151.5A6,6,0,1,1,553.5,151.5"></path><path id="kity_path_22797" fill="none" stroke="gray"></path></g><path id="node_outline759" fill="none" stroke="none" d="M553.5,133.5h336a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-336a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text759" fill="black"><text id="kity_text_9030" text-rendering="inherit" font-size="12" dy=".8em" y="134.70000004768372" x="553.5">https://www.cnblogs.com/gaoquanquan/p/11030999.html</text><text id="kity_text_9031" text-rendering="inherit" font-size="12" dy=".8em" y="152.70000004768372" x="553.5">https://www.cnblogs.com/ZhuChangwu/p/14041410.html</text></g></g><g id="minder_node764" display="none"><g id="node_expander762" display="none" style="cursor: pointer;"><path id="kity_path_22808" fill="white" stroke="gray" d="M521.5,159.5A6,6,0,1,1,509.5,159.5A6,6,0,1,1,521.5,159.5"></path><path id="kity_path_22809" fill="none" stroke="gray"></path></g><path id="node_outline763" fill="none" stroke="none" d="M521.5,150.5h212a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-212a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text763" fill="black"><text id="kity_text_9042" text-rendering="inherit" font-size="12" dy=".8em" y="151.70000004768372" x="521.5">varchar(4000)如果要创建索引怎么创建</text></g></g><g id="minder_node765" display="none"><g id="node_expander761" display="none" style="cursor: pointer;"><path id="kity_path_22805" fill="white" stroke="gray" d="M537.5,159.5A6,6,0,1,1,525.5,159.5A6,6,0,1,1,537.5,159.5"></path><path id="kity_path_22806" fill="none" stroke="gray"></path></g><path id="node_outline762" fill="none" stroke="none" d="M537.5,132.5h1136a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1136a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text762" fill="black"><text id="kity_text_9038" text-rendering="inherit" font-size="12" dy=".8em" y="133.70000004768372" x="537.5">1.innodb每个索引列长度限制为767字节（bytes），所有组成索引列的长度和不能大于3072字节.在utf-8字符集下，innodb引擎创建的单列索引长度不能超过255个字符，utf-8一个字符3个字节。或者修改配置文件</text><text id="kity_text_9039" text-rendering="inherit" font-size="12" dy=".8em" y="151.70000004768372" x="537.5">2.如果要创建这么长的索引，(1)通过hash，保存hash后的值，搜索的时侯，根据hash值查找，而不是全文查找</text><text id="kity_text_9040" text-rendering="inherit" font-size="12" dy=".8em" y="169.70000004768372" x="537.5">3.如果确实有必要，单独构造一个表来存放</text></g></g><g id="minder_node766"><g id="node_expander1182" style="cursor: pointer;"><path id="kity_path_24068" fill="white" stroke="gray" d="M397.5,201.5A6,6,0,1,1,385.5,201.5A6,6,0,1,1,397.5,201.5"></path><path id="kity_path_24069" fill="none" stroke="gray" d="M387,201.5L396,201.5M391.5,197L391.5,206"></path></g><path id="node_outline1183" fill="rgb(239, 238, 246)" stroke="rgb(123, 115, 191)" d="M401.5,188.5h80a3,3,0,0,1,3,3v20a3,3,0,0,1,-3,3h-80a3,3,0,0,1,-3,-3v-20a3,3,0,0,1,3,-3z" stroke-width="1"></path><g id="node_text1183" fill="black"><text id="kity_text_10426" text-rendering="inherit" font-size="14" dy=".8em" y="192.40000009536743" x="418.5">4.redis</text></g></g><g id="minder_node767" display="none"><g id="node_expander827" display="none" style="cursor: pointer;"><path id="kity_path_23003" fill="white" stroke="gray" d="M500.5,105.5A6,6,0,1,1,488.5,105.5A6,6,0,1,1,500.5,105.5"></path><path id="kity_path_23004" fill="none" stroke="gray"></path></g><path id="node_outline828" fill="none" stroke="none" d="M500.5,96.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text828" fill="black"><text id="kity_text_9277" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="500.5">基础</text></g></g><g id="minder_node768" display="none"><g id="node_expander766" display="none" style="cursor: pointer;"><path id="kity_path_22820" fill="white" stroke="gray" d="M516.5,-30.5A6,6,0,1,1,504.5,-30.5A6,6,0,1,1,516.5,-30.5"></path><path id="kity_path_22821" fill="none" stroke="gray"></path></g><path id="node_outline767" fill="none" stroke="none" d="M516.5,-39.5h184a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-184a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text767" fill="black"><text id="kity_text_9052" text-rendering="inherit" font-size="12" dy=".8em" y="-38.299999952316284" x="516.5">redis作为内存数据库有哪些优点？</text></g></g><g id="minder_node769" display="none"><g id="node_expander765" display="none" style="cursor: pointer;"><path id="kity_path_22817" fill="white" stroke="gray" d="M532.5,-30.5A6,6,0,1,1,520.5,-30.5A6,6,0,1,1,532.5,-30.5"></path><path id="kity_path_22818" fill="none" stroke="gray"></path></g><path id="node_outline766" fill="none" stroke="none" d="M532.5,-57.5h805a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-805a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text766" fill="black"><text id="kity_text_9048" text-rendering="inherit" font-size="12" dy=".8em" y="-56.299999952316284" x="532.5">1.</text><text id="kity_text_9049" text-rendering="inherit" font-size="12" dy=".8em" y="-38.299999952316284" x="532.5">为了达到最快的读写速度将数据都读到内存中，通过异步将数据写入磁盘。所以 redis 具有快速和数据持久化的特征。</text><text id="kity_text_9050" text-rendering="inherit" font-size="12" dy=".8em" y="-20.299999952316284" x="532.5">如果不将数据放在内存中，磁盘 I/O 速度为严重影响 redis 的性能。如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</text></g></g><g id="minder_node770" display="none"><g id="node_expander776" display="none" style="cursor: pointer;"><path id="kity_path_22850" fill="white" stroke="gray" d="M516.5,-22.5A6,6,0,1,1,504.5,-22.5A6,6,0,1,1,516.5,-22.5"></path><path id="kity_path_22851" fill="none" stroke="gray"></path></g><path id="node_outline777" fill="none" stroke="none" d="M516.5,-31.5h97a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-97a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text777" fill="black"><text id="kity_text_9084" text-rendering="inherit" font-size="12" dy=".8em" y="-30.299999952316284" x="516.5">redis 6.0相关问题</text></g></g><g id="minder_node771" display="none"><g id="node_expander768" display="none" style="cursor: pointer;"><path id="kity_path_22826" fill="white" stroke="gray" d="M532.5,-46.5A6,6,0,1,1,520.5,-46.5A6,6,0,1,1,532.5,-46.5"></path><path id="kity_path_22827" fill="none" stroke="gray"></path></g><path id="node_outline769" fill="none" stroke="none" d="M532.5,-55.5h227a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-227a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text769" fill="black"><text id="kity_text_9062" text-rendering="inherit" font-size="12" dy=".8em" y="-54.299999952316284" x="532.5">redis6以前都是单线程吗，为什么单线程？</text></g></g><g id="minder_node772" display="none"><g id="node_expander767" display="none" style="cursor: pointer;"><path id="kity_path_22823" fill="white" stroke="gray" d="M548.5,-46.5A6,6,0,1,1,536.5,-46.5A6,6,0,1,1,548.5,-46.5"></path><path id="kity_path_22824" fill="none" stroke="gray"></path></g><path id="node_outline768" fill="none" stroke="none" d="M548.5,-109.5h761a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-761a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text768" fill="black"><text id="kity_text_9054" text-rendering="inherit" font-size="12" dy=".8em" y="-108.29999995231628" x="548.5">1.</text><text id="kity_text_9055" text-rendering="inherit" font-size="12" dy=".8em" y="-90.29999995231628" x="548.5">单线程说的是Redis在处理请求时，包括获取 (socket 读)、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理。</text><text id="kity_text_9056" text-rendering="inherit" font-size="12" dy=".8em" y="-72.29999995231628" x="548.5">但从Redis4.0之后除了主线程外，也有后台线程在处理一些较为缓慢的操作，如清理脏数据、无用连接的释放、大 key 的删除等等。</text><text id="kity_text_9057" text-rendering="inherit" font-size="12" dy=".8em" y="-54.299999952316284" x="548.5">2.</text><text id="kity_text_9058" text-rendering="inherit" font-size="12" dy=".8em" y="-36.299999952316284" x="548.5">&#xa0;Redis的瓶颈主要受限于内存和网络。就算大量请求，Redis通过使用pipelining每秒可以处理100万个请求</text><text id="kity_text_9059" text-rendering="inherit" font-size="12" dy=".8em" y="-18.299999952316284" x="548.5">&#xa0;再说单线程的优点：可维护性高，没有并发读写的系列问题。增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗</text><text id="kity_text_9060" text-rendering="inherit" font-size="12" dy=".8em" y="-0.2999999523162842" x="548.5"> </text></g></g><g id="minder_node773" display="none"><g id="node_expander770" display="none" style="cursor: pointer;"><path id="kity_path_22832" fill="white" stroke="gray" d="M532.5,-38.5A6,6,0,1,1,520.5,-38.5A6,6,0,1,1,532.5,-38.5"></path><path id="kity_path_22833" fill="none" stroke="gray"></path></g><path id="node_outline771" fill="none" stroke="none" d="M532.5,-47.5h241a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-241a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text771" fill="black"><text id="kity_text_9070" text-rendering="inherit" font-size="12" dy=".8em" y="-46.299999952316284" x="532.5">默认开启单线程吗，为什么又使用多线程呢？</text></g></g><g id="minder_node774" display="none"><g id="node_expander769" display="none" style="cursor: pointer;"><path id="kity_path_22829" fill="white" stroke="gray" d="M548.5,-38.5A6,6,0,1,1,536.5,-38.5A6,6,0,1,1,548.5,-38.5"></path><path id="kity_path_22830" fill="none" stroke="gray"></path></g><path id="node_outline770" fill="none" stroke="none" d="M548.5,-83.5h619a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-619a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text770" fill="black"><text id="kity_text_9064" text-rendering="inherit" font-size="12" dy=".8em" y="-82.29999995231628" x="548.5">1.</text><text id="kity_text_9065" text-rendering="inherit" font-size="12" dy=".8em" y="-64.29999995231628" x="548.5">默认是禁用的，只使用主线程。开启需要修改redis.conf配置文件：io-threads-do-reads yes</text><text id="kity_text_9066" text-rendering="inherit" font-size="12" dy=".8em" y="-46.299999952316284" x="548.5">2.</text><text id="kity_text_9067" text-rendering="inherit" font-size="12" dy=".8em" y="-28.299999952316284" x="548.5">因为对于复杂的业务场景，更大的QPS，以前一般都是集群，这样会带来很多问题，</text><text id="kity_text_9068" text-rendering="inherit" font-size="12" dy=".8em" y="-10.299999952316284" x="548.5">而多线程可以充分利用服务器 CPU 资源，目前主线程只能利用一个核，多线程任务可以分摊 Redis 同步 IO 读写负荷</text></g></g><g id="minder_node775" display="none"><g id="node_expander773" display="none" style="cursor: pointer;"><path id="kity_path_22841" fill="white" stroke="gray" d="M532.5,-30.5A6,6,0,1,1,520.5,-30.5A6,6,0,1,1,532.5,-30.5"></path><path id="kity_path_22842" fill="none" stroke="gray"></path></g><path id="node_outline774" fill="none" stroke="none" d="M532.5,-39.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text774" fill="black"><text id="kity_text_9077" text-rendering="inherit" font-size="12" dy=".8em" y="-38.299999952316284" x="532.5">实现机制说说？</text></g></g><g id="minder_node776" display="none"><g id="node_expander772" display="none" style="cursor: pointer;"><path id="kity_path_22838" fill="white" stroke="gray" d="M548.5,-30.5A6,6,0,1,1,536.5,-30.5A6,6,0,1,1,548.5,-30.5"></path><path id="kity_path_22839" fill="none" stroke="gray"></path></g><path id="node_outline773" fill="none" stroke="none" d="M548.5,-48.5h951a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-951a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text773" fill="black"><text id="kity_text_9074" text-rendering="inherit" font-size="12" dy=".8em" y="-47.299999952316284" x="548.5">1.在读解析socket请求 和回写都是并行的，提升了效率</text><text id="kity_text_9075" text-rendering="inherit" font-size="12" dy=".8em" y="-29.299999952316284" x="548.5">2.redis 6.0 中，多线程主要用于网络 I/O 阶段，也就是接收命令和写回结果阶段，而在执行命令阶段，还是由单线程串行执行。由于执行时还是串行，因此无需考虑并发安全问题。</text></g></g><g id="minder_node777" display="none"><g id="node_expander771" display="none" style="cursor: pointer;"><path id="kity_path_22835" fill="white" stroke="gray" d="M564.5,-30.5A6,6,0,1,1,552.5,-30.5A6,6,0,1,1,564.5,-30.5"></path><path id="kity_path_22836" fill="none" stroke="gray"></path></g><path id="node_outline772" fill="none" stroke="none" d="M511.5,-249.5h161a5,5,0,0,1,5,5v223a5,5,0,0,1,-5,5h-161a5,5,0,0,1,-5,-5v-223a5,5,0,0,1,5,-5z"></path><g id="node_text772" fill="black"><text id="kity_text_9072" text-rendering="inherit" font-size="12" dy=".8em" y="-38.299999952316284" x="564.5">流程</text></g><a id="kity_a_16898" xlink:href="https://www.cnblogs.com/madashu/p/12832766.html" target="_blank" xlink:title="https://www.cnblogs.com/madashu/p/12832766.html" style="cursor: pointer;"><path id="kity_path_16900" fill="rgba(255, 255, 255, 0)" stroke="none" d="M599.5,-41.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16899" fill="#666" stroke="none" d="M614.114,-25.276h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V-31.666c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C609.766,-34.429,611.168,-35.5,612.836,-35.5h1.278c2.116,0,3.834,1.716,3.834,3.834V-29.11C617.948,-26.992,616.23,-25.276,614.114,-25.276zM602.612,-30.387999999999998c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S612.265,-29.11,611.558,-29.11H603.89C603.185,-29.11,602.612,-29.681,602.612,-30.387999999999998zM600.056,-31.666V-29.11c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H601.334C599.216,-25.276,597.5,-26.992,597.5,-29.11V-31.666C597.5,-33.784,599.216,-35.5,601.334,-35.5h1.278c1.667,0,3.071,1.071,3.599,2.556H601.334C600.629,-32.944,600.056,-32.373,600.056,-31.666z"></path></a><image id="kity_image_17039" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210321185349.png" x="511.5" y="-246.5" width="161" height="200"></image></g><g id="minder_node778" display="none"><g id="node_expander775" display="none" style="cursor: pointer;"><path id="kity_path_22847" fill="white" stroke="gray" d="M532.5,-22.5A6,6,0,1,1,520.5,-22.5A6,6,0,1,1,532.5,-22.5"></path><path id="kity_path_22848" fill="none" stroke="gray"></path></g><path id="node_outline776" fill="none" stroke="none" d="M532.5,-31.5h175a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-175a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text776" fill="black"><text id="kity_text_9082" text-rendering="inherit" font-size="12" dy=".8em" y="-30.299999952316284" x="532.5">redis6.0和memcached的比较？</text></g></g><g id="minder_node779" display="none"><g id="node_expander774" display="none" style="cursor: pointer;"><path id="kity_path_22844" fill="white" stroke="gray" d="M548.5,-22.5A6,6,0,1,1,536.5,-22.5A6,6,0,1,1,548.5,-22.5"></path><path id="kity_path_22845" fill="none" stroke="gray"></path></g><path id="node_outline775" fill="none" stroke="none" d="M548.5,-40.5h1310a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1310a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text775" fill="black"><text id="kity_text_9079" text-rendering="inherit" font-size="12" dy=".8em" y="-39.299999952316284" x="548.5">相同点：都采用了 master线程-worker 线程的模型</text><text id="kity_text_9080" text-rendering="inherit" font-size="12" dy=".8em" y="-21.299999952316284" x="548.5">不同点：Memcached 执行主逻辑也是在 worker 线程里，模型更加简单，实现了真正的线程隔离，符合我们对线程隔离的常规理解。而 Redis 把处理逻辑交还给 master 线程，虽然一定程度上增加了模型复杂度，但也解决了线程并发安全等问题。</text></g></g><g id="minder_node780" display="none"><g id="node_expander778" display="none" style="cursor: pointer;"><path id="kity_path_22856" fill="white" stroke="gray" d="M516.5,-14.5A6,6,0,1,1,504.5,-14.5A6,6,0,1,1,516.5,-14.5"></path><path id="kity_path_22857" fill="none" stroke="gray"></path></g><path id="node_outline779" fill="none" stroke="none" d="M516.5,-23.5h100a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-100a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text779" fill="black"><text id="kity_text_9090" text-rendering="inherit" font-size="12" dy=".8em" y="-22.299999952316284" x="516.5">redis为什么那么快</text></g></g><g id="minder_node781" display="none"><g id="node_expander777" display="none" style="cursor: pointer;"><path id="kity_path_22853" fill="white" stroke="gray" d="M532.5,-14.5A6,6,0,1,1,520.5,-14.5A6,6,0,1,1,532.5,-14.5"></path><path id="kity_path_22854" fill="none" stroke="gray"></path></g><path id="node_outline778" fill="none" stroke="none" d="M532.5,-41.5h1144a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1144a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text778" fill="black"><text id="kity_text_9086" text-rendering="inherit" font-size="12" dy=".8em" y="-40.299999952316284" x="532.5">- Redis由多路复用程序+事件分发器+事件处理器构成，其IO事件处理在单线程下运行，通过多路复用支持多个client的并发请求，但是执行的时候onebyone的执行，不存在任何的事务性竞争和线程上下文切换等开销</text><text id="kity_text_9087" text-rendering="inherit" font-size="12" dy=".8em" y="-22.299999952316284" x="532.5"> - 整个数据库放在内存中，在启动后不依赖持久化在磁盘的数据，IO开销对rt基本无影响</text><text id="kity_text_9088" text-rendering="inherit" font-size="12" dy=".8em" y="-4.299999952316284" x="532.5"> - 仅支持简单数据结构，减少序列化相关的cpu影响</text></g></g><g id="minder_node782" display="none"><g id="node_expander780" display="none" style="cursor: pointer;"><path id="kity_path_22862" fill="white" stroke="gray" d="M516.5,-6.5A6,6,0,1,1,504.5,-6.5A6,6,0,1,1,516.5,-6.5"></path><path id="kity_path_22863" fill="none" stroke="gray"></path></g><path id="node_outline781" fill="none" stroke="none" d="M516.5,-15.5h136a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-136a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text781" fill="black"><text id="kity_text_9105" text-rendering="inherit" font-size="12" dy=".8em" y="-14.299999952316284" x="516.5">redis的基础命令说几个？</text></g></g><g id="minder_node783" display="none"><g id="node_expander779" display="none" style="cursor: pointer;"><path id="kity_path_22859" fill="white" stroke="gray" d="M532.5,-6.5A6,6,0,1,1,520.5,-6.5A6,6,0,1,1,532.5,-6.5"></path><path id="kity_path_22860" fill="none" stroke="gray"></path></g><path id="node_outline780" fill="none" stroke="none" d="M532.5,-114.5h1362a5,5,0,0,1,5,5v206a5,5,0,0,1,-5,5h-1362a5,5,0,0,1,-5,-5v-206a5,5,0,0,1,5,-5z"></path><g id="node_text780" fill="black"><text id="kity_text_9092" text-rendering="inherit" font-size="12" dy=".8em" y="-113.29999995231628" x="532.5">1.redis方面</text><text id="kity_text_9093" text-rendering="inherit" font-size="12" dy=".8em" y="-95.29999995231628" x="532.5">expire key 20	设置过期时间 - 秒。move kxm 2	移动key到指定位置库中 2号库。persist key移除过期时间。ttl key秒为单位，返回给定 key 的剩余生存时间。randomkey	从当前数据库中随机返回一个 key。select 0	选择第一个库</text><text id="kity_text_9094" text-rendering="inherit" font-size="12" dy=".8em" y="-77.29999995231628" x="532.5">2.字符串方面</text><text id="kity_text_9095" text-rendering="inherit" font-size="12" dy=".8em" y="-59.299999952316284" x="532.5">setnx test test	只有在 key 不存在时设置 key 的值。incr key	将 key 中储存的数字值增1 相反是decr key。incrby num 1000	将 key 中储存的数字值增指定的值，相反操作是 decrby num 500。append key 11 如果key是字符串，追加到原key后面</text><text id="kity_text_9096" text-rendering="inherit" font-size="12" dy=".8em" y="-41.299999952316284" x="532.5">3.hash方面</text><text id="kity_text_9097" text-rendering="inherit" font-size="12" dy=".8em" y="-23.299999952316284" x="532.5">hexistskey field 指定的字段是否存在。hkeys hash 获取所有哈希表中的字段。hgetall key 获取在哈希表中指定 key 的所有字段和值。</text><text id="kity_text_9098" text-rendering="inherit" font-size="12" dy=".8em" y="-5.299999952316284" x="532.5">4.list</text><text id="kity_text_9099" text-rendering="inherit" font-size="12" dy=".8em" y="12.700000047683716" x="532.5">lpush list xxx将一个值插入到列表头部 。blpop key1 [key2 ] timeout移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。lpop list 移出并获取列表的第一个元素。lrange list 0 1 获取列表指定范围内的元素。</text><text id="kity_text_9100" text-rendering="inherit" font-size="12" dy=".8em" y="30.700000047683716" x="532.5">5.set</text><text id="kity_text_9101" text-rendering="inherit" font-size="12" dy=".8em" y="48.700000047683716" x="532.5">sadd set xxx 添加成员。sinter set newset 返回给定所有集合的交集。srandmember set 2。spop set。</text><text id="kity_text_9102" text-rendering="inherit" font-size="12" dy=".8em" y="66.70000004768372" x="532.5">6.zset</text><text id="kity_text_9103" text-rendering="inherit" font-size="12" dy=".8em" y="84.70000004768372" x="532.5">zadd sort 1 java 添加成员，或者更新已存在成员的分数。zincrby sort 500 java 对指定成员的分数加上增量increment。zrangebyscore sort 0 5 limit 0 1 分页 limit 0代表页码，1代表每页显示数量。zrevrank sort xxx 返回指定成员的排名，按分数值递减</text></g></g><g id="minder_node784" display="none"><g id="node_expander782" display="none" style="cursor: pointer;"><path id="kity_path_22868" fill="white" stroke="gray" d="M516.5,1.5A6,6,0,1,1,504.5,1.5A6,6,0,1,1,516.5,1.5"></path><path id="kity_path_22869" fill="none" stroke="gray"></path></g><path id="node_outline783" fill="none" stroke="none" d="M516.5,-7.5h124a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-124a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text783" fill="black"><text id="kity_text_9123" text-rendering="inherit" font-size="12" dy=".8em" y="-6.299999952316284" x="516.5">redis的基本数据结构？</text></g></g><g id="minder_node785" display="none"><g id="node_expander781" display="none" style="cursor: pointer;"><path id="kity_path_22865" fill="white" stroke="gray" d="M532.5,1.5A6,6,0,1,1,520.5,1.5A6,6,0,1,1,532.5,1.5"></path><path id="kity_path_22866" fill="none" stroke="gray"></path></g><path id="node_outline782" fill="none" stroke="none" d="M532.5,-133.5h1455a5,5,0,0,1,5,5v260a5,5,0,0,1,-5,5h-1455a5,5,0,0,1,-5,-5v-260a5,5,0,0,1,5,-5z"></path><g id="node_text782" fill="black"><text id="kity_text_9107" text-rendering="inherit" font-size="12" dy=".8em" y="-132.29999995231628" x="532.5">1.string</text><text id="kity_text_9108" text-rendering="inherit" font-size="12" dy=".8em" y="-114.29999995231628" x="532.5">key-value存储,源码中用SDS封装char[]，sds是Redis存储的最小单元，一个SDS最大可以存储512M。写入重复的key前值会被覆盖</text><text id="kity_text_9109" text-rendering="inherit" font-size="12" dy=".8em" y="-96.29999995231628" x="532.5">string是二进制安全可以包含任何数据。比如jpg图片或者序列化的对象。</text><text id="kity_text_9110" text-rendering="inherit" font-size="12" dy=".8em" y="-78.29999995231628" x="532.5">2.list</text><text id="kity_text_9111" text-rendering="inherit" font-size="12" dy=".8em" y="-60.299999952316284" x="532.5">底层是双端链表,每个列表存超40亿元素.常见组合 lpush + lpop = stack 先进后出的栈。lpush + rpop = queue 先进先出的队列。 lpush + brpop = message queue 简单消息队列</text><text id="kity_text_9112" text-rendering="inherit" font-size="12" dy=".8em" y="-42.299999952316284" x="532.5">数据量小的时候可能用压缩列表来提升性能</text><text id="kity_text_9113" text-rendering="inherit" font-size="12" dy=".8em" y="-24.299999952316284" x="532.5">3.hash</text><text id="kity_text_9114" text-rendering="inherit" font-size="12" dy=".8em" y="-6.299999952316284" x="532.5">底层主要是采用字典dict层层封装， K必须字符串对象，V 可以是String、List、Hash、Set、ZSet任意一种。最底层是dictEntry存K，V，next然后是存entry的dictht链表再然后是dict。dict有一个rehashidx 标志量-1说明当前没有扩容，不为 -1 则记录扩容到数组哪个位置。</text><text id="kity_text_9115" text-rendering="inherit" font-size="12" dy=".8em" y="11.700000047683716" x="532.5">采用渐进式扩容。和hashmap差不多，扩容以后，挨个遍历数组同时调整rehashidx的值，对每个dictEntry[i] 再挨个遍历链表将数据 Hash 后重新映射到 dictht[1]里面。</text><text id="kity_text_9116" text-rendering="inherit" font-size="12" dy=".8em" y="29.700000047683716" x="532.5">如果当前内存不够，扩容的过程可以随时停止。之后对对象的操作为 如果是新增，则直接新增后第二个数组 如果是删除，更新，查询，则先查找第一个数组，如果没找到，则再查询第二个数组。</text><text id="kity_text_9117" text-rendering="inherit" font-size="12" dy=".8em" y="47.700000047683716" x="532.5">键冲突的问题，哈希表使用链地址法来解决。同一个索引上的多个节点连接起来。hash扩展和收缩，通过rehash(重新散列)来执行</text><text id="kity_text_9118" text-rendering="inherit" font-size="12" dy=".8em" y="65.70000004768372" x="532.5">4.set</text><text id="kity_text_9119" text-rendering="inherit" font-size="12" dy=".8em" y="83.70000004768372" x="532.5">String元素组成的无序集合，通过哈希表实现（增删改查时间复杂度为O(1)），不允许重复。可以对set提供了求交集、并集、差集等操作，可以实现如同共同关注，共同好友等功能。</text><text id="kity_text_9120" text-rendering="inherit" font-size="12" dy=".8em" y="101.70000004768372" x="532.5">5.zset</text><text id="kity_text_9121" text-rendering="inherit" font-size="12" dy=".8em" y="119.70000004768372" x="532.5">和set差不多，zset成员唯一,score可以重复。Zset通过跳表来实现有序。跳表就是多层链表的结合体，跳表分为许多层(level)，每一层都可以看作是数据的索引，这些索引的意义就是加快跳表查找数据速度。</text></g></g><g id="minder_node786" display="none"><g id="node_expander785" display="none" style="cursor: pointer;"><path id="kity_path_22877" fill="white" stroke="gray" d="M516.5,9.5A6,6,0,1,1,504.5,9.5A6,6,0,1,1,516.5,9.5"></path><path id="kity_path_22878" fill="none" stroke="gray"></path></g><path id="node_outline786" fill="none" stroke="none" d="M516.5,0.5h97a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-97a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text786" fill="black"><text id="kity_text_9131" text-rendering="inherit" font-size="12" dy=".8em" y="1.7000000476837158" x="516.5">其它数据类型呢？</text></g></g><g id="minder_node787" display="none"><g id="node_expander784" display="none" style="cursor: pointer;"><path id="kity_path_22874" fill="white" stroke="gray" d="M532.5,9.5A6,6,0,1,1,520.5,9.5A6,6,0,1,1,532.5,9.5"></path><path id="kity_path_22875" fill="none" stroke="gray"></path></g><path id="node_outline785" fill="none" stroke="none" d="M532.5,-17.5h1022a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1022a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text785" fill="black"><text id="kity_text_9127" text-rendering="inherit" font-size="12" dy=".8em" y="-16.299999952316284" x="532.5">1.bitmap位图，二进制，就只有0和1两个状态。比如可以记录打卡，0是打卡 1是没打卡。统计用户信息 (所以bitcount统计key的1数) ，用户活跃状态 ，setbit设置， getbit获取&#xa0; bitcount统计</text><text id="kity_text_9128" text-rendering="inherit" font-size="12" dy=".8em" y="1.7000000476837158" x="532.5">2.Hyperloglog 基数统计。用来统计一个集合中不重复的元素个数。比如统计某个文章的独立访客(一个人访问一个网站多次，但是还是算作一个人)，也就是客户端的ip</text><text id="kity_text_9129" text-rendering="inherit" font-size="12" dy=".8em" y="19.700000047683716" x="532.5">3.Geospatial 地理位置。可以推算出地理位置的信息，两地之间的距离，方圆几里的人。底层是zset</text></g></g><g id="minder_node788" display="none"><g id="node_expander783" display="none" style="cursor: pointer;"><path id="kity_path_22871" fill="white" stroke="gray" d="M548.5,9.5A6,6,0,1,1,536.5,9.5A6,6,0,1,1,548.5,9.5"></path><path id="kity_path_22872" fill="none" stroke="gray"></path></g><path id="node_outline784" fill="none" stroke="none" d="M548.5,0.5h374a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-374a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text784" fill="black"><text id="kity_text_9125" text-rendering="inherit" font-size="12" dy=".8em" y="1.7000000476837158" x="548.5">https://blog.csdn.net/weixin_43246215/article/details/108041739</text></g></g><g id="minder_node789" display="none"><g id="node_expander791" display="none" style="cursor: pointer;"><path id="kity_path_22895" fill="white" stroke="gray" d="M516.5,17.5A6,6,0,1,1,504.5,17.5A6,6,0,1,1,516.5,17.5"></path><path id="kity_path_22896" fill="none" stroke="gray"></path></g><path id="node_outline792" fill="none" stroke="none" d="M516.5,8.5h136a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-136a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text792" fill="black"><text id="kity_text_9153" text-rendering="inherit" font-size="12" dy=".8em" y="9.700000047683716" x="516.5">redis的数据结构使用场景</text></g></g><g id="minder_node790" display="none"><g id="node_expander790" display="none" style="cursor: pointer;"><path id="kity_path_22892" fill="white" stroke="gray" d="M532.5,17.5A6,6,0,1,1,520.5,17.5A6,6,0,1,1,532.5,17.5"></path><path id="kity_path_22893" fill="none" stroke="gray"></path></g><path id="node_outline791" fill="none" stroke="none" d="M532.5,-81.5h1061a5,5,0,0,1,5,5v188a5,5,0,0,1,-5,5h-1061a5,5,0,0,1,-5,-5v-188a5,5,0,0,1,5,-5z"></path><g id="node_text791" fill="black"><text id="kity_text_9141" text-rendering="inherit" font-size="12" dy=".8em" y="-80.29999995231628" x="532.5">1.string</text><text id="kity_text_9142" text-rendering="inherit" font-size="12" dy=".8em" y="-62.299999952316284" x="532.5">通过设置过期时间 时效信息存储，如token,验证码。还有如 商品库存数，商品的浏览次数，问题或者回复的点赞次数等。这种计数的场景都可以考虑利用 Redis 来实现。还有集群下的session共享问题</text><text id="kity_text_9143" text-rendering="inherit" font-size="12" dy=".8em" y="-44.299999952316284" x="532.5">2.hash</text><text id="kity_text_9144" text-rendering="inherit" font-size="12" dy=".8em" y="-26.299999952316284" x="532.5">存储对象（例如：用户信息，产品数据信息，）的时候需要对对象进行序列化转换然后存储。也可以通过转json来存储</text><text id="kity_text_9145" text-rendering="inherit" font-size="12" dy=".8em" y="-8.299999952316284" x="532.5">3.list</text><text id="kity_text_9146" text-rendering="inherit" font-size="12" dy=".8em" y="9.700000047683716" x="532.5">最新上架商品，TOP100等，通过&#xa0; ltrim 指令对一个列表进行修剪</text><text id="kity_text_9147" text-rendering="inherit" font-size="12" dy=".8em" y="27.700000047683716" x="532.5">4.set</text><text id="kity_text_9148" text-rendering="inherit" font-size="12" dy=".8em" y="45.700000047683716" x="532.5">set 有去重功能，还可以求交集，并集，差集，就可以 共同关注好友，相似兴趣 tag 等场景的支持。计算相似产品信息等</text><text id="kity_text_9149" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="532.5">交集sinter setA setB。并集sunion setA setB。差集sdiff setA setB</text><text id="kity_text_9150" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="532.5">5.zset</text><text id="kity_text_9151" text-rendering="inherit" font-size="12" dy=".8em" y="99.70000004768372" x="532.5">常用于排行榜，如视频网站需要对用户上传视频做排行榜，或点赞数与集合有联系，不能有重复的成员，积分排行榜、时间排序新闻、延时队列。</text></g></g><g id="minder_node791" display="none"><g id="node_expander789" display="none" style="cursor: pointer;"><path id="kity_path_22889" fill="white" stroke="gray" d="M548.5,17.5A6,6,0,1,1,536.5,17.5A6,6,0,1,1,548.5,17.5"></path><path id="kity_path_22890" fill="none" stroke="gray"></path></g><path id="node_outline790" fill="none" stroke="none" d="M548.5,3.5h53a5,5,0,0,1,5,5v18a5,5,0,0,1,-5,5h-53a5,5,0,0,1,-5,-5v-18a5,5,0,0,1,5,-5z"></path><g id="node_text790" fill="black"><text id="kity_text_9139" text-rendering="inherit" font-size="12" dy=".8em" y="9.700000047683716" x="548.5">参考</text></g><a id="kity_a_16901" xlink:href="https://juejin.cn/post/6861803669898133517#comment" target="_blank" xlink:title="https://juejin.cn/post/6861803669898133517#comment" style="cursor: pointer;"><path id="kity_path_16903" fill="rgba(255, 255, 255, 0)" stroke="none" d="M581.5,6.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16902" fill="#666" stroke="none" d="M596.114,22.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V16.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C591.766,13.571,593.168,12.5,594.836,12.5h1.278c2.116,0,3.834,1.716,3.834,3.834V18.89C599.948,21.008,598.23,22.724,596.114,22.724zM584.612,17.612000000000002c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S594.265,18.89,593.558,18.89H585.89C585.185,18.89,584.612,18.319,584.612,17.612000000000002zM582.056,16.334V18.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H583.334C581.216,22.724,579.5,21.008,579.5,18.89V16.334C579.5,14.216,581.216,12.5,583.334,12.5h1.278c1.667,0,3.071,1.071,3.599,2.556H583.334C582.629,15.056000000000001,582.056,15.626999999999999,582.056,16.334z"></path></a></g><g id="minder_node792" display="none"><g id="node_expander786" display="none" style="cursor: pointer;"><path id="kity_path_22880" fill="white" stroke="gray" d="M564.5,1.5A6,6,0,1,1,552.5,1.5A6,6,0,1,1,564.5,1.5"></path><path id="kity_path_22881" fill="none" stroke="gray"></path></g><path id="node_outline787" fill="none" stroke="none" d="M489.5,-137.5h200a5,5,0,0,1,5,5v138a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-138a5,5,0,0,1,5,-5z"></path><g id="node_text787" fill="black"><text id="kity_text_9133" text-rendering="inherit" font-size="12" dy=".8em" y="-6.299999952316284" x="564.5">分支主题</text></g><image id="kity_image_17040" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210321233640.png" x="489.5" y="-134.5" width="200" height="125"></image></g><g id="minder_node793" display="none"><g id="node_expander787" display="none" style="cursor: pointer;"><path id="kity_path_22883" fill="white" stroke="gray" d="M564.5,9.5A6,6,0,1,1,552.5,9.5A6,6,0,1,1,564.5,9.5"></path><path id="kity_path_22884" fill="none" stroke="gray"></path></g><path id="node_outline788" fill="none" stroke="none" d="M489.5,-117.5h200a5,5,0,0,1,5,5v126a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-126a5,5,0,0,1,5,-5z"></path><g id="node_text788" fill="black"><text id="kity_text_9135" text-rendering="inherit" font-size="12" dy=".8em" y="1.7000000476837158" x="564.5">分支主题</text></g><image id="kity_image_17041" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210321233714.png" x="489.5" y="-114.5" width="200" height="113"></image></g><g id="minder_node794" display="none"><g id="node_expander788" display="none" style="cursor: pointer;"><path id="kity_path_22886" fill="white" stroke="gray" d="M564.5,17.5A6,6,0,1,1,552.5,17.5A6,6,0,1,1,564.5,17.5"></path><path id="kity_path_22887" fill="none" stroke="gray"></path></g><path id="node_outline789" fill="none" stroke="none" d="M489.5,-92.5h200a5,5,0,0,1,5,5v109a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-109a5,5,0,0,1,5,-5z"></path><g id="node_text789" fill="black"><text id="kity_text_9137" text-rendering="inherit" font-size="12" dy=".8em" y="9.700000047683716" x="564.5">分支主题</text></g><image id="kity_image_17042" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210321233739.png" x="489.5" y="-89.5" width="200" height="96"></image></g><g id="minder_node795" display="none"><g id="node_expander794" display="none" style="cursor: pointer;"><path id="kity_path_22904" fill="white" stroke="gray" d="M516.5,25.5A6,6,0,1,1,504.5,25.5A6,6,0,1,1,516.5,25.5"></path><path id="kity_path_22905" fill="none" stroke="gray"></path></g><path id="node_outline795" fill="none" stroke="none" d="M516.5,16.5h292a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-292a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text795" fill="black"><text id="kity_text_9161" text-rendering="inherit" font-size="12" dy=".8em" y="17.700000047683716" x="516.5">说说数据结构中的string底层是怎么样的?其他有了解？</text></g></g><g id="minder_node796" display="none"><g id="node_expander793" display="none" style="cursor: pointer;"><path id="kity_path_22901" fill="white" stroke="gray" d="M532.5,25.5A6,6,0,1,1,520.5,25.5A6,6,0,1,1,532.5,25.5"></path><path id="kity_path_22902" fill="none" stroke="gray"></path></g><path id="node_outline794" fill="none" stroke="none" d="M532.5,-1.5h875a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-875a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text794" fill="black"><text id="kity_text_9157" text-rendering="inherit" font-size="12" dy=".8em" y="-0.2999999523162842" x="532.5">1.redis构建了一种简单动态字符串SDS的抽象类型，作为Redis的默认字符串表示。Redis中包含字符串值的键值对底层都是用SDS实现的(K-V中的K),</text><text id="kity_text_9158" text-rendering="inherit" font-size="12" dy=".8em" y="17.700000047683716" x="532.5">SDS有5种数据结构，根据存储的内容长度来选择不同的结构，节省内存。</text><text id="kity_text_9159" text-rendering="inherit" font-size="12" dy=".8em" y="35.700000047683716" x="532.5">SDS的优点是 常数复杂度获取字符串长度，API是安全的，不会造成缓冲区溢出，减少修改字符串时带来的内存重分配次数，二进制安全，可以保存文本或二进制数据</text></g></g><g id="minder_node797" display="none"><g id="node_expander792" display="none" style="cursor: pointer;"><path id="kity_path_22898" fill="white" stroke="gray" d="M548.5,25.5A6,6,0,1,1,536.5,25.5A6,6,0,1,1,548.5,25.5"></path><path id="kity_path_22899" fill="none" stroke="gray"></path></g><path id="node_outline793" fill="none" stroke="none" d="M548.5,11.5h126a5,5,0,0,1,5,5v18a5,5,0,0,1,-5,5h-126a5,5,0,0,1,-5,-5v-18a5,5,0,0,1,5,-5z"></path><g id="node_text793" fill="black"><text id="kity_text_9155" text-rendering="inherit" font-size="12" dy=".8em" y="17.700000047683716" x="548.5">其他底层结构参考</text></g><a id="kity_a_16904" xlink:href="https://juejin.cn/post/6844903936520880135#heading-15" target="_blank" xlink:title="https://juejin.cn/post/6844903936520880135#heading-15" style="cursor: pointer;"><path id="kity_path_16906" fill="rgba(255, 255, 255, 0)" stroke="none" d="M654.5,14.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16905" fill="#666" stroke="none" d="M669.114,30.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V24.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C664.766,21.571,666.168,20.5,667.836,20.5h1.278c2.116,0,3.834,1.716,3.834,3.834V26.89C672.948,29.008,671.23,30.724,669.114,30.724zM657.612,25.612000000000002c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S667.265,26.89,666.558,26.89H658.89C658.185,26.89,657.612,26.319,657.612,25.612000000000002zM655.056,24.334V26.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H656.334C654.216,30.724,652.5,29.008,652.5,26.89V24.334C652.5,22.216,654.216,20.5,656.334,20.5h1.278c1.667,0,3.071,1.071,3.599,2.556H656.334C655.629,23.056,655.056,23.627,655.056,24.334z"></path></a></g><g id="minder_node798" display="none"><g id="node_expander796" display="none" style="cursor: pointer;"><path id="kity_path_22910" fill="white" stroke="gray" d="M516.5,33.5A6,6,0,1,1,504.5,33.5A6,6,0,1,1,516.5,33.5"></path><path id="kity_path_22911" fill="none" stroke="gray"></path></g><path id="node_outline797" fill="none" stroke="none" d="M516.5,24.5h194a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-194a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text797" fill="black"><text id="kity_text_9172" text-rendering="inherit" font-size="12" dy=".8em" y="25.700000047683716" x="516.5">redis底层 hash 表扩容机制说一下？</text></g></g><g id="minder_node799" display="none"><g id="node_expander795" display="none" style="cursor: pointer;"><path id="kity_path_22907" fill="white" stroke="gray" d="M532.5,33.5A6,6,0,1,1,520.5,33.5A6,6,0,1,1,532.5,33.5"></path><path id="kity_path_22908" fill="none" stroke="gray"></path></g><path id="node_outline796" fill="none" stroke="none" d="M532.5,-38.5h1000a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-1000a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text796" fill="black"><text id="kity_text_9163" text-rendering="inherit" font-size="12" dy=".8em" y="-37.299999952316284" x="532.5">1.</text><text id="kity_text_9164" text-rendering="inherit" font-size="12" dy=".8em" y="-19.299999952316284" x="532.5">先说说为什么会rehash，就和hashmap一样。主要是为了防止业务发展地址键冲突和空间浪费，需要做rehash再分配维持相应的扩展或者收缩，扩容内存大小时原来已使用数的2倍</text><text id="kity_text_9165" text-rendering="inherit" font-size="12" dy=".8em" y="-1.2999999523162842" x="532.5">从hash底层知道 有个关键的标志量rehashidx ，是否正在rehash就看是不是为-1，而rehash是在ht[1]上从新分配内存，将ht[0]的数据迁移到ht[1]</text><text id="kity_text_9166" text-rendering="inherit" font-size="12" dy=".8em" y="16.700000047683716" x="532.5">redis是用的渐进式rehash的过程不是一次完成的（避免 rehash 对服务器性能造成影响），而是在字典的读写操作，以及定时事件中每次完成一定量的迁移 执行一个键值从h[0]到h[1]的迁移</text><text id="kity_text_9167" text-rendering="inherit" font-size="12" dy=".8em" y="34.700000047683716" x="532.5">最后随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。</text><text id="kity_text_9168" text-rendering="inherit" font-size="12" dy=".8em" y="52.700000047683716" x="532.5">2.</text><text id="kity_text_9169" text-rendering="inherit" font-size="12" dy=".8em" y="70.70000004768372" x="532.5">当已使用的键值占比不到分配内存的0.1时，就进行内存收缩</text><text id="kity_text_9170" text-rendering="inherit" font-size="12" dy=".8em" y="88.70000004768372" x="532.5">https://juejin.cn/post/6882360168760213512#heading-4</text></g></g><g id="minder_node800" display="none"><g id="node_expander807" display="none" style="cursor: pointer;"><path id="kity_path_22943" fill="white" stroke="gray" d="M516.5,41.5A6,6,0,1,1,504.5,41.5A6,6,0,1,1,516.5,41.5"></path><path id="kity_path_22944" fill="none" stroke="gray"></path></g><path id="node_outline808" fill="none" stroke="none" d="M516.5,32.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text808" fill="black"><text id="kity_text_9212" text-rendering="inherit" font-size="12" dy=".8em" y="33.700000047683716" x="516.5">zset相关</text></g></g><g id="minder_node801" display="none"><g id="node_expander798" display="none" style="cursor: pointer;"><path id="kity_path_22916" fill="white" stroke="gray" d="M532.5,1.5A6,6,0,1,1,520.5,1.5A6,6,0,1,1,532.5,1.5"></path><path id="kity_path_22917" fill="none" stroke="gray"></path></g><path id="node_outline799" fill="none" stroke="none" d="M532.5,-7.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text799" fill="black"><text id="kity_text_9184" text-rendering="inherit" font-size="12" dy=".8em" y="-6.299999952316284" x="532.5">跳跃表的思想时怎样的？</text></g></g><g id="minder_node802" display="none"><g id="node_expander797" display="none" style="cursor: pointer;"><path id="kity_path_22913" fill="white" stroke="gray" d="M548.5,1.5A6,6,0,1,1,536.5,1.5A6,6,0,1,1,548.5,1.5"></path><path id="kity_path_22914" fill="none" stroke="gray"></path></g><path id="node_outline798" fill="none" stroke="none" d="M548.5,-79.5h1106a5,5,0,0,1,5,5v152a5,5,0,0,1,-5,5h-1106a5,5,0,0,1,-5,-5v-152a5,5,0,0,1,5,-5z"></path><g id="node_text798" fill="black"><text id="kity_text_9174" text-rendering="inherit" font-size="12" dy=".8em" y="-78.29999995231628" x="548.5">1.跳表(skiplist)就是多层的链表，是空间换时间。通过在每个节点维持多个指向其他节点的指针，而达到快速访问节点的目的。像有序链表 我们要查找最后一个元素，我们要O(n)复杂度，起码走一边，浪费时间</text><text id="kity_text_9175" text-rendering="inherit" font-size="12" dy=".8em" y="-60.299999952316284" x="548.5">结构：(1)多层链表结构，每层是一个有序的链表(2)最底层（level 1）的链表包含所有的元素，上一层数据是下一层数据的子集，层次越高，跳跃性越大，包含的数据越少。</text><text id="kity_text_9176" text-rendering="inherit" font-size="12" dy=".8em" y="-42.299999952316284" x="548.5">(3)跳跃表的查找次数近似于层数，时间复杂度为O(logn)，插入、删除也为 O(logn)(4)跳跃表是一种随机化的数据结构(通过抛硬币来决定元素上浮，也就是层数)。</text><text id="kity_text_9177" text-rendering="inherit" font-size="12" dy=".8em" y="-24.299999952316284" x="548.5">元素上浮：每隔一个元素，把它上浮(抛硬币的方式决定是否上浮到上一层链表)放到上一层的链表当中。</text><text id="kity_text_9178" text-rendering="inherit" font-size="12" dy=".8em" y="-6.299999952316284" x="548.5">查找顺序：查找数据时，是从上往下，从左往右进行查找。</text><text id="kity_text_9179" text-rendering="inherit" font-size="12" dy=".8em" y="11.700000047683716" x="548.5">2.增加和删除：</text><text id="kity_text_9180" text-rendering="inherit" font-size="12" dy=".8em" y="29.700000047683716" x="548.5">跳跃表节点的删除和添加都是不可预测的，很难保证跳表的索引是始终均匀的。通过抛硬币这种随机的方式来决定整个添加的元素是否上浮，</text><text id="kity_text_9181" text-rendering="inherit" font-size="12" dy=".8em" y="47.700000047683716" x="548.5">跳跃表的删除很简单，只要先找到要删除的节点，逐层删</text><text id="kity_text_9182" text-rendering="inherit" font-size="12" dy=".8em" y="65.70000004768372" x="548.5">3.25%的概率决定是否将单个节点放置到下一层</text></g></g><g id="minder_node803" display="none"><g id="node_expander800" display="none" style="cursor: pointer;"><path id="kity_path_22922" fill="white" stroke="gray" d="M532.5,9.5A6,6,0,1,1,520.5,9.5A6,6,0,1,1,532.5,9.5"></path><path id="kity_path_22923" fill="none" stroke="gray"></path></g><path id="node_outline801" fill="none" stroke="none" d="M532.5,0.5h108a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-108a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text801" fill="black"><text id="kity_text_9190" text-rendering="inherit" font-size="12" dy=".8em" y="1.7000000476837158" x="532.5">哪里有用到跳跃表？</text></g></g><g id="minder_node804" display="none"><g id="node_expander799" display="none" style="cursor: pointer;"><path id="kity_path_22919" fill="white" stroke="gray" d="M548.5,9.5A6,6,0,1,1,536.5,9.5A6,6,0,1,1,548.5,9.5"></path><path id="kity_path_22920" fill="none" stroke="gray"></path></g><path id="node_outline800" fill="none" stroke="none" d="M548.5,-17.5h894a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-894a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text800" fill="black"><text id="kity_text_9186" text-rendering="inherit" font-size="12" dy=".8em" y="-16.299999952316284" x="548.5">1.跳跃表是有序集合（Sorted Set）的底层实现之一，如果有序集合包含的元素比较多，或者元素的成员是比较长的字符串时，Redis会使用跳跃表做有序集合的底层实现</text><text id="kity_text_9187" text-rendering="inherit" font-size="12" dy=".8em" y="1.7000000476837158" x="548.5">2.当数据较少的时候，zset是由一个ziplist来实现的</text><text id="kity_text_9188" text-rendering="inherit" font-size="12" dy=".8em" y="19.700000047683716" x="548.5">当数据较多的时候，zset是一个由dict 和一个 skiplist来实现的，dict用来查询数据到分数的对应关系，而skiplist用来根据分数查询数据。</text></g></g><g id="minder_node805" display="none"><g id="node_expander802" display="none" style="cursor: pointer;"><path id="kity_path_22928" fill="white" stroke="gray" d="M532.5,17.5A6,6,0,1,1,520.5,17.5A6,6,0,1,1,532.5,17.5"></path><path id="kity_path_22929" fill="none" stroke="gray"></path></g><path id="node_outline803" fill="none" stroke="none" d="M532.5,-0.5h216a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-216a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text803" fill="black"><text id="kity_text_9201" text-rendering="inherit" font-size="12" dy=".8em" y="0.7000000476837158" x="532.5">zset为什么使用跳表 有什么优点？</text><text id="kity_text_9202" text-rendering="inherit" font-size="12" dy=".8em" y="18.700000047683716" x="532.5">zset为什么没有使用红黑树而使用跳表？</text></g></g><g id="minder_node806" display="none"><g id="node_expander801" display="none" style="cursor: pointer;"><path id="kity_path_22925" fill="white" stroke="gray" d="M548.5,17.5A6,6,0,1,1,536.5,17.5A6,6,0,1,1,548.5,17.5"></path><path id="kity_path_22926" fill="none" stroke="gray"></path></g><path id="node_outline802" fill="none" stroke="none" d="M548.5,-54.5h1484a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-1484a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text802" fill="black"><text id="kity_text_9192" text-rendering="inherit" font-size="12" dy=".8em" y="-53.299999952316284" x="548.5">1.</text><text id="kity_text_9193" text-rendering="inherit" font-size="12" dy=".8em" y="-35.299999952316284" x="548.5">时间复杂度优于有序链表，作者说 redis是单线程的，从内存占用、对范围查找的支持和实现难易程度选择跳表。用空间换时间，对于大量数据，还有压缩</text><text id="kity_text_9194" text-rendering="inherit" font-size="12" dy=".8em" y="-17.299999952316284" x="548.5">2.</text><text id="kity_text_9195" text-rendering="inherit" font-size="12" dy=".8em" y="0.7000000476837158" x="548.5">实现难易程度：平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</text><text id="kity_text_9196" text-rendering="inherit" font-size="12" dy=".8em" y="18.700000047683716" x="548.5">内存占用：skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</text><text id="kity_text_9197" text-rendering="inherit" font-size="12" dy=".8em" y="36.700000047683716" x="548.5">范围查找的支持：平衡树比skiplist操作要复杂。在平衡树上找到指定范围的小值之后，需中序遍历继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。</text><text id="kity_text_9198" text-rendering="inherit" font-size="12" dy=".8em" y="54.700000047683716" x="548.5">而skiplist上进行范围查找简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</text><text id="kity_text_9199" text-rendering="inherit" font-size="12" dy=".8em" y="72.70000004768372" x="548.5">从算法实现难度上来比较，skiplist比平衡树要简单得多。</text></g></g><g id="minder_node807" display="none"><g id="node_expander804" display="none" style="cursor: pointer;"><path id="kity_path_22934" fill="white" stroke="gray" d="M532.5,25.5A6,6,0,1,1,520.5,25.5A6,6,0,1,1,532.5,25.5"></path><path id="kity_path_22935" fill="none" stroke="gray"></path></g><path id="node_outline805" fill="none" stroke="none" d="M532.5,16.5h147a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-147a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text805" fill="black"><text id="kity_text_9206" text-rendering="inherit" font-size="12" dy=".8em" y="17.700000047683716" x="532.5">zset跳表 怎么增删说一下？</text></g></g><g id="minder_node808" display="none"><g id="node_expander803" display="none" style="cursor: pointer;"><path id="kity_path_22931" fill="white" stroke="gray" d="M548.5,25.5A6,6,0,1,1,536.5,25.5A6,6,0,1,1,548.5,25.5"></path><path id="kity_path_22932" fill="none" stroke="gray"></path></g><path id="node_outline804" fill="none" stroke="none" d="M548.5,16.5h238a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-238a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text804" fill="black"><text id="kity_text_9204" text-rendering="inherit" font-size="12" dy=".8em" y="17.700000047683716" x="548.5">https://zhuanlan.zhihu.com/p/148667260</text></g></g><g id="minder_node809" display="none"><g id="node_expander805" display="none" style="cursor: pointer;"><path id="kity_path_22937" fill="white" stroke="gray" d="M532.5,33.5A6,6,0,1,1,520.5,33.5A6,6,0,1,1,532.5,33.5"></path><path id="kity_path_22938" fill="none" stroke="gray"></path></g><path id="node_outline806" fill="none" stroke="none" d="M532.5,24.5h120a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-120a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text806" fill="black"><text id="kity_text_9208" text-rendering="inherit" font-size="12" dy=".8em" y="25.700000047683716" x="532.5">多级索引是怎么更新的</text></g></g><g id="minder_node810" display="none"><g id="node_expander806" display="none" style="cursor: pointer;"><path id="kity_path_22940" fill="white" stroke="gray" d="M532.5,41.5A6,6,0,1,1,520.5,41.5A6,6,0,1,1,532.5,41.5"></path><path id="kity_path_22941" fill="none" stroke="gray"></path></g><path id="node_outline807" fill="none" stroke="none" d="M532.5,32.5h313a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-313a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text807" fill="black"><text id="kity_text_9210" text-rendering="inherit" font-size="12" dy=".8em" y="33.700000047683716" x="532.5">那怎么确定一个数据在第几层呢，各自的时间复杂度是多少</text></g></g><g id="minder_node811" display="none"><g id="node_expander810" display="none" style="cursor: pointer;"><path id="kity_path_22952" fill="white" stroke="gray" d="M516.5,49.5A6,6,0,1,1,504.5,49.5A6,6,0,1,1,516.5,49.5"></path><path id="kity_path_22953" fill="none" stroke="gray"></path></g><path id="node_outline811" fill="none" stroke="none" d="M516.5,40.5h289a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-289a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text811" fill="black"><text id="kity_text_9227" text-rendering="inherit" font-size="12" dy=".8em" y="41.700000047683716" x="516.5">给redis服务端发送get数据请求，是怎么样的一个过程</text></g></g><g id="minder_node812" display="none"><g id="node_expander809" display="none" style="cursor: pointer;"><path id="kity_path_22949" fill="white" stroke="gray" d="M532.5,49.5A6,6,0,1,1,520.5,49.5A6,6,0,1,1,532.5,49.5"></path><path id="kity_path_22950" fill="none" stroke="gray"></path></g><path id="node_outline810" fill="none" stroke="none" d="M532.5,-40.5h914a5,5,0,0,1,5,5v170a5,5,0,0,1,-5,5h-914a5,5,0,0,1,-5,-5v-170a5,5,0,0,1,5,-5z"></path><g id="node_text810" fill="black"><text id="kity_text_9216" text-rendering="inherit" font-size="12" dy=".8em" y="-39.299999952316284" x="532.5">1.客户端输入命令请求时，客户端会将这个命令请求转换成协议格式，然后通过连接到服务器的套接字，将协议格式的命令请求发送给服务器</text><text id="kity_text_9217" text-rendering="inherit" font-size="12" dy=".8em" y="-21.299999952316284" x="532.5">2.然后服务端读取客户端命令请求，</text><text id="kity_text_9218" text-rendering="inherit" font-size="12" dy=".8em" y="-3.299999952316284" x="532.5">①读取套接字中协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里面</text><text id="kity_text_9219" text-rendering="inherit" font-size="12" dy=".8em" y="14.700000047683716" x="532.5">②对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数，以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的argv属性和argc属性里面</text><text id="kity_text_9220" text-rendering="inherit" font-size="12" dy=".8em" y="32.700000047683716" x="532.5">③调用命令执行器，执行客户端指定的命令</text><text id="kity_text_9221" text-rendering="inherit" font-size="12" dy=".8em" y="50.700000047683716" x="532.5">3.命令执行器(1)：查找命令实现</text><text id="kity_text_9222" text-rendering="inherit" font-size="12" dy=".8em" y="68.70000004768372" x="532.5">4.命令执行器(2)：执行预备操作 保证命令可以正确、顺利地被执行，如身份验证，命令是否正确</text><text id="kity_text_9223" text-rendering="inherit" font-size="12" dy=".8em" y="86.70000004768372" x="532.5">5.命令执行器(3)：调用命令的实现函数</text><text id="kity_text_9224" text-rendering="inherit" font-size="12" dy=".8em" y="104.70000004768372" x="532.5">6.将命令回复发送给客户端</text><text id="kity_text_9225" text-rendering="inherit" font-size="12" dy=".8em" y="122.70000004768372" x="532.5">7.当客户端接收到协议格式的命令回复之后，它会将这些回复转换成人类可读的格式</text></g></g><g id="minder_node813" display="none"><g id="node_expander808" display="none" style="cursor: pointer;"><path id="kity_path_22946" fill="white" stroke="gray" d="M548.5,49.5A6,6,0,1,1,536.5,49.5A6,6,0,1,1,548.5,49.5"></path><path id="kity_path_22947" fill="none" stroke="gray"></path></g><path id="node_outline809" fill="none" stroke="none" d="M488.5,-113.5h200a5,5,0,0,1,5,5v167a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-167a5,5,0,0,1,5,-5z"></path><g id="node_text809" fill="black"><text id="kity_text_9214" text-rendering="inherit" font-size="12" dy=".8em" y="41.700000047683716" x="548.5">分支主题</text></g><a id="kity_a_16907" xlink:href="https://www.cnblogs.com/madashu/p/12832766.html" target="_blank" xlink:title="https://www.cnblogs.com/madashu/p/12832766.html" style="cursor: pointer;"><path id="kity_path_16909" fill="rgba(255, 255, 255, 0)" stroke="none" d="M607.5,38.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16908" fill="#666" stroke="none" d="M622.114,54.724000000000004h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V48.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C617.766,45.571,619.168,44.5,620.836,44.5h1.278c2.116,0,3.834,1.716,3.834,3.834V50.89C625.948,53.007999999999996,624.23,54.724000000000004,622.114,54.724000000000004zM610.612,49.612c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S620.265,50.89,619.558,50.89H611.89C611.185,50.89,610.612,50.319,610.612,49.612zM608.056,48.334V50.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H609.334C607.216,54.724000000000004,605.5,53.007999999999996,605.5,50.89V48.334C605.5,46.216,607.216,44.5,609.334,44.5h1.278c1.667,0,3.071,1.071,3.599,2.556H609.334C608.629,47.056,608.056,47.627,608.056,48.334z"></path></a><image id="kity_image_17043" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210322013332.png" x="488.5" y="-110.5" width="200" height="144"></image></g><g id="minder_node814" display="none"><g id="node_expander812" display="none" style="cursor: pointer;"><path id="kity_path_22958" fill="white" stroke="gray" d="M516.5,57.5A6,6,0,1,1,504.5,57.5A6,6,0,1,1,516.5,57.5"></path><path id="kity_path_22959" fill="none" stroke="gray"></path></g><path id="node_outline813" fill="none" stroke="none" d="M516.5,48.5h139a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-139a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text813" fill="black"><text id="kity_text_9231" text-rendering="inherit" font-size="12" dy=".8em" y="49.700000047683716" x="516.5">Redis是怎么处理请求的？</text></g></g><g id="minder_node815" display="none"><g id="node_expander811" display="none" style="cursor: pointer;"><path id="kity_path_22955" fill="white" stroke="gray" d="M532.5,57.5A6,6,0,1,1,520.5,57.5A6,6,0,1,1,532.5,57.5"></path><path id="kity_path_22956" fill="none" stroke="gray"></path></g><path id="node_outline812" fill="none" stroke="none" d="M532.5,48.5h24a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-24a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text812" fill="black"><text id="kity_text_9229" text-rendering="inherit" font-size="12" dy=".8em" y="49.700000047683716" x="532.5">同上</text></g></g><g id="minder_node816" display="none"><g id="node_expander814" display="none" style="cursor: pointer;"><path id="kity_path_22964" fill="white" stroke="gray" d="M516.5,65.5A6,6,0,1,1,504.5,65.5A6,6,0,1,1,516.5,65.5"></path><path id="kity_path_22965" fill="none" stroke="gray"></path></g><path id="node_outline815" fill="none" stroke="none" d="M516.5,56.5h148a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-148a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text815" fill="black"><text id="kity_text_9235" text-rendering="inherit" font-size="12" dy=".8em" y="57.700000047683716" x="516.5">redis和redisson有什么关系</text></g></g><g id="minder_node817" display="none"><g id="node_expander813" display="none" style="cursor: pointer;"><path id="kity_path_22961" fill="white" stroke="gray" d="M532.5,65.5A6,6,0,1,1,520.5,65.5A6,6,0,1,1,532.5,65.5"></path><path id="kity_path_22962" fill="none" stroke="gray"></path></g><path id="node_outline814" fill="none" stroke="none" d="M532.5,56.5h623a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-623a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text814" fill="black"><text id="kity_text_9233" text-rendering="inherit" font-size="12" dy=".8em" y="57.700000047683716" x="532.5">1.Redisson是一个实现redis分布式锁的框架，利用redisson 可以像JUC包下的加锁解锁来对redis实现分布式锁的功能</text></g></g><g id="minder_node818" display="none"><g id="node_expander816" display="none" style="cursor: pointer;"><path id="kity_path_22970" fill="white" stroke="gray" d="M516.5,73.5A6,6,0,1,1,504.5,73.5A6,6,0,1,1,516.5,73.5"></path><path id="kity_path_22971" fill="none" stroke="gray"></path></g><path id="node_outline817" fill="none" stroke="none" d="M516.5,64.5h137a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-137a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text817" fill="black"><text id="kity_text_9243" text-rendering="inherit" font-size="12" dy=".8em" y="65.70000004768372" x="516.5">知道redis哈希槽是什么吗</text></g></g><g id="minder_node819" display="none"><g id="node_expander815" display="none" style="cursor: pointer;"><path id="kity_path_22967" fill="white" stroke="gray" d="M532.5,73.5A6,6,0,1,1,520.5,73.5A6,6,0,1,1,532.5,73.5"></path><path id="kity_path_22968" fill="none" stroke="gray"></path></g><path id="node_outline816" fill="none" stroke="none" d="M532.5,28.5h728a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-728a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text816" fill="black"><text id="kity_text_9237" text-rendering="inherit" font-size="12" dy=".8em" y="29.700000047683716" x="532.5">1.</text><text id="kity_text_9238" text-rendering="inherit" font-size="12" dy=".8em" y="47.700000047683716" x="532.5">哈希槽集群模式下才有的，一个 redis 集群包含 16384 个哈希槽（hash slot），数据库中的每个数据都属于这16384个哈希槽中的一个。</text><text id="kity_text_9239" text-rendering="inherit" font-size="12" dy=".8em" y="65.70000004768372" x="532.5">集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽。集群中的每一个节点负责处理一部分哈希槽。</text><text id="kity_text_9240" text-rendering="inherit" font-size="12" dy=".8em" y="83.70000004768372" x="532.5">2.</text><text id="kity_text_9241" text-rendering="inherit" font-size="12" dy=".8em" y="101.70000004768372" x="532.5">哈希槽是用来决定这个key存在哪个节点，通过哈希计算，得到槽值为1，那么这个数据将存到槽值范围包括1的Redis实例上</text></g></g><g id="minder_node820" display="none"><g id="node_expander819" display="none" style="cursor: pointer;"><path id="kity_path_22979" fill="white" stroke="gray" d="M516.5,81.5A6,6,0,1,1,504.5,81.5A6,6,0,1,1,516.5,81.5"></path><path id="kity_path_22980" fill="none" stroke="gray"></path></g><path id="node_outline820" fill="none" stroke="none" d="M516.5,72.5h320a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-320a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text820" fill="black"><text id="kity_text_9257" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="516.5">Redis的字典rehash和JDK中hashmap等rehash有什么不同?</text></g></g><g id="minder_node821" display="none"><g id="node_expander818" display="none" style="cursor: pointer;"><path id="kity_path_22976" fill="white" stroke="gray" d="M532.5,81.5A6,6,0,1,1,520.5,81.5A6,6,0,1,1,532.5,81.5"></path><path id="kity_path_22977" fill="none" stroke="gray"></path></g><path id="node_outline819" fill="none" stroke="none" d="M532.5,0.5h1086a5,5,0,0,1,5,5v152a5,5,0,0,1,-5,5h-1086a5,5,0,0,1,-5,-5v-152a5,5,0,0,1,5,-5z"></path><g id="node_text819" fill="black"><text id="kity_text_9247" text-rendering="inherit" font-size="12" dy=".8em" y="1.7000000476837158" x="532.5">1.</text><text id="kity_text_9248" text-rendering="inherit" font-size="12" dy=".8em" y="19.700000047683716" x="532.5">主要区别，hashmap是集中式扩容一次性rehash完成，不支持收缩，采用链表和红黑树解决冲突	，而redis是渐进式扩容，内部支持收缩，利用两个哈希表完成，采用链表解决冲突。</text><text id="kity_text_9249" text-rendering="inherit" font-size="12" dy=".8em" y="37.700000047683716" x="532.5">2</text><text id="kity_text_9250" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="532.5">hashmap新索引的位置 为旧索引位置 + 扩容前的容量：newTab[j + oldCap] = hiHead，所以rehash也是很快的</text><text id="kity_text_9251" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="532.5">redis的rehash过程:</text><text id="kity_text_9252" text-rendering="inherit" font-size="12" dy=".8em" y="91.70000004768372" x="532.5">① 为ht[1]分配空间，空间大小为旧已使用空间的2n;</text><text id="kity_text_9253" text-rendering="inherit" font-size="12" dy=".8em" y="109.70000004768372" x="532.5">② 将字典中维持的索引计数器rehashidx设置0，表示rehash工作正式开始；</text><text id="kity_text_9254" text-rendering="inherit" font-size="12" dy=".8em" y="127.70000004768372" x="532.5">③ 在rehash期间，每次对字典的增、删、改、查，操作，程序除了执行指定的操作之外，还会顺带将ht[0]哈希表在rehashidex索引上的所有键值对rehash到ht[1]，当完成后，程序将rehashidex的值加一。</text><text id="kity_text_9255" text-rendering="inherit" font-size="12" dy=".8em" y="145.70000004768372" x="532.5">④ 随着字典操作的不断进行，ht[0]表中的所有键值对都会被rehash到ht[1]，这时会将rehashidx属性值设置为-1，表示rehash操作结束。</text></g></g><g id="minder_node822" display="none"><g id="node_expander817" display="none" style="cursor: pointer;"><path id="kity_path_22973" fill="white" stroke="gray" d="M548.5,81.5A6,6,0,1,1,536.5,81.5A6,6,0,1,1,548.5,81.5"></path><path id="kity_path_22974" fill="none" stroke="gray"></path></g><path id="node_outline818" fill="none" stroke="none" d="M473.5,-61.5h200a5,5,0,0,1,5,5v142a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-142a5,5,0,0,1,5,-5z"></path><g id="node_text818" fill="black"><text id="kity_text_9245" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="548.5">分支主题</text></g><image id="kity_image_17044" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210322102218.png" x="473.5" y="-58.5" width="200" height="129"></image></g><g id="minder_node823" display="none"><g id="node_expander821" display="none" style="cursor: pointer;"><path id="kity_path_22985" fill="white" stroke="gray" d="M516.5,89.5A6,6,0,1,1,504.5,89.5A6,6,0,1,1,516.5,89.5"></path><path id="kity_path_22986" fill="none" stroke="gray"></path></g><path id="node_outline822" fill="none" stroke="none" d="M516.5,80.5h78a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-78a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text822" fill="black"><text id="kity_text_9262" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="516.5">redis的rehash</text></g></g><g id="minder_node824" display="none"><g id="node_expander820" display="none" style="cursor: pointer;"><path id="kity_path_22982" fill="white" stroke="gray" d="M532.5,89.5A6,6,0,1,1,520.5,89.5A6,6,0,1,1,532.5,89.5"></path><path id="kity_path_22983" fill="none" stroke="gray"></path></g><path id="node_outline821" fill="none" stroke="none" d="M532.5,71.5h320a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-320a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text821" fill="black"><text id="kity_text_9259" text-rendering="inherit" font-size="12" dy=".8em" y="72.70000004768372" x="532.5">https://www.cnblogs.com/meituantech/p/9376472.html</text><text id="kity_text_9260" text-rendering="inherit" font-size="12" dy=".8em" y="90.70000004768372" x="532.5">https://juejin.cn/post/6870112620645449741</text></g></g><g id="minder_node825" display="none"><g id="node_expander823" display="none" style="cursor: pointer;"><path id="kity_path_22991" fill="white" stroke="gray" d="M516.5,97.5A6,6,0,1,1,504.5,97.5A6,6,0,1,1,516.5,97.5"></path><path id="kity_path_22992" fill="none" stroke="gray"></path></g><path id="node_outline824" fill="none" stroke="none" d="M516.5,88.5h139a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-139a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text824" fill="black"><text id="kity_text_9266" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="516.5">redis的zrange怎么实现的</text></g></g><g id="minder_node826" display="none"><g id="node_expander822" display="none" style="cursor: pointer;"><path id="kity_path_22988" fill="white" stroke="gray" d="M532.5,97.5A6,6,0,1,1,520.5,97.5A6,6,0,1,1,532.5,97.5"></path><path id="kity_path_22989" fill="none" stroke="gray"></path></g><path id="node_outline823" fill="none" stroke="none" d="M532.5,88.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text823" fill="black"><text id="kity_text_9264" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="532.5">分支主题</text></g></g><g id="minder_node827" display="none"><g id="node_expander826" display="none" style="cursor: pointer;"><path id="kity_path_23000" fill="white" stroke="gray" d="M516.5,105.5A6,6,0,1,1,504.5,105.5A6,6,0,1,1,516.5,105.5"></path><path id="kity_path_23001" fill="none" stroke="gray"></path></g><path id="node_outline827" fill="none" stroke="none" d="M516.5,96.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text827" fill="black"><text id="kity_text_9275" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="516.5">怎么批量查找？</text></g></g><g id="minder_node828" display="none"><g id="node_expander825" display="none" style="cursor: pointer;"><path id="kity_path_22997" fill="white" stroke="gray" d="M532.5,105.5A6,6,0,1,1,520.5,105.5A6,6,0,1,1,532.5,105.5"></path><path id="kity_path_22998" fill="none" stroke="gray"></path></g><path id="node_outline826" fill="none" stroke="none" d="M532.5,69.5h700a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-700a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text826" fill="black"><text id="kity_text_9270" text-rendering="inherit" font-size="12" dy=".8em" y="70.70000004768372" x="532.5">1.scan命令的时间复杂度虽然也是O(N)，但它是分次进行的，不会阻塞线程。提供了limit参数，可以控制每次返回结果的最大条数。</text><text id="kity_text_9271" text-rendering="inherit" font-size="12" dy=".8em" y="88.70000004768372" x="532.5">2.SCAN命令的遍历顺序是 高位加1,就是 0-2-1-3 =&#xa0; 00-10-01-11&#xa0; 为什么？遍历时发生字典扩容与缩容的情况</text><text id="kity_text_9272" text-rendering="inherit" font-size="12" dy=".8em" y="106.70000004768372" x="532.5">3.会出现重复元素，需要客户端去重</text><text id="kity_text_9273" text-rendering="inherit" font-size="12" dy=".8em" y="124.70000004768372" x="532.5">4.Redis使用的是渐进式rehash机制，因此，scan命令在需要同时扫描新表和旧表，将结果返回客户端。</text></g></g><g id="minder_node829" display="none"><g id="node_expander824" display="none" style="cursor: pointer;"><path id="kity_path_22994" fill="white" stroke="gray" d="M548.5,105.5A6,6,0,1,1,536.5,105.5A6,6,0,1,1,548.5,105.5"></path><path id="kity_path_22995" fill="none" stroke="gray"></path></g><path id="node_outline825" fill="none" stroke="none" d="M548.5,96.5h231a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-231a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text825" fill="black"><text id="kity_text_9268" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="548.5">https://zhuanlan.zhihu.com/p/46353221</text></g></g><g id="minder_node830" display="none"><g id="node_expander890" display="none" style="cursor: pointer;"><path id="kity_path_23192" fill="white" stroke="gray" d="M500.5,113.5A6,6,0,1,1,488.5,113.5A6,6,0,1,1,500.5,113.5"></path><path id="kity_path_23193" fill="none" stroke="gray"></path></g><path id="node_outline891" fill="none" stroke="none" d="M500.5,104.5h65a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-65a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text891" fill="black"><text id="kity_text_9486" text-rendering="inherit" font-size="12" dy=".8em" y="105.70000004768372" x="500.5">redis的原理</text></g></g><g id="minder_node831" display="none"><g id="node_expander830" display="none" style="cursor: pointer;"><path id="kity_path_23012" fill="white" stroke="gray" d="M516.5,65.5A6,6,0,1,1,504.5,65.5A6,6,0,1,1,516.5,65.5"></path><path id="kity_path_23013" fill="none" stroke="gray"></path></g><path id="node_outline831" fill="none" stroke="none" d="M516.5,56.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text831" fill="black"><text id="kity_text_9292" text-rendering="inherit" font-size="12" dy=".8em" y="57.700000047683716" x="516.5">通信协议</text></g></g><g id="minder_node832" display="none"><g id="node_expander829" display="none" style="cursor: pointer;"><path id="kity_path_23009" fill="white" stroke="gray" d="M532.5,65.5A6,6,0,1,1,520.5,65.5A6,6,0,1,1,532.5,65.5"></path><path id="kity_path_23010" fill="none" stroke="gray"></path></g><path id="node_outline830" fill="none" stroke="none" d="M532.5,-24.5h1087a5,5,0,0,1,5,5v170a5,5,0,0,1,-5,5h-1087a5,5,0,0,1,-5,-5v-170a5,5,0,0,1,5,-5z"></path><g id="node_text830" fill="black"><text id="kity_text_9281" text-rendering="inherit" font-size="12" dy=".8em" y="-23.299999952316284" x="532.5">1.client-server</text><text id="kity_text_9282" text-rendering="inherit" font-size="12" dy=".8em" y="-5.299999952316284" x="532.5">连接： 在 Redis 中客户端与服务端之间的通信协议是在TCP协议之上构建的。</text><text id="kity_text_9283" text-rendering="inherit" font-size="12" dy=".8em" y="12.700000047683716" x="532.5">数据格式： Redis 制定了RESP（REdis Serialization Protocol，Redis 序列化协议）实现客户端与服务端的正常交互</text><text id="kity_text_9284" text-rendering="inherit" font-size="12" dy=".8em" y="30.700000047683716" x="532.5">RESP协议是二进制安全的，并且不需要处理从一个进程传输到另一个进程的块数据的大小，因为它使用prefixed-length（前缀长度）的方式来传输块数据的</text><text id="kity_text_9285" text-rendering="inherit" font-size="12" dy=".8em" y="48.700000047683716" x="532.5">2.</text><text id="kity_text_9286" text-rendering="inherit" font-size="12" dy=".8em" y="66.70000004768372" x="532.5">当 Redis 客户端订阅 Pub/Sub模式的通道时，协议会改变语义变成推送协议，也就是说，客户端不再需要发送命令，因为服务器一旦收到消息就会自动向客户端发送该新消息（对于订阅了通道的客户端）。</text><text id="kity_text_9287" text-rendering="inherit" font-size="12" dy=".8em" y="84.70000004768372" x="532.5">3.</text><text id="kity_text_9288" text-rendering="inherit" font-size="12" dy=".8em" y="102.70000004768372" x="532.5">Redis 的返回结果类型分为以下五种，状态回复：在RESP中第一个字节为+。错误回复：xxx为-。整数回复：xxx为：。字符串回复：xxx为$。多条字符串回复：xxx为*。</text><text id="kity_text_9289" text-rendering="inherit" font-size="12" dy=".8em" y="120.70000004768372" x="532.5">4.集群通信协议</text><text id="kity_text_9290" text-rendering="inherit" font-size="12" dy=".8em" y="138.70000004768372" x="532.5">为了让让集群中的每个实例都知道其他所有实例的状态信息，Redis 集群规定各个实例之间按照 Gossip 协议来通信传递信息。</text></g></g><g id="minder_node833" display="none"><g id="node_expander828" display="none" style="cursor: pointer;"><path id="kity_path_23006" fill="white" stroke="gray" d="M548.5,65.5A6,6,0,1,1,536.5,65.5A6,6,0,1,1,548.5,65.5"></path><path id="kity_path_23007" fill="none" stroke="gray"></path></g><path id="node_outline829" fill="none" stroke="none" d="M548.5,51.5h126a5,5,0,0,1,5,5v18a5,5,0,0,1,-5,5h-126a5,5,0,0,1,-5,-5v-18a5,5,0,0,1,5,-5z"></path><g id="node_text829" fill="black"><text id="kity_text_9279" text-rendering="inherit" font-size="12" dy=".8em" y="57.700000047683716" x="548.5">集群通信协议参考</text></g><a id="kity_a_16910" xlink:href="https://juejin.cn/post/6902004920543952909#heading-2" target="_blank" xlink:title="https://juejin.cn/post/6902004920543952909#heading-2" style="cursor: pointer;"><path id="kity_path_16912" fill="rgba(255, 255, 255, 0)" stroke="none" d="M654.5,54.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16911" fill="#666" stroke="none" d="M669.114,70.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V64.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C664.766,61.571,666.168,60.5,667.836,60.5h1.278c2.116,0,3.834,1.716,3.834,3.834V66.89C672.948,69.008,671.23,70.724,669.114,70.724zM657.612,65.612c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S667.265,66.89,666.558,66.89H658.89C658.185,66.89,657.612,66.319,657.612,65.612zM655.056,64.334V66.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H656.334C654.216,70.724,652.5,69.008,652.5,66.89V64.334C652.5,62.216,654.216,60.5,656.334,60.5h1.278c1.667,0,3.071,1.071,3.599,2.556H656.334C655.629,63.056,655.056,63.627,655.056,64.334z"></path></a></g><g id="minder_node834" display="none"><g id="node_expander836" display="none" style="cursor: pointer;"><path id="kity_path_23030" fill="white" stroke="gray" d="M516.5,73.5A6,6,0,1,1,504.5,73.5A6,6,0,1,1,516.5,73.5"></path><path id="kity_path_23031" fill="none" stroke="gray"></path></g><path id="node_outline837" fill="none" stroke="none" d="M516.5,64.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text837" fill="black"><text id="kity_text_9304" text-rendering="inherit" font-size="12" dy=".8em" y="65.70000004768372" x="516.5">管道</text></g></g><g id="minder_node835" display="none"><g id="node_expander835" display="none" style="cursor: pointer;"><path id="kity_path_23027" fill="white" stroke="gray" d="M532.5,73.5A6,6,0,1,1,520.5,73.5A6,6,0,1,1,532.5,73.5"></path><path id="kity_path_23028" fill="none" stroke="gray"></path></g><path id="node_outline836" fill="none" stroke="none" d="M532.5,64.5h46a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-46a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text836" fill="black"><text id="kity_text_9302" text-rendering="inherit" font-size="12" dy=".8em" y="65.70000004768372" x="532.5">pipeline</text></g></g><g id="minder_node836" display="none"><g id="node_expander831" display="none" style="cursor: pointer;"><path id="kity_path_23015" fill="white" stroke="gray" d="M548.5,49.5A6,6,0,1,1,536.5,49.5A6,6,0,1,1,548.5,49.5"></path><path id="kity_path_23016" fill="none" stroke="gray"></path></g><path id="node_outline832" fill="none" stroke="none" d="M548.5,40.5h73a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-73a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text832" fill="black"><text id="kity_text_9294" text-rendering="inherit" font-size="12" dy=".8em" y="41.700000047683716" x="548.5">节省网络开销</text></g></g><g id="minder_node837" display="none"><g id="node_expander832" display="none" style="cursor: pointer;"><path id="kity_path_23018" fill="white" stroke="gray" d="M548.5,57.5A6,6,0,1,1,536.5,57.5A6,6,0,1,1,548.5,57.5"></path><path id="kity_path_23019" fill="none" stroke="gray"></path></g><path id="node_outline833" fill="none" stroke="none" d="M548.5,48.5h168a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-168a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text833" fill="black"><text id="kity_text_9296" text-rendering="inherit" font-size="12" dy=".8em" y="49.700000047683716" x="548.5">注意每次pipeline携带的数据量</text></g></g><g id="minder_node838" display="none"><g id="node_expander833" display="none" style="cursor: pointer;"><path id="kity_path_23021" fill="white" stroke="gray" d="M548.5,65.5A6,6,0,1,1,536.5,65.5A6,6,0,1,1,548.5,65.5"></path><path id="kity_path_23022" fill="none" stroke="gray"></path></g><path id="node_outline834" fill="none" stroke="none" d="M548.5,56.5h246a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-246a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text834" fill="black"><text id="kity_text_9298" text-rendering="inherit" font-size="12" dy=".8em" y="57.700000047683716" x="548.5">注意m操作与pipeline的区别：原子 vs 非原子</text></g></g><g id="minder_node839" display="none"><g id="node_expander834" display="none" style="cursor: pointer;"><path id="kity_path_23024" fill="white" stroke="gray" d="M548.5,73.5A6,6,0,1,1,536.5,73.5A6,6,0,1,1,548.5,73.5"></path><path id="kity_path_23025" fill="none" stroke="gray"></path></g><path id="node_outline835" fill="none" stroke="none" d="M548.5,64.5h218a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-218a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text835" fill="black"><text id="kity_text_9300" text-rendering="inherit" font-size="12" dy=".8em" y="65.70000004768372" x="548.5">pipeline每次只能作用在一个redis节点上</text></g></g><g id="minder_node840" display="none"><g id="node_expander839" display="none" style="cursor: pointer;"><path id="kity_path_23039" fill="white" stroke="gray" d="M516.5,81.5A6,6,0,1,1,504.5,81.5A6,6,0,1,1,516.5,81.5"></path><path id="kity_path_23040" fill="none" stroke="gray"></path></g><path id="node_outline840" fill="none" stroke="none" d="M516.5,72.5h36a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-36a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text840" fill="black"><text id="kity_text_9312" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="516.5">io模型</text></g></g><g id="minder_node841" display="none"><g id="node_expander838" display="none" style="cursor: pointer;"><path id="kity_path_23036" fill="white" stroke="gray" d="M532.5,81.5A6,6,0,1,1,520.5,81.5A6,6,0,1,1,532.5,81.5"></path><path id="kity_path_23037" fill="none" stroke="gray"></path></g><path id="node_outline839" fill="none" stroke="none" d="M532.5,54.5h971a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-971a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text839" fill="black"><text id="kity_text_9308" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="532.5">1.多路指的是多个socket连接，复用指的是复用一个线程。多路复用主要有三种技术：select，poll，epoll。</text><text id="kity_text_9309" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="532.5">epoll是最新的也是目前最好的多路复用技术。</text><text id="kity_text_9310" text-rendering="inherit" font-size="12" dy=".8em" y="91.70000004768372" x="532.5">采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），</text></g></g><g id="minder_node842" display="none"><g id="node_expander837" display="none" style="cursor: pointer;"><path id="kity_path_23033" fill="white" stroke="gray" d="M548.5,81.5A6,6,0,1,1,536.5,81.5A6,6,0,1,1,548.5,81.5"></path><path id="kity_path_23034" fill="none" stroke="gray"></path></g><path id="node_outline838" fill="none" stroke="none" d="M473.5,-37.5h200a5,5,0,0,1,5,5v118a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-118a5,5,0,0,1,5,-5z"></path><g id="node_text838" fill="black"><text id="kity_text_9306" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="548.5">分支主题</text></g><image id="kity_image_17045" xlink:href="https://img-blog.csdnimg.cn/20200505210054691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phNW9u,size_16,color_FFFFFF,t_70" x="473.5" y="-34.5" width="200" height="105"></image></g><g id="minder_node843" display="none"><g id="node_expander848" display="none" style="cursor: pointer;"><path id="kity_path_23066" fill="white" stroke="gray" d="M516.5,89.5A6,6,0,1,1,504.5,89.5A6,6,0,1,1,516.5,89.5"></path><path id="kity_path_23067" fill="none" stroke="gray"></path></g><path id="node_outline849" fill="none" stroke="none" d="M516.5,80.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text849" fill="black"><text id="kity_text_9349" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="516.5">事务</text></g></g><g id="minder_node844" display="none"><g id="node_expander841" display="none" style="cursor: pointer;"><path id="kity_path_23045" fill="white" stroke="gray" d="M532.5,65.5A6,6,0,1,1,520.5,65.5A6,6,0,1,1,532.5,65.5"></path><path id="kity_path_23046" fill="none" stroke="gray"></path></g><path id="node_outline842" fill="none" stroke="none" d="M532.5,56.5h149a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-149a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text842" fill="black"><text id="kity_text_9319" text-rendering="inherit" font-size="12" dy=".8em" y="57.700000047683716" x="532.5">说一些redis的事务是什么？</text></g></g><g id="minder_node845" display="none"><g id="node_expander840" display="none" style="cursor: pointer;"><path id="kity_path_23042" fill="white" stroke="gray" d="M548.5,65.5A6,6,0,1,1,536.5,65.5A6,6,0,1,1,548.5,65.5"></path><path id="kity_path_23043" fill="none" stroke="gray"></path></g><path id="node_outline841" fill="none" stroke="none" d="M548.5,29.5h1033a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1033a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text841" fill="black"><text id="kity_text_9314" text-rendering="inherit" font-size="12" dy=".8em" y="30.700000047683716" x="548.5">1.redis事务就是一系列连续按照先进先出的执行顺序 进入队列，然后等待我们执行。三步骤：开始事务-&gt;命令入队-&gt;执行事务</text><text id="kity_text_9315" text-rendering="inherit" font-size="12" dy=".8em" y="48.700000047683716" x="548.5">redis事务保证的是：1.事务执行命令exec之前命令要入队缓存，2.收到了exec命令后，事务中一条命令失败不影响其他命令的执行，3.在事务执行中，其他客户端命令不会插入正在执行的事务中。</text><text id="kity_text_9316" text-rendering="inherit" font-size="12" dy=".8em" y="66.70000004768372" x="548.5">2.命令</text><text id="kity_text_9317" text-rendering="inherit" font-size="12" dy=".8em" y="84.70000004768372" x="548.5">multi	标记一个事务开始。exec 执行事务。discard 撤销事务。watch key 监视 key ，如果在事务执行之前这些key 被其他命令所改动，那么事务将被打断。unwatch关闭</text></g></g><g id="minder_node846" display="none"><g id="node_expander843" display="none" style="cursor: pointer;"><path id="kity_path_23051" fill="white" stroke="gray" d="M532.5,73.5A6,6,0,1,1,520.5,73.5A6,6,0,1,1,532.5,73.5"></path><path id="kity_path_23052" fill="none" stroke="gray"></path></g><path id="node_outline844" fill="none" stroke="none" d="M532.5,64.5h208a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-208a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text844" fill="black"><text id="kity_text_9328" text-rendering="inherit" font-size="12" dy=".8em" y="65.70000004768372" x="532.5">redis存在并发竞争关系吗？怎么解决？</text></g></g><g id="minder_node847" display="none"><g id="node_expander842" display="none" style="cursor: pointer;"><path id="kity_path_23048" fill="white" stroke="gray" d="M548.5,73.5A6,6,0,1,1,536.5,73.5A6,6,0,1,1,548.5,73.5"></path><path id="kity_path_23049" fill="none" stroke="gray"></path></g><path id="node_outline843" fill="none" stroke="none" d="M548.5,19.5h1160a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1160a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text843" fill="black"><text id="kity_text_9321" text-rendering="inherit" font-size="12" dy=".8em" y="20.700000047683716" x="548.5">1.</text><text id="kity_text_9322" text-rendering="inherit" font-size="12" dy=".8em" y="38.700000047683716" x="548.5">多客户端同时并发写一个 key，可能本来应该先到的数据后到了，导致数据版本错了；或者是多客户端同时获取一个 key，修改值之后再写回去，只要顺序错了，数据就错了。</text><text id="kity_text_9323" text-rendering="inherit" font-size="12" dy=".8em" y="56.700000047683716" x="548.5">2.</text><text id="kity_text_9324" text-rendering="inherit" font-size="12" dy=".8em" y="74.70000004768372" x="548.5">Redis 有天然解决这个并发竞争问题的类 CAS 乐观锁方案：每次要写之前，先判断一下当前这个 value 的时间戳是否比缓存里的 value 的时间戳要新。如果是的话，那么可以写，否则，就不能用旧的数据覆盖新的数据。</text><text id="kity_text_9325" text-rendering="inherit" font-size="12" dy=".8em" y="92.70000004768372" x="548.5">WATCH命令类似于乐观锁，简单点说就是监控Redis对应的key,如果自己的值和Redis中的值对不上事务队列将不会被执行（类似于CAS机制）。</text><text id="kity_text_9326" text-rendering="inherit" font-size="12" dy=".8em" y="110.70000004768372" x="548.5">写入 mysql 中的时候必须保存一个时间戳，因此从 mysql 查出来的时候，时间戳也查出来。</text></g></g><g id="minder_node848" display="none"><g id="node_expander845" display="none" style="cursor: pointer;"><path id="kity_path_23057" fill="white" stroke="gray" d="M532.5,81.5A6,6,0,1,1,520.5,81.5A6,6,0,1,1,532.5,81.5"></path><path id="kity_path_23058" fill="none" stroke="gray"></path></g><path id="node_outline846" fill="none" stroke="none" d="M532.5,72.5h136a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-136a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text846" fill="black"><text id="kity_text_9334" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="532.5">redis的事务保证原子性？</text></g></g><g id="minder_node849" display="none"><g id="node_expander844" display="none" style="cursor: pointer;"><path id="kity_path_23054" fill="white" stroke="gray" d="M548.5,81.5A6,6,0,1,1,536.5,81.5A6,6,0,1,1,548.5,81.5"></path><path id="kity_path_23055" fill="none" stroke="gray"></path></g><path id="node_outline845" fill="none" stroke="none" d="M548.5,54.5h813a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-813a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text845" fill="black"><text id="kity_text_9330" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="548.5">1</text><text id="kity_text_9331" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="548.5">Redis的事务为了保证Redis除了客户端的请求高效，去除了传统关系型数据库的「事务回滚、加锁、解锁」这些消耗性能的操作，Redis的事务实现简单。</text><text id="kity_text_9332" text-rendering="inherit" font-size="12" dy=".8em" y="91.70000004768372" x="548.5">原子性中Redis的事务只能保证单个命令的原子性，原子顺序执行的，但是多个命令就无法保证原子性。</text></g></g><g id="minder_node850" display="none"><g id="node_expander847" display="none" style="cursor: pointer;"><path id="kity_path_23063" fill="white" stroke="gray" d="M532.5,89.5A6,6,0,1,1,520.5,89.5A6,6,0,1,1,532.5,89.5"></path><path id="kity_path_23064" fill="none" stroke="gray"></path></g><path id="node_outline848" fill="none" stroke="none" d="M532.5,71.5h172a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-172a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text848" fill="black"><text id="kity_text_9346" text-rendering="inherit" font-size="12" dy=".8em" y="72.70000004768372" x="532.5">redis的事务和数据库事务区别？</text><text id="kity_text_9347" text-rendering="inherit" font-size="12" dy=".8em" y="90.70000004768372" x="532.5">为什么不支持回滚？</text></g></g><g id="minder_node851" display="none"><g id="node_expander846" display="none" style="cursor: pointer;"><path id="kity_path_23060" fill="white" stroke="gray" d="M548.5,89.5A6,6,0,1,1,536.5,89.5A6,6,0,1,1,548.5,89.5"></path><path id="kity_path_23061" fill="none" stroke="gray"></path></g><path id="node_outline847" fill="none" stroke="none" d="M548.5,8.5h962a5,5,0,0,1,5,5v152a5,5,0,0,1,-5,5h-962a5,5,0,0,1,-5,-5v-152a5,5,0,0,1,5,-5z"></path><g id="node_text847" fill="black"><text id="kity_text_9336" text-rendering="inherit" font-size="12" dy=".8em" y="9.700000047683716" x="548.5">1.</text><text id="kity_text_9337" text-rendering="inherit" font-size="12" dy=".8em" y="27.700000047683716" x="548.5">redis没有事务隔离级别，只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会不会进行任何的重试或者回滚动作，而是会继续执行下去。</text><text id="kity_text_9338" text-rendering="inherit" font-size="12" dy=".8em" y="45.700000047683716" x="548.5">redis不保证原子性</text><text id="kity_text_9339" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="548.5">redis的隔离性：Redis 在执行命令是单线程的，这能保证在执行事务时，不会对事务进行中断，也不会执行其他客户端的命令，事务可以运行直到执行完所有事务队列中的命令为止。</text><text id="kity_text_9340" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="548.5">因此，Redis 的事务是总是带有隔离性的。</text><text id="kity_text_9341" text-rendering="inherit" font-size="12" dy=".8em" y="99.70000004768372" x="548.5">redis的持久性：基于它本身的持久性机制（AOF 和RDB）。</text><text id="kity_text_9342" text-rendering="inherit" font-size="12" dy=".8em" y="117.70000004768372" x="548.5">2.</text><text id="kity_text_9343" text-rendering="inherit" font-size="12" dy=".8em" y="135.70000004768372" x="548.5">Redis 命令只会因为错误的语法而失败，或是命令用在了错误类型的键上面。</text><text id="kity_text_9344" text-rendering="inherit" font-size="12" dy=".8em" y="153.70000004768372" x="548.5">因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</text></g></g><g id="minder_node852" display="none"><g id="node_expander857" display="none" style="cursor: pointer;"><path id="kity_path_23093" fill="white" stroke="gray" d="M516.5,97.5A6,6,0,1,1,504.5,97.5A6,6,0,1,1,516.5,97.5"></path><path id="kity_path_23094" fill="none" stroke="gray"></path></g><path id="node_outline858" fill="none" stroke="none" d="M516.5,88.5h74a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-74a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text858" fill="black"><text id="kity_text_9385" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="516.5">过期删除策略</text></g></g><g id="minder_node853" display="none"><g id="node_expander851" display="none" style="cursor: pointer;"><path id="kity_path_23075" fill="white" stroke="gray" d="M532.5,81.5A6,6,0,1,1,520.5,81.5A6,6,0,1,1,532.5,81.5"></path><path id="kity_path_23076" fill="none" stroke="gray"></path></g><path id="node_outline852" fill="none" stroke="none" d="M532.5,72.5h196a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-196a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text852" fill="black"><text id="kity_text_9366" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="532.5">redis有哪些过期删除策略？优缺点？</text></g></g><g id="minder_node854" display="none"><g id="node_expander850" display="none" style="cursor: pointer;"><path id="kity_path_23072" fill="white" stroke="gray" d="M548.5,81.5A6,6,0,1,1,536.5,81.5A6,6,0,1,1,548.5,81.5"></path><path id="kity_path_23073" fill="none" stroke="gray"></path></g><path id="node_outline851" fill="none" stroke="none" d="M548.5,-26.5h872a5,5,0,0,1,5,5v206a5,5,0,0,1,-5,5h-872a5,5,0,0,1,-5,-5v-206a5,5,0,0,1,5,-5z"></path><g id="node_text851" fill="black"><text id="kity_text_9353" text-rendering="inherit" font-size="12" dy=".8em" y="-25.299999952316284" x="548.5">1.</text><text id="kity_text_9354" text-rendering="inherit" font-size="12" dy=".8em" y="-7.299999952316284" x="548.5">(1)定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即对key进行清除。</text><text id="kity_text_9355" text-rendering="inherit" font-size="12" dy=".8em" y="10.700000047683716" x="548.5">优点：策略可以立即清除过期的数据，对内存很友好</text><text id="kity_text_9356" text-rendering="inherit" font-size="12" dy=".8em" y="28.700000047683716" x="548.5">缺点：会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</text><text id="kity_text_9357" text-rendering="inherit" font-size="12" dy=".8em" y="46.700000047683716" x="548.5">(2)惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除</text><text id="kity_text_9358" text-rendering="inherit" font-size="12" dy=".8em" y="64.70000004768372" x="548.5">优点：可以最大化地节省CPU资源，却对内存非常不友好</text><text id="kity_text_9359" text-rendering="inherit" font-size="12" dy=".8em" y="82.70000004768372" x="548.5">缺点：极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</text><text id="kity_text_9360" text-rendering="inherit" font-size="12" dy=".8em" y="100.70000004768372" x="548.5">(3)定期过期：每隔一段时间，扫描Redis中过期key字典(expires)，并清除部分过期的key</text><text id="kity_text_9361" text-rendering="inherit" font-size="12" dy=".8em" y="118.70000004768372" x="548.5">优点：可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</text><text id="kity_text_9362" text-rendering="inherit" font-size="12" dy=".8em" y="136.70000004768372" x="548.5">expires字典:会保存所有设置了过期时间的key的过期时间数据，其中 key 是指向键空间(集群中保存的所有键)中的某个键的指针，value是该键的毫秒精度的过期时间</text><text id="kity_text_9363" text-rendering="inherit" font-size="12" dy=".8em" y="154.70000004768372" x="548.5">2.</text><text id="kity_text_9364" text-rendering="inherit" font-size="12" dy=".8em" y="172.70000004768372" x="548.5">Redis采用的过期策略：惰性删除 + 定期删除。memcached采用的过期策略：惰性删除。</text></g></g><g id="minder_node855" display="none"><g id="node_expander849" display="none" style="cursor: pointer;"><path id="kity_path_23069" fill="white" stroke="gray" d="M564.5,81.5A6,6,0,1,1,552.5,81.5A6,6,0,1,1,564.5,81.5"></path><path id="kity_path_23070" fill="none" stroke="gray"></path></g><path id="node_outline850" fill="none" stroke="none" d="M564.5,67.5h126a5,5,0,0,1,5,5v18a5,5,0,0,1,-5,5h-126a5,5,0,0,1,-5,-5v-18a5,5,0,0,1,5,-5z"></path><g id="node_text850" fill="black"><text id="kity_text_9351" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="564.5">参考过期删除原理</text></g><a id="kity_a_16913" xlink:href="https://juejin.cn/post/6844903873618903048#heading-7" target="_blank" xlink:title="https://juejin.cn/post/6844903873618903048#heading-7" style="cursor: pointer;"><path id="kity_path_16915" fill="rgba(255, 255, 255, 0)" stroke="none" d="M670.5,70.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16914" fill="#666" stroke="none" d="M685.114,86.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V80.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C680.766,77.571,682.168,76.5,683.836,76.5h1.278c2.116,0,3.834,1.716,3.834,3.834V82.89C688.948,85.008,687.23,86.724,685.114,86.724zM673.612,81.612c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S683.265,82.89,682.558,82.89H674.89C674.185,82.89,673.612,82.319,673.612,81.612zM671.056,80.334V82.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H672.334C670.216,86.724,668.5,85.008,668.5,82.89V80.334C668.5,78.216,670.216,76.5,672.334,76.5h1.278c1.667,0,3.071,1.071,3.599,2.556H672.334C671.629,79.056,671.056,79.627,671.056,80.334z"></path></a></g><g id="minder_node856" display="none"><g id="node_expander853" display="none" style="cursor: pointer;"><path id="kity_path_23081" fill="white" stroke="gray" d="M532.5,89.5A6,6,0,1,1,520.5,89.5A6,6,0,1,1,532.5,89.5"></path><path id="kity_path_23082" fill="none" stroke="gray"></path></g><path id="node_outline854" fill="none" stroke="none" d="M532.5,80.5h208a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-208a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text854" fill="black"><text id="kity_text_9374" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="532.5">简单说说？Redis清理过期key的时机？</text></g></g><g id="minder_node857" display="none"><g id="node_expander852" display="none" style="cursor: pointer;"><path id="kity_path_23078" fill="white" stroke="gray" d="M548.5,89.5A6,6,0,1,1,536.5,89.5A6,6,0,1,1,548.5,89.5"></path><path id="kity_path_23079" fill="none" stroke="gray"></path></g><path id="node_outline853" fill="none" stroke="none" d="M548.5,44.5h1069a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1069a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text853" fill="black"><text id="kity_text_9368" text-rendering="inherit" font-size="12" dy=".8em" y="45.700000047683716" x="548.5">1.</text><text id="kity_text_9369" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="548.5">Redis在启动的时候，会注册两种事件，时间事件和文件事件。时间事件主要是Redis处理后台操作的一类事件，比如客户端超时、删除过期key；文件事件是处理请求。</text><text id="kity_text_9370" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="548.5">2.</text><text id="kity_text_9371" text-rendering="inherit" font-size="12" dy=".8em" y="99.70000004768372" x="548.5">时间事件中，redis注册的回调函数是serverCron，在定时任务回调函数中，通过调用databasesCron清理部分过期key。（这是定期删除的实现。）</text><text id="kity_text_9372" text-rendering="inherit" font-size="12" dy=".8em" y="117.70000004768372" x="548.5">Redis会在访问key时判断key是否过期，如果过期了，就删除，以及每一次Redis访问事件到来时，beforeSleep都会调用activeExpireCycle函数，在1ms时间内主动清理部分key，这是惰性删除的实现。</text></g></g><g id="minder_node858" display="none"><g id="node_expander856" display="none" style="cursor: pointer;"><path id="kity_path_23090" fill="white" stroke="gray" d="M532.5,97.5A6,6,0,1,1,520.5,97.5A6,6,0,1,1,532.5,97.5"></path><path id="kity_path_23091" fill="none" stroke="gray"></path></g><path id="node_outline857" fill="none" stroke="none" d="M532.5,88.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text857" fill="black"><text id="kity_text_9383" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="532.5">过期通知事件？说一下？</text></g></g><g id="minder_node859" display="none"><g id="node_expander855" display="none" style="cursor: pointer;"><path id="kity_path_23087" fill="white" stroke="gray" d="M548.5,97.5A6,6,0,1,1,536.5,97.5A6,6,0,1,1,548.5,97.5"></path><path id="kity_path_23088" fill="none" stroke="gray"></path></g><path id="node_outline856" fill="none" stroke="none" d="M548.5,79.5h951a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-951a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text856" fill="black"><text id="kity_text_9380" text-rendering="inherit" font-size="12" dy=".8em" y="80.70000004768372" x="548.5">1.通过配置文件ex那个可以让过期key被删除时通过监听得到redis发送的通知&#xa0; 这个通知是 redis key 因为value已经过期了。 Redis 产生 expired 通知的时间为过期键被删除的时候</text><text id="kity_text_9381" text-rendering="inherit" font-size="12" dy=".8em" y="98.70000004768372" x="548.5">2.可以通过监听频道来得到一些通知，比如 执行了 del的键 ，修改了key的键，这个key可以是通配符</text></g></g><g id="minder_node860" display="none"><g id="node_expander854" display="none" style="cursor: pointer;"><path id="kity_path_23084" fill="white" stroke="gray" d="M564.5,97.5A6,6,0,1,1,552.5,97.5A6,6,0,1,1,564.5,97.5"></path><path id="kity_path_23085" fill="none" stroke="gray"></path></g><path id="node_outline855" fill="none" stroke="none" d="M564.5,70.5h379a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-379a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text855" fill="black"><text id="kity_text_9376" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="564.5">https://www.cnblogs.com/yuluoxingkong/p/10475355.html</text><text id="kity_text_9377" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="564.5">https://blog.csdn.net/xixingzhe2/article/details/82882144</text><text id="kity_text_9378" text-rendering="inherit" font-size="12" dy=".8em" y="107.70000004768372" x="564.5">https://blog.csdn.net/for_the_time_begin/article/details/90376873</text></g></g><g id="minder_node861" display="none"><g id="node_expander878" display="none" style="cursor: pointer;"><path id="kity_path_23156" fill="white" stroke="gray" d="M516.5,105.5A6,6,0,1,1,504.5,105.5A6,6,0,1,1,516.5,105.5"></path><path id="kity_path_23157" fill="none" stroke="gray"></path></g><path id="node_outline879" fill="none" stroke="none" d="M516.5,96.5h73a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-73a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text879" fill="black"><text id="kity_text_9462" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="516.5">内存淘汰策略</text></g></g><g id="minder_node862" display="none"><g id="node_expander860" display="none" style="cursor: pointer;"><path id="kity_path_23102" fill="white" stroke="gray" d="M532.5,57.5A6,6,0,1,1,520.5,57.5A6,6,0,1,1,532.5,57.5"></path><path id="kity_path_23103" fill="none" stroke="gray"></path></g><path id="node_outline861" fill="none" stroke="none" d="M532.5,48.5h163a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-163a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text861" fill="black"><text id="kity_text_9396" text-rendering="inherit" font-size="12" dy=".8em" y="49.700000047683716" x="532.5">redis 内存淘汰策略是怎么样的</text></g></g><g id="minder_node863" display="none"><g id="node_expander859" display="none" style="cursor: pointer;"><path id="kity_path_23099" fill="white" stroke="gray" d="M548.5,57.5A6,6,0,1,1,536.5,57.5A6,6,0,1,1,548.5,57.5"></path><path id="kity_path_23100" fill="none" stroke="gray"></path></g><path id="node_outline860" fill="none" stroke="none" d="M548.5,3.5h788a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-788a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text860" fill="black"><text id="kity_text_9389" text-rendering="inherit" font-size="12" dy=".8em" y="4.700000047683716" x="548.5">1.</text><text id="kity_text_9390" text-rendering="inherit" font-size="12" dy=".8em" y="22.700000047683716" x="548.5">Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</text><text id="kity_text_9391" text-rendering="inherit" font-size="12" dy=".8em" y="40.700000047683716" x="548.5">因为内存空间也是有限的，需要定期清理无效数据，这就需要主键失效和淘汰策略。</text><text id="kity_text_9392" text-rendering="inherit" font-size="12" dy=".8em" y="58.700000047683716" x="548.5">如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。</text><text id="kity_text_9393" text-rendering="inherit" font-size="12" dy=".8em" y="76.70000004768372" x="548.5">2.</text><text id="kity_text_9394" text-rendering="inherit" font-size="12" dy=".8em" y="94.70000004768372" x="548.5">通过配置文件maxmemory-policy可以配置要使用哪一个淘汰机制。</text></g></g><g id="minder_node864" display="none"><g id="node_expander858" display="none" style="cursor: pointer;"><path id="kity_path_23096" fill="white" stroke="gray" d="M564.5,57.5A6,6,0,1,1,552.5,57.5A6,6,0,1,1,564.5,57.5"></path><path id="kity_path_23097" fill="none" stroke="gray"></path></g><path id="node_outline859" fill="none" stroke="none" d="M564.5,48.5h333a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text859" fill="black"><text id="kity_text_9387" text-rendering="inherit" font-size="12" dy=".8em" y="49.700000047683716" x="564.5">https://juejin.cn/post/6844903873618903048#heading-16</text></g></g><g id="minder_node865" display="none"><g id="node_expander862" display="none" style="cursor: pointer;"><path id="kity_path_23108" fill="white" stroke="gray" d="M532.5,65.5A6,6,0,1,1,520.5,65.5A6,6,0,1,1,532.5,65.5"></path><path id="kity_path_23109" fill="none" stroke="gray"></path></g><path id="node_outline863" fill="none" stroke="none" d="M532.5,56.5h152a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-152a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text863" fill="black"><text id="kity_text_9408" text-rendering="inherit" font-size="12" dy=".8em" y="57.700000047683716" x="532.5">r edis有哪几种内存淘汰策略</text></g></g><g id="minder_node866" display="none"><g id="node_expander861" display="none" style="cursor: pointer;"><path id="kity_path_23105" fill="white" stroke="gray" d="M548.5,65.5A6,6,0,1,1,536.5,65.5A6,6,0,1,1,548.5,65.5"></path><path id="kity_path_23106" fill="none" stroke="gray"></path></g><path id="node_outline862" fill="none" stroke="none" d="M548.5,-15.5h519a5,5,0,0,1,5,5v152a5,5,0,0,1,-5,5h-519a5,5,0,0,1,-5,-5v-152a5,5,0,0,1,5,-5z"></path><g id="node_text862" fill="black"><text id="kity_text_9398" text-rendering="inherit" font-size="12" dy=".8em" y="-14.299999952316284" x="548.5">1.</text><text id="kity_text_9399" text-rendering="inherit" font-size="12" dy=".8em" y="3.700000047683716" x="548.5">volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</text><text id="kity_text_9400" text-rendering="inherit" font-size="12" dy=".8em" y="21.700000047683716" x="548.5">volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</text><text id="kity_text_9401" text-rendering="inherit" font-size="12" dy=".8em" y="39.700000047683716" x="548.5">volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</text><text id="kity_text_9402" text-rendering="inherit" font-size="12" dy=".8em" y="57.700000047683716" x="548.5">allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</text><text id="kity_text_9403" text-rendering="inherit" font-size="12" dy=".8em" y="75.70000004768372" x="548.5">allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</text><text id="kity_text_9404" text-rendering="inherit" font-size="12" dy=".8em" y="93.70000004768372" x="548.5">no-enviction（驱逐）：禁止驱逐数据,新写入操作会报错</text><text id="kity_text_9405" text-rendering="inherit" font-size="12" dy=".8em" y="111.70000004768372" x="548.5">2.</text><text id="kity_text_9406" text-rendering="inherit" font-size="12" dy=".8em" y="129.70000004768372" x="548.5">6.0.8版本淘汰策略是：noeviction，只要没有被动过期，就不会主动过期，这是默认的淘汰策略。</text></g></g><g id="minder_node867" display="none"><g id="node_expander864" display="none" style="cursor: pointer;"><path id="kity_path_23114" fill="white" stroke="gray" d="M532.5,73.5A6,6,0,1,1,520.5,73.5A6,6,0,1,1,532.5,73.5"></path><path id="kity_path_23115" fill="none" stroke="gray"></path></g><path id="node_outline865" fill="none" stroke="none" d="M532.5,64.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text865" fill="black"><text id="kity_text_9412" text-rendering="inherit" font-size="12" dy=".8em" y="65.70000004768372" x="532.5">超过最大内存限制发生什么？</text></g></g><g id="minder_node868" display="none"><g id="node_expander863" display="none" style="cursor: pointer;"><path id="kity_path_23111" fill="white" stroke="gray" d="M548.5,73.5A6,6,0,1,1,536.5,73.5A6,6,0,1,1,548.5,73.5"></path><path id="kity_path_23112" fill="none" stroke="gray"></path></g><path id="node_outline864" fill="none" stroke="none" d="M548.5,64.5h226a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-226a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text864" fill="black"><text id="kity_text_9410" text-rendering="inherit" font-size="12" dy=".8em" y="65.70000004768372" x="548.5">1.新写入操作会报错，可以读，不可以写入</text></g></g><g id="minder_node869" display="none"><g id="node_expander866" display="none" style="cursor: pointer;"><path id="kity_path_23120" fill="white" stroke="gray" d="M532.5,81.5A6,6,0,1,1,520.5,81.5A6,6,0,1,1,532.5,81.5"></path><path id="kity_path_23121" fill="none" stroke="gray"></path></g><path id="node_outline867" fill="none" stroke="none" d="M532.5,72.5h194a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-194a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text867" fill="black"><text id="kity_text_9420" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="532.5">说说内存淘汰的选择场景？如何选择</text></g></g><g id="minder_node870" display="none"><g id="node_expander865" display="none" style="cursor: pointer;"><path id="kity_path_23117" fill="white" stroke="gray" d="M548.5,81.5A6,6,0,1,1,536.5,81.5A6,6,0,1,1,548.5,81.5"></path><path id="kity_path_23118" fill="none" stroke="gray"></path></g><path id="node_outline866" fill="none" stroke="none" d="M548.5,36.5h938a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-938a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text866" fill="black"><text id="kity_text_9414" text-rendering="inherit" font-size="12" dy=".8em" y="37.700000047683716" x="548.5">1.</text><text id="kity_text_9415" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="548.5">如果数据呈现幂等分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用 allkeys-lru。</text><text id="kity_text_9416" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="548.5">如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用 allkeys-random。</text><text id="kity_text_9417" text-rendering="inherit" font-size="12" dy=".8em" y="91.70000004768372" x="548.5">volatile-lru 策略和 volatile-random 策略适合我们将一个 Redis 实例既应用于缓存和又应用于持久化存储的时候，然而我们也可以通过使用两个 Redis 实例来达到相同的效果。</text><text id="kity_text_9418" text-rendering="inherit" font-size="12" dy=".8em" y="109.70000004768372" x="548.5">将 key 设置过期时间实际上会消耗更多的内存，建议使用 allkeys-lru 策略从而更有效率的使用内存。</text></g></g><g id="minder_node871" display="none"><g id="node_expander868" display="none" style="cursor: pointer;"><path id="kity_path_23126" fill="white" stroke="gray" d="M532.5,89.5A6,6,0,1,1,520.5,89.5A6,6,0,1,1,532.5,89.5"></path><path id="kity_path_23127" fill="none" stroke="gray"></path></g><path id="node_outline869" fill="none" stroke="none" d="M532.5,80.5h112a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-112a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text869" fill="black"><text id="kity_text_9424" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="532.5">redis什么时候会慢？</text></g></g><g id="minder_node872" display="none"><g id="node_expander867" display="none" style="cursor: pointer;"><path id="kity_path_23123" fill="white" stroke="gray" d="M548.5,89.5A6,6,0,1,1,536.5,89.5A6,6,0,1,1,548.5,89.5"></path><path id="kity_path_23124" fill="none" stroke="gray"></path></g><path id="node_outline868" fill="none" stroke="none" d="M519.5,-129.5h112a5,5,0,0,1,5,5v223a5,5,0,0,1,-5,5h-112a5,5,0,0,1,-5,-5v-223a5,5,0,0,1,5,-5z"></path><g id="node_text868" fill="black"><text id="kity_text_9422" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="548.5">参考</text></g><a id="kity_a_16916" xlink:href="https://zhuanlan.zhihu.com/p/346302897" target="_blank" xlink:title="https://zhuanlan.zhihu.com/p/346302897" style="cursor: pointer;"><path id="kity_path_16918" fill="rgba(255, 255, 255, 0)" stroke="none" d="M581.5,78.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16917" fill="#666" stroke="none" d="M596.114,94.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V88.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C591.766,85.571,593.168,84.5,594.836,84.5h1.278c2.116,0,3.834,1.716,3.834,3.834V90.89C599.948,93.008,598.23,94.724,596.114,94.724zM584.612,89.612c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S594.265,90.89,593.558,90.89H585.89C585.185,90.89,584.612,90.319,584.612,89.612zM582.056,88.334V90.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H583.334C581.216,94.724,579.5,93.008,579.5,90.89V88.334C579.5,86.216,581.216,84.5,583.334,84.5h1.278c1.667,0,3.071,1.071,3.599,2.556H583.334C582.629,87.056,582.056,87.627,582.056,88.334z"></path></a><image id="kity_image_17046" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210322160612.png" x="519.5" y="-126.5" width="112" height="200"></image></g><g id="minder_node873" display="none"><g id="node_expander874" display="none" style="cursor: pointer;"><path id="kity_path_23144" fill="white" stroke="gray" d="M532.5,97.5A6,6,0,1,1,520.5,97.5A6,6,0,1,1,532.5,97.5"></path><path id="kity_path_23145" fill="none" stroke="gray"></path></g><path id="node_outline875" fill="none" stroke="none" d="M532.5,88.5h48a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-48a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text875" fill="black"><text id="kity_text_9453" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="532.5">LRU算法</text></g></g><g id="minder_node874" display="none"><g id="node_expander869" display="none" style="cursor: pointer;"><path id="kity_path_23129" fill="white" stroke="gray" d="M548.5,81.5A6,6,0,1,1,536.5,81.5A6,6,0,1,1,548.5,81.5"></path><path id="kity_path_23130" fill="none" stroke="gray"></path></g><path id="node_outline870" fill="none" stroke="none" d="M548.5,72.5h71a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-71a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text870" fill="black"><text id="kity_text_9426" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="548.5">LRU是什么？</text></g></g><g id="minder_node875" display="none"><g id="node_expander871" display="none" style="cursor: pointer;"><path id="kity_path_23135" fill="white" stroke="gray" d="M548.5,89.5A6,6,0,1,1,536.5,89.5A6,6,0,1,1,548.5,89.5"></path><path id="kity_path_23136" fill="none" stroke="gray"></path></g><path id="node_outline872" fill="none" stroke="none" d="M548.5,80.5h182a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-182a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text872" fill="black"><text id="kity_text_9433" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="548.5">&#xa0;Redis的内存淘汰策略 LRU说思路</text></g></g><g id="minder_node876" display="none"><g id="node_expander870" display="none" style="cursor: pointer;"><path id="kity_path_23132" fill="white" stroke="gray" d="M564.5,89.5A6,6,0,1,1,552.5,89.5A6,6,0,1,1,564.5,89.5"></path><path id="kity_path_23133" fill="none" stroke="gray"></path></g><path id="node_outline871" fill="none" stroke="none" d="M564.5,53.5h780a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-780a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text871" fill="black"><text id="kity_text_9428" text-rendering="inherit" font-size="12" dy=".8em" y="54.700000047683716" x="564.5">1.</text><text id="kity_text_9429" text-rendering="inherit" font-size="12" dy=".8em" y="72.70000004768372" x="564.5">链表 + Hash;链表是控制优先级顺序，Hash控制是快速定位到具体的内容</text><text id="kity_text_9430" text-rendering="inherit" font-size="12" dy=".8em" y="90.70000004768372" x="564.5">2.</text><text id="kity_text_9431" text-rendering="inherit" font-size="12" dy=".8em" y="108.70000004768372" x="564.5">LRU算法，是一种 活跃淘汰算法，按照链表实现，可以使用Hash快速查找、通过双向链表绑定，进行活跃前置，不活跃则解除可达性引用，被GC；</text></g></g><g id="minder_node877" display="none"><g id="node_expander873" display="none" style="cursor: pointer;"><path id="kity_path_23141" fill="white" stroke="gray" d="M548.5,97.5A6,6,0,1,1,536.5,97.5A6,6,0,1,1,548.5,97.5"></path><path id="kity_path_23142" fill="none" stroke="gray"></path></g><path id="node_outline874" fill="none" stroke="none" d="M548.5,88.5h60a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-60a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text874" fill="black"><text id="kity_text_9451" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="548.5">写一下LRU</text></g></g><g id="minder_node878" display="none"><g id="node_expander872" display="none" style="cursor: pointer;"><path id="kity_path_23138" fill="white" stroke="gray" d="M564.5,97.5A6,6,0,1,1,552.5,97.5A6,6,0,1,1,564.5,97.5"></path><path id="kity_path_23139" fill="none" stroke="gray"></path></g><path id="node_outline873" fill="none" stroke="none" d="M564.5,-37.5h417a5,5,0,0,1,5,5v260a5,5,0,0,1,-5,5h-417a5,5,0,0,1,-5,-5v-260a5,5,0,0,1,5,-5z"></path><g id="node_text873" fill="black"><text id="kity_text_9435" text-rendering="inherit" font-size="12" dy=".8em" y="-36.299999952316284" x="564.5">public class LruDemo extends LinkedHashMap {</text><text id="kity_text_9436" text-rendering="inherit" font-size="12" dy=".8em" y="-18.299999952316284" x="564.5">private final int capacity;</text><text id="kity_text_9437" text-rendering="inherit" font-size="12" dy=".8em" y="-0.2999999523162842" x="564.5">/**</text><text id="kity_text_9438" text-rendering="inherit" font-size="12" dy=".8em" y="17.700000047683716" x="564.5">&#xa0;* @param capacity&#xa0; &#xa0; 最大容量</text><text id="kity_text_9439" text-rendering="inherit" font-size="12" dy=".8em" y="35.700000047683716" x="564.5">&#xa0;* @param accessOrder 排序规则：true=最近热点数据&#xa0; false=首次进入规则</text><text id="kity_text_9440" text-rendering="inherit" font-size="12" dy=".8em" y="53.700000047683716" x="564.5">&#xa0;*/</text><text id="kity_text_9441" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="564.5">public LruDemo(int capacity, boolean accessOrder) {</text><text id="kity_text_9442" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="564.5">	super(capacity, 0.75F, accessOrder);</text><text id="kity_text_9443" text-rendering="inherit" font-size="12" dy=".8em" y="107.70000004768372" x="564.5">	this.capacity = capacity;</text><text id="kity_text_9444" text-rendering="inherit" font-size="12" dy=".8em" y="125.70000004768372" x="564.5">}</text><text id="kity_text_9445" text-rendering="inherit" font-size="12" dy=".8em" y="143.70000004768372" x="564.5">@Override</text><text id="kity_text_9446" text-rendering="inherit" font-size="12" dy=".8em" y="161.70000004768372" x="564.5">protected boolean removeEldestEntry(Map.Entry eldest) {</text><text id="kity_text_9447" text-rendering="inherit" font-size="12" dy=".8em" y="179.70000004768372" x="564.5">	return super.size() &gt; capacity;</text><text id="kity_text_9448" text-rendering="inherit" font-size="12" dy=".8em" y="197.70000004768372" x="564.5">}}</text><text id="kity_text_9449" text-rendering="inherit" font-size="12" dy=".8em" y="215.70000004768372" x="564.5"> </text></g></g><g id="minder_node879" display="none"><g id="node_expander877" display="none" style="cursor: pointer;"><path id="kity_path_23153" fill="white" stroke="gray" d="M532.5,105.5A6,6,0,1,1,520.5,105.5A6,6,0,1,1,532.5,105.5"></path><path id="kity_path_23154" fill="none" stroke="gray"></path></g><path id="node_outline878" fill="none" stroke="none" d="M532.5,96.5h22a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-22a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text878" fill="black"><text id="kity_text_9460" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="532.5">LFU</text></g></g><g id="minder_node880" display="none"><g id="node_expander876" display="none" style="cursor: pointer;"><path id="kity_path_23150" fill="white" stroke="gray" d="M548.5,105.5A6,6,0,1,1,536.5,105.5A6,6,0,1,1,548.5,105.5"></path><path id="kity_path_23151" fill="none" stroke="gray"></path></g><path id="node_outline877" fill="none" stroke="none" d="M548.5,96.5h58a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-58a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text877" fill="black"><text id="kity_text_9458" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="548.5">了解LFU吗</text></g></g><g id="minder_node881" display="none"><g id="node_expander875" display="none" style="cursor: pointer;"><path id="kity_path_23147" fill="white" stroke="gray" d="M564.5,105.5A6,6,0,1,1,552.5,105.5A6,6,0,1,1,564.5,105.5"></path><path id="kity_path_23148" fill="none" stroke="gray"></path></g><path id="node_outline876" fill="none" stroke="none" d="M564.5,87.5h474a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-474a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text876" fill="black"><text id="kity_text_9455" text-rendering="inherit" font-size="12" dy=".8em" y="88.70000004768372" x="564.5">1.LFU算法就是一种最近不怎么使用的淘汰算法；</text><text id="kity_text_9456" text-rendering="inherit" font-size="12" dy=".8em" y="106.70000004768372" x="564.5">2.LRU针对时间角度进行淘汰（最新数据）；LFU为针对使用频率进行淘汰（热点数据）；</text></g></g><g id="minder_node882" display="none"><g id="node_expander889" display="none" style="cursor: pointer;"><path id="kity_path_23189" fill="white" stroke="gray" d="M516.5,113.5A6,6,0,1,1,504.5,113.5A6,6,0,1,1,516.5,113.5"></path><path id="kity_path_23190" fill="none" stroke="gray"></path></g><path id="node_outline890" fill="none" stroke="none" d="M516.5,104.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text890" fill="black"><text id="kity_text_9484" text-rendering="inherit" font-size="12" dy=".8em" y="105.70000004768372" x="516.5">存储结构</text></g></g><g id="minder_node883" display="none"><g id="node_expander885" display="none" style="cursor: pointer;"><path id="kity_path_23177" fill="white" stroke="gray" d="M532.5,105.5A6,6,0,1,1,520.5,105.5A6,6,0,1,1,532.5,105.5"></path><path id="kity_path_23178" fill="none" stroke="gray"></path></g><path id="node_outline886" fill="none" stroke="none" d="M532.5,96.5h112a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-112a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text886" fill="black"><text id="kity_text_9476" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="532.5">redisobject的结构？</text></g></g><g id="minder_node884" display="none"><g id="node_expander884" display="none" style="cursor: pointer;"><path id="kity_path_23174" fill="white" stroke="gray" d="M548.5,105.5A6,6,0,1,1,536.5,105.5A6,6,0,1,1,548.5,105.5"></path><path id="kity_path_23175" fill="none" stroke="gray"></path></g><path id="node_outline885" fill="none" stroke="none" d="M548.5,96.5h66a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-66a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text885" fill="black"><text id="kity_text_9474" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="548.5">redisObject</text></g></g><g id="minder_node885" display="none"><g id="node_expander879" display="none" style="cursor: pointer;"><path id="kity_path_23159" fill="white" stroke="gray" d="M564.5,73.5A6,6,0,1,1,552.5,73.5A6,6,0,1,1,564.5,73.5"></path><path id="kity_path_23160" fill="none" stroke="gray"></path></g><path id="node_outline880" fill="none" stroke="none" d="M564.5,64.5h79a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-79a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text880" fill="black"><text id="kity_text_9464" text-rendering="inherit" font-size="12" dy=".8em" y="65.70000004768372" x="564.5">type 数据类型</text></g></g><g id="minder_node886" display="none"><g id="node_expander880" display="none" style="cursor: pointer;"><path id="kity_path_23162" fill="white" stroke="gray" d="M564.5,81.5A6,6,0,1,1,552.5,81.5A6,6,0,1,1,564.5,81.5"></path><path id="kity_path_23163" fill="none" stroke="gray"></path></g><path id="node_outline881" fill="none" stroke="none" d="M564.5,72.5h106a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-106a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text881" fill="black"><text id="kity_text_9466" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="564.5">encoding 编码方式</text></g></g><g id="minder_node887" display="none"><g id="node_expander881" display="none" style="cursor: pointer;"><path id="kity_path_23165" fill="white" stroke="gray" d="M564.5,89.5A6,6,0,1,1,552.5,89.5A6,6,0,1,1,564.5,89.5"></path><path id="kity_path_23166" fill="none" stroke="gray"></path></g><path id="node_outline882" fill="none" stroke="none" d="M564.5,80.5h69a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-69a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text882" fill="black"><text id="kity_text_9468" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="564.5">ptr 数据指针</text></g></g><g id="minder_node888" display="none"><g id="node_expander882" display="none" style="cursor: pointer;"><path id="kity_path_23168" fill="white" stroke="gray" d="M564.5,97.5A6,6,0,1,1,552.5,97.5A6,6,0,1,1,564.5,97.5"></path><path id="kity_path_23169" fill="none" stroke="gray"></path></g><path id="node_outline883" fill="none" stroke="none" d="M564.5,88.5h71a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-71a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text883" fill="black"><text id="kity_text_9470" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="564.5">vm 虚拟内存</text></g></g><g id="minder_node889" display="none"><g id="node_expander883" display="none" style="cursor: pointer;"><path id="kity_path_23171" fill="white" stroke="gray" d="M564.5,105.5A6,6,0,1,1,552.5,105.5A6,6,0,1,1,564.5,105.5"></path><path id="kity_path_23172" fill="none" stroke="gray"></path></g><path id="node_outline884" fill="none" stroke="none" d="M564.5,96.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text884" fill="black"><text id="kity_text_9472" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="564.5">其他</text></g></g><g id="minder_node890" display="none"><g id="node_expander888" display="none" style="cursor: pointer;"><path id="kity_path_23186" fill="white" stroke="gray" d="M532.5,113.5A6,6,0,1,1,520.5,113.5A6,6,0,1,1,532.5,113.5"></path><path id="kity_path_23187" fill="none" stroke="gray"></path></g><path id="node_outline889" fill="none" stroke="none" d="M532.5,104.5h78a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-78a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text889" fill="black"><text id="kity_text_9482" text-rendering="inherit" font-size="12" dy=".8em" y="105.70000004768372" x="532.5">redisObject？</text></g></g><g id="minder_node891" display="none"><g id="node_expander887" display="none" style="cursor: pointer;"><path id="kity_path_23183" fill="white" stroke="gray" d="M548.5,113.5A6,6,0,1,1,536.5,113.5A6,6,0,1,1,548.5,113.5"></path><path id="kity_path_23184" fill="none" stroke="gray"></path></g><path id="node_outline888" fill="none" stroke="none" d="M548.5,104.5h337a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-337a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text888" fill="black"><text id="kity_text_9480" text-rendering="inherit" font-size="12" dy=".8em" y="105.70000004768372" x="548.5">1. redis内部使用一个redisObject对象来表示所有的key和value</text></g></g><g id="minder_node892" display="none"><g id="node_expander886" display="none" style="cursor: pointer;"><path id="kity_path_23180" fill="white" stroke="gray" d="M564.5,113.5A6,6,0,1,1,552.5,113.5A6,6,0,1,1,564.5,113.5"></path><path id="kity_path_23181" fill="none" stroke="gray"></path></g><path id="node_outline887" fill="none" stroke="none" d="M524.5,-9.5h200a5,5,0,0,1,5,5v127a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-127a5,5,0,0,1,5,-5z"></path><g id="node_text887" fill="black"><text id="kity_text_9478" text-rendering="inherit" font-size="12" dy=".8em" y="105.70000004768372" x="564.5">参考redisObject</text></g><a id="kity_a_16919" xlink:href="https://blog.csdn.net/u013256816/article/details/51133134" target="_blank" xlink:title="https://blog.csdn.net/u013256816/article/details/51133134" style="cursor: pointer;"><path id="kity_path_16921" fill="rgba(255, 255, 255, 0)" stroke="none" d="M663.5,102.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16920" fill="#666" stroke="none" d="M678.114,118.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V112.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C673.766,109.571,675.168,108.5,676.836,108.5h1.278c2.116,0,3.834,1.716,3.834,3.834V114.89C681.948,117.008,680.23,118.724,678.114,118.724zM666.612,113.612c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S676.265,114.89,675.558,114.89H667.89C667.185,114.89,666.612,114.319,666.612,113.612zM664.056,112.334V114.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H665.334C663.216,118.724,661.5,117.008,661.5,114.89V112.334C661.5,110.216,663.216,108.5,665.334,108.5h1.278c1.667,0,3.071,1.071,3.599,2.556H665.334C664.629,111.056,664.056,111.627,664.056,112.334z"></path></a><image id="kity_image_17047" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210322161239.png" x="524.5" y="-6.5" width="200" height="104"></image></g><g id="minder_node893" display="none"><g id="node_expander928" display="none" style="cursor: pointer;"><path id="kity_path_23306" fill="white" stroke="gray" d="M500.5,121.5A6,6,0,1,1,488.5,121.5A6,6,0,1,1,500.5,121.5"></path><path id="kity_path_23307" fill="none" stroke="gray"></path></g><path id="node_outline929" fill="none" stroke="none" d="M500.5,112.5h77a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-77a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text929" fill="black"><text id="kity_text_9625" text-rendering="inherit" font-size="12" dy=".8em" y="113.70000004768372" x="500.5">redis的持久化</text></g></g><g id="minder_node894" display="none"><g id="node_expander892" display="none" style="cursor: pointer;"><path id="kity_path_23198" fill="white" stroke="gray" d="M516.5,73.5A6,6,0,1,1,504.5,73.5A6,6,0,1,1,516.5,73.5"></path><path id="kity_path_23199" fill="none" stroke="gray"></path></g><path id="node_outline893" fill="none" stroke="none" d="M516.5,64.5h96a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-96a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text893" fill="black"><text id="kity_text_9492" text-rendering="inherit" font-size="12" dy=".8em" y="65.70000004768372" x="516.5">为什么要持久化？</text></g></g><g id="minder_node895" display="none"><g id="node_expander891" display="none" style="cursor: pointer;"><path id="kity_path_23195" fill="white" stroke="gray" d="M532.5,73.5A6,6,0,1,1,520.5,73.5A6,6,0,1,1,532.5,73.5"></path><path id="kity_path_23196" fill="none" stroke="gray"></path></g><path id="node_outline892" fill="none" stroke="none" d="M532.5,46.5h751a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-751a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text892" fill="black"><text id="kity_text_9488" text-rendering="inherit" font-size="12" dy=".8em" y="47.700000047683716" x="532.5">1.</text><text id="kity_text_9489" text-rendering="inherit" font-size="12" dy=".8em" y="65.70000004768372" x="532.5">因为Redis数据在内存，断电既丢，因此持久化到磁盘是必须得有的，Redis提供了RDB跟AOF两种模式。</text><text id="kity_text_9490" text-rendering="inherit" font-size="12" dy=".8em" y="83.70000004768372" x="532.5">为了避免内存中数据丢失，Redis提供了对持久化的支持，我们可以选择不同的方式将数据从内存中保存到硬盘当中，使数据可以持久化保存。</text></g></g><g id="minder_node896" display="none"><g id="node_expander894" display="none" style="cursor: pointer;"><path id="kity_path_23204" fill="white" stroke="gray" d="M516.5,81.5A6,6,0,1,1,504.5,81.5A6,6,0,1,1,516.5,81.5"></path><path id="kity_path_23205" fill="none" stroke="gray"></path></g><path id="node_outline895" fill="none" stroke="none" d="M516.5,72.5h185a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-185a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text895" fill="black"><text id="kity_text_9496" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="516.5">说一下redis的持久化策略有那几种</text></g></g><g id="minder_node897" display="none"><g id="node_expander893" display="none" style="cursor: pointer;"><path id="kity_path_23201" fill="white" stroke="gray" d="M532.5,81.5A6,6,0,1,1,520.5,81.5A6,6,0,1,1,532.5,81.5"></path><path id="kity_path_23202" fill="none" stroke="gray"></path></g><path id="node_outline894" fill="none" stroke="none" d="M532.5,72.5h245a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-245a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text894" fill="black"><text id="kity_text_9494" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="532.5">1.Redis 支持两种持久化方式：RDB 和 AOF。</text></g></g><g id="minder_node898" display="none"><g id="node_expander909" display="none" style="cursor: pointer;"><path id="kity_path_23249" fill="white" stroke="gray" d="M516.5,89.5A6,6,0,1,1,504.5,89.5A6,6,0,1,1,516.5,89.5"></path><path id="kity_path_23250" fill="none" stroke="gray"></path></g><path id="node_outline910" fill="none" stroke="none" d="M516.5,80.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text910" fill="black"><text id="kity_text_9556" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="516.5">AOF</text></g></g><g id="minder_node899" display="none"><g id="node_expander897" display="none" style="cursor: pointer;"><path id="kity_path_23213" fill="white" stroke="gray" d="M532.5,49.5A6,6,0,1,1,520.5,49.5A6,6,0,1,1,532.5,49.5"></path><path id="kity_path_23214" fill="none" stroke="gray"></path></g><path id="node_outline898" fill="none" stroke="none" d="M532.5,40.5h139a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-139a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text898" fill="black"><text id="kity_text_9508" text-rendering="inherit" font-size="12" dy=".8em" y="41.700000047683716" x="532.5">说说AOF？怎么用?原理？</text></g></g><g id="minder_node900" display="none"><g id="node_expander896" display="none" style="cursor: pointer;"><path id="kity_path_23210" fill="white" stroke="gray" d="M548.5,49.5A6,6,0,1,1,536.5,49.5A6,6,0,1,1,548.5,49.5"></path><path id="kity_path_23211" fill="none" stroke="gray"></path></g><path id="node_outline897" fill="none" stroke="none" d="M548.5,-13.5h1274a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-1274a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text897" fill="black"><text id="kity_text_9500" text-rendering="inherit" font-size="12" dy=".8em" y="-12.299999952316284" x="548.5">1.AOF(Append-only-file)</text><text id="kity_text_9501" text-rendering="inherit" font-size="12" dy=".8em" y="5.700000047683716" x="548.5">AOF持久化方式会记录客户端对服务器的每一次写操作命令，并将这些写操作以Redis协议以独立日志的形式追加保存到以后缀为aof文件末尾，具有实时性，在Redis服务器重启时，会加载并运行aof文件的命令，以达到恢复数据的目的。</text><text id="kity_text_9502" text-rendering="inherit" font-size="12" dy=".8em" y="23.700000047683716" x="548.5">2.配置开启看备注</text><text id="kity_text_9503" text-rendering="inherit" font-size="12" dy=".8em" y="41.700000047683716" x="548.5">3.原理</text><text id="kity_text_9504" text-rendering="inherit" font-size="12" dy=".8em" y="59.700000047683716" x="548.5">写命令刷新缓冲区，每一条命令通过一个后台的线程fsync操作，数据丢失不用怕。</text><text id="kity_text_9505" text-rendering="inherit" font-size="12" dy=".8em" y="77.70000004768372" x="548.5">fsync:定期冲洗内核的块缓冲区等待写磁盘。</text><text id="kity_text_9506" text-rendering="inherit" font-size="12" dy=".8em" y="95.70000004768372" x="548.5">确保文件fd所有已修改的内容已经正确同步到硬盘上，该调用会阻塞等待直到设备报告IO完成。</text></g><g id="kity_g_16979" style="cursor: pointer;"><path id="kity_path_16980" fill="none" stroke="none" d="M1809,41h12a2,2,0,0,1,2,2v13a2,2,0,0,1,-2,2h-12a2,2,0,0,1,-2,-2v-13a2,2,0,0,1,2,-2z"></path><path id="kity_path_16981" fill="black" stroke="none" d="M1818,52H1812V51h6L1818,52L1818,52zM1818,50H1812V49h6V50zM1818,48H1812V47h6V48zM1817.5,54H1811V45h8v7.5M1818,55l2,-2V44H1810v11"></path></g></g><g id="minder_node901" display="none"><g id="node_expander895" display="none" style="cursor: pointer;"><path id="kity_path_23207" fill="white" stroke="gray" d="M564.5,49.5A6,6,0,1,1,552.5,49.5A6,6,0,1,1,564.5,49.5"></path><path id="kity_path_23208" fill="none" stroke="gray"></path></g><path id="node_outline896" fill="none" stroke="none" d="M489.5,-59.5h200a5,5,0,0,1,5,5v108a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-108a5,5,0,0,1,5,-5z"></path><g id="node_text896" fill="black"><text id="kity_text_9498" text-rendering="inherit" font-size="12" dy=".8em" y="41.700000047683716" x="564.5">分支主题</text></g><image id="kity_image_17048" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210322164419.png" x="489.5" y="-56.5" width="200" height="95"></image></g><g id="minder_node902" display="none"><g id="node_expander899" display="none" style="cursor: pointer;"><path id="kity_path_23219" fill="white" stroke="gray" d="M532.5,57.5A6,6,0,1,1,520.5,57.5A6,6,0,1,1,532.5,57.5"></path><path id="kity_path_23220" fill="none" stroke="gray"></path></g><path id="node_outline900" fill="none" stroke="none" d="M532.5,48.5h122a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-122a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text900" fill="black"><text id="kity_text_9517" text-rendering="inherit" font-size="12" dy=".8em" y="49.700000047683716" x="532.5">说说AOF的三种策略？</text></g></g><g id="minder_node903" display="none"><g id="node_expander898" display="none" style="cursor: pointer;"><path id="kity_path_23216" fill="white" stroke="gray" d="M548.5,57.5A6,6,0,1,1,536.5,57.5A6,6,0,1,1,548.5,57.5"></path><path id="kity_path_23217" fill="none" stroke="gray"></path></g><path id="node_outline899" fill="none" stroke="none" d="M548.5,3.5h656a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-656a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text899" fill="black"><text id="kity_text_9510" text-rendering="inherit" font-size="12" dy=".8em" y="4.700000047683716" x="548.5">1. always</text><text id="kity_text_9511" text-rendering="inherit" font-size="12" dy=".8em" y="22.700000047683716" x="548.5">客户端的每一个写操作都保存到aof文件当，这种策略很安全，但是每个写请注都有IO操作，所以也很慢。</text><text id="kity_text_9512" text-rendering="inherit" font-size="12" dy=".8em" y="40.700000047683716" x="548.5">2. everysec</text><text id="kity_text_9513" text-rendering="inherit" font-size="12" dy=".8em" y="58.700000047683716" x="548.5">appendfsync的默认写入策略，每秒写入一次aof文件，因此，最多可能会丢失1s的数据。一般采用这种</text><text id="kity_text_9514" text-rendering="inherit" font-size="12" dy=".8em" y="76.70000004768372" x="548.5">3. no</text><text id="kity_text_9515" text-rendering="inherit" font-size="12" dy=".8em" y="94.70000004768372" x="548.5">Redis服务器不负责写入aof，而是交由操作系统来处理什么时候写入aof文件。更快，但也是最不安全的选择，不推荐使用。</text></g></g><g id="minder_node904" display="none"><g id="node_expander901" display="none" style="cursor: pointer;"><path id="kity_path_23225" fill="white" stroke="gray" d="M532.5,65.5A6,6,0,1,1,520.5,65.5A6,6,0,1,1,532.5,65.5"></path><path id="kity_path_23226" fill="none" stroke="gray"></path></g><path id="node_outline902" fill="none" stroke="none" d="M532.5,56.5h290a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-290a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text902" fill="black"><text id="kity_text_9528" text-rendering="inherit" font-size="12" dy=".8em" y="57.700000047683716" x="532.5">AOF重写？为什么要AOF重写？哪些方式？怎么开启？</text></g></g><g id="minder_node905" display="none"><g id="node_expander900" display="none" style="cursor: pointer;"><path id="kity_path_23222" fill="white" stroke="gray" d="M548.5,65.5A6,6,0,1,1,536.5,65.5A6,6,0,1,1,548.5,65.5"></path><path id="kity_path_23223" fill="none" stroke="gray"></path></g><path id="node_outline901" fill="none" stroke="none" d="M548.5,-6.5h736a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-736a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text901" fill="black"><text id="kity_text_9519" text-rendering="inherit" font-size="12" dy=".8em" y="-5.299999952316284" x="548.5">1.</text><text id="kity_text_9520" text-rendering="inherit" font-size="12" dy=".8em" y="12.700000047683716" x="548.5">AOF将客户端的每一个写操作都追加到aof文件末尾，会导致aof文件会变得非常大。而有些命令是可以合并的。比如incr 一百次</text><text id="kity_text_9521" text-rendering="inherit" font-size="12" dy=".8em" y="30.700000047683716" x="548.5">通过重写aof，可以生成一个恢复当前数据的最少命令集</text><text id="kity_text_9522" text-rendering="inherit" font-size="12" dy=".8em" y="48.700000047683716" x="548.5">2.方式和开启：</text><text id="kity_text_9523" text-rendering="inherit" font-size="12" dy=".8em" y="66.70000004768372" x="548.5">(1)手动:直接在redis-cli调用bgrewriteaof命令</text><text id="kity_text_9524" text-rendering="inherit" font-size="12" dy=".8em" y="84.70000004768372" x="548.5">(2)自动: 两个配置文件参数，默认是不重写的，no-appendfsync-on-rewrite no</text><text id="kity_text_9525" text-rendering="inherit" font-size="12" dy=".8em" y="102.70000004768372" x="548.5">auto-aof-rewrite-min-size：表示运行AOF重写时文件最小体积，默认为64MB。</text><text id="kity_text_9526" text-rendering="inherit" font-size="12" dy=".8em" y="120.70000004768372" x="548.5">auto-aof-rewrite-percentage：代表当前AOF文件空间（aof_current_size）和上一次重写后 AOF 文件空间（aof_base_size）的比值</text></g><g id="kity_g_16982" style="cursor: pointer;"><path id="kity_path_16983" fill="none" stroke="none" d="M1271,57h12a2,2,0,0,1,2,2v13a2,2,0,0,1,-2,2h-12a2,2,0,0,1,-2,-2v-13a2,2,0,0,1,2,-2z"></path><path id="kity_path_16984" fill="black" stroke="none" d="M1280,68H1274V67h6L1280,68L1280,68zM1280,66H1274V65h6V66zM1280,64H1274V63h6V64zM1279.5,70H1273V61h8v7.5M1280,71l2,-2V60H1272v11"></path></g></g><g id="minder_node906" display="none"><g id="node_expander903" display="none" style="cursor: pointer;"><path id="kity_path_23231" fill="white" stroke="gray" d="M532.5,73.5A6,6,0,1,1,520.5,73.5A6,6,0,1,1,532.5,73.5"></path><path id="kity_path_23232" fill="none" stroke="gray"></path></g><path id="node_outline904" fill="none" stroke="none" d="M532.5,64.5h97a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-97a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text904" fill="black"><text id="kity_text_9534" text-rendering="inherit" font-size="12" dy=".8em" y="65.70000004768372" x="532.5">重写宕机怎么办？</text></g></g><g id="minder_node907" display="none"><g id="node_expander902" display="none" style="cursor: pointer;"><path id="kity_path_23228" fill="white" stroke="gray" d="M548.5,73.5A6,6,0,1,1,536.5,73.5A6,6,0,1,1,548.5,73.5"></path><path id="kity_path_23229" fill="none" stroke="gray"></path></g><path id="node_outline903" fill="none" stroke="none" d="M548.5,46.5h476a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-476a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text903" fill="black"><text id="kity_text_9530" text-rendering="inherit" font-size="12" dy=".8em" y="47.700000047683716" x="548.5">1.备份现在aof文件</text><text id="kity_text_9531" text-rendering="inherit" font-size="12" dy=".8em" y="65.70000004768372" x="548.5">2.使用redis-check-aof命令修复aof文件，该命令格式如下：redis-check-aof -fix file.aof</text><text id="kity_text_9532" text-rendering="inherit" font-size="12" dy=".8em" y="83.70000004768372" x="548.5">3.重启Redis服务器，加载已经修复的aof文件，恢复数据。</text></g></g><g id="minder_node908" display="none"><g id="node_expander906" display="none" style="cursor: pointer;"><path id="kity_path_23240" fill="white" stroke="gray" d="M532.5,81.5A6,6,0,1,1,520.5,81.5A6,6,0,1,1,532.5,81.5"></path><path id="kity_path_23241" fill="none" stroke="gray"></path></g><path id="node_outline907" fill="none" stroke="none" d="M532.5,72.5h217a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-217a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text907" fill="black"><text id="kity_text_9545" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="532.5">重写过程中主线程还在响应命令怎么办？</text></g></g><g id="minder_node909" display="none"><g id="node_expander905" display="none" style="cursor: pointer;"><path id="kity_path_23237" fill="white" stroke="gray" d="M548.5,81.5A6,6,0,1,1,536.5,81.5A6,6,0,1,1,548.5,81.5"></path><path id="kity_path_23238" fill="none" stroke="gray"></path></g><path id="node_outline906" fill="none" stroke="none" d="M548.5,27.5h1046a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1046a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text906" fill="black"><text id="kity_text_9538" text-rendering="inherit" font-size="12" dy=".8em" y="28.700000047683716" x="548.5">1.为了保证最终备份的完整性；它依然会写入旧的AOF中，如果重写失败，能够保证数据不丢失。主要是通过为子进程保留一个buf(重写缓存区)，可以把重写期间响应的写入信息也写入到新的文件中</text><text id="kity_text_9539" text-rendering="inherit" font-size="12" dy=".8em" y="46.700000047683716" x="548.5">重写过程有两个缓存区，一个是AOF缓存区，一个是AOF重写缓存区。</text><text id="kity_text_9540" text-rendering="inherit" font-size="12" dy=".8em" y="64.70000004768372" x="548.5">AOF缓存区是为了保持新AOF和老AOF数据原则，而AOF重写缓存区是为了处理重写过程中主线程处理响应的那一部分数据。</text><text id="kity_text_9541" text-rendering="inherit" font-size="12" dy=".8em" y="82.70000004768372" x="548.5">当子进程完成AOF重写后，它会向父进程发送一个信号，父进程收到信号后会调用一个信号处理函数，该函数把AOF重写缓冲区的命令追加到新AOF文件中然后替换掉现有AOF文件。</text><text id="kity_text_9542" text-rendering="inherit" font-size="12" dy=".8em" y="100.70000004768372" x="548.5">2.而重写是直接把当前内存的数据生成对应命令，并不需要读取老的AOF文件进行分析、命令合并，和老AOF没关系</text><text id="kity_text_9543" text-rendering="inherit" font-size="12" dy=".8em" y="118.70000004768372" x="548.5">3.最后无论是 RDB 还是 AOF 都是先写入一个临时文件，然后通过rename完成文件的替换工作。</text></g></g><g id="minder_node910" display="none"><g id="node_expander904" display="none" style="cursor: pointer;"><path id="kity_path_23234" fill="white" stroke="gray" d="M564.5,81.5A6,6,0,1,1,552.5,81.5A6,6,0,1,1,564.5,81.5"></path><path id="kity_path_23235" fill="none" stroke="gray"></path></g><path id="node_outline905" fill="none" stroke="none" d="M492.5,-132.5h195a5,5,0,0,1,5,5v213a5,5,0,0,1,-5,5h-195a5,5,0,0,1,-5,-5v-213a5,5,0,0,1,5,-5z"></path><g id="node_text905" fill="black"><text id="kity_text_9536" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="564.5">分支主题</text></g><image id="kity_image_17049" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210322172009.png" x="492.5" y="-129.5" width="195" height="200"></image></g><g id="minder_node911" display="none"><g id="node_expander908" display="none" style="cursor: pointer;"><path id="kity_path_23246" fill="white" stroke="gray" d="M532.5,89.5A6,6,0,1,1,520.5,89.5A6,6,0,1,1,532.5,89.5"></path><path id="kity_path_23247" fill="none" stroke="gray"></path></g><path id="node_outline909" fill="none" stroke="none" d="M532.5,80.5h110a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-110a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text909" fill="black"><text id="kity_text_9554" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="532.5">说说AOF的优缺点？</text></g></g><g id="minder_node912" display="none"><g id="node_expander907" display="none" style="cursor: pointer;"><path id="kity_path_23243" fill="white" stroke="gray" d="M548.5,89.5A6,6,0,1,1,536.5,89.5A6,6,0,1,1,548.5,89.5"></path><path id="kity_path_23244" fill="none" stroke="gray"></path></g><path id="node_outline908" fill="none" stroke="none" d="M548.5,35.5h555a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-555a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text908" fill="black"><text id="kity_text_9547" text-rendering="inherit" font-size="12" dy=".8em" y="36.700000047683716" x="548.5">1.优点：</text><text id="kity_text_9548" text-rendering="inherit" font-size="12" dy=".8em" y="54.700000047683716" x="548.5">AOF可以更好的保护数据不丢失，如果 Redis 挂掉了，最多丢失 1 秒的数据(非常适合用来做热备)。</text><text id="kity_text_9549" text-rendering="inherit" font-size="12" dy=".8em" y="72.70000004768372" x="548.5">append-only的模式写入性能非常的高</text><text id="kity_text_9550" text-rendering="inherit" font-size="12" dy=".8em" y="90.70000004768372" x="548.5">适合做灾难性的误删除紧急恢复，如果误flushall，只要还没有rewirte，就可以恢复。</text><text id="kity_text_9551" text-rendering="inherit" font-size="12" dy=".8em" y="108.70000004768372" x="548.5">2.缺点：</text><text id="kity_text_9552" text-rendering="inherit" font-size="12" dy=".8em" y="126.70000004768372" x="548.5">AOF比RDB大。AOF开启后支持写的QPS会比RDB支持的写的QPS低。数据恢复比较慢，不适合做冷备。</text></g></g><g id="minder_node913" display="none"><g id="node_expander917" display="none" style="cursor: pointer;"><path id="kity_path_23273" fill="white" stroke="gray" d="M516.5,97.5A6,6,0,1,1,504.5,97.5A6,6,0,1,1,516.5,97.5"></path><path id="kity_path_23274" fill="none" stroke="gray"></path></g><path id="node_outline918" fill="none" stroke="none" d="M516.5,88.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text918" fill="black"><text id="kity_text_9588" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="516.5">RDB</text></g></g><g id="minder_node914" display="none"><g id="node_expander911" display="none" style="cursor: pointer;"><path id="kity_path_23255" fill="white" stroke="gray" d="M532.5,81.5A6,6,0,1,1,520.5,81.5A6,6,0,1,1,532.5,81.5"></path><path id="kity_path_23256" fill="none" stroke="gray"></path></g><path id="node_outline912" fill="none" stroke="none" d="M532.5,72.5h134a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-134a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text912" fill="black"><text id="kity_text_9568" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="532.5">说一下RDB？怎么开启？</text></g></g><g id="minder_node915" display="none"><g id="node_expander910" display="none" style="cursor: pointer;"><path id="kity_path_23252" fill="white" stroke="gray" d="M548.5,81.5A6,6,0,1,1,536.5,81.5A6,6,0,1,1,548.5,81.5"></path><path id="kity_path_23253" fill="none" stroke="gray"></path></g><path id="node_outline911" fill="none" stroke="none" d="M548.5,0.5h1162a5,5,0,0,1,5,5v152a5,5,0,0,1,-5,5h-1162a5,5,0,0,1,-5,-5v-152a5,5,0,0,1,5,-5z"></path><g id="node_text911" fill="black"><text id="kity_text_9558" text-rendering="inherit" font-size="12" dy=".8em" y="1.7000000476837158" x="548.5">1.RDB</text><text id="kity_text_9559" text-rendering="inherit" font-size="12" dy=".8em" y="19.700000047683716" x="548.5">RDB是一种快照存储持久化方式，能够在指定时间间隔内对内存数据进行快照存储将保存到硬盘的文件dump.rdb这个二进制文件当中，Redis服务器启动时，可以重新加载dump.rdb文件的数据到内存当中恢复数据。</text><text id="kity_text_9560" text-rendering="inherit" font-size="12" dy=".8em" y="37.700000047683716" x="548.5">2.触发开启</text><text id="kity_text_9561" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="548.5">手动：(1)save会阻塞当前 Redis 服务器，直到RDB过程完成为止。</text><text id="kity_text_9562" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="548.5">(2)bgsave 执行时，Redis 进程会执行fork操作创建子进程，RDB 持久化过程由子进程负责，完成后自动结束。阻塞只发生在 子线程fork 阶段，一般时间很短。但是子线程时间太长可能也会阻塞请求</text><text id="kity_text_9563" text-rendering="inherit" font-size="12" dy=".8em" y="91.70000004768372" x="548.5">BGSAVE 执行期间仍可以继续处理客户端的请求</text><text id="kity_text_9564" text-rendering="inherit" font-size="12" dy=".8em" y="109.70000004768372" x="548.5">自动：</text><text id="kity_text_9565" text-rendering="inherit" font-size="12" dy=".8em" y="127.70000004768372" x="548.5">自动触发的逻辑是 Redis 在 N 秒内有 M 个键被改动，通过修改配置文件实现。达到触发条件时，会forks一个子进程进行数据同步，不过最好不要通过这方式来触发RDB持久化，</text><text id="kity_text_9566" text-rendering="inherit" font-size="12" dy=".8em" y="145.70000004768372" x="548.5">因为设置触发的时间太短，则容易频繁写入rdb文件，影响服务器性能，时间设置太长则会造成数据丢失。</text></g><g id="kity_g_16985" style="cursor: pointer;"><path id="kity_path_16986" fill="none" stroke="none" d="M1697,73h12a2,2,0,0,1,2,2v13a2,2,0,0,1,-2,2h-12a2,2,0,0,1,-2,-2v-13a2,2,0,0,1,2,-2z"></path><path id="kity_path_16987" fill="black" stroke="none" d="M1706,84H1700V83h6L1706,84L1706,84zM1706,82H1700V81h6V82zM1706,80H1700V79h6V80zM1705.5,86H1699V77h8v7.5M1706,87l2,-2V76H1698v11"></path></g></g><g id="minder_node916" display="none"><g id="node_expander914" display="none" style="cursor: pointer;"><path id="kity_path_23264" fill="white" stroke="gray" d="M532.5,89.5A6,6,0,1,1,520.5,89.5A6,6,0,1,1,532.5,89.5"></path><path id="kity_path_23265" fill="none" stroke="gray"></path></g><path id="node_outline915" fill="none" stroke="none" d="M532.5,80.5h56a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-56a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text915" fill="black"><text id="kity_text_9577" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="532.5">rdb原理？</text></g></g><g id="minder_node917" display="none"><g id="node_expander913" display="none" style="cursor: pointer;"><path id="kity_path_23261" fill="white" stroke="gray" d="M548.5,89.5A6,6,0,1,1,536.5,89.5A6,6,0,1,1,548.5,89.5"></path><path id="kity_path_23262" fill="none" stroke="gray"></path></g><path id="node_outline914" fill="none" stroke="none" d="M548.5,53.5h1014a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1014a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text914" fill="black"><text id="kity_text_9572" text-rendering="inherit" font-size="12" dy=".8em" y="54.700000047683716" x="548.5">1.</text><text id="kity_text_9573" text-rendering="inherit" font-size="12" dy=".8em" y="72.70000004768372" x="548.5">fork 出一个子进程，子进程负责调用 rdbSave ，在保存完成后向主进程发送信号告知完成</text><text id="kity_text_9574" text-rendering="inherit" font-size="12" dy=".8em" y="90.70000004768372" x="548.5">然后Copy On Write 机制生成RDB，备份的是开始那个时刻内存中的数据，只复制被修改内存页数据，不是全部内存数据。也就是说此时，如果收到写请求，会在原副本上操作，不影响工作。</text><text id="kity_text_9575" text-rendering="inherit" font-size="12" dy=".8em" y="108.70000004768372" x="548.5">如果父子进程大量写操作会导致分页错误。</text></g></g><g id="minder_node918" display="none"><g id="node_expander912" display="none" style="cursor: pointer;"><path id="kity_path_23258" fill="white" stroke="gray" d="M564.5,89.5A6,6,0,1,1,552.5,89.5A6,6,0,1,1,564.5,89.5"></path><path id="kity_path_23259" fill="none" stroke="gray"></path></g><path id="node_outline913" fill="none" stroke="none" d="M498.5,-124.5h182a5,5,0,0,1,5,5v213a5,5,0,0,1,-5,5h-182a5,5,0,0,1,-5,-5v-213a5,5,0,0,1,5,-5z"></path><g id="node_text913" fill="black"><text id="kity_text_9570" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="564.5">分支主题</text></g><image id="kity_image_17050" xlink:href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/164f26c8b7704d5fbd4eea4a59355cac~tplv-k3u1fbpfcp-zoom-1.image" x="498.5" y="-121.5" width="182" height="200"></image></g><g id="minder_node919" display="none"><g id="node_expander916" display="none" style="cursor: pointer;"><path id="kity_path_23270" fill="white" stroke="gray" d="M532.5,97.5A6,6,0,1,1,520.5,97.5A6,6,0,1,1,532.5,97.5"></path><path id="kity_path_23271" fill="none" stroke="gray"></path></g><path id="node_outline917" fill="none" stroke="none" d="M532.5,88.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text917" fill="black"><text id="kity_text_9586" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="532.5">优缺点？</text></g></g><g id="minder_node920" display="none"><g id="node_expander915" display="none" style="cursor: pointer;"><path id="kity_path_23267" fill="white" stroke="gray" d="M548.5,97.5A6,6,0,1,1,536.5,97.5A6,6,0,1,1,548.5,97.5"></path><path id="kity_path_23268" fill="none" stroke="gray"></path></g><path id="node_outline916" fill="none" stroke="none" d="M548.5,43.5h1069a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1069a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text916" fill="black"><text id="kity_text_9579" text-rendering="inherit" font-size="12" dy=".8em" y="44.700000047683716" x="548.5">1.优点：</text><text id="kity_text_9580" text-rendering="inherit" font-size="12" dy=".8em" y="62.700000047683716" x="548.5">RDB文件是单一紧凑的二进制文件，比较适合做冷备，全量复制的场景。可以将一个时间内产生的RDB文件复制到本地或者存储到云端，这样可以产生多个不同时间段内的数据备份，从而达到容灾恢复。</text><text id="kity_text_9581" text-rendering="inherit" font-size="12" dy=".8em" y="80.70000004768372" x="548.5">RDB存储的就是数据，AOF存储的是操作命令。RDB对Redis影响非常小，可以让 Redis 保持高性能，</text><text id="kity_text_9582" text-rendering="inherit" font-size="12" dy=".8em" y="98.70000004768372" x="548.5">2.缺点：</text><text id="kity_text_9583" text-rendering="inherit" font-size="12" dy=".8em" y="116.70000004768372" x="548.5">RDB 持久化丢失的数据可能会比AOF多。数据量较大时，fork的过程是比较耗时耗性能的。</text><text id="kity_text_9584" text-rendering="inherit" font-size="12" dy=".8em" y="134.70000004768372" x="548.5">RDB内存数据全量同步。无法实现实时或者秒级持久化。</text></g></g><g id="minder_node921" display="none"><g id="node_expander919" display="none" style="cursor: pointer;"><path id="kity_path_23279" fill="white" stroke="gray" d="M516.5,105.5A6,6,0,1,1,504.5,105.5A6,6,0,1,1,516.5,105.5"></path><path id="kity_path_23280" fill="none" stroke="gray"></path></g><path id="node_outline920" fill="none" stroke="none" d="M516.5,96.5h122a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-122a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text920" fill="black"><text id="kity_text_9593" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="516.5">这两个主要区别是什么 </text></g></g><g id="minder_node922" display="none"><g id="node_expander918" display="none" style="cursor: pointer;"><path id="kity_path_23276" fill="white" stroke="gray" d="M532.5,105.5A6,6,0,1,1,520.5,105.5A6,6,0,1,1,532.5,105.5"></path><path id="kity_path_23277" fill="none" stroke="gray"></path></g><path id="node_outline919" fill="none" stroke="none" d="M532.5,87.5h582a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-582a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text919" fill="black"><text id="kity_text_9590" text-rendering="inherit" font-size="12" dy=".8em" y="88.70000004768372" x="532.5">1.AOF启动优先级高，体积大，恢复速度慢，数据安全性 由策略决定，对服务器性能影响较小 比较</text><text id="kity_text_9591" text-rendering="inherit" font-size="12" dy=".8em" y="106.70000004768372" x="532.5">2.RDB启动优先级低，体积小，恢复速度快，会丢数据，使用子进程生成，所以对Redis服务器性能影响较小。</text></g></g><g id="minder_node923" display="none"><g id="node_expander922" display="none" style="cursor: pointer;"><path id="kity_path_23288" fill="white" stroke="gray" d="M516.5,113.5A6,6,0,1,1,504.5,113.5A6,6,0,1,1,516.5,113.5"></path><path id="kity_path_23289" fill="none" stroke="gray"></path></g><path id="node_outline923" fill="none" stroke="none" d="M516.5,104.5h241a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-241a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text923" fill="black"><text id="kity_text_9607" text-rendering="inherit" font-size="12" dy=".8em" y="105.70000004768372" x="516.5">他们两个使用场景？应该选择什么样的策略？</text></g></g><g id="minder_node924" display="none"><g id="node_expander921" display="none" style="cursor: pointer;"><path id="kity_path_23285" fill="white" stroke="gray" d="M532.5,113.5A6,6,0,1,1,520.5,113.5A6,6,0,1,1,532.5,113.5"></path><path id="kity_path_23286" fill="none" stroke="gray"></path></g><path id="node_outline922" fill="none" stroke="none" d="M532.5,32.5h1595a5,5,0,0,1,5,5v152a5,5,0,0,1,-5,5h-1595a5,5,0,0,1,-5,-5v-152a5,5,0,0,1,5,-5z"></path><g id="node_text922" fill="black"><text id="kity_text_9597" text-rendering="inherit" font-size="12" dy=".8em" y="33.700000047683716" x="532.5">1.使用场景就是根据他们的优缺点来说</text><text id="kity_text_9598" text-rendering="inherit" font-size="12" dy=".8em" y="51.700000047683716" x="532.5">RDB优点：全量数据快照，文件小，恢复快。缺点：无法保存最近一次快照之后的数据。</text><text id="kity_text_9599" text-rendering="inherit" font-size="12" dy=".8em" y="69.70000004768372" x="532.5">AOF优点：可读性高，适合保存增量数据，数据不易丢失。缺点：文件体积大，恢复时间长。</text><text id="kity_text_9600" text-rendering="inherit" font-size="12" dy=".8em" y="87.70000004768372" x="532.5">2.</text><text id="kity_text_9601" text-rendering="inherit" font-size="12" dy=".8em" y="105.70000004768372" x="532.5">RDB作为全量备份，AOF作为增量备份，并且将此种方式作为默认方式使用。redis5是默认开启的，配置参数为 aof-use-rdb-preamble</text><text id="kity_text_9602" text-rendering="inherit" font-size="12" dy=".8em" y="123.70000004768372" x="532.5">RDB-AOF混合方式下，持久化策略首先将缓存中数据以RDB方式全量写入数据文件，再将写入后新增的数据以AOF的方式追加在RDB数据的后面，在下一次做RDB持久化的时候将AOF的数据重新以RDB的形式写入文件，最后一个形成的是AOF文件，这个过程都是子线程在后台执行，通过管道读取数据</text><text id="kity_text_9603" text-rendering="inherit" font-size="12" dy=".8em" y="141.70000004768372" x="532.5">相当于前半段是RDB格式的全量数据，后半段是AOF格式的增量数据</text><text id="kity_text_9604" text-rendering="inherit" font-size="12" dy=".8em" y="159.70000004768372" x="532.5">3.优点：</text><text id="kity_text_9605" text-rendering="inherit" font-size="12" dy=".8em" y="177.70000004768372" x="532.5">提高读写和恢复效率，也可以减少文件大小，同时可以保证数据的完整性.不会造成管道阻塞</text></g></g><g id="minder_node925" display="none"><g id="node_expander920" display="none" style="cursor: pointer;"><path id="kity_path_23282" fill="white" stroke="gray" d="M548.5,113.5A6,6,0,1,1,536.5,113.5A6,6,0,1,1,548.5,113.5"></path><path id="kity_path_23283" fill="none" stroke="gray"></path></g><path id="node_outline921" fill="none" stroke="none" d="M548.5,99.5h53a5,5,0,0,1,5,5v18a5,5,0,0,1,-5,5h-53a5,5,0,0,1,-5,-5v-18a5,5,0,0,1,5,-5z"></path><g id="node_text921" fill="black"><text id="kity_text_9595" text-rendering="inherit" font-size="12" dy=".8em" y="105.70000004768372" x="548.5">参考</text></g><a id="kity_a_16922" xlink:href="https://mp.weixin.qq.com/s/FcYgoU58APnxkNTAX8U9nQ" target="_blank" xlink:title="https://mp.weixin.qq.com/s/FcYgoU58APnxkNTAX8U9nQ" style="cursor: pointer;"><path id="kity_path_16924" fill="rgba(255, 255, 255, 0)" stroke="none" d="M581.5,102.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16923" fill="#666" stroke="none" d="M596.114,118.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V112.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C591.766,109.571,593.168,108.5,594.836,108.5h1.278c2.116,0,3.834,1.716,3.834,3.834V114.89C599.948,117.008,598.23,118.724,596.114,118.724zM584.612,113.612c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S594.265,114.89,593.558,114.89H585.89C585.185,114.89,584.612,114.319,584.612,113.612zM582.056,112.334V114.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H583.334C581.216,118.724,579.5,117.008,579.5,114.89V112.334C579.5,110.216,581.216,108.5,583.334,108.5h1.278c1.667,0,3.071,1.071,3.599,2.556H583.334C582.629,111.056,582.056,111.627,582.056,112.334z"></path></a></g><g id="minder_node926" display="none"><g id="node_expander927" display="none" style="cursor: pointer;"><path id="kity_path_23303" fill="white" stroke="gray" d="M516.5,121.5A6,6,0,1,1,504.5,121.5A6,6,0,1,1,516.5,121.5"></path><path id="kity_path_23304" fill="none" stroke="gray"></path></g><path id="node_outline928" fill="none" stroke="none" d="M516.5,112.5h62a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-62a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text928" fill="black"><text id="kity_text_9623" text-rendering="inherit" font-size="12" dy=".8em" y="113.70000004768372" x="516.5">恢复和备份</text></g></g><g id="minder_node927" display="none"><g id="node_expander924" display="none" style="cursor: pointer;"><path id="kity_path_23294" fill="white" stroke="gray" d="M532.5,113.5A6,6,0,1,1,520.5,113.5A6,6,0,1,1,532.5,113.5"></path><path id="kity_path_23295" fill="none" stroke="gray"></path></g><path id="node_outline925" fill="none" stroke="none" d="M532.5,104.5h136a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-136a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text925" fill="black"><text id="kity_text_9613" text-rendering="inherit" font-size="12" dy=".8em" y="105.70000004768372" x="532.5">redis的数据备份和恢复？</text></g></g><g id="minder_node928" display="none"><g id="node_expander923" display="none" style="cursor: pointer;"><path id="kity_path_23291" fill="white" stroke="gray" d="M548.5,113.5A6,6,0,1,1,536.5,113.5A6,6,0,1,1,548.5,113.5"></path><path id="kity_path_23292" fill="none" stroke="gray"></path></g><path id="node_outline924" fill="none" stroke="none" d="M548.5,86.5h480a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-480a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text924" fill="black"><text id="kity_text_9609" text-rendering="inherit" font-size="12" dy=".8em" y="87.70000004768372" x="548.5">1.</text><text id="kity_text_9610" text-rendering="inherit" font-size="12" dy=".8em" y="105.70000004768372" x="548.5">Redis SAVE 命令用于创建当前数据库的备份</text><text id="kity_text_9611" text-rendering="inherit" font-size="12" dy=".8em" y="123.70000004768372" x="548.5">如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。</text></g></g><g id="minder_node929" display="none"><g id="node_expander926" display="none" style="cursor: pointer;"><path id="kity_path_23300" fill="white" stroke="gray" d="M532.5,121.5A6,6,0,1,1,520.5,121.5A6,6,0,1,1,532.5,121.5"></path><path id="kity_path_23301" fill="none" stroke="gray"></path></g><path id="node_outline927" fill="none" stroke="none" d="M532.5,112.5h75a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-75a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text927" fill="black"><text id="kity_text_9621" text-rendering="inherit" font-size="12" dy=".8em" y="113.70000004768372" x="532.5">aof和rdb恢复</text></g></g><g id="minder_node930" display="none"><g id="node_expander925" display="none" style="cursor: pointer;"><path id="kity_path_23297" fill="white" stroke="gray" d="M548.5,121.5A6,6,0,1,1,536.5,121.5A6,6,0,1,1,548.5,121.5"></path><path id="kity_path_23298" fill="none" stroke="gray"></path></g><path id="node_outline926" fill="none" stroke="none" d="M548.5,76.5h350a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-350a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text926" fill="black"><text id="kity_text_9615" text-rendering="inherit" font-size="12" dy=".8em" y="77.70000004768372" x="548.5">AOF和RDB文件都可以用于服务器重启时的数据恢复。流程如下：</text><text id="kity_text_9616" text-rendering="inherit" font-size="12" dy=".8em" y="95.70000004768372" x="548.5">AOF持久化开启且存在AOF文件时，Redis 会优先加载AOF文件。</text><text id="kity_text_9617" text-rendering="inherit" font-size="12" dy=".8em" y="113.70000004768372" x="548.5">AOF关闭或者AOF文件不存在时，加载RDB文件。</text><text id="kity_text_9618" text-rendering="inherit" font-size="12" dy=".8em" y="131.70000004768372" x="548.5">加载AOF/RDB文件成功后，Redis 启动成功。</text><text id="kity_text_9619" text-rendering="inherit" font-size="12" dy=".8em" y="149.70000004768372" x="548.5">AOF/RDB文件存在错误时，Redis 启动失败并打印错误信息</text></g></g><g id="minder_node931" display="none"><g id="node_expander1037" display="none" style="cursor: pointer;"><path id="kity_path_23633" fill="white" stroke="gray" d="M500.5,129.5A6,6,0,1,1,488.5,129.5A6,6,0,1,1,500.5,129.5"></path><path id="kity_path_23634" fill="none" stroke="gray"></path></g><path id="node_outline1038" fill="none" stroke="none" d="M500.5,120.5h127a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-127a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1038" fill="black"><text id="kity_text_10008" text-rendering="inherit" font-size="12" dy=".8em" y="121.70000004768372" x="500.5">redis集群和高性能方面&#xa0;</text></g></g><g id="minder_node932" display="none"><g id="node_expander977" display="none" style="cursor: pointer;"><path id="kity_path_23453" fill="white" stroke="gray" d="M516.5,105.5A6,6,0,1,1,504.5,105.5A6,6,0,1,1,516.5,105.5"></path><path id="kity_path_23454" fill="none" stroke="gray"></path></g><path id="node_outline978" fill="none" stroke="none" d="M516.5,96.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text978" fill="black"><text id="kity_text_9783" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="516.5">主从</text></g></g><g id="minder_node933" display="none"><g id="node_expander930" display="none" style="cursor: pointer;"><path id="kity_path_23312" fill="white" stroke="gray" d="M532.5,-54.5A6,6,0,1,1,520.5,-54.5A6,6,0,1,1,532.5,-54.5"></path><path id="kity_path_23313" fill="none" stroke="gray"></path></g><path id="node_outline931" fill="none" stroke="none" d="M532.5,-63.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text931" fill="black"><text id="kity_text_9630" text-rendering="inherit" font-size="12" dy=".8em" y="-62.299999952316284" x="532.5">主从复制是什么</text></g></g><g id="minder_node934" display="none"><g id="node_expander929" display="none" style="cursor: pointer;"><path id="kity_path_23309" fill="white" stroke="gray" d="M548.5,-54.5A6,6,0,1,1,536.5,-54.5A6,6,0,1,1,548.5,-54.5"></path><path id="kity_path_23310" fill="none" stroke="gray"></path></g><path id="node_outline930" fill="none" stroke="none" d="M548.5,-72.5h823a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-823a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text930" fill="black"><text id="kity_text_9627" text-rendering="inherit" font-size="12" dy=".8em" y="-71.29999995231628" x="548.5">1.</text><text id="kity_text_9628" text-rendering="inherit" font-size="12" dy=".8em" y="-53.299999952316284" x="548.5">Redis的主从复制机制是指可以让从服务器(slave)能精确复制主服务器(master)的数据，主把数据放给从。最终目的是为了保证双方的数据最终一致、同步。</text></g></g><g id="minder_node935" display="none"><g id="node_expander932" display="none" style="cursor: pointer;"><path id="kity_path_23318" fill="white" stroke="gray" d="M532.5,-46.5A6,6,0,1,1,520.5,-46.5A6,6,0,1,1,532.5,-46.5"></path><path id="kity_path_23319" fill="none" stroke="gray"></path></g><path id="node_outline933" fill="none" stroke="none" d="M532.5,-55.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text933" fill="black"><text id="kity_text_9637" text-rendering="inherit" font-size="12" dy=".8em" y="-54.299999952316284" x="532.5">主从复制的作用是什么</text></g></g><g id="minder_node936" display="none"><g id="node_expander931" display="none" style="cursor: pointer;"><path id="kity_path_23315" fill="white" stroke="gray" d="M548.5,-46.5A6,6,0,1,1,536.5,-46.5A6,6,0,1,1,548.5,-46.5"></path><path id="kity_path_23316" fill="none" stroke="gray"></path></g><path id="node_outline932" fill="none" stroke="none" d="M548.5,-82.5h341a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-341a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text932" fill="black"><text id="kity_text_9632" text-rendering="inherit" font-size="12" dy=".8em" y="-81.29999995231628" x="548.5">①数据冗余备份，保证数据的安全。</text><text id="kity_text_9633" text-rendering="inherit" font-size="12" dy=".8em" y="-63.299999952316284" x="548.5">②故障恢复和转移（服务冗余）如集群sentinel让slave升master</text><text id="kity_text_9634" text-rendering="inherit" font-size="12" dy=".8em" y="-45.299999952316284" x="548.5">③负载均衡</text><text id="kity_text_9635" text-rendering="inherit" font-size="12" dy=".8em" y="-27.299999952316284" x="548.5">④读写分离（主节点写操作、从节点读操作，减轻主压力）</text></g></g><g id="minder_node937" display="none"><g id="node_expander935" display="none" style="cursor: pointer;"><path id="kity_path_23327" fill="white" stroke="gray" d="M532.5,-38.5A6,6,0,1,1,520.5,-38.5A6,6,0,1,1,532.5,-38.5"></path><path id="kity_path_23328" fill="none" stroke="gray"></path></g><path id="node_outline936" fill="none" stroke="none" d="M532.5,-47.5h144a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-144a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text936" fill="black"><text id="kity_text_9655" text-rendering="inherit" font-size="12" dy=".8em" y="-46.299999952316284" x="532.5">主从复制的过程是什么样的</text></g></g><g id="minder_node938" display="none"><g id="node_expander934" display="none" style="cursor: pointer;"><path id="kity_path_23324" fill="white" stroke="gray" d="M548.5,-38.5A6,6,0,1,1,536.5,-38.5A6,6,0,1,1,548.5,-38.5"></path><path id="kity_path_23325" fill="none" stroke="gray"></path></g><path id="node_outline935" fill="none" stroke="none" d="M548.5,-155.5h1006a5,5,0,0,1,5,5v224a5,5,0,0,1,-5,5h-1006a5,5,0,0,1,-5,-5v-224a5,5,0,0,1,5,-5z"></path><g id="node_text935" fill="black"><text id="kity_text_9641" text-rendering="inherit" font-size="12" dy=".8em" y="-154.29999995231628" x="548.5">1.主从复制分全量复制和增量复制</text><text id="kity_text_9642" text-rendering="inherit" font-size="12" dy=".8em" y="-136.29999995231628" x="548.5">2.全量复制：一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份</text><text id="kity_text_9643" text-rendering="inherit" font-size="12" dy=".8em" y="-118.29999995231628" x="548.5">(1.Slave发送psync命令到Master。连接master。</text><text id="kity_text_9644" text-rendering="inherit" font-size="12" dy=".8em" y="-100.29999995231628" x="548.5">(2.Master接收命令后启动一个后台进程，执行bgsave命令生成RDB文件并使用缓冲区记录此后执行的所有写命令(因为生成的时侯master可能还在处理响应，这些命令也需要经历在缓存区)。</text><text id="kity_text_9645" text-rendering="inherit" font-size="12" dy=".8em" y="-82.29999995231628" x="548.5">(3.Master将持续记录被执行的写命令，保存数据快照期间接收到的写命令缓存起来。</text><text id="kity_text_9646" text-rendering="inherit" font-size="12" dy=".8em" y="-64.29999995231628" x="548.5">(4.Master完成写文件操作后，将该文件发送给Slave。</text><text id="kity_text_9647" text-rendering="inherit" font-size="12" dy=".8em" y="-46.299999952316284" x="548.5">(5.slave收到快照文件后丢弃所有旧数据，使用新的AOF文件替换掉旧的AOF文件。</text><text id="kity_text_9648" text-rendering="inherit" font-size="12" dy=".8em" y="-28.299999952316284" x="548.5">(6.slave完成对快照的载入，Master将这期间收集的增量写命令发送给Slave端,slave开始接收命令请求，并执行来自master缓冲区的写命令。</text><text id="kity_text_9649" text-rendering="inherit" font-size="12" dy=".8em" y="-10.299999952316284" x="548.5">3.增量复制:主要是master每执行一个写命令就会向slave发送相同的写命令。</text><text id="kity_text_9650" text-rendering="inherit" font-size="12" dy=".8em" y="7.700000047683716" x="548.5">(1.Master接收到用户的操作指令，判断是否需要传播到Slave。</text><text id="kity_text_9651" text-rendering="inherit" font-size="12" dy=".8em" y="25.700000047683716" x="548.5">(2.将操作记录追加到AOF文件。</text><text id="kity_text_9652" text-rendering="inherit" font-size="12" dy=".8em" y="43.700000047683716" x="548.5">(3.将操作传播到其它Slave：1.对齐主从库；2.往响应缓存写入指令。</text><text id="kity_text_9653" text-rendering="inherit" font-size="12" dy=".8em" y="61.700000047683716" x="548.5">(4.将缓存中的数据发送给Slave。</text></g></g><g id="minder_node939" display="none"><g id="node_expander933" display="none" style="cursor: pointer;"><path id="kity_path_23321" fill="white" stroke="gray" d="M564.5,-38.5A6,6,0,1,1,552.5,-38.5A6,6,0,1,1,564.5,-38.5"></path><path id="kity_path_23322" fill="none" stroke="gray"></path></g><path id="node_outline934" fill="none" stroke="none" d="M489.5,-175.5h200a5,5,0,0,1,5,5v136a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-136a5,5,0,0,1,5,-5z"></path><g id="node_text934" fill="black"><text id="kity_text_9639" text-rendering="inherit" font-size="12" dy=".8em" y="-46.299999952316284" x="564.5">分支主题</text></g><image id="kity_image_17051" xlink:href="https://img-blog.csdnimg.cn/20200819225904123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMjU1MDE3,size_16,color_FFFFFF,t_70#pic_center" x="489.5" y="-172.5" width="200" height="123"></image></g><g id="minder_node940" display="none"><g id="node_expander937" display="none" style="cursor: pointer;"><path id="kity_path_23333" fill="white" stroke="gray" d="M532.5,-30.5A6,6,0,1,1,520.5,-30.5A6,6,0,1,1,532.5,-30.5"></path><path id="kity_path_23334" fill="none" stroke="gray"></path></g><path id="node_outline938" fill="none" stroke="none" d="M532.5,-39.5h205a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-205a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text938" fill="black"><text id="kity_text_9666" text-rendering="inherit" font-size="12" dy=".8em" y="-38.299999952316284" x="532.5">全量复制和增量复制说一下区别和场景</text></g></g><g id="minder_node941" display="none"><g id="node_expander936" display="none" style="cursor: pointer;"><path id="kity_path_23330" fill="white" stroke="gray" d="M548.5,-30.5A6,6,0,1,1,536.5,-30.5A6,6,0,1,1,548.5,-30.5"></path><path id="kity_path_23331" fill="none" stroke="gray"></path></g><path id="node_outline937" fill="none" stroke="none" d="M548.5,-102.5h775a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-775a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text937" fill="black"><text id="kity_text_9657" text-rendering="inherit" font-size="12" dy=".8em" y="-101.29999995231628" x="548.5">1.</text><text id="kity_text_9658" text-rendering="inherit" font-size="12" dy=".8em" y="-83.29999995231628" x="548.5">全量:一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份</text><text id="kity_text_9659" text-rendering="inherit" font-size="12" dy=".8em" y="-65.29999995231628" x="548.5">增量：指Slave初始化后开始正常工作时master发生的写操作同步到slave的过程。</text><text id="kity_text_9660" text-rendering="inherit" font-size="12" dy=".8em" y="-47.299999952316284" x="548.5">Redis会把指令存放在一个环形队列当中，因为内存容量有限，如果备机一直起不来，不可能把所有的内存都去存指令，所以指令可能会被覆盖掉。</text><text id="kity_text_9661" text-rendering="inherit" font-size="12" dy=".8em" y="-29.299999952316284" x="548.5">增量复制的过程主要是master每执行一个写命令就会向slave发送相同的写命令。</text><text id="kity_text_9662" text-rendering="inherit" font-size="12" dy=".8em" y="-11.299999952316284" x="548.5">2.</text><text id="kity_text_9663" text-rendering="inherit" font-size="12" dy=".8em" y="6.700000047683716" x="548.5">主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然 slave 在任何时候都可以发起全量同步。</text><text id="kity_text_9664" text-rendering="inherit" font-size="12" dy=".8em" y="24.700000047683716" x="548.5">redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步</text></g></g><g id="minder_node942" display="none"><g id="node_expander939" display="none" style="cursor: pointer;"><path id="kity_path_23339" fill="white" stroke="gray" d="M532.5,-22.5A6,6,0,1,1,520.5,-22.5A6,6,0,1,1,532.5,-22.5"></path><path id="kity_path_23340" fill="none" stroke="gray"></path></g><path id="node_outline940" fill="none" stroke="none" d="M532.5,-31.5h156a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-156a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text940" fill="black"><text id="kity_text_9671" text-rendering="inherit" font-size="12" dy=".8em" y="-30.299999952316284" x="532.5">主从复制时丢了数据怎么办？</text></g></g><g id="minder_node943" display="none"><g id="node_expander938" display="none" style="cursor: pointer;"><path id="kity_path_23336" fill="white" stroke="gray" d="M548.5,-22.5A6,6,0,1,1,536.5,-22.5A6,6,0,1,1,548.5,-22.5"></path><path id="kity_path_23337" fill="none" stroke="gray"></path></g><path id="node_outline939" fill="none" stroke="none" d="M548.5,-40.5h474a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-474a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text939" fill="black"><text id="kity_text_9668" text-rendering="inherit" font-size="12" dy=".8em" y="-39.299999952316284" x="548.5">1.</text><text id="kity_text_9669" text-rendering="inherit" font-size="12" dy=".8em" y="-21.299999952316284" x="548.5">、slave在同步master数据时候如果slave丢失连接不用怕，slave在重新连接之后丢失重补</text></g></g><g id="minder_node944" display="none"><g id="node_expander941" display="none" style="cursor: pointer;"><path id="kity_path_23345" fill="white" stroke="gray" d="M532.5,-14.5A6,6,0,1,1,520.5,-14.5A6,6,0,1,1,532.5,-14.5"></path><path id="kity_path_23346" fill="none" stroke="gray"></path></g><path id="node_outline942" fill="none" stroke="none" d="M532.5,-23.5h120a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-120a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text942" fill="black"><text id="kity_text_9676" text-rendering="inherit" font-size="12" dy=".8em" y="-22.299999952316284" x="532.5">主从复制的工作流程？</text></g></g><g id="minder_node945" display="none"><g id="node_expander940" display="none" style="cursor: pointer;"><path id="kity_path_23342" fill="white" stroke="gray" d="M548.5,-14.5A6,6,0,1,1,536.5,-14.5A6,6,0,1,1,548.5,-14.5"></path><path id="kity_path_23343" fill="none" stroke="gray"></path></g><path id="node_outline941" fill="none" stroke="none" d="M548.5,-32.5h662a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-662a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text941" fill="black"><text id="kity_text_9673" text-rendering="inherit" font-size="12" dy=".8em" y="-31.299999952316284" x="548.5">&#xa0;1. 设置主从服务器。2. 主从服务器建立 TCP 连接。3. 发送 PING 检查通信状态。 4. 身份验证。5. 发送端口信息。 6. 同步。</text><text id="kity_text_9674" text-rendering="inherit" font-size="12" dy=".8em" y="-13.299999952316284" x="548.5">&#xa0;7. 命令传播(心跳)。</text></g></g><g id="minder_node946" display="none"><g id="node_expander943" display="none" style="cursor: pointer;"><path id="kity_path_23351" fill="white" stroke="gray" d="M532.5,-6.5A6,6,0,1,1,520.5,-6.5A6,6,0,1,1,532.5,-6.5"></path><path id="kity_path_23352" fill="none" stroke="gray"></path></g><path id="node_outline944" fill="none" stroke="none" d="M532.5,-15.5h156a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-156a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text944" fill="black"><text id="kity_text_9687" text-rendering="inherit" font-size="12" dy=".8em" y="-14.299999952316284" x="532.5">主从复制的实现原理有了解吗</text></g></g><g id="minder_node947" display="none"><g id="node_expander942" display="none" style="cursor: pointer;"><path id="kity_path_23348" fill="white" stroke="gray" d="M548.5,-6.5A6,6,0,1,1,536.5,-6.5A6,6,0,1,1,548.5,-6.5"></path><path id="kity_path_23349" fill="none" stroke="gray"></path></g><path id="node_outline943" fill="none" stroke="none" d="M548.5,-78.5h1030a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-1030a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text943" fill="black"><text id="kity_text_9678" text-rendering="inherit" font-size="12" dy=".8em" y="-77.29999995231628" x="548.5">1.实现原理主要是同步和命令传播</text><text id="kity_text_9679" text-rendering="inherit" font-size="12" dy=".8em" y="-59.299999952316284" x="548.5">master中有两个关键值，偏移量offset，标识当前的数据集版本replicationId。当master与slave正常连接时，slave使用PSYNC命令向master发送自己记录的旧master的replication id和offset，</text><text id="kity_text_9680" text-rendering="inherit" font-size="12" dy=".8em" y="-41.299999952316284" x="548.5">master计算与slave之间的数据偏移量，并将缓冲区中的偏移数量同步到slave，此时master和slave的数据一致。</text><text id="kity_text_9681" text-rendering="inherit" font-size="12" dy=".8em" y="-23.299999952316284" x="548.5">如果master与slave之间的数据差异太大 就会全量复制。</text><text id="kity_text_9682" text-rendering="inherit" font-size="12" dy=".8em" y="-5.299999952316284" x="548.5">在同步过程中还有一个关键的运行id：每个Redis服务器启动时，都会有自动生成自己的运行ID。</text><text id="kity_text_9683" text-rendering="inherit" font-size="12" dy=".8em" y="12.700000047683716" x="548.5">当从服务器对主服务器进行初次复制时，主服务器会发送自己的运行ID给从服务器。当从服务器断线重连时，会将之前主服务器的运行ID发送给当前连接的主服务器。</text><text id="kity_text_9684" text-rendering="inherit" font-size="12" dy=".8em" y="30.700000047683716" x="548.5">如果和以前一致说明可以执行部分重同步操作，如果不一致 说明和以前不是同一台，执行全量重同步</text><text id="kity_text_9685" text-rendering="inherit" font-size="12" dy=".8em" y="48.700000047683716" x="548.5"> </text></g></g><g id="minder_node948" display="none"><g id="node_expander945" display="none" style="cursor: pointer;"><path id="kity_path_23357" fill="white" stroke="gray" d="M532.5,1.5A6,6,0,1,1,520.5,1.5A6,6,0,1,1,532.5,1.5"></path><path id="kity_path_23358" fill="none" stroke="gray"></path></g><path id="node_outline946" fill="none" stroke="none" d="M532.5,-7.5h355a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-355a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text946" fill="black"><text id="kity_text_9694" text-rendering="inherit" font-size="12" dy=".8em" y="-6.299999952316284" x="532.5">Redis是如何保证主从服务器一致处于连接状态以及命令是否丢失？</text></g></g><g id="minder_node949" display="none"><g id="node_expander944" display="none" style="cursor: pointer;"><path id="kity_path_23354" fill="white" stroke="gray" d="M548.5,1.5A6,6,0,1,1,536.5,1.5A6,6,0,1,1,548.5,1.5"></path><path id="kity_path_23355" fill="none" stroke="gray"></path></g><path id="node_outline945" fill="none" stroke="none" d="M548.5,-34.5h1013a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1013a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text945" fill="black"><text id="kity_text_9689" text-rendering="inherit" font-size="12" dy=".8em" y="-33.299999952316284" x="548.5">1.</text><text id="kity_text_9690" text-rendering="inherit" font-size="12" dy=".8em" y="-15.299999952316284" x="548.5">在同步阶段以后，master和slave数据已经是一致的了。当master有新的命令时，会把命令发给slave，继续保持数据一致并防止数据丢失，这个过程主要是通过心跳定时的向主服务发送消息。</text><text id="kity_text_9691" text-rendering="inherit" font-size="12" dy=".8em" y="2.700000047683716" x="548.5">发的东西主要是slave当前复制的偏移量offset,主服务器的复制偏移量与从服务器的复制偏移量不一致时，主服务器会补发缺失的数据。</text><text id="kity_text_9692" text-rendering="inherit" font-size="12" dy=".8em" y="20.700000047683716" x="548.5">通过 info replication可以查看slave状态和复制偏移量。</text></g></g><g id="minder_node950" display="none"><g id="node_expander947" display="none" style="cursor: pointer;"><path id="kity_path_23363" fill="white" stroke="gray" d="M532.5,9.5A6,6,0,1,1,520.5,9.5A6,6,0,1,1,532.5,9.5"></path><path id="kity_path_23364" fill="none" stroke="gray"></path></g><path id="node_outline948" fill="none" stroke="none" d="M532.5,-8.5h144a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-144a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text948" fill="black"><text id="kity_text_9700" text-rendering="inherit" font-size="12" dy=".8em" y="-7.299999952316284" x="532.5">心跳的优点作用？</text><text id="kity_text_9701" text-rendering="inherit" font-size="12" dy=".8em" y="10.700000047683716" x="532.5">主从复制的心跳详细说说？</text></g></g><g id="minder_node951" display="none"><g id="node_expander946" display="none" style="cursor: pointer;"><path id="kity_path_23360" fill="white" stroke="gray" d="M548.5,9.5A6,6,0,1,1,536.5,9.5A6,6,0,1,1,548.5,9.5"></path><path id="kity_path_23361" fill="none" stroke="gray"></path></g><path id="node_outline947" fill="none" stroke="none" d="M548.5,-17.5h856a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-856a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text947" fill="black"><text id="kity_text_9696" text-rendering="inherit" font-size="12" dy=".8em" y="-16.299999952316284" x="548.5">检查主从服务器的网络连接状态</text><text id="kity_text_9697" text-rendering="inherit" font-size="12" dy=".8em" y="1.7000000476837158" x="548.5">辅助实现min-slaves选项(配置文件中的参数如果从服务器的数量少于xxx个，或者三个从服务器的延迟（lag）大于等于xxx秒时，主服务器都会拒绝执行写命令。)</text><text id="kity_text_9698" text-rendering="inherit" font-size="12" dy=".8em" y="19.700000047683716" x="548.5">检测命令丢失</text></g></g><g id="minder_node952" display="none"><g id="node_expander949" display="none" style="cursor: pointer;"><path id="kity_path_23369" fill="white" stroke="gray" d="M532.5,17.5A6,6,0,1,1,520.5,17.5A6,6,0,1,1,532.5,17.5"></path><path id="kity_path_23370" fill="none" stroke="gray"></path></g><path id="node_outline950" fill="none" stroke="none" d="M532.5,8.5h108a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-108a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text950" fill="black"><text id="kity_text_9710" text-rendering="inherit" font-size="12" dy=".8em" y="9.700000047683716" x="532.5">主从复制的优缺点？</text></g></g><g id="minder_node953" display="none"><g id="node_expander948" display="none" style="cursor: pointer;"><path id="kity_path_23366" fill="white" stroke="gray" d="M548.5,17.5A6,6,0,1,1,536.5,17.5A6,6,0,1,1,548.5,17.5"></path><path id="kity_path_23367" fill="none" stroke="gray"></path></g><path id="node_outline949" fill="none" stroke="none" d="M548.5,-36.5h1001a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1001a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text949" fill="black"><text id="kity_text_9703" text-rendering="inherit" font-size="12" dy=".8em" y="-35.299999952316284" x="548.5">1.优点：</text><text id="kity_text_9704" text-rendering="inherit" font-size="12" dy=".8em" y="-17.299999952316284" x="548.5">解决单机版并发量大和主的压力，导致请求延迟或者redis宕机服务停止的问题。从数据库分担主数据库的读压力，若是主数据库是只写模式，那么实现读写分离，主数据库就没有了读压力了</text><text id="kity_text_9705" text-rendering="inherit" font-size="12" dy=".8em" y="0.7000000476837158" x="548.5">主从同步以异步方式进行同步，期间Redis仍然可以响应客户端提交的查询和更新的请求。</text><text id="kity_text_9706" text-rendering="inherit" font-size="12" dy=".8em" y="18.700000047683716" x="548.5">2.缺点：</text><text id="kity_text_9707" text-rendering="inherit" font-size="12" dy=".8em" y="36.700000047683716" x="548.5">数据的一致性问题，因为主从复制延时导致没读取到最新的数据，还有网络原因也会导致数据一致性，</text><text id="kity_text_9708" text-rendering="inherit" font-size="12" dy=".8em" y="54.700000047683716" x="548.5">主从模式不具备自动容错和恢复的功能，开销大</text></g></g><g id="minder_node954" display="none"><g id="node_expander951" display="none" style="cursor: pointer;"><path id="kity_path_23375" fill="white" stroke="gray" d="M532.5,25.5A6,6,0,1,1,520.5,25.5A6,6,0,1,1,532.5,25.5"></path><path id="kity_path_23376" fill="none" stroke="gray"></path></g><path id="node_outline952" fill="none" stroke="none" d="M532.5,16.5h126a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-126a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text952" fill="black"><text id="kity_text_9714" text-rendering="inherit" font-size="12" dy=".8em" y="17.700000047683716" x="532.5">高性能redis是怎么实现</text></g></g><g id="minder_node955" display="none"><g id="node_expander950" display="none" style="cursor: pointer;"><path id="kity_path_23372" fill="white" stroke="gray" d="M548.5,25.5A6,6,0,1,1,536.5,25.5A6,6,0,1,1,548.5,25.5"></path><path id="kity_path_23373" fill="none" stroke="gray"></path></g><path id="node_outline951" fill="none" stroke="none" d="M548.5,16.5h417a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-417a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text951" fill="black"><text id="kity_text_9712" text-rendering="inherit" font-size="12" dy=".8em" y="17.700000047683716" x="548.5">1.实现高性能高可靠高可用主要是通过集群部署，主从复制，sentinel，cluster</text></g></g><g id="minder_node956" display="none"><g id="node_expander953" display="none" style="cursor: pointer;"><path id="kity_path_23381" fill="white" stroke="gray" d="M532.5,33.5A6,6,0,1,1,520.5,33.5A6,6,0,1,1,532.5,33.5"></path><path id="kity_path_23382" fill="none" stroke="gray"></path></g><path id="node_outline954" fill="none" stroke="none" d="M532.5,24.5h108a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-108a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text954" fill="black"><text id="kity_text_9718" text-rendering="inherit" font-size="12" dy=".8em" y="25.700000047683716" x="532.5">多主多从是什么样的</text></g></g><g id="minder_node957" display="none"><g id="node_expander952" display="none" style="cursor: pointer;"><path id="kity_path_23378" fill="white" stroke="gray" d="M548.5,33.5A6,6,0,1,1,536.5,33.5A6,6,0,1,1,548.5,33.5"></path><path id="kity_path_23379" fill="none" stroke="gray"></path></g><path id="node_outline953" fill="none" stroke="none" d="M548.5,24.5h561a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-561a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text953" fill="black"><text id="kity_text_9716" text-rendering="inherit" font-size="12" dy=".8em" y="25.700000047683716" x="548.5">1.多主多从主要是在集群模式下的，通过水平扩展实现多master，每一个master多个slave，保证高可用。</text></g></g><g id="minder_node958" display="none"><g id="node_expander955" display="none" style="cursor: pointer;"><path id="kity_path_23387" fill="white" stroke="gray" d="M532.5,41.5A6,6,0,1,1,520.5,41.5A6,6,0,1,1,532.5,41.5"></path><path id="kity_path_23388" fill="none" stroke="gray"></path></g><path id="node_outline956" fill="none" stroke="none" d="M532.5,32.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text956" fill="black"><text id="kity_text_9722" text-rendering="inherit" font-size="12" dy=".8em" y="33.700000047683716" x="532.5">一主多从是什么样的</text></g></g><g id="minder_node959" display="none"><g id="node_expander954" display="none" style="cursor: pointer;"><path id="kity_path_23384" fill="white" stroke="gray" d="M548.5,41.5A6,6,0,1,1,536.5,41.5A6,6,0,1,1,548.5,41.5"></path><path id="kity_path_23385" fill="none" stroke="gray"></path></g><path id="node_outline955" fill="none" stroke="none" d="M548.5,32.5h431a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-431a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text955" fill="black"><text id="kity_text_9720" text-rendering="inherit" font-size="12" dy=".8em" y="33.700000047683716" x="548.5">1.一主多从可以实现读写分离，和mysql差不多，减少master压力，用的也挺多的</text></g></g><g id="minder_node960" display="none"><g id="node_expander957" display="none" style="cursor: pointer;"><path id="kity_path_23393" fill="white" stroke="gray" d="M532.5,49.5A6,6,0,1,1,520.5,49.5A6,6,0,1,1,532.5,49.5"></path><path id="kity_path_23394" fill="none" stroke="gray"></path></g><path id="node_outline958" fill="none" stroke="none" d="M532.5,40.5h77a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-77a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text958" fill="black"><text id="kity_text_9726" text-rendering="inherit" font-size="12" dy=".8em" y="41.700000047683716" x="532.5">怎么强一致性&#xa0;</text></g></g><g id="minder_node961" display="none"><g id="node_expander956" display="none" style="cursor: pointer;"><path id="kity_path_23390" fill="white" stroke="gray" d="M548.5,49.5A6,6,0,1,1,536.5,49.5A6,6,0,1,1,548.5,49.5"></path><path id="kity_path_23391" fill="none" stroke="gray"></path></g><path id="node_outline957" fill="none" stroke="none" d="M548.5,40.5h461a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-461a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text957" fill="black"><text id="kity_text_9724" text-rendering="inherit" font-size="12" dy=".8em" y="41.700000047683716" x="548.5">1.主从复制是异步的，不保证强一致性，如果用保证db和redis的强一致性有其他方案，</text></g></g><g id="minder_node962" display="none"><g id="node_expander959" display="none" style="cursor: pointer;"><path id="kity_path_23399" fill="white" stroke="gray" d="M532.5,57.5A6,6,0,1,1,520.5,57.5A6,6,0,1,1,532.5,57.5"></path><path id="kity_path_23400" fill="none" stroke="gray"></path></g><path id="node_outline960" fill="none" stroke="none" d="M532.5,48.5h134a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-134a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text960" fill="black"><text id="kity_text_9730" text-rendering="inherit" font-size="12" dy=".8em" y="49.700000047683716" x="532.5">什么场景不适合强一致性</text></g></g><g id="minder_node963" display="none"><g id="node_expander958" display="none" style="cursor: pointer;"><path id="kity_path_23396" fill="white" stroke="gray" d="M548.5,57.5A6,6,0,1,1,536.5,57.5A6,6,0,1,1,548.5,57.5"></path><path id="kity_path_23397" fill="none" stroke="gray"></path></g><path id="node_outline959" fill="none" stroke="none" d="M548.5,48.5h688a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-688a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text959" fill="black"><text id="kity_text_9728" text-rendering="inherit" font-size="12" dy=".8em" y="49.700000047683716" x="548.5">1.业务场景允许弱一致性和最终一致性。像这种mysql的读写分离是异步的 不满足强一致性，redis主从复制也是没法保证强一致性</text></g></g><g id="minder_node964" display="none"><g id="node_expander961" display="none" style="cursor: pointer;"><path id="kity_path_23405" fill="white" stroke="gray" d="M532.5,65.5A6,6,0,1,1,520.5,65.5A6,6,0,1,1,532.5,65.5"></path><path id="kity_path_23406" fill="none" stroke="gray"></path></g><path id="node_outline962" fill="none" stroke="none" d="M532.5,56.5h98a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-98a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text962" fill="black"><text id="kity_text_9734" text-rendering="inherit" font-size="12" dy=".8em" y="57.700000047683716" x="532.5">怎么完成主备切换</text></g></g><g id="minder_node965" display="none"><g id="node_expander960" display="none" style="cursor: pointer;"><path id="kity_path_23402" fill="white" stroke="gray" d="M548.5,65.5A6,6,0,1,1,536.5,65.5A6,6,0,1,1,548.5,65.5"></path><path id="kity_path_23403" fill="none" stroke="gray"></path></g><path id="node_outline961" fill="none" stroke="none" d="M548.5,56.5h226a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-226a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text961" fill="black"><text id="kity_text_9732" text-rendering="inherit" font-size="12" dy=".8em" y="57.700000047683716" x="548.5">1.通过sentinel可以完成主备切换 故障转移</text></g></g><g id="minder_node966" display="none"><g id="node_expander963" display="none" style="cursor: pointer;"><path id="kity_path_23411" fill="white" stroke="gray" d="M532.5,73.5A6,6,0,1,1,520.5,73.5A6,6,0,1,1,532.5,73.5"></path><path id="kity_path_23412" fill="none" stroke="gray"></path></g><path id="node_outline964" fill="none" stroke="none" d="M532.5,55.5h253a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-253a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text964" fill="black"><text id="kity_text_9741" text-rendering="inherit" font-size="12" dy=".8em" y="56.700000047683716" x="532.5">如果主挂了，从没完全复制，会出现什么问题？</text><text id="kity_text_9742" text-rendering="inherit" font-size="12" dy=".8em" y="74.70000004768372" x="532.5">怎么解决？</text></g></g><g id="minder_node967" display="none"><g id="node_expander962" display="none" style="cursor: pointer;"><path id="kity_path_23408" fill="white" stroke="gray" d="M548.5,73.5A6,6,0,1,1,536.5,73.5A6,6,0,1,1,548.5,73.5"></path><path id="kity_path_23409" fill="none" stroke="gray"></path></g><path id="node_outline963" fill="none" stroke="none" d="M548.5,37.5h682a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-682a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text963" fill="black"><text id="kity_text_9736" text-rendering="inherit" font-size="12" dy=".8em" y="38.700000047683716" x="548.5">1.复制风暴</text><text id="kity_text_9737" text-rendering="inherit" font-size="12" dy=".8em" y="56.700000047683716" x="548.5">若主节点挂掉后，再次重启，runid的值会变。此时从节点的发送psync命令，会提示找不到原runid，则会再进行一次全量复制。</text><text id="kity_text_9738" text-rendering="inherit" font-size="12" dy=".8em" y="74.70000004768372" x="548.5">2.</text><text id="kity_text_9739" text-rendering="inherit" font-size="12" dy=".8em" y="92.70000004768372" x="548.5">为避免这种状况，使用Redis故障转移机制，主节点挂掉后，从节点升级为主节点。如哨兵模式。</text></g></g><g id="minder_node968" display="none"><g id="node_expander965" display="none" style="cursor: pointer;"><path id="kity_path_23417" fill="white" stroke="gray" d="M532.5,81.5A6,6,0,1,1,520.5,81.5A6,6,0,1,1,532.5,81.5"></path><path id="kity_path_23418" fill="none" stroke="gray"></path></g><path id="node_outline966" fill="none" stroke="none" d="M532.5,72.5h138a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-138a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text966" fill="black"><text id="kity_text_9748" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="532.5">如何避免slave被清空呢？</text></g></g><g id="minder_node969" display="none"><g id="node_expander964" display="none" style="cursor: pointer;"><path id="kity_path_23414" fill="white" stroke="gray" d="M548.5,81.5A6,6,0,1,1,536.5,81.5A6,6,0,1,1,548.5,81.5"></path><path id="kity_path_23415" fill="none" stroke="gray"></path></g><path id="node_outline965" fill="none" stroke="none" d="M548.5,54.5h488a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-488a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text965" fill="black"><text id="kity_text_9744" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="548.5">1.</text><text id="kity_text_9745" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="548.5">条件允许master服务器开启持久化，如果不能开启，不应该设置让master发生故障后重启，</text><text id="kity_text_9746" text-rendering="inherit" font-size="12" dy=".8em" y="91.70000004768372" x="548.5">采用sentinel，slave升master解决这个问题</text></g></g><g id="minder_node970" display="none"><g id="node_expander972" display="none" style="cursor: pointer;"><path id="kity_path_23438" fill="white" stroke="gray" d="M532.5,89.5A6,6,0,1,1,520.5,89.5A6,6,0,1,1,532.5,89.5"></path><path id="kity_path_23439" fill="none" stroke="gray"></path></g><path id="node_outline973" fill="none" stroke="none" d="M532.5,80.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text973" fill="black"><text id="kity_text_9764" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="532.5">读写分离有什么问题？</text></g></g><g id="minder_node971" display="none"><g id="node_expander967" display="none" style="cursor: pointer;"><path id="kity_path_23423" fill="white" stroke="gray" d="M548.5,73.5A6,6,0,1,1,536.5,73.5A6,6,0,1,1,548.5,73.5"></path><path id="kity_path_23424" fill="none" stroke="gray"></path></g><path id="node_outline968" fill="none" stroke="none" d="M548.5,64.5h74a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-74a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text968" fill="black"><text id="kity_text_9752" text-rendering="inherit" font-size="12" dy=".8em" y="65.70000004768372" x="548.5">复制数据延迟</text></g></g><g id="minder_node972" display="none"><g id="node_expander966" display="none" style="cursor: pointer;"><path id="kity_path_23420" fill="white" stroke="gray" d="M564.5,73.5A6,6,0,1,1,552.5,73.5A6,6,0,1,1,564.5,73.5"></path><path id="kity_path_23421" fill="none" stroke="gray"></path></g><path id="node_outline967" fill="none" stroke="none" d="M564.5,64.5h82a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-82a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text967" fill="black"><text id="kity_text_9750" text-rendering="inherit" font-size="12" dy=".8em" y="65.70000004768372" x="564.5">1.多方面原因。</text></g></g><g id="minder_node973" display="none"><g id="node_expander969" display="none" style="cursor: pointer;"><path id="kity_path_23429" fill="white" stroke="gray" d="M548.5,81.5A6,6,0,1,1,536.5,81.5A6,6,0,1,1,548.5,81.5"></path><path id="kity_path_23430" fill="none" stroke="gray"></path></g><path id="node_outline970" fill="none" stroke="none" d="M548.5,72.5h74a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-74a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text970" fill="black"><text id="kity_text_9758" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="548.5">读到过期数据</text></g></g><g id="minder_node974" display="none"><g id="node_expander968" display="none" style="cursor: pointer;"><path id="kity_path_23426" fill="white" stroke="gray" d="M564.5,81.5A6,6,0,1,1,552.5,81.5A6,6,0,1,1,564.5,81.5"></path><path id="kity_path_23427" fill="none" stroke="gray"></path></g><path id="node_outline969" fill="none" stroke="none" d="M564.5,54.5h496a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-496a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text969" fill="black"><text id="kity_text_9754" text-rendering="inherit" font-size="12" dy=".8em" y="55.700000047683716" x="564.5">1.slave没有权限处理过期的key，master上过期的key，在slave服务器就可能被读取</text><text id="kity_text_9755" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="564.5">1）master会累积过期的key，积累一定的量之后，发送del命令到slave，删除slave上的key。</text><text id="kity_text_9756" text-rendering="inherit" font-size="12" dy=".8em" y="91.70000004768372" x="564.5">2）slave升master</text></g></g><g id="minder_node975" display="none"><g id="node_expander971" display="none" style="cursor: pointer;"><path id="kity_path_23435" fill="white" stroke="gray" d="M548.5,89.5A6,6,0,1,1,536.5,89.5A6,6,0,1,1,548.5,89.5"></path><path id="kity_path_23436" fill="none" stroke="gray"></path></g><path id="node_outline972" fill="none" stroke="none" d="M548.5,80.5h62a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-62a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text972" fill="black"><text id="kity_text_9762" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="548.5">从节点故障</text></g></g><g id="minder_node976" display="none"><g id="node_expander970" display="none" style="cursor: pointer;"><path id="kity_path_23432" fill="white" stroke="gray" d="M564.5,89.5A6,6,0,1,1,552.5,89.5A6,6,0,1,1,564.5,89.5"></path><path id="kity_path_23433" fill="none" stroke="gray"></path></g><path id="node_outline971" fill="none" stroke="none" d="M564.5,80.5h51a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-51a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text971" fill="black"><text id="kity_text_9760" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="564.5">1.多slave</text></g></g><g id="minder_node977" display="none"><g id="node_expander974" display="none" style="cursor: pointer;"><path id="kity_path_23444" fill="white" stroke="gray" d="M532.5,97.5A6,6,0,1,1,520.5,97.5A6,6,0,1,1,532.5,97.5"></path><path id="kity_path_23445" fill="none" stroke="gray"></path></g><path id="node_outline975" fill="none" stroke="none" d="M532.5,88.5h221a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-221a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text975" fill="black"><text id="kity_text_9772" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="532.5">怎么选择redis集群的组合方式，说说场景</text></g></g><g id="minder_node978" display="none"><g id="node_expander973" display="none" style="cursor: pointer;"><path id="kity_path_23441" fill="white" stroke="gray" d="M548.5,97.5A6,6,0,1,1,536.5,97.5A6,6,0,1,1,548.5,97.5"></path><path id="kity_path_23442" fill="none" stroke="gray"></path></g><path id="node_outline974" fill="none" stroke="none" d="M548.5,52.5h479a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-479a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text974" fill="black"><text id="kity_text_9766" text-rendering="inherit" font-size="12" dy=".8em" y="53.700000047683716" x="548.5">1.单机版架构简单，部署方便机器故障、容量瓶颈、QPS瓶颈主从复制高可靠性，</text><text id="kity_text_9767" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="548.5">2.读写分离故障恢复复杂，主库的写跟存受单机限制</text><text id="kity_text_9768" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="548.5">3.Sentinel 哨兵集群部署简单，HA原理繁琐，slave存在资源浪费，不能解决读写分离问题</text><text id="kity_text_9769" text-rendering="inherit" font-size="12" dy=".8em" y="107.70000004768372" x="548.5">4.Cluster数据动态存储solt，可扩展，高可用客户端动态感知后端变更，批量操作支持查</text><text id="kity_text_9770" text-rendering="inherit" font-size="12" dy=".8em" y="125.70000004768372" x="548.5">5.具体多少主多少从 视业务场景和数据量大小，支撑不了就水平扩展，</text></g></g><g id="minder_node979" display="none"><g id="node_expander976" display="none" style="cursor: pointer;"><path id="kity_path_23450" fill="white" stroke="gray" d="M532.5,105.5A6,6,0,1,1,520.5,105.5A6,6,0,1,1,532.5,105.5"></path><path id="kity_path_23451" fill="none" stroke="gray"></path></g><path id="node_outline977" fill="none" stroke="none" d="M532.5,87.5h269a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-269a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text977" fill="black"><text id="kity_text_9780" text-rendering="inherit" font-size="12" dy=".8em" y="88.70000004768372" x="532.5">有关注redis主从的延时问题吗，主从延时有多少？</text><text id="kity_text_9781" text-rendering="inherit" font-size="12" dy=".8em" y="106.70000004768372" x="532.5">复制超时呢？</text></g></g><g id="minder_node980" display="none"><g id="node_expander975" display="none" style="cursor: pointer;"><path id="kity_path_23447" fill="white" stroke="gray" d="M548.5,105.5A6,6,0,1,1,536.5,105.5A6,6,0,1,1,548.5,105.5"></path><path id="kity_path_23448" fill="none" stroke="gray"></path></g><path id="node_outline976" fill="none" stroke="none" d="M548.5,60.5h826a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-826a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text976" fill="black"><text id="kity_text_9774" text-rendering="inherit" font-size="12" dy=".8em" y="61.700000047683716" x="548.5">1.延时解决？</text><text id="kity_text_9775" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="548.5">优化主从节点之间的网络环境（如在同机房部署）.监控主从节点延迟（通过offset）判断，如果从节点延迟过大，通知应用不再通过该从节点读取数据；</text><text id="kity_text_9776" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="548.5">2.复制超时，&#xa0;会导致复制中断</text><text id="kity_text_9777" text-rendering="inherit" font-size="12" dy=".8em" y="115.70000004768372" x="548.5">主节点判断连接超时，其会释放相应从节点的连接,释放从占的资源，</text><text id="kity_text_9778" text-rendering="inherit" font-size="12" dy=".8em" y="133.70000004768372" x="548.5">主从复制超时判断的核心，在于repl-timeout参数，该参数规定了超时时间的阈值（默认60s），对于主节点和从节点同时有效</text></g><g id="kity_g_16988" style="cursor: pointer;"><path id="kity_path_16989" fill="none" stroke="none" d="M1361,97h12a2,2,0,0,1,2,2v13a2,2,0,0,1,-2,2h-12a2,2,0,0,1,-2,-2v-13a2,2,0,0,1,2,-2z"></path><path id="kity_path_16990" fill="black" stroke="none" d="M1370,108H1364V107h6L1370,108L1370,108zM1370,106H1364V105h6V106zM1370,104H1364V103h6V104zM1369.5,110H1363V101h8v7.5M1370,111l2,-2V100H1362v11"></path></g></g><g id="minder_node981" display="none"><g id="node_expander978" display="none" style="cursor: pointer;"><path id="kity_path_23456" fill="white" stroke="gray" d="M516.5,113.5A6,6,0,1,1,504.5,113.5A6,6,0,1,1,516.5,113.5"></path><path id="kity_path_23457" fill="none" stroke="gray"></path></g><path id="node_outline979" fill="none" stroke="none" d="M516.5,104.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text979" fill="black"><text id="kity_text_9785" text-rendering="inherit" font-size="12" dy=".8em" y="105.70000004768372" x="516.5">单点</text></g></g><g id="minder_node982" display="none"><g id="node_expander998" display="none" style="cursor: pointer;"><path id="kity_path_23516" fill="white" stroke="gray" d="M516.5,121.5A6,6,0,1,1,504.5,121.5A6,6,0,1,1,516.5,121.5"></path><path id="kity_path_23517" fill="none" stroke="gray"></path></g><path id="node_outline999" fill="none" stroke="none" d="M516.5,112.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text999" fill="black"><text id="kity_text_9860" text-rendering="inherit" font-size="12" dy=".8em" y="113.70000004768372" x="516.5">哨兵</text></g></g><g id="minder_node983" display="none"><g id="node_expander980" display="none" style="cursor: pointer;"><path id="kity_path_23462" fill="white" stroke="gray" d="M532.5,57.5A6,6,0,1,1,520.5,57.5A6,6,0,1,1,532.5,57.5"></path><path id="kity_path_23463" fill="none" stroke="gray"></path></g><path id="node_outline981" fill="none" stroke="none" d="M532.5,48.5h108a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-108a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text981" fill="black"><text id="kity_text_9792" text-rendering="inherit" font-size="12" dy=".8em" y="49.700000047683716" x="532.5">为什么有哨兵机制？</text></g></g><g id="minder_node984" display="none"><g id="node_expander979" display="none" style="cursor: pointer;"><path id="kity_path_23459" fill="white" stroke="gray" d="M548.5,57.5A6,6,0,1,1,536.5,57.5A6,6,0,1,1,548.5,57.5"></path><path id="kity_path_23460" fill="none" stroke="gray"></path></g><path id="node_outline980" fill="none" stroke="none" d="M548.5,21.5h840a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-840a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text980" fill="black"><text id="kity_text_9787" text-rendering="inherit" font-size="12" dy=".8em" y="22.700000047683716" x="548.5">1.</text><text id="kity_text_9788" text-rendering="inherit" font-size="12" dy=".8em" y="40.700000047683716" x="548.5">复制是高可用Redis的基础，哨兵和集群都是在复制基础上实现高可用的。但是问题有 故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。</text><text id="kity_text_9789" text-rendering="inherit" font-size="12" dy=".8em" y="58.700000047683716" x="548.5">在主从复制的基础上，哨兵实现了自动化的故障恢复。</text><text id="kity_text_9790" text-rendering="inherit" font-size="12" dy=".8em" y="76.70000004768372" x="548.5">2.哨兵的核心功能是主节点的自动故障转移</text></g></g><g id="minder_node985" display="none"><g id="node_expander982" display="none" style="cursor: pointer;"><path id="kity_path_23468" fill="white" stroke="gray" d="M532.5,65.5A6,6,0,1,1,520.5,65.5A6,6,0,1,1,532.5,65.5"></path><path id="kity_path_23469" fill="none" stroke="gray"></path></g><path id="node_outline983" fill="none" stroke="none" d="M532.5,56.5h229a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-229a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text983" fill="black"><text id="kity_text_9800" text-rendering="inherit" font-size="12" dy=".8em" y="57.700000047683716" x="532.5">哨兵机制的节点组成描述一下还有功能描述</text></g></g><g id="minder_node986" display="none"><g id="node_expander981" display="none" style="cursor: pointer;"><path id="kity_path_23465" fill="white" stroke="gray" d="M548.5,65.5A6,6,0,1,1,536.5,65.5A6,6,0,1,1,548.5,65.5"></path><path id="kity_path_23466" fill="none" stroke="gray"></path></g><path id="node_outline982" fill="none" stroke="none" d="M548.5,20.5h1090a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1090a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text982" fill="black"><text id="kity_text_9794" text-rendering="inherit" font-size="12" dy=".8em" y="21.700000047683716" x="548.5">1.</text><text id="kity_text_9795" text-rendering="inherit" font-size="12" dy=".8em" y="39.700000047683716" x="548.5">哨兵节点：哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的redis节点，不存储数据。</text><text id="kity_text_9796" text-rendering="inherit" font-size="12" dy=".8em" y="57.700000047683716" x="548.5">数据节点：主节点和从节点都是数据节点。</text><text id="kity_text_9797" text-rendering="inherit" font-size="12" dy=".8em" y="75.70000004768372" x="548.5">2.哨兵会不断地检查主节点和从节点是否运作正常。当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。</text><text id="kity_text_9798" text-rendering="inherit" font-size="12" dy=".8em" y="93.70000004768372" x="548.5">哨兵可以将故障转移的结果发送给客户端。</text></g></g><g id="minder_node987" display="none"><g id="node_expander984" display="none" style="cursor: pointer;"><path id="kity_path_23474" fill="white" stroke="gray" d="M532.5,73.5A6,6,0,1,1,520.5,73.5A6,6,0,1,1,532.5,73.5"></path><path id="kity_path_23475" fill="none" stroke="gray"></path></g><path id="node_outline985" fill="none" stroke="none" d="M532.5,64.5h178a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-178a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text985" fill="black"><text id="kity_text_9806" text-rendering="inherit" font-size="12" dy=".8em" y="65.70000004768372" x="532.5">说几个sentinel获取信息的命令？</text></g></g><g id="minder_node988" display="none"><g id="node_expander983" display="none" style="cursor: pointer;"><path id="kity_path_23471" fill="white" stroke="gray" d="M548.5,73.5A6,6,0,1,1,536.5,73.5A6,6,0,1,1,548.5,73.5"></path><path id="kity_path_23472" fill="none" stroke="gray"></path></g><path id="node_outline984" fill="none" stroke="none" d="M548.5,46.5h635a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-635a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text984" fill="black"><text id="kity_text_9802" text-rendering="inherit" font-size="12" dy=".8em" y="47.700000047683716" x="548.5">1.</text><text id="kity_text_9803" text-rendering="inherit" font-size="12" dy=".8em" y="65.70000004768372" x="548.5">info sentinel：获取监控的所有主节点的基本信息。sentinel masters：获取监控的所有主节点的详细信息</text><text id="kity_text_9804" text-rendering="inherit" font-size="12" dy=".8em" y="83.70000004768372" x="548.5">sentinel is-master-down-by-addr：哨兵节点之间可以通过该命令询问主节点是否下线，从而对是否客观下线做出判断</text></g></g><g id="minder_node989" display="none"><g id="node_expander986" display="none" style="cursor: pointer;"><path id="kity_path_23480" fill="white" stroke="gray" d="M532.5,81.5A6,6,0,1,1,520.5,81.5A6,6,0,1,1,532.5,81.5"></path><path id="kity_path_23481" fill="none" stroke="gray"></path></g><path id="node_outline987" fill="none" stroke="none" d="M532.5,72.5h132a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-132a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text987" fill="black"><text id="kity_text_9815" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="532.5">哨兵机制的原理描述一下</text></g></g><g id="minder_node990" display="none"><g id="node_expander985" display="none" style="cursor: pointer;"><path id="kity_path_23477" fill="white" stroke="gray" d="M548.5,81.5A6,6,0,1,1,536.5,81.5A6,6,0,1,1,548.5,81.5"></path><path id="kity_path_23478" fill="none" stroke="gray"></path></g><path id="node_outline986" fill="none" stroke="none" d="M548.5,27.5h1339a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1339a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text986" fill="black"><text id="kity_text_9808" text-rendering="inherit" font-size="12" dy=".8em" y="28.700000047683716" x="548.5">（1）定时任务：每个哨兵节点维护了3个定时任务。定时任务的功能分别如下：通过向主从节点发送info命令获取最新的主从结构；通过发布订阅功能获取其他哨兵节点的信息；通过向其他节点发送ping命令进行心跳检测，判断是否下线。 </text><text id="kity_text_9809" text-rendering="inherit" font-size="12" dy=".8em" y="46.700000047683716" x="548.5">  （2）主观下线：在心跳检测的定时任务中，如果其他节点超过一定时间没有回复，哨兵节点就会将其进行主观下线。顾名思义，主观下线的意思是一个哨兵节点“主观地”判断下线；与主观下线相对应的是客观下线。 </text><text id="kity_text_9810" text-rendering="inherit" font-size="12" dy=".8em" y="64.70000004768372" x="548.5">  （3）客观下线：哨兵节点在对主节点进行主观下线后，会通过sentinel is-master-down-by-addr命令询问其他哨兵节点该主节点的状态；如果判断主节点下线的哨兵数量达到一定数值，则对该主节点进行客观下线。 </text><text id="kity_text_9811" text-rendering="inherit" font-size="12" dy=".8em" y="82.70000004768372" x="548.5">  （4）选举领导者哨兵节点：当主节点被判断客观下线以后，各个哨兵节点会进行协商，选举出一个领导者哨兵节点，并由该领导者节点对其进行故障转移操作。监视该主节点的所有哨兵都有可能被选为领导者，选举使用的算法是Raft算法；</text><text id="kity_text_9812" text-rendering="inherit" font-size="12" dy=".8em" y="100.70000004768372" x="548.5">Raft算法的基本思路是先到先得：即在一轮选举中，哨兵A向B发送成为领导者的申请，如果B没有同意过其他哨兵，则会同意A成为领导者。选举的具体过程这里不做详细描述，一般来说，哨兵选择的过程很快，谁先完成客观下线，一般就能成为领导者。 </text><text id="kity_text_9813" text-rendering="inherit" font-size="12" dy=".8em" y="118.70000004768372" x="548.5">  （5）故障转移：选举出的领导者哨兵，开始进行故障转移操作，</text></g></g><g id="minder_node991" display="none"><g id="node_expander988" display="none" style="cursor: pointer;"><path id="kity_path_23486" fill="white" stroke="gray" d="M532.5,89.5A6,6,0,1,1,520.5,89.5A6,6,0,1,1,532.5,89.5"></path><path id="kity_path_23487" fill="none" stroke="gray"></path></g><path id="node_outline989" fill="none" stroke="none" d="M532.5,80.5h221a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-221a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text989" fill="black"><text id="kity_text_9821" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="532.5">继续上面那个问题，故障转移 详细说一下</text></g></g><g id="minder_node992" display="none"><g id="node_expander987" display="none" style="cursor: pointer;"><path id="kity_path_23483" fill="white" stroke="gray" d="M548.5,89.5A6,6,0,1,1,536.5,89.5A6,6,0,1,1,548.5,89.5"></path><path id="kity_path_23484" fill="none" stroke="gray"></path></g><path id="node_outline988" fill="none" stroke="none" d="M548.5,62.5h1242a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1242a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text988" fill="black"><text id="kity_text_9817" text-rendering="inherit" font-size="12" dy=".8em" y="63.700000047683716" x="548.5">①在从节点中选择新的主节点：选择的原则是，首先过滤掉不健康的从节点；然后选择优先级最高的从节点(由slave-priority指定)；如果优先级无法区分，则选择复制偏移量最大的从节点；如果仍无法区分，则选择runid最小的从节点。 </text><text id="kity_text_9818" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="548.5">  ②更新主从状态：通过slaveof no one命令，让选出来的从节点成为主节点；并通过slaveof命令让其他节点成为其从节点。 </text><text id="kity_text_9819" text-rendering="inherit" font-size="12" dy=".8em" y="99.70000004768372" x="548.5">  ③将已经下线的主节点(即6379)设置为新的主节点的从节点，当6379重新上线后，它会成为新的主节点的从节点。</text></g></g><g id="minder_node993" display="none"><g id="node_expander990" display="none" style="cursor: pointer;"><path id="kity_path_23492" fill="white" stroke="gray" d="M532.5,97.5A6,6,0,1,1,520.5,97.5A6,6,0,1,1,532.5,97.5"></path><path id="kity_path_23493" fill="none" stroke="gray"></path></g><path id="node_outline991" fill="none" stroke="none" d="M532.5,88.5h108a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-108a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text991" fill="black"><text id="kity_text_9827" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="532.5">主观下线客观下线？</text></g></g><g id="minder_node994" display="none"><g id="node_expander989" display="none" style="cursor: pointer;"><path id="kity_path_23489" fill="white" stroke="gray" d="M548.5,97.5A6,6,0,1,1,536.5,97.5A6,6,0,1,1,548.5,97.5"></path><path id="kity_path_23490" fill="none" stroke="gray"></path></g><path id="node_outline990" fill="none" stroke="none" d="M548.5,70.5h944a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-944a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text990" fill="black"><text id="kity_text_9823" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="548.5">1.主观下线：针对所有数据节点，如果在 down-after-milliseconds 毫秒内，Sentinel 没有收到 目标节点 的有效回复，则会判定 该节点 为 主观下线。</text><text id="kity_text_9824" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="548.5">2.客观下线：针对master，如果没有收到某一个master的回复，Sentinel 节点会通过 sentinel is-master-down-by-addr 命令，向其它 Sentinel 节点询问对该节点的 状态判断。</text><text id="kity_text_9825" text-rendering="inherit" font-size="12" dy=".8em" y="107.70000004768372" x="548.5">如果超过 &lt;quorum&gt; (半数以上)个数的节点判定 主节点 不可达，则该 Sentinel 节点会判断 主节点 为 客观下线。</text></g></g><g id="minder_node995" display="none"><g id="node_expander992" display="none" style="cursor: pointer;"><path id="kity_path_23498" fill="white" stroke="gray" d="M532.5,105.5A6,6,0,1,1,520.5,105.5A6,6,0,1,1,532.5,105.5"></path><path id="kity_path_23499" fill="none" stroke="gray"></path></g><path id="node_outline993" fill="none" stroke="none" d="M532.5,96.5h105a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-105a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text993" fill="black"><text id="kity_text_9839" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="532.5">sentinel选举说说？</text></g></g><g id="minder_node996" display="none"><g id="node_expander991" display="none" style="cursor: pointer;"><path id="kity_path_23495" fill="white" stroke="gray" d="M548.5,105.5A6,6,0,1,1,536.5,105.5A6,6,0,1,1,548.5,105.5"></path><path id="kity_path_23496" fill="none" stroke="gray"></path></g><path id="node_outline992" fill="none" stroke="none" d="M548.5,24.5h917a5,5,0,0,1,5,5v152a5,5,0,0,1,-5,5h-917a5,5,0,0,1,-5,-5v-152a5,5,0,0,1,5,-5z"></path><g id="node_text992" fill="black"><text id="kity_text_9829" text-rendering="inherit" font-size="12" dy=".8em" y="25.700000047683716" x="548.5">1.先选老大sentinel</text><text id="kity_text_9830" text-rendering="inherit" font-size="12" dy=".8em" y="43.700000047683716" x="548.5">当master下线以后，通过raft选举一个老大sentinel来进行故障转移恢复</text><text id="kity_text_9831" text-rendering="inherit" font-size="12" dy=".8em" y="61.700000047683716" x="548.5">首先 发现master下线的哨兵（sentinelA）会向其它的哨兵发送命令进行拉票，要求选择自己为哨兵大佬。sentinelA可以自己选自己，如果不选别的，那就是他自己是老大了</text><text id="kity_text_9832" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="548.5">只要选sentinelA超一半，老大就sentinelA了。如果票一致，那么下一次随机时间再选直到选出来</text><text id="kity_text_9833" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="548.5">2.老大sentinel从slave中选出一名slave作为主数据库</text><text id="kity_text_9834" text-rendering="inherit" font-size="12" dy=".8em" y="115.70000004768372" x="548.5">选slave-priority最高的从节点列表</text><text id="kity_text_9835" text-rendering="inherit" font-size="12" dy=".8em" y="133.70000004768372" x="548.5">上一步相同就选择复制偏移量最大的。</text><text id="kity_text_9836" text-rendering="inherit" font-size="12" dy=".8em" y="151.70000004768372" x="548.5">若是以上两者都相同，选择run ID最小的。</text><text id="kity_text_9837" text-rendering="inherit" font-size="12" dy=".8em" y="169.70000004768372" x="548.5">然后执行 slaveof no one 命令，让它成master，给其他节点发消息 成为这个master的从，原来的主变为从</text></g></g><g id="minder_node997" display="none"><g id="node_expander995" display="none" style="cursor: pointer;"><path id="kity_path_23507" fill="white" stroke="gray" d="M532.5,113.5A6,6,0,1,1,520.5,113.5A6,6,0,1,1,532.5,113.5"></path><path id="kity_path_23508" fill="none" stroke="gray"></path></g><path id="node_outline996" fill="none" stroke="none" d="M532.5,104.5h103a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-103a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text996" fill="black"><text id="kity_text_9852" text-rendering="inherit" font-size="12" dy=".8em" y="105.70000004768372" x="532.5">节点之间怎么通信?</text></g></g><g id="minder_node998" display="none"><g id="node_expander994" display="none" style="cursor: pointer;"><path id="kity_path_23504" fill="white" stroke="gray" d="M548.5,113.5A6,6,0,1,1,536.5,113.5A6,6,0,1,1,548.5,113.5"></path><path id="kity_path_23505" fill="none" stroke="gray"></path></g><path id="node_outline995" fill="none" stroke="none" d="M548.5,41.5h880a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-880a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text995" fill="black"><text id="kity_text_9843" text-rendering="inherit" font-size="12" dy=".8em" y="42.700000047683716" x="548.5">1.当哨兵启动后，会与master建立一条连接，用于订阅master的_sentinel_:hello频道。</text><text id="kity_text_9844" text-rendering="inherit" font-size="12" dy=".8em" y="60.700000047683716" x="548.5">当哨兵与master建立连接后，定期会向（10秒一次）master和slave发送INFO命令，若是master被标记为主观下线，频率就会变为1秒一次。</text><text id="kity_text_9845" text-rendering="inherit" font-size="12" dy=".8em" y="78.70000004768372" x="548.5">sentinel定期的向master、slave和其它哨兵发送PING命令（每秒一次），以便检测对象是否存活，若是对方接收到了PING命令，无故障情况下，会回复PONG命令。</text><text id="kity_text_9846" text-rendering="inherit" font-size="12" dy=".8em" y="96.70000004768372" x="548.5">2.哨兵通过建立这两条连接、通过定期发送INFO、PING命令来实现哨兵与哨兵、哨兵与data节点之间的通信。</text><text id="kity_text_9847" text-rendering="inherit" font-size="12" dy=".8em" y="114.70000004768372" x="548.5">每一秒钟 sentinel和sentinel通信(心跳，发送ping判断所有data是否存活)&#xa0;</text><text id="kity_text_9848" text-rendering="inherit" font-size="12" dy=".8em" y="132.70000004768372" x="548.5">每两秒 sentinel和master的channel通信(sentinel通过订阅频道发送自己的信息，发现其他sentinel信息，交换master的状态信息，做故障转移)，&#xa0;</text><text id="kity_text_9849" text-rendering="inherit" font-size="12" dy=".8em" y="150.70000004768372" x="548.5">每十秒sentinel 给data节点方式info通信(获取主关系，确认主从关系，让新节点更知加入集群)，</text><text id="kity_text_9850" text-rendering="inherit" font-size="12" dy=".8em" y="168.70000004768372" x="548.5"> </text></g></g><g id="minder_node999" display="none"><g id="node_expander993" display="none" style="cursor: pointer;"><path id="kity_path_23501" fill="white" stroke="gray" d="M564.5,113.5A6,6,0,1,1,552.5,113.5A6,6,0,1,1,564.5,113.5"></path><path id="kity_path_23502" fill="none" stroke="gray"></path></g><path id="node_outline994" fill="none" stroke="none" d="M564.5,99.5h102a5,5,0,0,1,5,5v18a5,5,0,0,1,-5,5h-102a5,5,0,0,1,-5,-5v-18a5,5,0,0,1,5,-5z"></path><g id="node_text994" fill="black"><text id="kity_text_9841" text-rendering="inherit" font-size="12" dy=".8em" y="105.70000004768372" x="564.5">参考工作原理</text></g><a id="kity_a_16925" xlink:href="https://juejin.cn/post/6844903663362637832#heading-10" target="_blank" xlink:title="https://juejin.cn/post/6844903663362637832#heading-10" style="cursor: pointer;"><path id="kity_path_16927" fill="rgba(255, 255, 255, 0)" stroke="none" d="M646.5,102.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16926" fill="#666" stroke="none" d="M661.114,118.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V112.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C656.766,109.571,658.168,108.5,659.836,108.5h1.278c2.116,0,3.834,1.716,3.834,3.834V114.89C664.948,117.008,663.23,118.724,661.114,118.724zM649.612,113.612c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S659.265,114.89,658.558,114.89H650.89C650.185,114.89,649.612,114.319,649.612,113.612zM647.056,112.334V114.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H648.334C646.216,118.724,644.5,117.008,644.5,114.89V112.334C644.5,110.216,646.216,108.5,648.334,108.5h1.278c1.667,0,3.071,1.071,3.599,2.556H648.334C647.629,111.056,647.056,111.627,647.056,112.334z"></path></a></g><g id="minder_node1000" display="none"><g id="node_expander997" display="none" style="cursor: pointer;"><path id="kity_path_23513" fill="white" stroke="gray" d="M532.5,121.5A6,6,0,1,1,520.5,121.5A6,6,0,1,1,532.5,121.5"></path><path id="kity_path_23514" fill="none" stroke="gray"></path></g><path id="node_outline998" fill="none" stroke="none" d="M532.5,112.5h96a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-96a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text998" fill="black"><text id="kity_text_9858" text-rendering="inherit" font-size="12" dy=".8em" y="113.70000004768372" x="532.5">哨兵机制有缺点吗</text></g></g><g id="minder_node1001" display="none"><g id="node_expander996" display="none" style="cursor: pointer;"><path id="kity_path_23510" fill="white" stroke="gray" d="M548.5,121.5A6,6,0,1,1,536.5,121.5A6,6,0,1,1,548.5,121.5"></path><path id="kity_path_23511" fill="none" stroke="gray"></path></g><path id="node_outline997" fill="none" stroke="none" d="M548.5,94.5h754a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-754a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text997" fill="black"><text id="kity_text_9854" text-rendering="inherit" font-size="12" dy=".8em" y="95.70000004768372" x="548.5">1.写操作无法负载均衡；sentinel的一主多从存储能力受到单机的限制。若是master宕机了，故障恢复的时间比较长，写的业务就会受到影响。</text><text id="kity_text_9855" text-rendering="inherit" font-size="12" dy=".8em" y="113.70000004768372" x="548.5">2.Sentinel 仅仅解决了 高可用 的问题，对于 主节点 单点写入和单节点无法扩容等问题，还需要引入 Redis Cluster 集群模式 予以解决。</text><text id="kity_text_9856" text-rendering="inherit" font-size="12" dy=".8em" y="131.70000004768372" x="548.5">3.增加了系统的复杂度</text></g></g><g id="minder_node1002" display="none"><g id="node_expander1036" display="none" style="cursor: pointer;"><path id="kity_path_23630" fill="white" stroke="gray" d="M516.5,129.5A6,6,0,1,1,504.5,129.5A6,6,0,1,1,516.5,129.5"></path><path id="kity_path_23631" fill="none" stroke="gray"></path></g><path id="node_outline1037" fill="none" stroke="none" d="M516.5,120.5h38a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-38a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1037" fill="black"><text id="kity_text_10006" text-rendering="inherit" font-size="12" dy=".8em" y="121.70000004768372" x="516.5">cluster</text></g></g><g id="minder_node1003" display="none"><g id="node_expander1012" display="none" style="cursor: pointer;"><path id="kity_path_23558" fill="white" stroke="gray" d="M532.5,113.5A6,6,0,1,1,520.5,113.5A6,6,0,1,1,532.5,113.5"></path><path id="kity_path_23559" fill="none" stroke="gray"></path></g><path id="node_outline1013" fill="none" stroke="none" d="M532.5,104.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1013" fill="black"><text id="kity_text_9926" text-rendering="inherit" font-size="12" dy=".8em" y="105.70000004768372" x="532.5">基础</text></g></g><g id="minder_node1004" display="none"><g id="node_expander1000" display="none" style="cursor: pointer;"><path id="kity_path_23522" fill="white" stroke="gray" d="M548.5,73.5A6,6,0,1,1,536.5,73.5A6,6,0,1,1,548.5,73.5"></path><path id="kity_path_23523" fill="none" stroke="gray"></path></g><path id="node_outline1001" fill="none" stroke="none" d="M548.5,55.5h144a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-144a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1001" fill="black"><text id="kity_text_9871" text-rendering="inherit" font-size="12" dy=".8em" y="56.700000047683716" x="548.5">什么是cluster模式?</text><text id="kity_text_9872" text-rendering="inherit" font-size="12" dy=".8em" y="74.70000004768372" x="548.5">&#xa0;为什么要引入cluster模式?</text></g></g><g id="minder_node1005" display="none"><g id="node_expander999" display="none" style="cursor: pointer;"><path id="kity_path_23519" fill="white" stroke="gray" d="M564.5,73.5A6,6,0,1,1,552.5,73.5A6,6,0,1,1,564.5,73.5"></path><path id="kity_path_23520" fill="none" stroke="gray"></path></g><path id="node_outline1000" fill="none" stroke="none" d="M564.5,1.5h1119a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-1119a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text1000" fill="black"><text id="kity_text_9862" text-rendering="inherit" font-size="12" dy=".8em" y="2.700000047683716" x="564.5">1.</text><text id="kity_text_9863" text-rendering="inherit" font-size="12" dy=".8em" y="20.700000047683716" x="564.5">cluster是 Redis 官方提供具备：可扩展、高可用、一致性的分布式数据库方案。</text><text id="kity_text_9864" text-rendering="inherit" font-size="12" dy=".8em" y="38.700000047683716" x="564.5">2.</text><text id="kity_text_9865" text-rendering="inherit" font-size="12" dy=".8em" y="56.700000047683716" x="564.5">哨兵解决主从不能自动故障恢复的问题，但是同时也存在难以扩容以及单机存储、读写能力受限的问题，并且集群之前都是一台redis都是全量的数据，这样所有的redis都冗余一份，就会大大消耗内存空间。</text><text id="kity_text_9866" text-rendering="inherit" font-size="12" dy=".8em" y="74.70000004768372" x="564.5">集群模式实现了Redis数据的分布式存储，每个 Redis 对应一部分的槽。实现数据的分片，整个集群分担所有数据，不同的 key 会放到不同的 Redis 中。并且解决了在线的节点收缩（下线）和扩容（上线）问题。</text><text id="kity_text_9867" text-rendering="inherit" font-size="12" dy=".8em" y="92.70000004768372" x="564.5">集群模式真正意义上实现了系统的高可用和高性能</text><text id="kity_text_9868" text-rendering="inherit" font-size="12" dy=".8em" y="110.70000004768372" x="564.5">redis 集群的选择是CAP中的 AP。Redis 集群节点间采用异步通信方式，不保证强一致性，尽力达到最终一致性。</text><text id="kity_text_9869" text-rendering="inherit" font-size="12" dy=".8em" y="128.70000004768372" x="564.5">3.cluster最少需要三个master</text></g></g><g id="minder_node1006" display="none"><g id="node_expander1002" display="none" style="cursor: pointer;"><path id="kity_path_23528" fill="white" stroke="gray" d="M548.5,81.5A6,6,0,1,1,536.5,81.5A6,6,0,1,1,548.5,81.5"></path><path id="kity_path_23529" fill="none" stroke="gray"></path></g><path id="node_outline1003" fill="none" stroke="none" d="M548.5,72.5h79a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-79a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1003" fill="black"><text id="kity_text_9881" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="548.5">集群的优缺点?</text></g></g><g id="minder_node1007" display="none"><g id="node_expander1001" display="none" style="cursor: pointer;"><path id="kity_path_23525" fill="white" stroke="gray" d="M564.5,81.5A6,6,0,1,1,552.5,81.5A6,6,0,1,1,564.5,81.5"></path><path id="kity_path_23526" fill="none" stroke="gray"></path></g><path id="node_outline1002" fill="none" stroke="none" d="M564.5,27.5h752a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-752a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1002" fill="black"><text id="kity_text_9874" text-rendering="inherit" font-size="12" dy=".8em" y="28.700000047683716" x="564.5">1.优点</text><text id="kity_text_9875" text-rendering="inherit" font-size="12" dy=".8em" y="46.700000047683716" x="564.5">无中心架构（不存在哪个节点影响性能瓶颈），少了 proxy 层。数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。</text><text id="kity_text_9876" text-rendering="inherit" font-size="12" dy=".8em" y="64.70000004768372" x="564.5">可线性扩展，节点可动态添加或删除。高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本</text><text id="kity_text_9877" text-rendering="inherit" font-size="12" dy=".8em" y="82.70000004768372" x="564.5">实现故障自动转移，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。</text><text id="kity_text_9878" text-rendering="inherit" font-size="12" dy=".8em" y="100.70000004768372" x="564.5">2.缺点</text><text id="kity_text_9879" text-rendering="inherit" font-size="12" dy=".8em" y="118.70000004768372" x="564.5">异步复制，不保证数据的强一致性，</text></g></g><g id="minder_node1008" display="none"><g id="node_expander1005" display="none" style="cursor: pointer;"><path id="kity_path_23537" fill="white" stroke="gray" d="M548.5,89.5A6,6,0,1,1,536.5,89.5A6,6,0,1,1,548.5,89.5"></path><path id="kity_path_23538" fill="none" stroke="gray"></path></g><path id="node_outline1006" fill="none" stroke="none" d="M548.5,80.5h176a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-176a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1006" fill="black"><text id="kity_text_9893" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="548.5">说一下redis 分片，为什么分片，</text></g></g><g id="minder_node1009" display="none"><g id="node_expander1004" display="none" style="cursor: pointer;"><path id="kity_path_23534" fill="white" stroke="gray" d="M564.5,89.5A6,6,0,1,1,552.5,89.5A6,6,0,1,1,564.5,89.5"></path><path id="kity_path_23535" fill="none" stroke="gray"></path></g><path id="node_outline1005" fill="none" stroke="none" d="M564.5,35.5h1049a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1049a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1005" fill="black"><text id="kity_text_9886" text-rendering="inherit" font-size="12" dy=".8em" y="36.700000047683716" x="564.5">1.</text><text id="kity_text_9887" text-rendering="inherit" font-size="12" dy=".8em" y="54.700000047683716" x="564.5">三种分片，节点取余：hash(key) % N。一致性哈希： 一致性哈希环。虚拟槽哈希：CRC16[key] &amp; 16383。redis用的是虚拟槽分区.</text><text id="kity_text_9888" text-rendering="inherit" font-size="12" dy=".8em" y="72.70000004768372" x="564.5">Redis Cluster将自己分成了16384个Slot（槽位）。通过CRC16算法计算出来的哈希值会跟16384取模，取模之后得到的值就是对应的槽位，然后每个Redis节点都会负责处理一部分的槽位</text><text id="kity_text_9889" text-rendering="inherit" font-size="12" dy=".8em" y="90.70000004768372" x="564.5">每个Redis实例会自己维护一份slot - Redis节点的映射关系，假设你在节点A上设置了某个key，但是这个key通过CRC16计算出来的槽位是由节点B维护的，那么就会提示你需要去节点B上进行操作。</text><text id="kity_text_9890" text-rendering="inherit" font-size="12" dy=".8em" y="108.70000004768372" x="564.5">2.</text><text id="kity_text_9891" text-rendering="inherit" font-size="12" dy=".8em" y="126.70000004768372" x="564.5">将key负载均衡到每一个Redis节点上去&#xa0;&#xa0;防止单台的redis数据量过大，影响性能的问题。</text></g></g><g id="minder_node1010" display="none"><g id="node_expander1003" display="none" style="cursor: pointer;"><path id="kity_path_23531" fill="white" stroke="gray" d="M580.5,89.5A6,6,0,1,1,568.5,89.5A6,6,0,1,1,580.5,89.5"></path><path id="kity_path_23532" fill="none" stroke="gray"></path></g><path id="node_outline1004" fill="none" stroke="none" d="M545.5,-9.5h200a5,5,0,0,1,5,5v107a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-107a5,5,0,0,1,5,-5z"></path><g id="node_text1004" fill="black"><text id="kity_text_9883" text-rendering="inherit" font-size="12" dy=".8em" y="72.70000004768372" x="580.5">1.redis 集群方案 分片。</text><text id="kity_text_9884" text-rendering="inherit" font-size="12" dy=".8em" y="90.70000004768372" x="580.5">2.提高系统瓶颈</text></g><image id="kity_image_17052" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20210318003949274.png" x="545.5" y="-6.5" width="200" height="76"></image></g><g id="minder_node1011" display="none"><g id="node_expander1007" display="none" style="cursor: pointer;"><path id="kity_path_23543" fill="white" stroke="gray" d="M548.5,97.5A6,6,0,1,1,536.5,97.5A6,6,0,1,1,548.5,97.5"></path><path id="kity_path_23544" fill="none" stroke="gray"></path></g><path id="node_outline1008" fill="none" stroke="none" d="M548.5,88.5h216a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-216a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1008" fill="black"><text id="kity_text_9899" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="548.5">为什么用的是solt，而不是一致性hash？</text></g></g><g id="minder_node1012" display="none"><g id="node_expander1006" display="none" style="cursor: pointer;"><path id="kity_path_23540" fill="white" stroke="gray" d="M564.5,97.5A6,6,0,1,1,552.5,97.5A6,6,0,1,1,564.5,97.5"></path><path id="kity_path_23541" fill="none" stroke="gray"></path></g><path id="node_outline1007" fill="none" stroke="none" d="M564.5,70.5h833a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-833a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1007" fill="black"><text id="kity_text_9895" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="564.5">1.</text><text id="kity_text_9896" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="564.5">如果此时某一台master发生了宕机，那么此时会导致Redis中所有的缓存失效。为什么是所有的？假设之前有3个master，那么之前的算法应该是 hash % 3，</text><text id="kity_text_9897" text-rendering="inherit" font-size="12" dy=".8em" y="107.70000004768372" x="564.5">但是如果其中一台master宕机了，则算法就会变成 hash % 2，会影响到之前存储的所有的key。而这对缓存后面保护的DB来说，是致命的打击。</text></g></g><g id="minder_node1013" display="none"><g id="node_expander1009" display="none" style="cursor: pointer;"><path id="kity_path_23549" fill="white" stroke="gray" d="M548.5,105.5A6,6,0,1,1,536.5,105.5A6,6,0,1,1,548.5,105.5"></path><path id="kity_path_23550" fill="none" stroke="gray"></path></g><path id="node_outline1010" fill="none" stroke="none" d="M548.5,96.5h122a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-122a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1010" fill="black"><text id="kity_text_9913" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="548.5">集群节点之间怎么通信</text></g></g><g id="minder_node1014" display="none"><g id="node_expander1008" display="none" style="cursor: pointer;"><path id="kity_path_23546" fill="white" stroke="gray" d="M564.5,105.5A6,6,0,1,1,552.5,105.5A6,6,0,1,1,564.5,105.5"></path><path id="kity_path_23547" fill="none" stroke="gray"></path></g><path id="node_outline1009" fill="none" stroke="none" d="M564.5,6.5h1279a5,5,0,0,1,5,5v188a5,5,0,0,1,-5,5h-1279a5,5,0,0,1,-5,-5v-188a5,5,0,0,1,5,-5z"></path><g id="node_text1009" fill="black"><text id="kity_text_9901" text-rendering="inherit" font-size="12" dy=".8em" y="7.700000047683716" x="564.5">1.每个Redis群集节点都有一个额外的TCP端口，每个节点使用TCP连接与每个其他节点连接。之后就是定时任务，不断的向其它节点发送PING消息，这样做的目的就是为了了解节点之间的元数据存储情况，以及健康状况，以便即使发现问题。</text><text id="kity_text_9902" text-rendering="inherit" font-size="12" dy=".8em" y="25.700000047683716" x="564.5">2.</text><text id="kity_text_9903" text-rendering="inherit" font-size="12" dy=".8em" y="43.700000047683716" x="564.5">cluster采用的是一种轻量级的gossip协议通信，Redis集群利用了gossip来实现自身的信息扩散的，进行 故障消息交换，新增删除节点，solt的迁移</text><text id="kity_text_9904" text-rendering="inherit" font-size="12" dy=".8em" y="61.700000047683716" x="564.5">2.</text><text id="kity_text_9905" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="564.5">对于新加入的节点，首先发送一个meet，然后就互相通过ping pong来通信，如果一个master判断另外一个master下线就会通过广播fail命令，所有收到这条消息的就会标记这个master下线</text><text id="kity_text_9906" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="564.5">节点如果收到了publish命令，会向集群广播这条publish消息，所有收到消息的节点都执行相同的命令</text><text id="kity_text_9907" text-rendering="inherit" font-size="12" dy=".8em" y="115.70000004768372" x="564.5">3.gossip优点</text><text id="kity_text_9908" text-rendering="inherit" font-size="12" dy=".8em" y="133.70000004768372" x="564.5">gossip可以动态的允许节点增加和减少，并保持新增加节点和其他节点数据一致。并且gossip的容错性可以让任何一个节点宕机都不会影响gossip运行</text><text id="kity_text_9909" text-rendering="inherit" font-size="12" dy=".8em" y="151.70000004768372" x="564.5">当有新的信息需要传递时，消息可以快速的发送到所有的节点，让所有的节点都拥有最新的数据，gossip可以在O(logN) 轮就可以将信息传播到所有的节点。</text><text id="kity_text_9910" text-rendering="inherit" font-size="12" dy=".8em" y="169.70000004768372" x="564.5">4.gossip缺点</text><text id="kity_text_9911" text-rendering="inherit" font-size="12" dy=".8em" y="187.70000004768372" x="564.5">消息可能最终会经过很多轮才能到达目标节点，而这可能会带来较大的延迟。</text></g></g><g id="minder_node1015" display="none"><g id="node_expander1011" display="none" style="cursor: pointer;"><path id="kity_path_23555" fill="white" stroke="gray" d="M548.5,113.5A6,6,0,1,1,536.5,113.5A6,6,0,1,1,548.5,113.5"></path><path id="kity_path_23556" fill="none" stroke="gray"></path></g><path id="node_outline1012" fill="none" stroke="none" d="M548.5,104.5h217a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-217a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1012" fill="black"><text id="kity_text_9924" text-rendering="inherit" font-size="12" dy=".8em" y="105.70000004768372" x="548.5">我怎么保证我的数据请求是我要的数据？</text></g></g><g id="minder_node1016" display="none"><g id="node_expander1010" display="none" style="cursor: pointer;"><path id="kity_path_23552" fill="white" stroke="gray" d="M564.5,113.5A6,6,0,1,1,552.5,113.5A6,6,0,1,1,564.5,113.5"></path><path id="kity_path_23553" fill="none" stroke="gray"></path></g><path id="node_outline1011" fill="none" stroke="none" d="M564.5,41.5h994a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-994a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text1011" fill="black"><text id="kity_text_9915" text-rendering="inherit" font-size="12" dy=".8em" y="42.700000047683716" x="564.5">1.</text><text id="kity_text_9916" text-rendering="inherit" font-size="12" dy=".8em" y="60.700000047683716" x="564.5">redis底层维护了一个映射数组和一个集群节点数组，映射数组只表示自己是否存储对应的槽数据，比如说 节点1存0-5000槽，只有 0，1，2有数据，那么 0 1 2就表示1，说明这里有数据，</text><text id="kity_text_9917" text-rendering="inherit" font-size="12" dy=".8em" y="78.70000004768372" x="564.5">查询就比较快。集群节点数组维护了其他节点数据，方便快速定位查询对应节点数据，</text><text id="kity_text_9918" text-rendering="inherit" font-size="12" dy=".8em" y="96.70000004768372" x="564.5">2.</text><text id="kity_text_9919" text-rendering="inherit" font-size="12" dy=".8em" y="114.70000004768372" x="564.5">当新结点加入或者节点收缩，通过PING命令通信，及时的更新自己clusterNode数组中的元数据信息，这样有请求过来也就能及时的找到对应的节点。</text><text id="kity_text_9920" text-rendering="inherit" font-size="12" dy=".8em" y="132.70000004768372" x="564.5">若是请求过来发现，数据发生了迁移，比如新节点加入，会使旧的缓存节点数据迁移到新结点。</text><text id="kity_text_9921" text-rendering="inherit" font-size="12" dy=".8em" y="150.70000004768372" x="564.5">如果已经发生了数据迁移，集群节点数组会发送MOVES重定向请求，表示节点数据迁移了，你重新请求才能获取数据</text><text id="kity_text_9922" text-rendering="inherit" font-size="12" dy=".8em" y="168.70000004768372" x="564.5">如何正在发生数据迁移，老节点给客户端发送ASK重定向，告诉客户端迁移的地址信息，就可以获取数据了</text></g></g><g id="minder_node1017" display="none"><g id="node_expander1020" display="none" style="cursor: pointer;"><path id="kity_path_23582" fill="white" stroke="gray" d="M532.5,121.5A6,6,0,1,1,520.5,121.5A6,6,0,1,1,532.5,121.5"></path><path id="kity_path_23583" fill="none" stroke="gray"></path></g><path id="node_outline1021" fill="none" stroke="none" d="M532.5,112.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1021" fill="black"><text id="kity_text_9953" text-rendering="inherit" font-size="12" dy=".8em" y="113.70000004768372" x="532.5">进阶</text></g></g><g id="minder_node1018" display="none"><g id="node_expander1014" display="none" style="cursor: pointer;"><path id="kity_path_23564" fill="white" stroke="gray" d="M548.5,105.5A6,6,0,1,1,536.5,105.5A6,6,0,1,1,548.5,105.5"></path><path id="kity_path_23565" fill="none" stroke="gray"></path></g><path id="node_outline1015" fill="none" stroke="none" d="M548.5,96.5h122a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-122a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1015" fill="black"><text id="kity_text_9930" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="548.5">集群模式的扩容和缩容</text></g></g><g id="minder_node1019" display="none"><g id="node_expander1013" display="none" style="cursor: pointer;"><path id="kity_path_23561" fill="white" stroke="gray" d="M564.5,105.5A6,6,0,1,1,552.5,105.5A6,6,0,1,1,564.5,105.5"></path><path id="kity_path_23562" fill="none" stroke="gray"></path></g><path id="node_outline1014" fill="none" stroke="none" d="M564.5,96.5h340a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-340a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1014" fill="black"><text id="kity_text_9928" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="564.5">https://blog.csdn.net/qyp199312/article/details/106030107</text></g></g><g id="minder_node1020" display="none"><g id="node_expander1016" display="none" style="cursor: pointer;"><path id="kity_path_23570" fill="white" stroke="gray" d="M548.5,113.5A6,6,0,1,1,536.5,113.5A6,6,0,1,1,548.5,113.5"></path><path id="kity_path_23571" fill="none" stroke="gray"></path></g><path id="node_outline1017" fill="none" stroke="none" d="M548.5,104.5h134a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-134a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1017" fill="black"><text id="kity_text_9939" text-rendering="inherit" font-size="12" dy=".8em" y="105.70000004768372" x="548.5">cluster如何实现的高可用</text></g></g><g id="minder_node1021" display="none"><g id="node_expander1015" display="none" style="cursor: pointer;"><path id="kity_path_23567" fill="white" stroke="gray" d="M564.5,113.5A6,6,0,1,1,552.5,113.5A6,6,0,1,1,564.5,113.5"></path><path id="kity_path_23568" fill="none" stroke="gray"></path></g><path id="node_outline1016" fill="none" stroke="none" d="M564.5,59.5h1132a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1132a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1016" fill="black"><text id="kity_text_9932" text-rendering="inherit" font-size="12" dy=".8em" y="60.700000047683716" x="564.5">1.扩容和缩容就是节点的上线和下线：</text><text id="kity_text_9933" text-rendering="inherit" font-size="12" dy=".8em" y="78.70000004768372" x="564.5">节点的收缩和扩容时，会重新计算每一个节点负责的槽范围，并根据虚拟槽算法，将对应的数据更新到对应的节点。</text><text id="kity_text_9934" text-rendering="inherit" font-size="12" dy=".8em" y="96.70000004768372" x="564.5">对于新加入的加点，通过重新分片 来获取对应对应的slot，并且把已经分配的数据重新迁移的对应的节点</text><text id="kity_text_9935" text-rendering="inherit" font-size="12" dy=".8em" y="114.70000004768372" x="564.5">2.高可用和故障转移：</text><text id="kity_text_9936" text-rendering="inherit" font-size="12" dy=".8em" y="132.70000004768372" x="564.5">如果某一个节点被认为客观下线，其他master就会从已挂的master中的slave选一个master，如果超半数，这个slave就是Master了，如果没选出来，随机时间再选</text><text id="kity_text_9937" text-rendering="inherit" font-size="12" dy=".8em" y="150.70000004768372" x="564.5">当slave成功成为master，新的master会执行slaveof no one来让自己停止复制A节点，使自己成为master。然后将A节点所负责处理的slot，全部转移给自己，然后就会向集群发PONG消息来广播自己的最新状态。</text></g></g><g id="minder_node1022" display="none"><g id="node_expander1019" display="none" style="cursor: pointer;"><path id="kity_path_23579" fill="white" stroke="gray" d="M548.5,121.5A6,6,0,1,1,536.5,121.5A6,6,0,1,1,548.5,121.5"></path><path id="kity_path_23580" fill="none" stroke="gray"></path></g><path id="node_outline1020" fill="none" stroke="none" d="M548.5,112.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1020" fill="black"><text id="kity_text_9951" text-rendering="inherit" font-size="12" dy=".8em" y="113.70000004768372" x="548.5">集群的限制条件？解决？</text></g></g><g id="minder_node1023" display="none"><g id="node_expander1018" display="none" style="cursor: pointer;"><path id="kity_path_23576" fill="white" stroke="gray" d="M564.5,121.5A6,6,0,1,1,552.5,121.5A6,6,0,1,1,564.5,121.5"></path><path id="kity_path_23577" fill="none" stroke="gray"></path></g><path id="node_outline1019" fill="none" stroke="none" d="M564.5,58.5h1303a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-1303a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text1019" fill="black"><text id="kity_text_9943" text-rendering="inherit" font-size="12" dy=".8em" y="59.700000047683716" x="564.5">1.</text><text id="kity_text_9944" text-rendering="inherit" font-size="12" dy=".8em" y="77.70000004768372" x="564.5">key的配置操作&#xa0; 只支持对具有相同 slot 值的 key 执行 批量操作。</text><text id="kity_text_9945" text-rendering="inherit" font-size="12" dy=".8em" y="95.70000004768372" x="564.5">一种思路是在客户端记录槽与key的信息，每次针对特定槽执行mget/mset；另外一种思路是使用Hash Tag(当一个key包含 {} 的时候，不对整个key做hash，而仅对 {} 包括的字符串做hash,让不同的key拥有相同的hash值，从而分配在同一个槽里)</text><text id="kity_text_9946" text-rendering="inherit" font-size="12" dy=".8em" y="113.70000004768372" x="564.5">使用hash tag的问题：(1)调整不同节点中槽的数量，使数据分布尽量均匀；(2)避免对热点数据使用Hash Tag，导致请求分布不均。</text><text id="kity_text_9947" text-rendering="inherit" font-size="12" dy=".8em" y="131.70000004768372" x="564.5">只支持 多 key 在 同一节点上 的 事务操作。使用hash tag</text><text id="kity_text_9948" text-rendering="inherit" font-size="12" dy=".8em" y="149.70000004768372" x="564.5">单机 下的 Redis 可以支持 16 个数据库（db0 ~ db15），集群模式 下只能使用 一个 数据库空间，即 db0。</text><text id="kity_text_9949" text-rendering="inherit" font-size="12" dy=".8em" y="167.70000004768372" x="564.5">从节点 只能复制 主节点</text></g></g><g id="minder_node1024" display="none"><g id="node_expander1017" display="none" style="cursor: pointer;"><path id="kity_path_23573" fill="white" stroke="gray" d="M580.5,121.5A6,6,0,1,1,568.5,121.5A6,6,0,1,1,580.5,121.5"></path><path id="kity_path_23574" fill="none" stroke="gray"></path></g><path id="node_outline1018" fill="none" stroke="none" d="M580.5,107.5h79a5,5,0,0,1,5,5v18a5,5,0,0,1,-5,5h-79a5,5,0,0,1,-5,-5v-18a5,5,0,0,1,5,-5z"></path><g id="node_text1018" fill="black"><text id="kity_text_9941" text-rendering="inherit" font-size="12" dy=".8em" y="113.70000004768372" x="580.5">分支主题</text></g><a id="kity_a_16928" xlink:href="https://www.cnblogs.com/kismetv/p/9853040.html" target="_blank" xlink:title="https://www.cnblogs.com/kismetv/p/9853040.html" style="cursor: pointer;"><path id="kity_path_16930" fill="rgba(255, 255, 255, 0)" stroke="none" d="M639.5,110.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16929" fill="#666" stroke="none" d="M654.114,126.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V120.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C649.766,117.571,651.168,116.5,652.836,116.5h1.278c2.116,0,3.834,1.716,3.834,3.834V122.89C657.948,125.008,656.23,126.724,654.114,126.724zM642.612,121.612c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S652.265,122.89,651.558,122.89H643.89C643.185,122.89,642.612,122.319,642.612,121.612zM640.056,120.334V122.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H641.334C639.216,126.724,637.5,125.008,637.5,122.89V120.334C637.5,118.216,639.216,116.5,641.334,116.5h1.278c1.667,0,3.071,1.071,3.599,2.556H641.334C640.629,119.056,640.056,119.627,640.056,120.334z"></path></a></g><g id="minder_node1025" display="none"><g id="node_expander1035" display="none" style="cursor: pointer;"><path id="kity_path_23627" fill="white" stroke="gray" d="M532.5,129.5A6,6,0,1,1,520.5,129.5A6,6,0,1,1,532.5,129.5"></path><path id="kity_path_23628" fill="none" stroke="gray"></path></g><path id="node_outline1036" fill="none" stroke="none" d="M532.5,120.5h86a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-86a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1036" fill="black"><text id="kity_text_10004" text-rendering="inherit" font-size="12" dy=".8em" y="121.70000004768372" x="532.5">场景和项目问题</text></g></g><g id="minder_node1026" display="none"><g id="node_expander1022" display="none" style="cursor: pointer;"><path id="kity_path_23588" fill="white" stroke="gray" d="M548.5,81.5A6,6,0,1,1,536.5,81.5A6,6,0,1,1,548.5,81.5"></path><path id="kity_path_23589" fill="none" stroke="gray"></path></g><path id="node_outline1023" fill="none" stroke="none" d="M548.5,72.5h278a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-278a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1023" fill="black"><text id="kity_text_9962" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="548.5">集群节点之间的数据倾斜和访问倾斜的问题？怎么办</text></g></g><g id="minder_node1027" display="none"><g id="node_expander1021" display="none" style="cursor: pointer;"><path id="kity_path_23585" fill="white" stroke="gray" d="M564.5,81.5A6,6,0,1,1,552.5,81.5A6,6,0,1,1,564.5,81.5"></path><path id="kity_path_23586" fill="none" stroke="gray"></path></g><path id="node_outline1022" fill="none" stroke="none" d="M564.5,27.5h451a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-451a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1022" fill="black"><text id="kity_text_9955" text-rendering="inherit" font-size="12" dy=".8em" y="28.700000047683716" x="564.5">1.数据倾斜导致集群中部分节点数据多，压力大。</text><text id="kity_text_9956" text-rendering="inherit" font-size="12" dy=".8em" y="46.700000047683716" x="564.5">2.业务层面提前预测，哪些key是热点，在设计的过程中规避。 </text><text id="kity_text_9957" text-rendering="inherit" font-size="12" dy=".8em" y="64.70000004768372" x="564.5">3.后期是slot迁移，尽量将压力分摊（slot调整有自动rebalance、reshard和手动）。</text><text id="kity_text_9958" text-rendering="inherit" font-size="12" dy=".8em" y="82.70000004768372" x="564.5">4.热点key 本地缓存+key打散</text><text id="kity_text_9959" text-rendering="inherit" font-size="12" dy=".8em" y="100.70000004768372" x="564.5">5.大key&#xa0;&#xa0;对 big key 进行拆分</text><text id="kity_text_9960" text-rendering="inherit" font-size="12" dy=".8em" y="118.70000004768372" x="564.5">6.代理层进行 监控key的请求，进行收集上报</text></g></g><g id="minder_node1028" display="none"><g id="node_expander1024" display="none" style="cursor: pointer;"><path id="kity_path_23594" fill="white" stroke="gray" d="M548.5,89.5A6,6,0,1,1,536.5,89.5A6,6,0,1,1,548.5,89.5"></path><path id="kity_path_23595" fill="none" stroke="gray"></path></g><path id="node_outline1025" fill="none" stroke="none" d="M548.5,80.5h120a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-120a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1025" fill="black"><text id="kity_text_9969" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="548.5">为什么出现数据倾斜？</text></g></g><g id="minder_node1029" display="none"><g id="node_expander1023" display="none" style="cursor: pointer;"><path id="kity_path_23591" fill="white" stroke="gray" d="M564.5,89.5A6,6,0,1,1,552.5,89.5A6,6,0,1,1,564.5,89.5"></path><path id="kity_path_23592" fill="none" stroke="gray"></path></g><path id="node_outline1024" fill="none" stroke="none" d="M564.5,53.5h987a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-987a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1024" fill="black"><text id="kity_text_9964" text-rendering="inherit" font-size="12" dy=".8em" y="54.700000047683716" x="564.5">原因：</text><text id="kity_text_9965" text-rendering="inherit" font-size="12" dy=".8em" y="72.70000004768372" x="564.5">1.数据槽(slot)数分配不均匀，导致容量和请求qps倾斜;</text><text id="kity_text_9966" text-rendering="inherit" font-size="12" dy=".8em" y="90.70000004768372" x="564.5">2.热点 key，一段时间内，访问量远远高于其他的 redis key， 导致大部分的访问流量在经过 proxy 分片之后，都集中访问到某一个 redis 节点实例上</text><text id="kity_text_9967" text-rendering="inherit" font-size="12" dy=".8em" y="108.70000004768372" x="564.5">3.big key&#xa0;，数据量大的 key由于其数据大小远大于其他key，导致经过分片之后，某个具体存储这个 big key 的实例内存使用量远大于其他实例，造成，内存不足，拖累整个集群的使用。</text></g></g><g id="minder_node1030" display="none"><g id="node_expander1026" display="none" style="cursor: pointer;"><path id="kity_path_23600" fill="white" stroke="gray" d="M548.5,97.5A6,6,0,1,1,536.5,97.5A6,6,0,1,1,548.5,97.5"></path><path id="kity_path_23601" fill="none" stroke="gray"></path></g><path id="node_outline1027" fill="none" stroke="none" d="M548.5,88.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1027" fill="black"><text id="kity_text_9973" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="548.5">数据倾斜有什么影响？</text></g></g><g id="minder_node1031" display="none"><g id="node_expander1025" display="none" style="cursor: pointer;"><path id="kity_path_23597" fill="white" stroke="gray" d="M564.5,97.5A6,6,0,1,1,552.5,97.5A6,6,0,1,1,564.5,97.5"></path><path id="kity_path_23598" fill="none" stroke="gray"></path></g><path id="node_outline1026" fill="none" stroke="none" d="M564.5,88.5h658a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-658a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1026" fill="black"><text id="kity_text_9971" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="564.5">影响：1.一旦出现访问量倾斜或者数据量倾斜，则可能会导致某个 redis 实例达到性能瓶颈，从而使整个集群达到性能瓶颈。</text></g></g><g id="minder_node1032" display="none"><g id="node_expander1028" display="none" style="cursor: pointer;"><path id="kity_path_23606" fill="white" stroke="gray" d="M548.5,105.5A6,6,0,1,1,536.5,105.5A6,6,0,1,1,548.5,105.5"></path><path id="kity_path_23607" fill="none" stroke="gray"></path></g><path id="node_outline1029" fill="none" stroke="none" d="M548.5,96.5h173a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-173a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1029" fill="black"><text id="kity_text_9977" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="548.5">redis集群会有写丢失吗，为什么</text></g></g><g id="minder_node1033" display="none"><g id="node_expander1027" display="none" style="cursor: pointer;"><path id="kity_path_23603" fill="white" stroke="gray" d="M564.5,105.5A6,6,0,1,1,552.5,105.5A6,6,0,1,1,564.5,105.5"></path><path id="kity_path_23604" fill="none" stroke="gray"></path></g><path id="node_outline1028" fill="none" stroke="none" d="M564.5,96.5h147a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-147a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1028" fill="black"><text id="kity_text_9975" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="564.5">1.redis没保证数据强一致性</text></g></g><g id="minder_node1034" display="none"><g id="node_expander1029" display="none" style="cursor: pointer;"><path id="kity_path_23609" fill="white" stroke="gray" d="M548.5,113.5A6,6,0,1,1,536.5,113.5A6,6,0,1,1,548.5,113.5"></path><path id="kity_path_23610" fill="none" stroke="gray"></path></g><path id="node_outline1030" fill="none" stroke="none" d="M548.5,104.5h280a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-280a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1030" fill="black"><text id="kity_text_9979" text-rendering="inherit" font-size="12" dy=".8em" y="105.70000004768372" x="548.5">redis主从集群切换丢失数据？哪些因素？怎么处理？</text></g></g><g id="minder_node1035" display="none"><g id="node_expander1031" display="none" style="cursor: pointer;"><path id="kity_path_23615" fill="white" stroke="gray" d="M548.5,121.5A6,6,0,1,1,536.5,121.5A6,6,0,1,1,548.5,121.5"></path><path id="kity_path_23616" fill="none" stroke="gray"></path></g><path id="node_outline1032" fill="none" stroke="none" d="M548.5,112.5h172a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-172a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1032" fill="black"><text id="kity_text_9983" text-rendering="inherit" font-size="12" dy=".8em" y="113.70000004768372" x="548.5">比如说什么情况redis集群不可用</text></g></g><g id="minder_node1036" display="none"><g id="node_expander1030" display="none" style="cursor: pointer;"><path id="kity_path_23612" fill="white" stroke="gray" d="M564.5,121.5A6,6,0,1,1,552.5,121.5A6,6,0,1,1,564.5,121.5"></path><path id="kity_path_23613" fill="none" stroke="gray"></path></g><path id="node_outline1031" fill="none" stroke="none" d="M564.5,112.5h921a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-921a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1031" fill="black"><text id="kity_text_9981" text-rendering="inherit" font-size="12" dy=".8em" y="113.70000004768372" x="564.5">1.如果集群中的master没有slave节点，则master挂掉后整个集群就会进入fail状态，因为集群的slot映射不完整。如果集群超过半数以上的master挂掉，集群都会进入fail状态</text></g></g><g id="minder_node1037" display="none"><g id="node_expander1034" display="none" style="cursor: pointer;"><path id="kity_path_23624" fill="white" stroke="gray" d="M548.5,129.5A6,6,0,1,1,536.5,129.5A6,6,0,1,1,548.5,129.5"></path><path id="kity_path_23625" fill="none" stroke="gray"></path></g><path id="node_outline1035" fill="none" stroke="none" d="M548.5,120.5h161a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-161a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1035" fill="black"><text id="kity_text_10002" text-rendering="inherit" font-size="12" dy=".8em" y="121.70000004768372" x="548.5">说说redis集群的有哪些方案？</text></g></g><g id="minder_node1038" display="none"><g id="node_expander1033" display="none" style="cursor: pointer;"><path id="kity_path_23621" fill="white" stroke="gray" d="M564.5,129.5A6,6,0,1,1,552.5,129.5A6,6,0,1,1,564.5,129.5"></path><path id="kity_path_23622" fill="none" stroke="gray"></path></g><path id="node_outline1034" fill="none" stroke="none" d="M564.5,3.5h1193a5,5,0,0,1,5,5v242a5,5,0,0,1,-5,5h-1193a5,5,0,0,1,-5,-5v-242a5,5,0,0,1,5,-5z"></path><g id="node_text1034" fill="black"><text id="kity_text_9987" text-rendering="inherit" font-size="12" dy=".8em" y="4.700000047683716" x="564.5">1.客户端分区</text><text id="kity_text_9988" text-rendering="inherit" font-size="12" dy=".8em" y="22.700000047683716" x="564.5">客户端 决定数据会被 存储 到哪个节点和从哪个节点 读取。</text><text id="kity_text_9989" text-rendering="inherit" font-size="12" dy=".8em" y="40.700000047683716" x="564.5">其主要思想是采用 哈希算法 将 Redis 数据的 key 进行散列，通过 hash 函数，特定的 key会 映射 到特定的 Redis 节点上。</text><text id="kity_text_9990" text-rendering="inherit" font-size="12" dy=".8em" y="58.700000047683716" x="564.5">优点：不使用 第三方中间件，分区逻辑 可控，配置 简单，节点之间无关联，容易 线性扩展，灵活性强。</text><text id="kity_text_9991" text-rendering="inherit" font-size="12" dy=".8em" y="76.70000004768372" x="564.5">缺点：客户端 无法 动态增删 服务节点，客户端需要自行维护 分发逻辑，客户端之间 无连接共享，会造成 连接浪费。</text><text id="kity_text_9992" text-rendering="inherit" font-size="12" dy=".8em" y="94.70000004768372" x="564.5">2.代理分区</text><text id="kity_text_9993" text-rendering="inherit" font-size="12" dy=".8em" y="112.70000004768372" x="564.5">客户端 发送请求到一个 代理组件，代理 解析 客户端 的数据，并将请求转发至正确的节点，最后将结果回复给客户端。</text><text id="kity_text_9994" text-rendering="inherit" font-size="12" dy=".8em" y="130.70000004768372" x="564.5">优点：代理的 转发 和 存储 分离。</text><text id="kity_text_9995" text-rendering="inherit" font-size="12" dy=".8em" y="148.70000004768372" x="564.5">缺点：多了一层 代理层，加重了 架构部署复杂度 和 性能损耗。</text><text id="kity_text_9996" text-rendering="inherit" font-size="12" dy=".8em" y="166.70000004768372" x="564.5">代理分区 主流实现的有方案有 Twemproxy 和 Codis（实现了上层 Proxy 和底层 Redis 的 高可用，数据分片 和 自动平衡，提供 命令行接口 和 RESTful API，提供 监控 和 管理 界面，可以动态 添加 和 删除 Redis 节点。）。</text><text id="kity_text_9997" text-rendering="inherit" font-size="12" dy=".8em" y="184.70000004768372" x="564.5">3.查询路由</text><text id="kity_text_9998" text-rendering="inherit" font-size="12" dy=".8em" y="202.70000004768372" x="564.5">客户端随机地 请求任意一个 Redis 实例，然后在 客户端 的帮助下直接 重定向（ redirected）到正确的 Redis 节点。由 Redis 将请求 转发 给 正确 的 Redis 节点。</text><text id="kity_text_9999" text-rendering="inherit" font-size="12" dy=".8em" y="220.70000004768372" x="564.5">优点：优点无中心节点，数据按照 slot 存储分布在多个 Redis 实例上，可以平滑的进行节点 扩容/缩容，支持 高可用 和 自动故障转移，运维成本低</text><text id="kity_text_10000" text-rendering="inherit" font-size="12" dy=".8em" y="238.70000004768372" x="564.5">缺点：Failover 节点的 检测过慢，无法根据统计区分 冷热数据。</text></g></g><g id="minder_node1039" display="none"><g id="node_expander1032" display="none" style="cursor: pointer;"><path id="kity_path_23618" fill="white" stroke="gray" d="M580.5,129.5A6,6,0,1,1,568.5,129.5A6,6,0,1,1,580.5,129.5"></path><path id="kity_path_23619" fill="none" stroke="gray"></path></g><path id="node_outline1033" fill="none" stroke="none" d="M580.5,115.5h79a5,5,0,0,1,5,5v18a5,5,0,0,1,-5,5h-79a5,5,0,0,1,-5,-5v-18a5,5,0,0,1,5,-5z"></path><g id="node_text1033" fill="black"><text id="kity_text_9985" text-rendering="inherit" font-size="12" dy=".8em" y="121.70000004768372" x="580.5">分支主题</text></g><a id="kity_a_16931" xlink:href="https://dunwu.github.io/db-tutorial/nosql/redis/redis-cluster.html#%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE" target="_blank" xlink:title="https://dunwu.github.io/db-tutorial/nosql/redis/redis-cluster.html#%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE" style="cursor: pointer;"><path id="kity_path_16933" fill="rgba(255, 255, 255, 0)" stroke="none" d="M639.5,118.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16932" fill="#666" stroke="none" d="M654.114,134.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V128.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C649.766,125.571,651.168,124.5,652.836,124.5h1.278c2.116,0,3.834,1.716,3.834,3.834V130.89C657.948,133.008,656.23,134.724,654.114,134.724zM642.612,129.612c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S652.265,130.89,651.558,130.89H643.89C643.185,130.89,642.612,130.319,642.612,129.612zM640.056,128.334V130.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H641.334C639.216,134.724,637.5,133.008,637.5,130.89V128.334C637.5,126.216,639.216,124.5,641.334,124.5h1.278c1.667,0,3.071,1.071,3.599,2.556H641.334C640.629,127.056,640.056,127.627,640.056,128.334z"></path></a></g><g id="minder_node1040" display="none"><g id="node_expander1108" display="none" style="cursor: pointer;"><path id="kity_path_23846" fill="white" stroke="gray" d="M500.5,137.5A6,6,0,1,1,488.5,137.5A6,6,0,1,1,500.5,137.5"></path><path id="kity_path_23847" fill="none" stroke="gray"></path></g><path id="node_outline1109" fill="none" stroke="none" d="M500.5,128.5h52a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-52a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1109" fill="black"><text id="kity_text_10225" text-rendering="inherit" font-size="12" dy=".8em" y="129.70000004768372" x="500.5">redis应用</text></g></g><g id="minder_node1041" display="none"><g id="node_expander1076" display="none" style="cursor: pointer;"><path id="kity_path_23750" fill="white" stroke="gray" d="M516.5,105.5A6,6,0,1,1,504.5,105.5A6,6,0,1,1,516.5,105.5"></path><path id="kity_path_23751" fill="none" stroke="gray"></path></g><path id="node_outline1077" fill="none" stroke="none" d="M516.5,96.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1077" fill="black"><text id="kity_text_10124" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="516.5">分布式锁</text></g></g><g id="minder_node1042" display="none"><g id="node_expander1039" display="none" style="cursor: pointer;"><path id="kity_path_23639" fill="white" stroke="gray" d="M532.5,-38.5A6,6,0,1,1,520.5,-38.5A6,6,0,1,1,532.5,-38.5"></path><path id="kity_path_23640" fill="none" stroke="gray"></path></g><path id="node_outline1040" fill="none" stroke="none" d="M532.5,-47.5h268a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-268a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1040" fill="black"><text id="kity_text_10023" text-rendering="inherit" font-size="12" dy=".8em" y="-46.299999952316284" x="532.5">redis怎么实现分布式锁，描述下？用的什么命令？</text></g></g><g id="minder_node1043" display="none"><g id="node_expander1038" display="none" style="cursor: pointer;"><path id="kity_path_23636" fill="white" stroke="gray" d="M548.5,-38.5A6,6,0,1,1,536.5,-38.5A6,6,0,1,1,548.5,-38.5"></path><path id="kity_path_23637" fill="none" stroke="gray"></path></g><path id="node_outline1039" fill="none" stroke="none" d="M548.5,-146.5h1187a5,5,0,0,1,5,5v206a5,5,0,0,1,-5,5h-1187a5,5,0,0,1,-5,-5v-206a5,5,0,0,1,5,-5z"></path><g id="node_text1039" fill="black"><text id="kity_text_10010" text-rendering="inherit" font-size="12" dy=".8em" y="-145.29999995231628" x="548.5">1.</text><text id="kity_text_10011" text-rendering="inherit" font-size="12" dy=".8em" y="-127.29999995231628" x="548.5">setnx命令说的是 当不存在才能set成功，都是没有超时时间，我们需要超时时间来解决死锁问题，就用的setnxex这个扩展命令，这个扩展命令相当于 setnx+expire，</text><text id="kity_text_10012" text-rendering="inherit" font-size="12" dy=".8em" y="-109.29999995231628" x="548.5">最后使用setnxex来lua脚本来实现，保证加锁解锁的原子性，然后为了防止误删，加个随机值，一般是uuid 来 保证加解锁是同一个人，然后带上超时时间，防止还没有解锁就挂了死锁这种情况，</text><text id="kity_text_10013" text-rendering="inherit" font-size="12" dy=".8em" y="-91.29999995231628" x="548.5">所以整体就是 setnxex()带上 锁参数 uuid 超时时间，解锁 带着uuid Lua脚本去解，然后没有获取到锁可以采用一定的自旋，最后获取到锁再去执行我们的业务逻辑</text><text id="kity_text_10014" text-rendering="inherit" font-size="12" dy=".8em" y="-73.29999995231628" x="548.5">最重要的就是保证加锁+过期时间是 和解锁(判断+删除) 是原子性。因为如果 加锁和timesout不是原子性 如果 加锁的时侯 挂了，还是会死锁，所以 加锁+timeout也要是原子性的，</text><text id="kity_text_10015" text-rendering="inherit" font-size="12" dy=".8em" y="-55.299999952316284" x="548.5">而解锁也要保证原子性 使用lua脚本让我们的判断加解锁是原子性， 是因为 ，如果解锁不保证原子性 那么 解锁时 判断了是自己的，而锁更好过期了，别人刚好先设置了新的值，我们再去删，删的就是别人的，</text><text id="kity_text_10016" text-rendering="inherit" font-size="12" dy=".8em" y="-37.299999952316284" x="548.5">因为判断了是自己的 就要去执行删除操作的。</text><text id="kity_text_10017" text-rendering="inherit" font-size="12" dy=".8em" y="-19.299999952316284" x="548.5">2.</text><text id="kity_text_10018" text-rendering="inherit" font-size="12" dy=".8em" y="-1.2999999523162842" x="548.5">上面执行完以后，我们设置了timeout，但是timeout设置的不一定100合理，因为这个timeout是需要去测试的，但是可能出现如果锁释放了，而业务没有执行完，这种情况就可能发生了，而又不能直接直接timeout</text><text id="kity_text_10019" text-rendering="inherit" font-size="12" dy=".8em" y="16.700000047683716" x="548.5">然后我们一般用redission来实现，而且redission和juc差不多，和juc下面的锁是一个东西，加锁解锁都是封装了lua脚本，不需要像之前那么麻烦，加很多重复的东西，使用他的api就可以了，</text><text id="kity_text_10020" text-rendering="inherit" font-size="12" dy=".8em" y="34.700000047683716" x="548.5">主要思路就是开个定时守护线程，去看锁还存在不存在，如果存在就给它延迟一点点时间，然后这个就相当于看门狗，看门狗可以解决这个问题，实现了锁的自动续期,默认是30s，没有指定时间就是使用的看门狗的默认时间，</text><text id="kity_text_10021" text-rendering="inherit" font-size="12" dy=".8em" y="52.700000047683716" x="548.5">续期多久，续期 看门狗时间/3&#xa0; 相当于 默认的 30/3 = 10 默认续10。如果节点挂了，锁都不存在了，那么锁也就释放了</text></g></g><g id="minder_node1044" display="none"><g id="node_expander1041" display="none" style="cursor: pointer;"><path id="kity_path_23645" fill="white" stroke="gray" d="M532.5,-30.5A6,6,0,1,1,520.5,-30.5A6,6,0,1,1,532.5,-30.5"></path><path id="kity_path_23646" fill="none" stroke="gray"></path></g><path id="node_outline1042" fill="none" stroke="none" d="M532.5,-39.5h97a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-97a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1042" fill="black"><text id="kity_text_10027" text-rendering="inherit" font-size="12" dy=".8em" y="-38.299999952316284" x="532.5">分布式锁的要求？</text></g></g><g id="minder_node1045" display="none"><g id="node_expander1040" display="none" style="cursor: pointer;"><path id="kity_path_23642" fill="white" stroke="gray" d="M548.5,-30.5A6,6,0,1,1,536.5,-30.5A6,6,0,1,1,548.5,-30.5"></path><path id="kity_path_23643" fill="none" stroke="gray"></path></g><path id="node_outline1041" fill="none" stroke="none" d="M548.5,-39.5h286a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-286a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1041" fill="black"><text id="kity_text_10025" text-rendering="inherit" font-size="12" dy=".8em" y="-38.299999952316284" x="548.5">1.锁安全，锁重入，死锁，锁超时，加解锁，锁续期，</text></g></g><g id="minder_node1046" display="none"><g id="node_expander1044" display="none" style="cursor: pointer;"><path id="kity_path_23654" fill="white" stroke="gray" d="M532.5,-22.5A6,6,0,1,1,520.5,-22.5A6,6,0,1,1,532.5,-22.5"></path><path id="kity_path_23655" fill="none" stroke="gray"></path></g><path id="node_outline1045" fill="none" stroke="none" d="M532.5,-31.5h233a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-233a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1045" fill="black"><text id="kity_text_10040" text-rendering="inherit" font-size="12" dy=".8em" y="-30.299999952316284" x="532.5">redis实现分布式锁，redisson具体实现说说</text></g></g><g id="minder_node1047" display="none"><g id="node_expander1043" display="none" style="cursor: pointer;"><path id="kity_path_23651" fill="white" stroke="gray" d="M548.5,-22.5A6,6,0,1,1,536.5,-22.5A6,6,0,1,1,548.5,-22.5"></path><path id="kity_path_23652" fill="none" stroke="gray"></path></g><path id="node_outline1044" fill="none" stroke="none" d="M548.5,-94.5h956a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-956a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text1044" fill="black"><text id="kity_text_10031" text-rendering="inherit" font-size="12" dy=".8em" y="-93.29999995231628" x="548.5">1.加解锁</text><text id="kity_text_10032" text-rendering="inherit" font-size="12" dy=".8em" y="-75.29999995231628" x="548.5">redission可以像juc中的lock 一样操作 加锁解锁，一般我们可以通过tryLock(),尝试去获取锁，为了防止忘记释放锁，还可以指定时间去自动解锁，不需要去调用unLock()去释放锁，</text><text id="kity_text_10033" text-rendering="inherit" font-size="12" dy=".8em" y="-57.299999952316284" x="548.5">也可以尝试去加锁在指定时间以内，比如说50s没获取到锁，这这一段时间锁都被别人占用，最多等待50s，如果上锁以后照样可以指定时间自动解锁</text><text id="kity_text_10034" text-rendering="inherit" font-size="12" dy=".8em" y="-39.299999952316284" x="548.5">和lock下的api差不多，不是很麻烦，具体详细的api用什么具体去看，太多了没有每一个都记得，</text><text id="kity_text_10035" text-rendering="inherit" font-size="12" dy=".8em" y="-21.299999952316284" x="548.5">2.CDL闭锁- 和juc的countDownLatch 差不多</text><text id="kity_text_10036" text-rendering="inherit" font-size="12" dy=".8em" y="-3.299999952316284" x="548.5">通过获取CWL 和尝试设置count， 等待闭锁都完成 才执行，相当于珊栏</text><text id="kity_text_10037" text-rendering="inherit" font-size="12" dy=".8em" y="14.700000047683716" x="548.5">3.还要信号量</text><text id="kity_text_10038" text-rendering="inherit" font-size="12" dy=".8em" y="32.700000047683716" x="548.5">和多线程中的信号量一样，通过设置信号量 让锁去抢占，抢到了执行下面的业务逻辑，没有抢到的 可以等待，获取了也可以释放再还回去。</text></g></g><g id="minder_node1048" display="none"><g id="node_expander1042" display="none" style="cursor: pointer;"><path id="kity_path_23648" fill="white" stroke="gray" d="M564.5,-22.5A6,6,0,1,1,552.5,-22.5A6,6,0,1,1,564.5,-22.5"></path><path id="kity_path_23649" fill="none" stroke="gray"></path></g><path id="node_outline1043" fill="none" stroke="none" d="M503.5,-161.5h200a5,5,0,0,1,5,5v138a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-138a5,5,0,0,1,5,-5z"></path><g id="node_text1043" fill="black"><text id="kity_text_10029" text-rendering="inherit" font-size="12" dy=".8em" y="-30.299999952316284" x="564.5">redission流程</text></g><image id="kity_image_17053" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210324132114.png" x="503.5" y="-158.5" width="200" height="125"></image></g><g id="minder_node1049" display="none"><g id="node_expander1046" display="none" style="cursor: pointer;"><path id="kity_path_23660" fill="white" stroke="gray" d="M532.5,-14.5A6,6,0,1,1,520.5,-14.5A6,6,0,1,1,532.5,-14.5"></path><path id="kity_path_23661" fill="none" stroke="gray"></path></g><path id="node_outline1047" fill="none" stroke="none" d="M532.5,-23.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1047" fill="black"><text id="kity_text_10047" text-rendering="inherit" font-size="12" dy=".8em" y="-22.299999952316284" x="532.5">看门狗会有问题？怎么解决？</text></g></g><g id="minder_node1050" display="none"><g id="node_expander1045" display="none" style="cursor: pointer;"><path id="kity_path_23657" fill="white" stroke="gray" d="M548.5,-14.5A6,6,0,1,1,536.5,-14.5A6,6,0,1,1,548.5,-14.5"></path><path id="kity_path_23658" fill="none" stroke="gray"></path></g><path id="node_outline1046" fill="none" stroke="none" d="M548.5,-50.5h455a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-455a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1046" fill="black"><text id="kity_text_10042" text-rendering="inherit" font-size="12" dy=".8em" y="-49.299999952316284" x="548.5">1.</text><text id="kity_text_10043" text-rendering="inherit" font-size="12" dy=".8em" y="-31.299999952316284" x="548.5">redis 异步复制带来的数据不一致问题导致 多个客户端获取锁，锁的安全性受到影响。</text><text id="kity_text_10044" text-rendering="inherit" font-size="12" dy=".8em" y="-13.299999952316284" x="548.5">&#xa0;2.</text><text id="kity_text_10045" text-rendering="inherit" font-size="12" dy=".8em" y="4.700000047683716" x="548.5">redlock或者ZK实现分布式锁</text></g></g><g id="minder_node1051" display="none"><g id="node_expander1048" display="none" style="cursor: pointer;"><path id="kity_path_23666" fill="white" stroke="gray" d="M532.5,-6.5A6,6,0,1,1,520.5,-6.5A6,6,0,1,1,532.5,-6.5"></path><path id="kity_path_23667" fill="none" stroke="gray"></path></g><path id="node_outline1049" fill="none" stroke="none" d="M532.5,-15.5h99a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-99a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1049" fill="black"><text id="kity_text_10056" text-rendering="inherit" font-size="12" dy=".8em" y="-14.299999952316284" x="532.5">那用jedis怎么实现</text></g></g><g id="minder_node1052" display="none"><g id="node_expander1047" display="none" style="cursor: pointer;"><path id="kity_path_23663" fill="white" stroke="gray" d="M548.5,-6.5A6,6,0,1,1,536.5,-6.5A6,6,0,1,1,548.5,-6.5"></path><path id="kity_path_23664" fill="none" stroke="gray"></path></g><path id="node_outline1048" fill="none" stroke="none" d="M548.5,-60.5h423a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-423a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1048" fill="black"><text id="kity_text_10049" text-rendering="inherit" font-size="12" dy=".8em" y="-59.299999952316284" x="548.5">1.</text><text id="kity_text_10050" text-rendering="inherit" font-size="12" dy=".8em" y="-41.299999952316284" x="548.5">加锁，</text><text id="kity_text_10051" text-rendering="inherit" font-size="12" dy=".8em" y="-23.299999952316284" x="548.5">jedis.set(key_resource_id, uni_request_id, "NX", "EX", 100s) == 1</text><text id="kity_text_10052" text-rendering="inherit" font-size="12" dy=".8em" y="-5.299999952316284" x="548.5">解锁</text><text id="kity_text_10053" text-rendering="inherit" font-size="12" dy=".8em" y="12.700000047683716" x="548.5">if (uni_request_id.equals(jedis.get(key_resource_id)))&#xa0;</text><text id="kity_text_10054" text-rendering="inherit" font-size="12" dy=".8em" y="30.700000047683716" x="548.5">这样有问题，需要使用lua脚本 加解锁，思路是一样的， 和前面的setnxex +lua</text></g></g><g id="minder_node1053" display="none"><g id="node_expander1050" display="none" style="cursor: pointer;"><path id="kity_path_23672" fill="white" stroke="gray" d="M532.5,1.5A6,6,0,1,1,520.5,1.5A6,6,0,1,1,532.5,1.5"></path><path id="kity_path_23673" fill="none" stroke="gray"></path></g><path id="node_outline1051" fill="none" stroke="none" d="M532.5,-7.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1051" fill="black"><text id="kity_text_10061" text-rendering="inherit" font-size="12" dy=".8em" y="-6.299999952316284" x="532.5">缓存分布式锁会带来哪些问题</text></g></g><g id="minder_node1054" display="none"><g id="node_expander1049" display="none" style="cursor: pointer;"><path id="kity_path_23669" fill="white" stroke="gray" d="M548.5,1.5A6,6,0,1,1,536.5,1.5A6,6,0,1,1,548.5,1.5"></path><path id="kity_path_23670" fill="none" stroke="gray"></path></g><path id="node_outline1050" fill="none" stroke="none" d="M548.5,-16.5h289a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-289a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1050" fill="black"><text id="kity_text_10058" text-rendering="inherit" font-size="12" dy=".8em" y="-15.299999952316284" x="548.5">1.</text><text id="kity_text_10059" text-rendering="inherit" font-size="12" dy=".8em" y="2.700000047683716" x="548.5">通过超时时间来控制锁的失效时间并不是十分的靠谱。</text></g></g><g id="minder_node1055" display="none"><g id="node_expander1052" display="none" style="cursor: pointer;"><path id="kity_path_23678" fill="white" stroke="gray" d="M532.5,9.5A6,6,0,1,1,520.5,9.5A6,6,0,1,1,532.5,9.5"></path><path id="kity_path_23679" fill="none" stroke="gray"></path></g><path id="node_outline1053" fill="none" stroke="none" d="M532.5,0.5h97a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-97a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1053" fill="black"><text id="kity_text_10065" text-rendering="inherit" font-size="12" dy=".8em" y="1.7000000476837158" x="532.5">死锁怎么避免解决</text></g></g><g id="minder_node1056" display="none"><g id="node_expander1051" display="none" style="cursor: pointer;"><path id="kity_path_23675" fill="white" stroke="gray" d="M548.5,9.5A6,6,0,1,1,536.5,9.5A6,6,0,1,1,548.5,9.5"></path><path id="kity_path_23676" fill="none" stroke="gray"></path></g><path id="node_outline1052" fill="none" stroke="none" d="M548.5,0.5h307a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-307a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1052" fill="black"><text id="kity_text_10063" text-rendering="inherit" font-size="12" dy=".8em" y="1.7000000476837158" x="548.5">1.上面已经说了，死锁=》超时时间，自动释放，自动续期</text></g></g><g id="minder_node1057" display="none"><g id="node_expander1054" display="none" style="cursor: pointer;"><path id="kity_path_23684" fill="white" stroke="gray" d="M532.5,17.5A6,6,0,1,1,520.5,17.5A6,6,0,1,1,532.5,17.5"></path><path id="kity_path_23685" fill="none" stroke="gray"></path></g><path id="node_outline1055" fill="none" stroke="none" d="M532.5,8.5h313a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-313a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1055" fill="black"><text id="kity_text_10069" text-rendering="inherit" font-size="12" dy=".8em" y="9.700000047683716" x="532.5">加锁的时候什么时候选择本地锁，什么时候选择分布式锁？</text></g></g><g id="minder_node1058" display="none"><g id="node_expander1053" display="none" style="cursor: pointer;"><path id="kity_path_23681" fill="white" stroke="gray" d="M548.5,17.5A6,6,0,1,1,536.5,17.5A6,6,0,1,1,548.5,17.5"></path><path id="kity_path_23682" fill="none" stroke="gray"></path></g><path id="node_outline1054" fill="none" stroke="none" d="M548.5,8.5h914a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-914a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1054" fill="black"><text id="kity_text_10067" text-rendering="inherit" font-size="12" dy=".8em" y="9.700000047683716" x="548.5">1.当你只操作自己的模块，你的模块是独立出来的，并且其他模块只读不写，写只在自己的模块下操作，没有实例并发安全问题 就可以用本地锁，集群环境就可以用分布式锁</text></g></g><g id="minder_node1059" display="none"><g id="node_expander1056" display="none" style="cursor: pointer;"><path id="kity_path_23690" fill="white" stroke="gray" d="M532.5,25.5A6,6,0,1,1,520.5,25.5A6,6,0,1,1,532.5,25.5"></path><path id="kity_path_23691" fill="none" stroke="gray"></path></g><path id="node_outline1057" fill="none" stroke="none" d="M532.5,16.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1057" fill="black"><text id="kity_text_10073" text-rendering="inherit" font-size="12" dy=".8em" y="17.700000047683716" x="532.5">为什么要加分布式锁</text></g></g><g id="minder_node1060" display="none"><g id="node_expander1055" display="none" style="cursor: pointer;"><path id="kity_path_23687" fill="white" stroke="gray" d="M548.5,25.5A6,6,0,1,1,536.5,25.5A6,6,0,1,1,548.5,25.5"></path><path id="kity_path_23688" fill="none" stroke="gray"></path></g><path id="node_outline1056" fill="none" stroke="none" d="M548.5,16.5h433a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-433a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1056" fill="black"><text id="kity_text_10071" text-rendering="inherit" font-size="12" dy=".8em" y="17.700000047683716" x="548.5">1.因为象JUC和JVM的synchronized都只能锁本地，锁本地线程，没法锁集群环境</text></g></g><g id="minder_node1061" display="none"><g id="node_expander1058" display="none" style="cursor: pointer;"><path id="kity_path_23696" fill="white" stroke="gray" d="M532.5,33.5A6,6,0,1,1,520.5,33.5A6,6,0,1,1,532.5,33.5"></path><path id="kity_path_23697" fill="none" stroke="gray"></path></g><path id="node_outline1059" fill="none" stroke="none" d="M532.5,24.5h197a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-197a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1059" fill="black"><text id="kity_text_10077" text-rendering="inherit" font-size="12" dy=".8em" y="25.700000047683716" x="532.5">不用redis实现可以吗？有什么问题？</text></g></g><g id="minder_node1062" display="none"><g id="node_expander1057" display="none" style="cursor: pointer;"><path id="kity_path_23693" fill="white" stroke="gray" d="M548.5,33.5A6,6,0,1,1,536.5,33.5A6,6,0,1,1,548.5,33.5"></path><path id="kity_path_23694" fill="none" stroke="gray"></path></g><path id="node_outline1058" fill="none" stroke="none" d="M548.5,24.5h888a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-888a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1058" fill="black"><text id="kity_text_10075" text-rendering="inherit" font-size="12" dy=".8em" y="25.700000047683716" x="548.5">1.完全可以，缓存层实现性能比较高，但是不保证高可靠性，使用ZK可以保证强一致性，一般选择的就是ZK或者redis，不考虑数据库层面，否则又引入了db的很多问题</text></g></g><g id="minder_node1063" display="none"><g id="node_expander1060" display="none" style="cursor: pointer;"><path id="kity_path_23702" fill="white" stroke="gray" d="M532.5,41.5A6,6,0,1,1,520.5,41.5A6,6,0,1,1,532.5,41.5"></path><path id="kity_path_23703" fill="none" stroke="gray"></path></g><path id="node_outline1061" fill="none" stroke="none" d="M532.5,32.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1061" fill="black"><text id="kity_text_10081" text-rendering="inherit" font-size="12" dy=".8em" y="33.700000047683716" x="532.5">生产上出现过问题吗？</text></g></g><g id="minder_node1064" display="none"><g id="node_expander1059" display="none" style="cursor: pointer;"><path id="kity_path_23699" fill="white" stroke="gray" d="M548.5,41.5A6,6,0,1,1,536.5,41.5A6,6,0,1,1,548.5,41.5"></path><path id="kity_path_23700" fill="none" stroke="gray"></path></g><path id="node_outline1060" fill="none" stroke="none" d="M548.5,32.5h61a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-61a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1060" fill="black"><text id="kity_text_10079" text-rendering="inherit" font-size="12" dy=".8em" y="33.700000047683716" x="548.5">1.暂时没有&#xa0;</text></g></g><g id="minder_node1065" display="none"><g id="node_expander1061" display="none" style="cursor: pointer;"><path id="kity_path_23705" fill="white" stroke="gray" d="M532.5,49.5A6,6,0,1,1,520.5,49.5A6,6,0,1,1,532.5,49.5"></path><path id="kity_path_23706" fill="none" stroke="gray"></path></g><path id="node_outline1062" fill="none" stroke="none" d="M532.5,40.5h84a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-84a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1062" fill="black"><text id="kity_text_10083" text-rendering="inherit" font-size="12" dy=".8em" y="41.700000047683716" x="532.5">为什么会出现？</text></g></g><g id="minder_node1066" display="none"><g id="node_expander1062" display="none" style="cursor: pointer;"><path id="kity_path_23708" fill="white" stroke="gray" d="M532.5,57.5A6,6,0,1,1,520.5,57.5A6,6,0,1,1,532.5,57.5"></path><path id="kity_path_23709" fill="none" stroke="gray"></path></g><path id="node_outline1063" fill="none" stroke="none" d="M532.5,48.5h61a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-61a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1063" fill="black"><text id="kity_text_10085" text-rendering="inherit" font-size="12" dy=".8em" y="49.700000047683716" x="532.5">怎么优化？</text></g></g><g id="minder_node1067" display="none"><g id="node_expander1064" display="none" style="cursor: pointer;"><path id="kity_path_23714" fill="white" stroke="gray" d="M532.5,65.5A6,6,0,1,1,520.5,65.5A6,6,0,1,1,532.5,65.5"></path><path id="kity_path_23715" fill="none" stroke="gray"></path></g><path id="node_outline1065" fill="none" stroke="none" d="M532.5,56.5h126a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-126a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1065" fill="black"><text id="kity_text_10089" text-rendering="inherit" font-size="12" dy=".8em" y="57.700000047683716" x="532.5">单机redis分布式锁说说</text></g></g><g id="minder_node1068" display="none"><g id="node_expander1063" display="none" style="cursor: pointer;"><path id="kity_path_23711" fill="white" stroke="gray" d="M548.5,65.5A6,6,0,1,1,536.5,65.5A6,6,0,1,1,548.5,65.5"></path><path id="kity_path_23712" fill="none" stroke="gray"></path></g><path id="node_outline1064" fill="none" stroke="none" d="M548.5,56.5h222a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-222a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1064" fill="black"><text id="kity_text_10087" text-rendering="inherit" font-size="12" dy=".8em" y="57.700000047683716" x="548.5">1.setnxex +lua 或redission上面已经说了</text></g></g><g id="minder_node1069" display="none"><g id="node_expander1066" display="none" style="cursor: pointer;"><path id="kity_path_23720" fill="white" stroke="gray" d="M532.5,73.5A6,6,0,1,1,520.5,73.5A6,6,0,1,1,532.5,73.5"></path><path id="kity_path_23721" fill="none" stroke="gray"></path></g><path id="node_outline1067" fill="none" stroke="none" d="M532.5,64.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1067" fill="black"><text id="kity_text_10093" text-rendering="inherit" font-size="12" dy=".8em" y="65.70000004768372" x="532.5">集群状态下分布式锁知道吗</text></g></g><g id="minder_node1070" display="none"><g id="node_expander1065" display="none" style="cursor: pointer;"><path id="kity_path_23717" fill="white" stroke="gray" d="M548.5,73.5A6,6,0,1,1,536.5,73.5A6,6,0,1,1,548.5,73.5"></path><path id="kity_path_23718" fill="none" stroke="gray"></path></g><path id="node_outline1066" fill="none" stroke="none" d="M548.5,64.5h196a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-196a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1066" fill="black"><text id="kity_text_10091" text-rendering="inherit" font-size="12" dy=".8em" y="65.70000004768372" x="548.5">1.redission+redlock 或 ZK分布式锁</text></g></g><g id="minder_node1071" display="none"><g id="node_expander1068" display="none" style="cursor: pointer;"><path id="kity_path_23726" fill="white" stroke="gray" d="M532.5,81.5A6,6,0,1,1,520.5,81.5A6,6,0,1,1,532.5,81.5"></path><path id="kity_path_23727" fill="none" stroke="gray"></path></g><path id="node_outline1069" fill="none" stroke="none" d="M532.5,72.5h120a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-120a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1069" fill="black"><text id="kity_text_10097" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="532.5">主从下分布式锁知道吗</text></g></g><g id="minder_node1072" display="none"><g id="node_expander1067" display="none" style="cursor: pointer;"><path id="kity_path_23723" fill="white" stroke="gray" d="M548.5,81.5A6,6,0,1,1,536.5,81.5A6,6,0,1,1,548.5,81.5"></path><path id="kity_path_23724" fill="none" stroke="gray"></path></g><path id="node_outline1068" fill="none" stroke="none" d="M548.5,72.5h82a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-82a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1068" fill="black"><text id="kity_text_10095" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="548.5">1.和单机一样，</text></g></g><g id="minder_node1073" display="none"><g id="node_expander1070" display="none" style="cursor: pointer;"><path id="kity_path_23732" fill="white" stroke="gray" d="M532.5,89.5A6,6,0,1,1,520.5,89.5A6,6,0,1,1,532.5,89.5"></path><path id="kity_path_23733" fill="none" stroke="gray"></path></g><path id="node_outline1071" fill="none" stroke="none" d="M532.5,80.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1071" fill="black"><text id="kity_text_10101" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="532.5">分布式锁加在什么上面</text></g></g><g id="minder_node1074" display="none"><g id="node_expander1069" display="none" style="cursor: pointer;"><path id="kity_path_23729" fill="white" stroke="gray" d="M548.5,89.5A6,6,0,1,1,536.5,89.5A6,6,0,1,1,548.5,89.5"></path><path id="kity_path_23730" fill="none" stroke="gray"></path></g><path id="node_outline1070" fill="none" stroke="none" d="M548.5,80.5h285a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-285a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1070" fill="black"><text id="kity_text_10099" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="548.5">1.共享资源唯一标识，如商品id什么的，流水号什么的</text></g></g><g id="minder_node1075" display="none"><g id="node_expander1073" display="none" style="cursor: pointer;"><path id="kity_path_23741" fill="white" stroke="gray" d="M532.5,97.5A6,6,0,1,1,520.5,97.5A6,6,0,1,1,532.5,97.5"></path><path id="kity_path_23742" fill="none" stroke="gray"></path></g><path id="node_outline1074" fill="none" stroke="none" d="M532.5,88.5h521a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-521a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1074" fill="black"><text id="kity_text_10111" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="532.5">如果redis作为分布式锁的时候，主节点挂掉了，但是数据还没有同步到从节点，这种情况怎么办？</text></g></g><g id="minder_node1076" display="none"><g id="node_expander1072" display="none" style="cursor: pointer;"><path id="kity_path_23738" fill="white" stroke="gray" d="M548.5,97.5A6,6,0,1,1,536.5,97.5A6,6,0,1,1,548.5,97.5"></path><path id="kity_path_23739" fill="none" stroke="gray"></path></g><path id="node_outline1073" fill="none" stroke="none" d="M548.5,52.5h1152a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1152a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1073" fill="black"><text id="kity_text_10105" text-rendering="inherit" font-size="12" dy=".8em" y="53.700000047683716" x="548.5">1.像你说的，如果本来master是获取到锁的，而master挂了，然后集群的故障转移 某一个slave就会成为master，但是这个时侯，master的key没有同步到slave，</text><text id="kity_text_10106" text-rendering="inherit" font-size="12" dy=".8em" y="71.70000004768372" x="548.5">这样会导致 其他客户端线程也可以获取到锁，这样 一把锁 就有两个客户端获取到锁了，没有安全性了，在集群中 有一个算法radlock算法，</text><text id="kity_text_10107" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="548.5">只要成功了 （N/2）+1个节点加锁成功 就认为是成功的加锁，解锁就把所以实例解锁。相当于 ，因为节点一般的是单数的嘛，我有5个master实例，而且他们没有主从关系，</text><text id="kity_text_10108" text-rendering="inherit" font-size="12" dy=".8em" y="107.70000004768372" x="548.5">redlock会按照顺序去给这五个master加锁， 有两个超时了，可以具体的超时时间来判断是否超时(一般是5-50ms)，其他三个没有超时，并且这三个加锁成功的时间 小于 这把锁的一些时间，那么整体就是加锁成功的，</text><text id="kity_text_10109" text-rendering="inherit" font-size="12" dy=".8em" y="125.70000004768372" x="548.5">并且key的有效时间需要减去获取锁的时间。如果最后获取锁失败了，不管实例有没有加锁成功都会解锁</text></g></g><g id="minder_node1077" display="none"><g id="node_expander1071" display="none" style="cursor: pointer;"><path id="kity_path_23735" fill="white" stroke="gray" d="M564.5,97.5A6,6,0,1,1,552.5,97.5A6,6,0,1,1,564.5,97.5"></path><path id="kity_path_23736" fill="none" stroke="gray"></path></g><path id="node_outline1072" fill="none" stroke="none" d="M489.5,9.5h200a5,5,0,0,1,5,5v87a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-87a5,5,0,0,1,5,-5z"></path><g id="node_text1072" fill="black"><text id="kity_text_10103" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="564.5">分支主题</text></g><image id="kity_image_17054" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210324133533.png" x="489.5" y="12.5" width="200" height="74"></image></g><g id="minder_node1078" display="none"><g id="node_expander1075" display="none" style="cursor: pointer;"><path id="kity_path_23747" fill="white" stroke="gray" d="M532.5,105.5A6,6,0,1,1,520.5,105.5A6,6,0,1,1,532.5,105.5"></path><path id="kity_path_23748" fill="none" stroke="gray"></path></g><path id="node_outline1076" fill="none" stroke="none" d="M532.5,96.5h91a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-91a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1076" fill="black"><text id="kity_text_10122" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="532.5">redlock怎么理解</text></g></g><g id="minder_node1079" display="none"><g id="node_expander1074" display="none" style="cursor: pointer;"><path id="kity_path_23744" fill="white" stroke="gray" d="M548.5,105.5A6,6,0,1,1,536.5,105.5A6,6,0,1,1,548.5,105.5"></path><path id="kity_path_23745" fill="none" stroke="gray"></path></g><path id="node_outline1075" fill="none" stroke="none" d="M548.5,33.5h2132a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-2132a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text1075" fill="black"><text id="kity_text_10113" text-rendering="inherit" font-size="12" dy=".8em" y="34.700000047683716" x="548.5">1.redlock流程</text><text id="kity_text_10114" text-rendering="inherit" font-size="12" dy=".8em" y="52.700000047683716" x="548.5">1）、获取当前时间，以毫秒为单位。</text><text id="kity_text_10115" text-rendering="inherit" font-size="12" dy=".8em" y="70.70000004768372" x="548.5">2）、依次尝试从5个实例，使用相同的 key 和随机值（例如UUID）获取锁。当向Redis 请求获取锁时，客户端应该设置一个超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在 5-50 毫秒之间。这样可以防止客户端在试图与一个宕机的 Redis 节点对话时长时间处于阻塞状态。如果一个实例不可用，客户端应该尽快尝试去另外一个Redis实例请求获取锁</text><text id="kity_text_10116" text-rendering="inherit" font-size="12" dy=".8em" y="88.70000004768372" x="548.5">3）客户端通过当前时间减去步骤1记录的时间来计算获取锁使用的时间。当且仅当从大多数（N/2+1，这里是3个节点）的Redis节点都取到锁，并且获取锁使用的时间小于锁失效时间时，锁才算获取成功。</text><text id="kity_text_10117" text-rendering="inherit" font-size="12" dy=".8em" y="106.70000004768372" x="548.5">4）如果取到了锁，其有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。</text><text id="kity_text_10118" text-rendering="inherit" font-size="12" dy=".8em" y="124.70000004768372" x="548.5">5）如果由于某些原因未能获得锁（无法在至少N/2+1个Redis实例获取锁、或获取锁的时间超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功，防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁）。</text><text id="kity_text_10119" text-rendering="inherit" font-size="12" dy=".8em" y="142.70000004768372" x="548.5">2.缺点：</text><text id="kity_text_10120" text-rendering="inherit" font-size="12" dy=".8em" y="160.70000004768372" x="548.5">为了防止异步复制 数据不一致问题，只使用master，而且实例需要5及以上，有一定的成本，而且最重要的时间，5个实例时间必须需要一样快，如果不一致 可能出现锁安全，锁提前释放，</text></g></g><g id="minder_node1080" display="none"><g id="node_expander1085" display="none" style="cursor: pointer;"><path id="kity_path_23777" fill="white" stroke="gray" d="M516.5,113.5A6,6,0,1,1,504.5,113.5A6,6,0,1,1,516.5,113.5"></path><path id="kity_path_23778" fill="none" stroke="gray"></path></g><path id="node_outline1086" fill="none" stroke="none" d="M516.5,104.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1086" fill="black"><text id="kity_text_10150" text-rendering="inherit" font-size="12" dy=".8em" y="105.70000004768372" x="516.5">延时队列</text></g></g><g id="minder_node1081" display="none"><g id="node_expander1080" display="none" style="cursor: pointer;"><path id="kity_path_23762" fill="white" stroke="gray" d="M532.5,97.5A6,6,0,1,1,520.5,97.5A6,6,0,1,1,532.5,97.5"></path><path id="kity_path_23763" fill="none" stroke="gray"></path></g><path id="node_outline1081" fill="none" stroke="none" d="M532.5,88.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1081" fill="black"><text id="kity_text_10135" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="532.5">zset延时队列怎么实现</text></g></g><g id="minder_node1082" display="none"><g id="node_expander1079" display="none" style="cursor: pointer;"><path id="kity_path_23759" fill="white" stroke="gray" d="M548.5,97.5A6,6,0,1,1,536.5,97.5A6,6,0,1,1,548.5,97.5"></path><path id="kity_path_23760" fill="none" stroke="gray"></path></g><path id="node_outline1080" fill="none" stroke="none" d="M548.5,61.5h1373a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1373a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1080" fill="black"><text id="kity_text_10130" text-rendering="inherit" font-size="12" dy=".8em" y="62.700000047683716" x="548.5">1.</text><text id="kity_text_10131" text-rendering="inherit" font-size="12" dy=".8em" y="80.70000004768372" x="548.5">Redis可通过zset来实现。使用业务或uuid作为key,保证唯一，我们可以将有序集合的value设置为我们的消息任务，把value的score设置为消息的到期时间，然后轮询获取有序集合的中的到期消息进行转到延迟队列处理。主要是就是一个中转队列 一个延迟队列</text><text id="kity_text_10132" text-rendering="inherit" font-size="12" dy=".8em" y="98.70000004768372" x="548.5">2.通过redission实现</text><text id="kity_text_10133" text-rendering="inherit" font-size="12" dy=".8em" y="116.70000004768372" x="548.5">可以通过redission的RDelayedQueue来实现，RDelayedQueue实现了RQueue接口可以延迟添加， getDelayedQueue(xx); 获取一个实例，然后设置指定时间把msg发送到指定队列</text></g></g><g id="minder_node1083" display="none"><g id="node_expander1077" display="none" style="cursor: pointer;"><path id="kity_path_23753" fill="white" stroke="gray" d="M564.5,89.5A6,6,0,1,1,552.5,89.5A6,6,0,1,1,564.5,89.5"></path><path id="kity_path_23754" fill="none" stroke="gray"></path></g><path id="node_outline1078" fill="none" stroke="none" d="M489.5,-12.5h200a5,5,0,0,1,5,5v101a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-101a5,5,0,0,1,5,-5z"></path><g id="node_text1078" fill="black"><text id="kity_text_10126" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="564.5">分支主题</text></g><image id="kity_image_17055" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210324164909.png" x="489.5" y="-9.5" width="200" height="88"></image></g><g id="minder_node1084" display="none"><g id="node_expander1078" display="none" style="cursor: pointer;"><path id="kity_path_23756" fill="white" stroke="gray" d="M564.5,97.5A6,6,0,1,1,552.5,97.5A6,6,0,1,1,564.5,97.5"></path><path id="kity_path_23757" fill="none" stroke="gray"></path></g><path id="node_outline1079" fill="none" stroke="none" d="M489.5,33.5h200a5,5,0,0,1,5,5v63a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-63a5,5,0,0,1,5,-5z"></path><g id="node_text1079" fill="black"><text id="kity_text_10128" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="564.5">分支主题</text></g><image id="kity_image_17056" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210324165958.png" x="489.5" y="36.5" width="200" height="50"></image></g><g id="minder_node1085" display="none"><g id="node_expander1082" display="none" style="cursor: pointer;"><path id="kity_path_23768" fill="white" stroke="gray" d="M532.5,105.5A6,6,0,1,1,520.5,105.5A6,6,0,1,1,532.5,105.5"></path><path id="kity_path_23769" fill="none" stroke="gray"></path></g><path id="node_outline1083" fill="none" stroke="none" d="M532.5,96.5h217a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-217a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1083" fill="black"><text id="kity_text_10143" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="532.5">zset做延时队列会有什么问题？怎么解决</text></g></g><g id="minder_node1086" display="none"><g id="node_expander1081" display="none" style="cursor: pointer;"><path id="kity_path_23765" fill="white" stroke="gray" d="M548.5,105.5A6,6,0,1,1,536.5,105.5A6,6,0,1,1,548.5,105.5"></path><path id="kity_path_23766" fill="none" stroke="gray"></path></g><path id="node_outline1082" fill="none" stroke="none" d="M548.5,60.5h615a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-615a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1082" fill="black"><text id="kity_text_10137" text-rendering="inherit" font-size="12" dy=".8em" y="61.700000047683716" x="548.5">1.</text><text id="kity_text_10138" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="548.5">死循环轮询耗时</text><text id="kity_text_10139" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="548.5">2.</text><text id="kity_text_10140" text-rendering="inherit" font-size="12" dy=".8em" y="115.70000004768372" x="548.5">同一个任务可能会被多个进程取到之后再使用 zrem 进行争抢，那些没抢到 的进程都是白取了一次任务，这是浪费。</text><text id="kity_text_10141" text-rendering="inherit" font-size="12" dy=".8em" y="133.70000004768372" x="548.5">将&#xa0;zrangebyscore和zrem使用lua脚本进行原子化操作,这样多个进程之间争抢任务时就不会出现这种浪费了。</text></g></g><g id="minder_node1087" display="none"><g id="node_expander1084" display="none" style="cursor: pointer;"><path id="kity_path_23774" fill="white" stroke="gray" d="M532.5,113.5A6,6,0,1,1,520.5,113.5A6,6,0,1,1,532.5,113.5"></path><path id="kity_path_23775" fill="none" stroke="gray"></path></g><path id="node_outline1085" fill="none" stroke="none" d="M532.5,104.5h139a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-139a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1085" fill="black"><text id="kity_text_10148" text-rendering="inherit" font-size="12" dy=".8em" y="105.70000004768372" x="532.5">延迟队列有什么使用场景?</text></g></g><g id="minder_node1088" display="none"><g id="node_expander1083" display="none" style="cursor: pointer;"><path id="kity_path_23771" fill="white" stroke="gray" d="M548.5,113.5A6,6,0,1,1,536.5,113.5A6,6,0,1,1,548.5,113.5"></path><path id="kity_path_23772" fill="none" stroke="gray"></path></g><path id="node_outline1084" fill="none" stroke="none" d="M548.5,95.5h241a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-241a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1084" fill="black"><text id="kity_text_10145" text-rendering="inherit" font-size="12" dy=".8em" y="96.70000004768372" x="548.5">1.</text><text id="kity_text_10146" text-rendering="inherit" font-size="12" dy=".8em" y="114.70000004768372" x="548.5">排行榜，订单未支付每隔一段时间提醒用户，</text></g></g><g id="minder_node1089" display="none"><g id="node_expander1093" display="none" style="cursor: pointer;"><path id="kity_path_23801" fill="white" stroke="gray" d="M516.5,121.5A6,6,0,1,1,504.5,121.5A6,6,0,1,1,516.5,121.5"></path><path id="kity_path_23802" fill="none" stroke="gray"></path></g><path id="node_outline1094" fill="none" stroke="none" d="M516.5,112.5h61a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-61a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1094" fill="black"><text id="kity_text_10173" text-rendering="inherit" font-size="12" dy=".8em" y="113.70000004768372" x="516.5">优先级队列</text></g></g><g id="minder_node1090" display="none"><g id="node_expander1090" display="none" style="cursor: pointer;"><path id="kity_path_23792" fill="white" stroke="gray" d="M532.5,113.5A6,6,0,1,1,520.5,113.5A6,6,0,1,1,532.5,113.5"></path><path id="kity_path_23793" fill="none" stroke="gray"></path></g><path id="node_outline1091" fill="none" stroke="none" d="M532.5,104.5h148a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-148a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1091" fill="black"><text id="kity_text_10166" text-rendering="inherit" font-size="12" dy=".8em" y="105.70000004768372" x="532.5">redis实现带优先级的队列？</text></g></g><g id="minder_node1091" display="none"><g id="node_expander1089" display="none" style="cursor: pointer;"><path id="kity_path_23789" fill="white" stroke="gray" d="M548.5,113.5A6,6,0,1,1,536.5,113.5A6,6,0,1,1,548.5,113.5"></path><path id="kity_path_23790" fill="none" stroke="gray"></path></g><path id="node_outline1090" fill="none" stroke="none" d="M548.5,50.5h1507a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-1507a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text1090" fill="black"><text id="kity_text_10158" text-rendering="inherit" font-size="12" dy=".8em" y="51.700000047683716" x="548.5">1.</text><text id="kity_text_10159" text-rendering="inherit" font-size="12" dy=".8em" y="69.70000004768372" x="548.5">主要是使用list来实现，然后利用push 和pop 命令来做左出右进，然后开启线程或者定时任务来轮询，不停的调用pop来查看是否有消息需要消费，</text><text id="kity_text_10160" text-rendering="inherit" font-size="12" dy=".8em" y="87.70000004768372" x="548.5">但是这种轮询会容易浪费内存资源，而且每一次调用都发起一次连接。1）、如果生产者速度大于消费者消费速度，消息队列长度会一直增大，时间久了会占用大量内存空间。 2）、如果睡眠时间过长，这样不能处理一些时效性的消息，睡眠时间过短，也会在连接上造成比较大的开销。</text><text id="kity_text_10161" text-rendering="inherit" font-size="12" dy=".8em" y="105.70000004768372" x="548.5">2.使用blpop左出和brpop右出，只有在有元素时才返回，没有则会阻塞直到超时返回null 阻塞实现：不用轮询，当队列key有数据时候，就会响应，这里读取消息不会一直循环去读取，而是一直阻塞，等到有消息过来才读取</text><text id="kity_text_10162" text-rendering="inherit" font-size="12" dy=".8em" y="123.70000004768372" x="548.5">&#xa0;然后带参数就可以实现优先级和超时时间，</text><text id="kity_text_10163" text-rendering="inherit" font-size="12" dy=".8em" y="141.70000004768372" x="548.5">&#xa0;BLPOP high normal low 可以创建三个队列，high，normal, low ，分别代表高优先级，普通优先级，低优先级当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。</text><text id="kity_text_10164" text-rendering="inherit" font-size="12" dy=".8em" y="159.70000004768372" x="548.5"> </text></g></g><g id="minder_node1092" display="none"><g id="node_expander1086" display="none" style="cursor: pointer;"><path id="kity_path_23780" fill="white" stroke="gray" d="M564.5,97.5A6,6,0,1,1,552.5,97.5A6,6,0,1,1,564.5,97.5"></path><path id="kity_path_23781" fill="none" stroke="gray"></path></g><path id="node_outline1087" fill="none" stroke="none" d="M564.5,88.5h231a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-231a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1087" fill="black"><text id="kity_text_10152" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="564.5">https://zhuanlan.zhihu.com/p/58118563</text></g></g><g id="minder_node1093" display="none"><g id="node_expander1087" display="none" style="cursor: pointer;"><path id="kity_path_23783" fill="white" stroke="gray" d="M564.5,105.5A6,6,0,1,1,552.5,105.5A6,6,0,1,1,564.5,105.5"></path><path id="kity_path_23784" fill="none" stroke="gray"></path></g><path id="node_outline1088" fill="none" stroke="none" d="M564.5,96.5h238a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-238a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1088" fill="black"><text id="kity_text_10154" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="564.5">https://zhuanlan.zhihu.com/p/267067862</text></g></g><g id="minder_node1094" display="none"><g id="node_expander1088" display="none" style="cursor: pointer;"><path id="kity_path_23786" fill="white" stroke="gray" d="M564.5,113.5A6,6,0,1,1,552.5,113.5A6,6,0,1,1,564.5,113.5"></path><path id="kity_path_23787" fill="none" stroke="gray"></path></g><path id="node_outline1089" fill="none" stroke="none" d="M564.5,104.5h338a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-338a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1089" fill="black"><text id="kity_text_10156" text-rendering="inherit" font-size="12" dy=".8em" y="105.70000004768372" x="564.5">https://blog.csdn.net/woshiaotian/article/details/44757621</text></g></g><g id="minder_node1095" display="none"><g id="node_expander1092" display="none" style="cursor: pointer;"><path id="kity_path_23798" fill="white" stroke="gray" d="M532.5,121.5A6,6,0,1,1,520.5,121.5A6,6,0,1,1,532.5,121.5"></path><path id="kity_path_23799" fill="none" stroke="gray"></path></g><path id="node_outline1093" fill="none" stroke="none" d="M532.5,112.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1093" fill="black"><text id="kity_text_10171" text-rendering="inherit" font-size="12" dy=".8em" y="113.70000004768372" x="532.5">空闲连接断开？</text></g></g><g id="minder_node1096" display="none"><g id="node_expander1091" display="none" style="cursor: pointer;"><path id="kity_path_23795" fill="white" stroke="gray" d="M548.5,121.5A6,6,0,1,1,536.5,121.5A6,6,0,1,1,548.5,121.5"></path><path id="kity_path_23796" fill="none" stroke="gray"></path></g><path id="node_outline1092" fill="none" stroke="none" d="M548.5,103.5h888a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-888a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1092" fill="black"><text id="kity_text_10168" text-rendering="inherit" font-size="12" dy=".8em" y="104.70000004768372" x="548.5">如果线程一直阻塞在哪里，Redis 的客户端连接就成了闲置连接，闲置过久，服务器一般 会主动断开连接，减少闲置资源占用。这个时候 blpop/brpop 会抛出异常来。</text><text id="kity_text_10169" text-rendering="inherit" font-size="12" dy=".8em" y="122.70000004768372" x="548.5">所以编写客户端消费者的时候要小心，注意捕获异常，还要重试。</text></g></g><g id="minder_node1097" display="none"><g id="node_expander1104" display="none" style="cursor: pointer;"><path id="kity_path_23834" fill="white" stroke="gray" d="M516.5,129.5A6,6,0,1,1,504.5,129.5A6,6,0,1,1,516.5,129.5"></path><path id="kity_path_23835" fill="none" stroke="gray"></path></g><path id="node_outline1105" fill="none" stroke="none" d="M516.5,120.5h62a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-62a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1105" fill="black"><text id="kity_text_10216" text-rendering="inherit" font-size="12" dy=".8em" y="121.70000004768372" x="516.5">布隆过滤器</text></g></g><g id="minder_node1098" display="none"><g id="node_expander1095" display="none" style="cursor: pointer;"><path id="kity_path_23807" fill="white" stroke="gray" d="M532.5,97.5A6,6,0,1,1,520.5,97.5A6,6,0,1,1,532.5,97.5"></path><path id="kity_path_23808" fill="none" stroke="gray"></path></g><path id="node_outline1096" fill="none" stroke="none" d="M532.5,88.5h98a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-98a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1096" fill="black"><text id="kity_text_10182" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="532.5">布隆过滤器是什么</text></g></g><g id="minder_node1099" display="none"><g id="node_expander1094" display="none" style="cursor: pointer;"><path id="kity_path_23804" fill="white" stroke="gray" d="M548.5,97.5A6,6,0,1,1,536.5,97.5A6,6,0,1,1,548.5,97.5"></path><path id="kity_path_23805" fill="none" stroke="gray"></path></g><path id="node_outline1095" fill="none" stroke="none" d="M548.5,43.5h1172a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1172a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1095" fill="black"><text id="kity_text_10175" text-rendering="inherit" font-size="12" dy=".8em" y="44.700000047683716" x="548.5">1.布隆过滤器就是一个一个很长的二进制向量 也就是位数组，每一位 0和1， 和一系列随机映射函数，存一个意思经过hash以后，得到值，放到对应的位上面去，把这一位变为1，然后因为可能随着数据变大然后误报</text><text id="kity_text_10176" text-rendering="inherit" font-size="12" dy=".8em" y="62.700000047683716" x="548.5">就多hash几次和改进hash，比如说 字母a&#xa0; hash一次 是 1&#xa0; &#xa0;把 位数组1的值改1，再hash一次 是2，把位数组中的2改为1，那么最后一个去看 只需要 把子母a hash两次 再看对应位数组的值是不是都为1，然后都是1 大概率</text><text id="kity_text_10177" text-rendering="inherit" font-size="12" dy=".8em" y="80.70000004768372" x="548.5">是存在，如果不为1，100%不存在，</text><text id="kity_text_10178" text-rendering="inherit" font-size="12" dy=".8em" y="98.70000004768372" x="548.5">整体流程就是 存的时侯 hash 存，判断在不在的时侯 hahs去取，</text><text id="kity_text_10179" text-rendering="inherit" font-size="12" dy=".8em" y="116.70000004768372" x="548.5">具体作用就是判断一个值在不在集合中</text><text id="kity_text_10180" text-rendering="inherit" font-size="12" dy=".8em" y="134.70000004768372" x="548.5">优点就是 查询快，把set map快多了，而且占空间很小，每个元素都只占用 1 bit </text></g></g><g id="minder_node1100" display="none"><g id="node_expander1097" display="none" style="cursor: pointer;"><path id="kity_path_23813" fill="white" stroke="gray" d="M532.5,105.5A6,6,0,1,1,520.5,105.5A6,6,0,1,1,532.5,105.5"></path><path id="kity_path_23814" fill="none" stroke="gray"></path></g><path id="node_outline1098" fill="none" stroke="none" d="M532.5,96.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1098" fill="black"><text id="kity_text_10192" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="532.5">布隆过滤器可以做什么？</text></g></g><g id="minder_node1101" display="none"><g id="node_expander1096" display="none" style="cursor: pointer;"><path id="kity_path_23810" fill="white" stroke="gray" d="M548.5,105.5A6,6,0,1,1,536.5,105.5A6,6,0,1,1,548.5,105.5"></path><path id="kity_path_23811" fill="none" stroke="gray"></path></g><path id="node_outline1097" fill="none" stroke="none" d="M548.5,42.5h1057a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-1057a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text1097" fill="black"><text id="kity_text_10184" text-rendering="inherit" font-size="12" dy=".8em" y="43.700000047683716" x="548.5">1.数据库防止穿库，减少不存在的行或列的磁盘查找。避免代价高昂的磁盘查找会大大提高数据库查询操作的性能。</text><text id="kity_text_10185" text-rendering="inherit" font-size="12" dy=".8em" y="61.700000047683716" x="548.5">2.业务场景中判断用户是否阅读过某视频或文章，</text><text id="kity_text_10186" text-rendering="inherit" font-size="12" dy=".8em" y="79.70000004768372" x="548.5">3.缓存宕机、缓存击穿场景，一般判断用户是否在缓存中，如果在则直接返回结果，不在则查询db，如果来一波冷数据，会导致缓存大量击穿，造成雪崩效应，这时候可以用布隆过滤器当缓存的索引，</text><text id="kity_text_10187" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="548.5">只有在布隆过滤器中，才去查询缓存，如果没查询到，则穿透到db。如果不在布隆器中，则直接返回</text><text id="kity_text_10188" text-rendering="inherit" font-size="12" dy=".8em" y="115.70000004768372" x="548.5">4.WEB拦截器，如果相同请求则拦截，防止重复被攻击。用户第一次请求，将请求参数放入布隆过滤器中，当第二次请求时，先判断请求参数是否被布隆过滤器命中。可以提高缓存命中率。</text><text id="kity_text_10189" text-rendering="inherit" font-size="12" dy=".8em" y="133.70000004768372" x="548.5">5.去重：比如爬给定网址的时候对已经爬取过的 URL 去重。</text><text id="kity_text_10190" text-rendering="inherit" font-size="12" dy=".8em" y="151.70000004768372" x="548.5">总结就是：正确率要求不是100%,同时存在海量的数据集.</text></g></g><g id="minder_node1102" display="none"><g id="node_expander1099" display="none" style="cursor: pointer;"><path id="kity_path_23819" fill="white" stroke="gray" d="M532.5,113.5A6,6,0,1,1,520.5,113.5A6,6,0,1,1,532.5,113.5"></path><path id="kity_path_23820" fill="none" stroke="gray"></path></g><path id="node_outline1100" fill="none" stroke="none" d="M532.5,104.5h127a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-127a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1100" fill="black"><text id="kity_text_10200" text-rendering="inherit" font-size="12" dy=".8em" y="105.70000004768372" x="532.5">你在项目中是怎么用的?</text></g></g><g id="minder_node1103" display="none"><g id="node_expander1098" display="none" style="cursor: pointer;"><path id="kity_path_23816" fill="white" stroke="gray" d="M548.5,113.5A6,6,0,1,1,536.5,113.5A6,6,0,1,1,548.5,113.5"></path><path id="kity_path_23817" fill="none" stroke="gray"></path></g><path id="node_outline1099" fill="none" stroke="none" d="M548.5,68.5h877a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-877a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1099" fill="black"><text id="kity_text_10194" text-rendering="inherit" font-size="12" dy=".8em" y="69.70000004768372" x="548.5">1.单机用的google的guava有布隆过滤器</text><text id="kity_text_10195" text-rendering="inherit" font-size="12" dy=".8em" y="87.70000004768372" x="548.5">实际我们实例化一个BloomFilter，指定类型，最多容量，可以容忍误判的概率。</text><text id="kity_text_10196" text-rendering="inherit" font-size="12" dy=".8em" y="105.70000004768372" x="548.5">当mightContain（） 方法返回true时，我们可以99％确定该元素在过滤器中，当过滤器返回false时，我们可以100％确定该元素不存在于过滤器中。</text><text id="kity_text_10197" text-rendering="inherit" font-size="12" dy=".8em" y="123.70000004768372" x="548.5">2.集群用的redisbloom</text><text id="kity_text_10198" text-rendering="inherit" font-size="12" dy=".8em" y="141.70000004768372" x="548.5">通过按照redis的bloom的module，通过BF.ADD	将元素添加到布隆过滤器中，如果该过滤器尚不存在，则创建该过滤器 。通过BF.EXISTS，是否在布隆过滤器中存在</text></g></g><g id="minder_node1104" display="none"><g id="node_expander1101" display="none" style="cursor: pointer;"><path id="kity_path_23825" fill="white" stroke="gray" d="M532.5,121.5A6,6,0,1,1,520.5,121.5A6,6,0,1,1,532.5,121.5"></path><path id="kity_path_23826" fill="none" stroke="gray"></path></g><path id="node_outline1102" fill="none" stroke="none" d="M532.5,112.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1102" fill="black"><text id="kity_text_10210" text-rendering="inherit" font-size="12" dy=".8em" y="113.70000004768372" x="532.5">布隆过滤器的原理了解吗</text></g></g><g id="minder_node1105" display="none"><g id="node_expander1100" display="none" style="cursor: pointer;"><path id="kity_path_23822" fill="white" stroke="gray" d="M548.5,121.5A6,6,0,1,1,536.5,121.5A6,6,0,1,1,548.5,121.5"></path><path id="kity_path_23823" fill="none" stroke="gray"></path></g><path id="node_outline1101" fill="none" stroke="none" d="M548.5,58.5h825a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-825a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text1101" fill="black"><text id="kity_text_10202" text-rendering="inherit" font-size="12" dy=".8em" y="59.700000047683716" x="548.5">1.当一个元素加入布隆过滤器中的时候，会进行如下操作：</text><text id="kity_text_10203" text-rendering="inherit" font-size="12" dy=".8em" y="77.70000004768372" x="548.5">使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</text><text id="kity_text_10204" text-rendering="inherit" font-size="12" dy=".8em" y="95.70000004768372" x="548.5">根据得到的哈希值，在位数组中把对应下标的值置为 1。</text><text id="kity_text_10205" text-rendering="inherit" font-size="12" dy=".8em" y="113.70000004768372" x="548.5">2.当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：</text><text id="kity_text_10206" text-rendering="inherit" font-size="12" dy=".8em" y="131.70000004768372" x="548.5">对给定元素再次进行相同的哈希计算；</text><text id="kity_text_10207" text-rendering="inherit" font-size="12" dy=".8em" y="149.70000004768372" x="548.5">得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</text><text id="kity_text_10208" text-rendering="inherit" font-size="12" dy=".8em" y="167.70000004768372" x="548.5">3.底层就是构建了一个hash函数，把输入数据hash到size一个位置上，当数据所有的hash结果都在size中 就认为数据重复， 把结果返回</text></g></g><g id="minder_node1106" display="none"><g id="node_expander1103" display="none" style="cursor: pointer;"><path id="kity_path_23831" fill="white" stroke="gray" d="M532.5,129.5A6,6,0,1,1,520.5,129.5A6,6,0,1,1,532.5,129.5"></path><path id="kity_path_23832" fill="none" stroke="gray"></path></g><path id="node_outline1104" fill="none" stroke="none" d="M532.5,120.5h218a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-218a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1104" fill="black"><text id="kity_text_10214" text-rendering="inherit" font-size="12" dy=".8em" y="121.70000004768372" x="532.5">布隆过滤器的缺点有了解吗，误判？说说</text></g></g><g id="minder_node1107" display="none"><g id="node_expander1102" display="none" style="cursor: pointer;"><path id="kity_path_23828" fill="white" stroke="gray" d="M548.5,129.5A6,6,0,1,1,536.5,129.5A6,6,0,1,1,548.5,129.5"></path><path id="kity_path_23829" fill="none" stroke="gray"></path></g><path id="node_outline1103" fill="none" stroke="none" d="M548.5,120.5h287a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-287a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1103" fill="black"><text id="kity_text_10212" text-rendering="inherit" font-size="12" dy=".8em" y="121.70000004768372" x="548.5">1.元素添加到集合中后，不能被删除。有一定的误判率</text></g></g><g id="minder_node1108" display="none"><g id="node_expander1107" display="none" style="cursor: pointer;"><path id="kity_path_23843" fill="white" stroke="gray" d="M516.5,137.5A6,6,0,1,1,504.5,137.5A6,6,0,1,1,516.5,137.5"></path><path id="kity_path_23844" fill="none" stroke="gray"></path></g><path id="node_outline1108" fill="none" stroke="none" d="M516.5,128.5h77a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-77a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1108" fill="black"><text id="kity_text_10223" text-rendering="inherit" font-size="12" dy=".8em" y="129.70000004768372" x="516.5">redis实现限流</text></g></g><g id="minder_node1109" display="none"><g id="node_expander1106" display="none" style="cursor: pointer;"><path id="kity_path_23840" fill="white" stroke="gray" d="M532.5,137.5A6,6,0,1,1,520.5,137.5A6,6,0,1,1,532.5,137.5"></path><path id="kity_path_23841" fill="none" stroke="gray"></path></g><path id="node_outline1107" fill="none" stroke="none" d="M532.5,128.5h114a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-114a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1107" fill="black"><text id="kity_text_10221" text-rendering="inherit" font-size="12" dy=".8em" y="129.70000004768372" x="532.5">redis+lua实现限流？</text></g></g><g id="minder_node1110" display="none"><g id="node_expander1105" display="none" style="cursor: pointer;"><path id="kity_path_23837" fill="white" stroke="gray" d="M548.5,137.5A6,6,0,1,1,536.5,137.5A6,6,0,1,1,548.5,137.5"></path><path id="kity_path_23838" fill="none" stroke="gray"></path></g><path id="node_outline1106" fill="none" stroke="none" d="M548.5,119.5h729a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-729a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1106" fill="black"><text id="kity_text_10218" text-rendering="inherit" font-size="12" dy=".8em" y="120.70000004768372" x="548.5">1.redis+lua可以实现令牌桶限流，使用lua主要是 原子操作，减少网络开销(发送一次请求即可)，复用</text><text id="kity_text_10219" text-rendering="inherit" font-size="12" dy=".8em" y="138.70000004768372" x="548.5">通过lua脚本，限制最大访问量大小，限流时间，限流的key，如果超过限流大小，我们就返回0，否则就请求数+1，key重新设置过期时间</text></g></g><g id="minder_node1111" display="none"><g id="node_expander1112" display="none" style="cursor: pointer;"><path id="kity_path_23858" fill="white" stroke="gray" d="M500.5,145.5A6,6,0,1,1,488.5,145.5A6,6,0,1,1,500.5,145.5"></path><path id="kity_path_23859" fill="none" stroke="gray"></path></g><path id="node_outline1113" fill="none" stroke="none" d="M500.5,136.5h53a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-53a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1113" fill="black"><text id="kity_text_10233" text-rendering="inherit" font-size="12" dy=".8em" y="137.70000004768372" x="500.5">redis运维</text></g></g><g id="minder_node1112" display="none"><g id="node_expander1109" display="none" style="cursor: pointer;"><path id="kity_path_23849" fill="white" stroke="gray" d="M516.5,129.5A6,6,0,1,1,504.5,129.5A6,6,0,1,1,516.5,129.5"></path><path id="kity_path_23850" fill="none" stroke="gray"></path></g><path id="node_outline1110" fill="none" stroke="none" d="M516.5,120.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1110" fill="black"><text id="kity_text_10227" text-rendering="inherit" font-size="12" dy=".8em" y="121.70000004768372" x="516.5">基础</text></g></g><g id="minder_node1113" display="none"><g id="node_expander1110" display="none" style="cursor: pointer;"><path id="kity_path_23852" fill="white" stroke="gray" d="M516.5,137.5A6,6,0,1,1,504.5,137.5A6,6,0,1,1,516.5,137.5"></path><path id="kity_path_23853" fill="none" stroke="gray"></path></g><path id="node_outline1111" fill="none" stroke="none" d="M516.5,128.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1111" fill="black"><text id="kity_text_10229" text-rendering="inherit" font-size="12" dy=".8em" y="129.70000004768372" x="516.5">进阶</text></g></g><g id="minder_node1114" display="none"><g id="node_expander1111" display="none" style="cursor: pointer;"><path id="kity_path_23855" fill="white" stroke="gray" d="M516.5,145.5A6,6,0,1,1,504.5,145.5A6,6,0,1,1,516.5,145.5"></path><path id="kity_path_23856" fill="none" stroke="gray"></path></g><path id="node_outline1112" fill="none" stroke="none" d="M516.5,136.5h106a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-106a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1112" fill="black"><text id="kity_text_10231" text-rendering="inherit" font-size="12" dy=".8em" y="137.70000004768372" x="516.5">问题分析优化&amp;场景</text></g></g><g id="minder_node1115" display="none"><g id="node_expander1120" display="none" style="cursor: pointer;"><path id="kity_path_23882" fill="white" stroke="gray" d="M500.5,153.5A6,6,0,1,1,488.5,153.5A6,6,0,1,1,500.5,153.5"></path><path id="kity_path_23883" fill="none" stroke="gray"></path></g><path id="node_outline1121" fill="none" stroke="none" d="M500.5,144.5h48a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-48a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1121" fill="black"><text id="kity_text_10257" text-rendering="inherit" font-size="12" dy=".8em" y="145.70000004768372" x="500.5">缓存雪崩</text></g></g><g id="minder_node1116" display="none"><g id="node_expander1117" display="none" style="cursor: pointer;"><path id="kity_path_23873" fill="white" stroke="gray" d="M516.5,137.5A6,6,0,1,1,504.5,137.5A6,6,0,1,1,516.5,137.5"></path><path id="kity_path_23874" fill="none" stroke="gray"></path></g><path id="node_outline1118" fill="none" stroke="none" d="M516.5,128.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1118" fill="black"><text id="kity_text_10251" text-rendering="inherit" font-size="12" dy=".8em" y="129.70000004768372" x="516.5">基础</text></g></g><g id="minder_node1117" display="none"><g id="node_expander1114" display="none" style="cursor: pointer;"><path id="kity_path_23864" fill="white" stroke="gray" d="M532.5,129.5A6,6,0,1,1,520.5,129.5A6,6,0,1,1,532.5,129.5"></path><path id="kity_path_23865" fill="none" stroke="gray"></path></g><path id="node_outline1115" fill="none" stroke="none" d="M532.5,120.5h96a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-96a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1115" fill="black"><text id="kity_text_10244" text-rendering="inherit" font-size="12" dy=".8em" y="121.70000004768372" x="532.5">缓存雪崩是什么？</text></g></g><g id="minder_node1118" display="none"><g id="node_expander1113" display="none" style="cursor: pointer;"><path id="kity_path_23861" fill="white" stroke="gray" d="M548.5,129.5A6,6,0,1,1,536.5,129.5A6,6,0,1,1,548.5,129.5"></path><path id="kity_path_23862" fill="none" stroke="gray"></path></g><path id="node_outline1114" fill="none" stroke="none" d="M548.5,57.5h551a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-551a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text1114" fill="black"><text id="kity_text_10235" text-rendering="inherit" font-size="12" dy=".8em" y="58.700000047683716" x="548.5">回答1：</text><text id="kity_text_10236" text-rendering="inherit" font-size="12" dy=".8em" y="76.70000004768372" x="548.5">1.Redis挂掉了，请求全部走数据库。</text><text id="kity_text_10237" text-rendering="inherit" font-size="12" dy=".8em" y="94.70000004768372" x="548.5">2.对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。</text><text id="kity_text_10238" text-rendering="inherit" font-size="12" dy=".8em" y="112.70000004768372" x="548.5">回答2：</text><text id="kity_text_10239" text-rendering="inherit" font-size="12" dy=".8em" y="130.70000004768372" x="548.5">1.缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求</text><text id="kity_text_10240" text-rendering="inherit" font-size="12" dy=".8em" y="148.70000004768372" x="548.5">2.Redis挂掉了，请求全部走数据库。</text><text id="kity_text_10241" text-rendering="inherit" font-size="12" dy=".8em" y="166.70000004768372" x="548.5">3.对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。</text><text id="kity_text_10242" text-rendering="inherit" font-size="12" dy=".8em" y="184.70000004768372" x="548.5">4.热点key同一时间失效，请求打到缓存上</text></g></g><g id="minder_node1119" display="none"><g id="node_expander1116" display="none" style="cursor: pointer;"><path id="kity_path_23870" fill="white" stroke="gray" d="M532.5,137.5A6,6,0,1,1,520.5,137.5A6,6,0,1,1,532.5,137.5"></path><path id="kity_path_23871" fill="none" stroke="gray"></path></g><path id="node_outline1117" fill="none" stroke="none" d="M532.5,128.5h61a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-61a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1117" fill="black"><text id="kity_text_10249" text-rendering="inherit" font-size="12" dy=".8em" y="129.70000004768372" x="532.5">怎么解决？</text></g></g><g id="minder_node1120" display="none"><g id="node_expander1115" display="none" style="cursor: pointer;"><path id="kity_path_23867" fill="white" stroke="gray" d="M548.5,137.5A6,6,0,1,1,536.5,137.5A6,6,0,1,1,548.5,137.5"></path><path id="kity_path_23868" fill="none" stroke="gray"></path></g><path id="node_outline1116" fill="none" stroke="none" d="M548.5,119.5h653a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-653a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1116" fill="black"><text id="kity_text_10246" text-rendering="inherit" font-size="12" dy=".8em" y="120.70000004768372" x="548.5">1.redis服务不可用， 用集群，高可用，防止单点挂了，全局挂，并且单点持久化。限流，防止大量请求同一时间打到缓存上</text><text id="kity_text_10247" text-rendering="inherit" font-size="12" dy=".8em" y="138.70000004768372" x="548.5">2.热点key同一时间大面积同一时间失效， 给个合理的随机过期时间</text></g></g><g id="minder_node1121" display="none"><g id="node_expander1118" display="none" style="cursor: pointer;"><path id="kity_path_23876" fill="white" stroke="gray" d="M516.5,145.5A6,6,0,1,1,504.5,145.5A6,6,0,1,1,516.5,145.5"></path><path id="kity_path_23877" fill="none" stroke="gray"></path></g><path id="node_outline1119" fill="none" stroke="none" d="M516.5,136.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1119" fill="black"><text id="kity_text_10253" text-rendering="inherit" font-size="12" dy=".8em" y="137.70000004768372" x="516.5">进阶</text></g></g><g id="minder_node1122" display="none"><g id="node_expander1119" display="none" style="cursor: pointer;"><path id="kity_path_23879" fill="white" stroke="gray" d="M516.5,153.5A6,6,0,1,1,504.5,153.5A6,6,0,1,1,516.5,153.5"></path><path id="kity_path_23880" fill="none" stroke="gray"></path></g><path id="node_outline1120" fill="none" stroke="none" d="M516.5,144.5h108a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-108a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1120" fill="black"><text id="kity_text_10255" text-rendering="inherit" font-size="12" dy=".8em" y="145.70000004768372" x="516.5">场景&amp;问题分析优化</text></g></g><g id="minder_node1123" display="none"><g id="node_expander1129" display="none" style="cursor: pointer;"><path id="kity_path_23909" fill="white" stroke="gray" d="M500.5,161.5A6,6,0,1,1,488.5,161.5A6,6,0,1,1,500.5,161.5"></path><path id="kity_path_23910" fill="none" stroke="gray"></path></g><path id="node_outline1130" fill="none" stroke="none" d="M500.5,152.5h48a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-48a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1130" fill="black"><text id="kity_text_10283" text-rendering="inherit" font-size="12" dy=".8em" y="153.70000004768372" x="500.5">缓存击穿</text></g></g><g id="minder_node1124" display="none"><g id="node_expander1126" display="none" style="cursor: pointer;"><path id="kity_path_23900" fill="white" stroke="gray" d="M516.5,145.5A6,6,0,1,1,504.5,145.5A6,6,0,1,1,516.5,145.5"></path><path id="kity_path_23901" fill="none" stroke="gray"></path></g><path id="node_outline1127" fill="none" stroke="none" d="M516.5,136.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1127" fill="black"><text id="kity_text_10277" text-rendering="inherit" font-size="12" dy=".8em" y="137.70000004768372" x="516.5">基础</text></g></g><g id="minder_node1125" display="none"><g id="node_expander1122" display="none" style="cursor: pointer;"><path id="kity_path_23888" fill="white" stroke="gray" d="M532.5,137.5A6,6,0,1,1,520.5,137.5A6,6,0,1,1,532.5,137.5"></path><path id="kity_path_23889" fill="none" stroke="gray"></path></g><path id="node_outline1123" fill="none" stroke="none" d="M532.5,128.5h96a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-96a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1123" fill="black"><text id="kity_text_10262" text-rendering="inherit" font-size="12" dy=".8em" y="129.70000004768372" x="532.5">缓存击穿是什么？</text></g></g><g id="minder_node1126" display="none"><g id="node_expander1121" display="none" style="cursor: pointer;"><path id="kity_path_23885" fill="white" stroke="gray" d="M548.5,137.5A6,6,0,1,1,536.5,137.5A6,6,0,1,1,548.5,137.5"></path><path id="kity_path_23886" fill="none" stroke="gray"></path></g><path id="node_outline1122" fill="none" stroke="none" d="M548.5,119.5h616a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-616a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1122" fill="black"><text id="kity_text_10259" text-rendering="inherit" font-size="12" dy=".8em" y="120.70000004768372" x="548.5">1.对于一些设置了过期时间的 key，如果这些 key 可能会在某些时间点被超高并发地访问， 是一种非常热点的数据。</text><text id="kity_text_10260" text-rendering="inherit" font-size="12" dy=".8em" y="138.70000004768372" x="548.5">这个时候，这个key在大量请求来的时侯 刚好失效，这些请求就都打到了db上面，造成了db很多的压力</text></g></g><g id="minder_node1127" display="none"><g id="node_expander1125" display="none" style="cursor: pointer;"><path id="kity_path_23897" fill="white" stroke="gray" d="M532.5,145.5A6,6,0,1,1,520.5,145.5A6,6,0,1,1,532.5,145.5"></path><path id="kity_path_23898" fill="none" stroke="gray"></path></g><path id="node_outline1126" fill="none" stroke="none" d="M532.5,136.5h97a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-97a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1126" fill="black"><text id="kity_text_10275" text-rendering="inherit" font-size="12" dy=".8em" y="137.70000004768372" x="532.5">有什么解决办法？</text></g></g><g id="minder_node1128" display="none"><g id="node_expander1124" display="none" style="cursor: pointer;"><path id="kity_path_23894" fill="white" stroke="gray" d="M548.5,145.5A6,6,0,1,1,536.5,145.5A6,6,0,1,1,548.5,145.5"></path><path id="kity_path_23895" fill="none" stroke="gray"></path></g><path id="node_outline1125" fill="none" stroke="none" d="M548.5,73.5h1034a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-1034a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text1125" fill="black"><text id="kity_text_10266" text-rendering="inherit" font-size="12" dy=".8em" y="74.70000004768372" x="548.5">1.分布式锁和本地锁</text><text id="kity_text_10267" text-rendering="inherit" font-size="12" dy=".8em" y="92.70000004768372" x="548.5">可以加锁，分布式下加分布式锁，单机加本地锁，用户大并发访问时，如果获取到的value为空时，就锁上，让第一个请求去db加载数据，走正常流程，放到缓存中。</text><text id="kity_text_10268" text-rendering="inherit" font-size="12" dy=".8em" y="110.70000004768372" x="548.5">如果线程获取锁失败，就重试，</text><text id="kity_text_10269" text-rendering="inherit" font-size="12" dy=".8em" y="128.70000004768372" x="548.5">2.互斥锁，</text><text id="kity_text_10270" text-rendering="inherit" font-size="12" dy=".8em" y="146.70000004768372" x="548.5">抢到锁的话读数据库并写入缓存，抢不到锁的话也不阻塞，而是直接去读缓存，如果缓存中依然读不到数据（抢到锁的可能还没有将缓存写入成功），就等一会再试试读缓存。</text><text id="kity_text_10271" text-rendering="inherit" font-size="12" dy=".8em" y="164.70000004768372" x="548.5">3.双缓存机制</text><text id="kity_text_10272" text-rendering="inherit" font-size="12" dy=".8em" y="182.70000004768372" x="548.5">设置一级缓存和二级缓存，一级缓存过期时间短，二级缓存过期时间长或者不过期，一级缓存失效后访问二级缓存，同时刷新一级缓存和二级缓存。</text><text id="kity_text_10273" text-rendering="inherit" font-size="12" dy=".8em" y="200.70000004768372" x="548.5">一级缓存和二级缓存中数据不会同时变成失效。当一级缓存失效后，有多个请求访问，彼此之间依然是竞争锁，抢到锁的线程查询数据库并刷新缓存，而其他没有抢到锁的线程，直接访问二级缓存</text></g></g><g id="minder_node1129" display="none"><g id="node_expander1123" display="none" style="cursor: pointer;"><path id="kity_path_23891" fill="white" stroke="gray" d="M564.5,145.5A6,6,0,1,1,552.5,145.5A6,6,0,1,1,564.5,145.5"></path><path id="kity_path_23892" fill="none" stroke="gray"></path></g><path id="node_outline1124" fill="none" stroke="none" d="M489.5,48.5h200a5,5,0,0,1,5,5v96a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-96a5,5,0,0,1,5,-5z"></path><g id="node_text1124" fill="black"><text id="kity_text_10264" text-rendering="inherit" font-size="12" dy=".8em" y="137.70000004768372" x="564.5">分支主题</text></g><image id="kity_image_17057" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210324233039.png" x="489.5" y="51.5" width="200" height="83"></image></g><g id="minder_node1130" display="none"><g id="node_expander1127" display="none" style="cursor: pointer;"><path id="kity_path_23903" fill="white" stroke="gray" d="M516.5,153.5A6,6,0,1,1,504.5,153.5A6,6,0,1,1,516.5,153.5"></path><path id="kity_path_23904" fill="none" stroke="gray"></path></g><path id="node_outline1128" fill="none" stroke="none" d="M516.5,144.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1128" fill="black"><text id="kity_text_10279" text-rendering="inherit" font-size="12" dy=".8em" y="145.70000004768372" x="516.5">进阶</text></g></g><g id="minder_node1131" display="none"><g id="node_expander1128" display="none" style="cursor: pointer;"><path id="kity_path_23906" fill="white" stroke="gray" d="M516.5,161.5A6,6,0,1,1,504.5,161.5A6,6,0,1,1,516.5,161.5"></path><path id="kity_path_23907" fill="none" stroke="gray"></path></g><path id="node_outline1129" fill="none" stroke="none" d="M516.5,152.5h108a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-108a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1129" fill="black"><text id="kity_text_10281" text-rendering="inherit" font-size="12" dy=".8em" y="153.70000004768372" x="516.5">场景&amp;问题分析优化</text></g></g><g id="minder_node1132" display="none"><g id="node_expander1137" display="none" style="cursor: pointer;"><path id="kity_path_23933" fill="white" stroke="gray" d="M500.5,169.5A6,6,0,1,1,488.5,169.5A6,6,0,1,1,500.5,169.5"></path><path id="kity_path_23934" fill="none" stroke="gray"></path></g><path id="node_outline1138" fill="none" stroke="none" d="M500.5,160.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1138" fill="black"><text id="kity_text_10305" text-rendering="inherit" font-size="12" dy=".8em" y="161.70000004768372" x="500.5">缓存穿透</text></g></g><g id="minder_node1133" display="none"><g id="node_expander1134" display="none" style="cursor: pointer;"><path id="kity_path_23924" fill="white" stroke="gray" d="M516.5,153.5A6,6,0,1,1,504.5,153.5A6,6,0,1,1,516.5,153.5"></path><path id="kity_path_23925" fill="none" stroke="gray"></path></g><path id="node_outline1135" fill="none" stroke="none" d="M516.5,144.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1135" fill="black"><text id="kity_text_10299" text-rendering="inherit" font-size="12" dy=".8em" y="145.70000004768372" x="516.5">基础</text></g></g><g id="minder_node1134" display="none"><g id="node_expander1131" display="none" style="cursor: pointer;"><path id="kity_path_23915" fill="white" stroke="gray" d="M532.5,145.5A6,6,0,1,1,520.5,145.5A6,6,0,1,1,532.5,145.5"></path><path id="kity_path_23916" fill="none" stroke="gray"></path></g><path id="node_outline1132" fill="none" stroke="none" d="M532.5,136.5h97a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-97a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1132" fill="black"><text id="kity_text_10288" text-rendering="inherit" font-size="12" dy=".8em" y="137.70000004768372" x="532.5">什么是缓存穿透？</text></g></g><g id="minder_node1135" display="none"><g id="node_expander1130" display="none" style="cursor: pointer;"><path id="kity_path_23912" fill="white" stroke="gray" d="M548.5,145.5A6,6,0,1,1,536.5,145.5A6,6,0,1,1,548.5,145.5"></path><path id="kity_path_23913" fill="none" stroke="gray"></path></g><path id="node_outline1131" fill="none" stroke="none" d="M548.5,127.5h1008a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1008a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1131" fill="black"><text id="kity_text_10285" text-rendering="inherit" font-size="12" dy=".8em" y="128.70000004768372" x="548.5">1.</text><text id="kity_text_10286" text-rendering="inherit" font-size="12" dy=".8em" y="146.70000004768372" x="548.5">查询一个一定不存在的数据，由于缓存是不命中，将去查询数据库，但是数 据库也无此记录，我们没有将这次查询的 null 写入缓存，这将导致这个不存在的数据每次 请求都要到存储层去查询</text></g></g><g id="minder_node1136" display="none"><g id="node_expander1133" display="none" style="cursor: pointer;"><path id="kity_path_23921" fill="white" stroke="gray" d="M532.5,153.5A6,6,0,1,1,520.5,153.5A6,6,0,1,1,532.5,153.5"></path><path id="kity_path_23922" fill="none" stroke="gray"></path></g><path id="node_outline1134" fill="none" stroke="none" d="M532.5,144.5h97a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-97a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1134" fill="black"><text id="kity_text_10297" text-rendering="inherit" font-size="12" dy=".8em" y="145.70000004768372" x="532.5">有什么解决办法？</text></g></g><g id="minder_node1137" display="none"><g id="node_expander1132" display="none" style="cursor: pointer;"><path id="kity_path_23918" fill="white" stroke="gray" d="M548.5,153.5A6,6,0,1,1,536.5,153.5A6,6,0,1,1,548.5,153.5"></path><path id="kity_path_23919" fill="none" stroke="gray"></path></g><path id="node_outline1133" fill="none" stroke="none" d="M548.5,99.5h1076a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1076a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1133" fill="black"><text id="kity_text_10290" text-rendering="inherit" font-size="12" dy=".8em" y="100.70000004768372" x="548.5">1.缓存空对象</text><text id="kity_text_10291" text-rendering="inherit" font-size="12" dy=".8em" y="118.70000004768372" x="548.5">当一个请求过来缓存中和数据库中都不存在该请求的数据，第一次请求就会跳过缓存进行数据库的访问，并且访问数据库后返回为空，此时也将该空对象进行缓存。</text><text id="kity_text_10292" text-rendering="inherit" font-size="12" dy=".8em" y="136.70000004768372" x="548.5">下次访问该空对象就会击中缓存 ，而不是去db查</text><text id="kity_text_10293" text-rendering="inherit" font-size="12" dy=".8em" y="154.70000004768372" x="548.5">缺点：占内存 ，需要设置一个比较短的过期时间</text><text id="kity_text_10294" text-rendering="inherit" font-size="12" dy=".8em" y="172.70000004768372" x="548.5">2.布隆过滤器</text><text id="kity_text_10295" text-rendering="inherit" font-size="12" dy=".8em" y="190.70000004768372" x="548.5">启动一个系统任务或者定时任务，来初始化布隆过滤器，将热点查询数据的id放进布隆过滤器里面，当用户再次请求的时候，使用布隆过滤器进行判断，该id是否在布隆过滤器中存在，不存在直接返回null</text></g></g><g id="minder_node1138" display="none"><g id="node_expander1135" display="none" style="cursor: pointer;"><path id="kity_path_23927" fill="white" stroke="gray" d="M516.5,161.5A6,6,0,1,1,504.5,161.5A6,6,0,1,1,516.5,161.5"></path><path id="kity_path_23928" fill="none" stroke="gray"></path></g><path id="node_outline1136" fill="none" stroke="none" d="M516.5,152.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1136" fill="black"><text id="kity_text_10301" text-rendering="inherit" font-size="12" dy=".8em" y="153.70000004768372" x="516.5">进阶</text></g></g><g id="minder_node1139" display="none"><g id="node_expander1136" display="none" style="cursor: pointer;"><path id="kity_path_23930" fill="white" stroke="gray" d="M516.5,169.5A6,6,0,1,1,504.5,169.5A6,6,0,1,1,516.5,169.5"></path><path id="kity_path_23931" fill="none" stroke="gray"></path></g><path id="node_outline1137" fill="none" stroke="none" d="M516.5,160.5h108a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-108a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1137" fill="black"><text id="kity_text_10303" text-rendering="inherit" font-size="12" dy=".8em" y="161.70000004768372" x="516.5">场景&amp;问题分析优化</text></g></g><g id="minder_node1140" display="none"><g id="node_expander1140" display="none" style="cursor: pointer;"><path id="kity_path_23942" fill="white" stroke="gray" d="M500.5,177.5A6,6,0,1,1,488.5,177.5A6,6,0,1,1,500.5,177.5"></path><path id="kity_path_23943" fill="none" stroke="gray"></path></g><path id="node_outline1141" fill="none" stroke="none" d="M500.5,168.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1141" fill="black"><text id="kity_text_10317" text-rendering="inherit" font-size="12" dy=".8em" y="169.70000004768372" x="500.5">缓存预热</text></g></g><g id="minder_node1141" display="none"><g id="node_expander1139" display="none" style="cursor: pointer;"><path id="kity_path_23939" fill="white" stroke="gray" d="M516.5,177.5A6,6,0,1,1,504.5,177.5A6,6,0,1,1,516.5,177.5"></path><path id="kity_path_23940" fill="none" stroke="gray"></path></g><path id="node_outline1140" fill="none" stroke="none" d="M516.5,168.5h77a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-77a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1140" fill="black"><text id="kity_text_10315" text-rendering="inherit" font-size="12" dy=".8em" y="169.70000004768372" x="516.5">redis怎么预热</text></g></g><g id="minder_node1142" display="none"><g id="node_expander1138" display="none" style="cursor: pointer;"><path id="kity_path_23936" fill="white" stroke="gray" d="M532.5,177.5A6,6,0,1,1,520.5,177.5A6,6,0,1,1,532.5,177.5"></path><path id="kity_path_23937" fill="none" stroke="gray"></path></g><path id="node_outline1139" fill="none" stroke="none" d="M532.5,114.5h912a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-912a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text1139" fill="black"><text id="kity_text_10307" text-rendering="inherit" font-size="12" dy=".8em" y="115.70000004768372" x="532.5">1.</text><text id="kity_text_10308" text-rendering="inherit" font-size="12" dy=".8em" y="133.70000004768372" x="532.5">系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</text><text id="kity_text_10309" text-rendering="inherit" font-size="12" dy=".8em" y="151.70000004768372" x="532.5">但是不是把所有数据都放到缓存中，而是根据当天实际访问情况，统计出大概率的热点数据，然后并行去读数据写到redis中，这样就不至于上线时redis冷启动，db太大压力</text><text id="kity_text_10310" text-rendering="inherit" font-size="12" dy=".8em" y="169.70000004768372" x="532.5">2.总结起来就是</text><text id="kity_text_10311" text-rendering="inherit" font-size="12" dy=".8em" y="187.70000004768372" x="532.5">数据量不大的时候，工程启动的时候进行加载缓存动作；</text><text id="kity_text_10312" text-rendering="inherit" font-size="12" dy=".8em" y="205.70000004768372" x="532.5">数据量大的时候，设置一个定时任务脚本，进行缓存的刷新；</text><text id="kity_text_10313" text-rendering="inherit" font-size="12" dy=".8em" y="223.70000004768372" x="532.5">数据量太大的时候，优先保证热点数据进行提前加载到缓存。</text></g></g><g id="minder_node1143" display="none"><g id="node_expander1148" display="none" style="cursor: pointer;"><path id="kity_path_23966" fill="white" stroke="gray" d="M500.5,185.5A6,6,0,1,1,488.5,185.5A6,6,0,1,1,500.5,185.5"></path><path id="kity_path_23967" fill="none" stroke="gray"></path></g><path id="node_outline1149" fill="none" stroke="none" d="M500.5,176.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1149" fill="black"><text id="kity_text_10337" text-rendering="inherit" font-size="12" dy=".8em" y="177.70000004768372" x="500.5">缓存降级</text></g></g><g id="minder_node1144" display="none"><g id="node_expander1145" display="none" style="cursor: pointer;"><path id="kity_path_23957" fill="white" stroke="gray" d="M516.5,169.5A6,6,0,1,1,504.5,169.5A6,6,0,1,1,516.5,169.5"></path><path id="kity_path_23958" fill="none" stroke="gray"></path></g><path id="node_outline1146" fill="none" stroke="none" d="M516.5,160.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1146" fill="black"><text id="kity_text_10331" text-rendering="inherit" font-size="12" dy=".8em" y="161.70000004768372" x="516.5">基础</text></g></g><g id="minder_node1145" display="none"><g id="node_expander1142" display="none" style="cursor: pointer;"><path id="kity_path_23948" fill="white" stroke="gray" d="M532.5,161.5A6,6,0,1,1,520.5,161.5A6,6,0,1,1,532.5,161.5"></path><path id="kity_path_23949" fill="none" stroke="gray"></path></g><path id="node_outline1143" fill="none" stroke="none" d="M532.5,152.5h96a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-96a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1143" fill="black"><text id="kity_text_10323" text-rendering="inherit" font-size="12" dy=".8em" y="153.70000004768372" x="532.5">缓存降级是什么？</text></g></g><g id="minder_node1146" display="none"><g id="node_expander1141" display="none" style="cursor: pointer;"><path id="kity_path_23945" fill="white" stroke="gray" d="M548.5,161.5A6,6,0,1,1,536.5,161.5A6,6,0,1,1,548.5,161.5"></path><path id="kity_path_23946" fill="none" stroke="gray"></path></g><path id="node_outline1142" fill="none" stroke="none" d="M548.5,134.5h841a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-841a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1142" fill="black"><text id="kity_text_10319" text-rendering="inherit" font-size="12" dy=".8em" y="135.70000004768372" x="548.5">1.</text><text id="kity_text_10320" text-rendering="inherit" font-size="12" dy=".8em" y="153.70000004768372" x="548.5">缓存降级是指当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务</text><text id="kity_text_10321" text-rendering="inherit" font-size="12" dy=".8em" y="171.70000004768372" x="548.5">最终目的就是保证服务不要挂了 保证可用，需要注意的是什么可以容忍降级，什么不可以，</text></g></g><g id="minder_node1147" display="none"><g id="node_expander1144" display="none" style="cursor: pointer;"><path id="kity_path_23954" fill="white" stroke="gray" d="M532.5,169.5A6,6,0,1,1,520.5,169.5A6,6,0,1,1,532.5,169.5"></path><path id="kity_path_23955" fill="none" stroke="gray"></path></g><path id="node_outline1145" fill="none" stroke="none" d="M532.5,160.5h96a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-96a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1145" fill="black"><text id="kity_text_10329" text-rendering="inherit" font-size="12" dy=".8em" y="161.70000004768372" x="532.5">缓存降级怎么做？</text></g></g><g id="minder_node1148" display="none"><g id="node_expander1143" display="none" style="cursor: pointer;"><path id="kity_path_23951" fill="white" stroke="gray" d="M548.5,169.5A6,6,0,1,1,536.5,169.5A6,6,0,1,1,548.5,169.5"></path><path id="kity_path_23952" fill="none" stroke="gray"></path></g><path id="node_outline1144" fill="none" stroke="none" d="M548.5,142.5h820a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-820a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1144" fill="black"><text id="kity_text_10325" text-rendering="inherit" font-size="12" dy=".8em" y="143.70000004768372" x="548.5">1.</text><text id="kity_text_10326" text-rendering="inherit" font-size="12" dy=".8em" y="161.70000004768372" x="548.5">比如说我们缓存中的一些默认信息，使用这些默认信息来作为降级时默认返回用户的数据，当然这些都不是最核心的，可以采用系统自动降级 和人工降级，</text><text id="kity_text_10327" text-rendering="inherit" font-size="12" dy=".8em" y="179.70000004768372" x="548.5">而一般像redis真的不可用了，也可以给用户一个默认页面之类的，而不全去数据库查，尽量减少对整体业务流程的影响。</text></g></g><g id="minder_node1149" display="none"><g id="node_expander1146" display="none" style="cursor: pointer;"><path id="kity_path_23960" fill="white" stroke="gray" d="M516.5,177.5A6,6,0,1,1,504.5,177.5A6,6,0,1,1,516.5,177.5"></path><path id="kity_path_23961" fill="none" stroke="gray"></path></g><path id="node_outline1147" fill="none" stroke="none" d="M516.5,168.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1147" fill="black"><text id="kity_text_10333" text-rendering="inherit" font-size="12" dy=".8em" y="169.70000004768372" x="516.5">进阶</text></g></g><g id="minder_node1150" display="none"><g id="node_expander1147" display="none" style="cursor: pointer;"><path id="kity_path_23963" fill="white" stroke="gray" d="M516.5,185.5A6,6,0,1,1,504.5,185.5A6,6,0,1,1,516.5,185.5"></path><path id="kity_path_23964" fill="none" stroke="gray"></path></g><path id="node_outline1148" fill="none" stroke="none" d="M516.5,176.5h108a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-108a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1148" fill="black"><text id="kity_text_10335" text-rendering="inherit" font-size="12" dy=".8em" y="177.70000004768372" x="516.5">场景&amp;问题分析优化</text></g></g><g id="minder_node1151" display="none"><g id="node_expander1152" display="none" style="cursor: pointer;"><path id="kity_path_23978" fill="white" stroke="gray" d="M500.5,193.5A6,6,0,1,1,488.5,193.5A6,6,0,1,1,500.5,193.5"></path><path id="kity_path_23979" fill="none" stroke="gray"></path></g><path id="node_outline1153" fill="none" stroke="none" d="M500.5,184.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1153" fill="black"><text id="kity_text_10349" text-rendering="inherit" font-size="12" dy=".8em" y="185.70000004768372" x="500.5">项目优化</text></g></g><g id="minder_node1152" display="none"><g id="node_expander1151" display="none" style="cursor: pointer;"><path id="kity_path_23975" fill="white" stroke="gray" d="M516.5,193.5A6,6,0,1,1,504.5,193.5A6,6,0,1,1,516.5,193.5"></path><path id="kity_path_23976" fill="none" stroke="gray"></path></g><path id="node_outline1152" fill="none" stroke="none" d="M516.5,184.5h100a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-100a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1152" fill="black"><text id="kity_text_10347" text-rendering="inherit" font-size="12" dy=".8em" y="185.70000004768372" x="516.5">redis慢查询了解吗</text></g></g><g id="minder_node1153" display="none"><g id="node_expander1150" display="none" style="cursor: pointer;"><path id="kity_path_23972" fill="white" stroke="gray" d="M532.5,193.5A6,6,0,1,1,520.5,193.5A6,6,0,1,1,532.5,193.5"></path><path id="kity_path_23973" fill="none" stroke="gray"></path></g><path id="node_outline1151" fill="none" stroke="none" d="M532.5,148.5h740a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-740a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1151" fill="black"><text id="kity_text_10341" text-rendering="inherit" font-size="12" dy=".8em" y="149.70000004768372" x="532.5">1.</text><text id="kity_text_10342" text-rendering="inherit" font-size="12" dy=".8em" y="167.70000004768372" x="532.5">Redis 提供了lowlog-log-slower-than配置来设置预设阀值，它的单位是微秒（1 秒=1000 毫秒=1000000 微秒），</text><text id="kity_text_10343" text-rendering="inherit" font-size="12" dy=".8em" y="185.70000004768372" x="532.5">默认值是 10000，假如执行了一条“很慢”的命令（例如 keys*），如果它的执行时间超过了 10000 微秒，那么它将被记录在慢查询日志中</text><text id="kity_text_10344" text-rendering="inherit" font-size="12" dy=".8em" y="203.70000004768372" x="532.5">2.</text><text id="kity_text_10345" text-rendering="inherit" font-size="12" dy=".8em" y="221.70000004768372" x="532.5">慢查询只记录命令执行时间，并不包括命令排队和网络传输时间。因此客户端执行命令的时间会大于命令实际执行时间。</text></g></g><g id="minder_node1154" display="none"><g id="node_expander1149" display="none" style="cursor: pointer;"><path id="kity_path_23969" fill="white" stroke="gray" d="M548.5,193.5A6,6,0,1,1,536.5,193.5A6,6,0,1,1,548.5,193.5"></path><path id="kity_path_23970" fill="none" stroke="gray"></path></g><path id="node_outline1150" fill="none" stroke="none" d="M548.5,179.5h79a5,5,0,0,1,5,5v18a5,5,0,0,1,-5,5h-79a5,5,0,0,1,-5,-5v-18a5,5,0,0,1,5,-5z"></path><g id="node_text1150" fill="black"><text id="kity_text_10339" text-rendering="inherit" font-size="12" dy=".8em" y="185.70000004768372" x="548.5">分支主题</text></g><a id="kity_a_16934" xlink:href="https://juejin.cn/post/6904197863820296200" target="_blank" xlink:title="https://juejin.cn/post/6904197863820296200" style="cursor: pointer;"><path id="kity_path_16936" fill="rgba(255, 255, 255, 0)" stroke="none" d="M607.5,182.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16935" fill="#666" stroke="none" d="M622.114,198.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V192.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C617.766,189.571,619.168,188.5,620.836,188.5h1.278c2.116,0,3.834,1.716,3.834,3.834V194.89C625.948,197.008,624.23,198.724,622.114,198.724zM610.612,193.612c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S620.265,194.89,619.558,194.89H611.89C611.185,194.89,610.612,194.319,610.612,193.612zM608.056,192.334V194.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H609.334C607.216,198.724,605.5,197.008,605.5,194.89V192.334C605.5,190.216,607.216,188.5,609.334,188.5h1.278c1.667,0,3.071,1.071,3.599,2.556H609.334C608.629,191.056,608.056,191.627,608.056,192.334z"></path></a></g><g id="minder_node1155" display="none"><g id="node_expander1181" display="none" style="cursor: pointer;"><path id="kity_path_24065" fill="white" stroke="gray" d="M500.5,201.5A6,6,0,1,1,488.5,201.5A6,6,0,1,1,500.5,201.5"></path><path id="kity_path_24066" fill="none" stroke="gray"></path></g><path id="node_outline1182" fill="none" stroke="none" d="M500.5,192.5h110a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-110a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1182" fill="black"><text id="kity_text_10424" text-rendering="inherit" font-size="12" dy=".8em" y="193.70000004768372" x="500.5">项目问题和排查解决</text></g></g><g id="minder_node1156" display="none"><g id="node_expander1153" display="none" style="cursor: pointer;"><path id="kity_path_23981" fill="white" stroke="gray" d="M516.5,81.5A6,6,0,1,1,504.5,81.5A6,6,0,1,1,516.5,81.5"></path><path id="kity_path_23982" fill="none" stroke="gray"></path></g><path id="node_outline1154" fill="none" stroke="none" d="M516.5,72.5h149a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-149a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1154" fill="black"><text id="kity_text_10351" text-rendering="inherit" font-size="12" dy=".8em" y="73.70000004768372" x="516.5">你们的项目哪里用到了redis</text></g></g><g id="minder_node1157" display="none"><g id="node_expander1155" display="none" style="cursor: pointer;"><path id="kity_path_23987" fill="white" stroke="gray" d="M516.5,89.5A6,6,0,1,1,504.5,89.5A6,6,0,1,1,516.5,89.5"></path><path id="kity_path_23988" fill="none" stroke="gray"></path></g><path id="node_outline1156" fill="none" stroke="none" d="M516.5,80.5h88a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-88a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1156" fill="black"><text id="kity_text_10355" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="516.5">为什么要用redis</text></g></g><g id="minder_node1158" display="none"><g id="node_expander1154" display="none" style="cursor: pointer;"><path id="kity_path_23984" fill="white" stroke="gray" d="M532.5,89.5A6,6,0,1,1,520.5,89.5A6,6,0,1,1,532.5,89.5"></path><path id="kity_path_23985" fill="none" stroke="gray"></path></g><path id="node_outline1155" fill="none" stroke="none" d="M532.5,80.5h10a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-10a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1155" fill="black"><text id="kity_text_10353" text-rendering="inherit" font-size="12" dy=".8em" y="81.70000004768372" x="532.5">1.</text></g></g><g id="minder_node1159" display="none"><g id="node_expander1156" display="none" style="cursor: pointer;"><path id="kity_path_23990" fill="white" stroke="gray" d="M516.5,97.5A6,6,0,1,1,504.5,97.5A6,6,0,1,1,516.5,97.5"></path><path id="kity_path_23991" fill="none" stroke="gray"></path></g><path id="node_outline1157" fill="none" stroke="none" d="M516.5,88.5h136a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-136a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1157" fill="black"><text id="kity_text_10357" text-rendering="inherit" font-size="12" dy=".8em" y="89.70000004768372" x="516.5">redis还可以用到哪些场景</text></g></g><g id="minder_node1160" display="none"><g id="node_expander1158" display="none" style="cursor: pointer;"><path id="kity_path_23996" fill="white" stroke="gray" d="M516.5,105.5A6,6,0,1,1,504.5,105.5A6,6,0,1,1,516.5,105.5"></path><path id="kity_path_23997" fill="none" stroke="gray"></path></g><path id="node_outline1159" fill="none" stroke="none" d="M516.5,96.5h113a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-113a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1159" fill="black"><text id="kity_text_10361" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="516.5">有redis的其他选型吗</text></g></g><g id="minder_node1161" display="none"><g id="node_expander1157" display="none" style="cursor: pointer;"><path id="kity_path_23993" fill="white" stroke="gray" d="M532.5,105.5A6,6,0,1,1,520.5,105.5A6,6,0,1,1,532.5,105.5"></path><path id="kity_path_23994" fill="none" stroke="gray"></path></g><path id="node_outline1158" fill="none" stroke="none" d="M532.5,96.5h155a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-155a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1158" fill="black"><text id="kity_text_10359" text-rendering="inherit" font-size="12" dy=".8em" y="97.70000004768372" x="532.5">如果你回答的是memcached</text></g></g><g id="minder_node1162" display="none"><g id="node_expander1160" display="none" style="cursor: pointer;"><path id="kity_path_24002" fill="white" stroke="gray" d="M516.5,113.5A6,6,0,1,1,504.5,113.5A6,6,0,1,1,516.5,113.5"></path><path id="kity_path_24003" fill="none" stroke="gray"></path></g><path id="node_outline1161" fill="none" stroke="none" d="M516.5,104.5h236a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-236a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1161" fill="black"><text id="kity_text_10370" text-rendering="inherit" font-size="12" dy=".8em" y="105.70000004768372" x="516.5">继续上面那个问题 和redis有什么区别知道吗</text></g></g><g id="minder_node1163" display="none"><g id="node_expander1159" display="none" style="cursor: pointer;"><path id="kity_path_23999" fill="white" stroke="gray" d="M532.5,113.5A6,6,0,1,1,520.5,113.5A6,6,0,1,1,532.5,113.5"></path><path id="kity_path_24000" fill="none" stroke="gray"></path></g><path id="node_outline1160" fill="none" stroke="none" d="M532.5,59.5h999a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-999a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1160" fill="black"><text id="kity_text_10363" text-rendering="inherit" font-size="12" dy=".8em" y="60.700000047683716" x="532.5">1)存储方式上：memcache会把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。redis</text><text id="kity_text_10364" text-rendering="inherit" font-size="12" dy=".8em" y="78.70000004768372" x="532.5">有部分数据存在硬盘上，这样能保证数据的持久性。 </text><text id="kity_text_10365" text-rendering="inherit" font-size="12" dy=".8em" y="96.70000004768372" x="532.5">  (2)数据支持类型上：memcache对数据类型的支持简单，只支持简单的key-value，而redis</text><text id="kity_text_10366" text-rendering="inherit" font-size="12" dy=".8em" y="114.70000004768372" x="532.5">支持五种数据类型。 </text><text id="kity_text_10367" text-rendering="inherit" font-size="12" dy=".8em" y="132.70000004768372" x="532.5">  (3)用底层模型不同：它们之间底层实现方式以及与客户端之间通信的应用协议不一样。redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 </text><text id="kity_text_10368" text-rendering="inherit" font-size="12" dy=".8em" y="150.70000004768372" x="532.5">  (4)value的大小：redis可以达到1GB，而memcache只有1MB。</text></g></g><g id="minder_node1164" display="none"><g id="node_expander1162" display="none" style="cursor: pointer;"><path id="kity_path_24008" fill="white" stroke="gray" d="M516.5,121.5A6,6,0,1,1,504.5,121.5A6,6,0,1,1,516.5,121.5"></path><path id="kity_path_24009" fill="none" stroke="gray"></path></g><path id="node_outline1163" fill="none" stroke="none" d="M516.5,112.5h106a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-106a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1163" fill="black"><text id="kity_text_10374" text-rendering="inherit" font-size="12" dy=".8em" y="113.70000004768372" x="516.5">单机的qps是多少？</text></g></g><g id="minder_node1165" display="none"><g id="node_expander1161" display="none" style="cursor: pointer;"><path id="kity_path_24005" fill="white" stroke="gray" d="M532.5,121.5A6,6,0,1,1,520.5,121.5A6,6,0,1,1,532.5,121.5"></path><path id="kity_path_24006" fill="none" stroke="gray"></path></g><path id="node_outline1162" fill="none" stroke="none" d="M532.5,112.5h252a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-252a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1162" fill="black"><text id="kity_text_10372" text-rendering="inherit" font-size="12" dy=".8em" y="113.70000004768372" x="532.5">1.看配置吧，大概差不多10万左右是可以到的。</text></g></g><g id="minder_node1166" display="none"><g id="node_expander1163" display="none" style="cursor: pointer;"><path id="kity_path_24011" fill="white" stroke="gray" d="M516.5,129.5A6,6,0,1,1,504.5,129.5A6,6,0,1,1,516.5,129.5"></path><path id="kity_path_24012" fill="none" stroke="gray"></path></g><path id="node_outline1164" fill="none" stroke="none" d="M516.5,120.5h329a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-329a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1164" fill="black"><text id="kity_text_10376" text-rendering="inherit" font-size="12" dy=".8em" y="121.70000004768372" x="516.5">如果一直用get，你觉得达到qps的顶点，它的限制点在哪里？</text></g></g><g id="minder_node1167" display="none"><g id="node_expander1164" display="none" style="cursor: pointer;"><path id="kity_path_24014" fill="white" stroke="gray" d="M516.5,137.5A6,6,0,1,1,504.5,137.5A6,6,0,1,1,516.5,137.5"></path><path id="kity_path_24015" fill="none" stroke="gray"></path></g><path id="node_outline1165" fill="none" stroke="none" d="M516.5,128.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1165" fill="black"><text id="kity_text_10378" text-rendering="inherit" font-size="12" dy=".8em" y="129.70000004768372" x="516.5">怎么用单线程处理的请求？</text></g></g><g id="minder_node1168" display="none"><g id="node_expander1166" display="none" style="cursor: pointer;"><path id="kity_path_24020" fill="white" stroke="gray" d="M516.5,145.5A6,6,0,1,1,504.5,145.5A6,6,0,1,1,516.5,145.5"></path><path id="kity_path_24021" fill="none" stroke="gray"></path></g><path id="node_outline1167" fill="none" stroke="none" d="M516.5,136.5h190a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-190a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1167" fill="black"><text id="kity_text_10382" text-rendering="inherit" font-size="12" dy=".8em" y="137.70000004768372" x="516.5">如何解决单机qps达到峰值的问题？</text></g></g><g id="minder_node1169" display="none"><g id="node_expander1165" display="none" style="cursor: pointer;"><path id="kity_path_24017" fill="white" stroke="gray" d="M532.5,145.5A6,6,0,1,1,520.5,145.5A6,6,0,1,1,532.5,145.5"></path><path id="kity_path_24018" fill="none" stroke="gray"></path></g><path id="node_outline1166" fill="none" stroke="none" d="M532.5,136.5h93a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-93a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1166" fill="black"><text id="kity_text_10380" text-rendering="inherit" font-size="12" dy=".8em" y="137.70000004768372" x="532.5">1.升配置，2.集群</text></g></g><g id="minder_node1170" display="none"><g id="node_expander1167" display="none" style="cursor: pointer;"><path id="kity_path_24023" fill="white" stroke="gray" d="M516.5,153.5A6,6,0,1,1,504.5,153.5A6,6,0,1,1,516.5,153.5"></path><path id="kity_path_24024" fill="none" stroke="gray"></path></g><path id="node_outline1168" fill="none" stroke="none" d="M516.5,144.5h307a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-307a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1168" fill="black"><text id="kity_text_10384" text-rendering="inherit" font-size="12" dy=".8em" y="145.70000004768372" x="516.5">如果redis中 有一个value就是特别大 ，怎么解决，说思路</text></g></g><g id="minder_node1171" display="none"><g id="node_expander1169" display="none" style="cursor: pointer;"><path id="kity_path_24029" fill="white" stroke="gray" d="M516.5,161.5A6,6,0,1,1,504.5,161.5A6,6,0,1,1,516.5,161.5"></path><path id="kity_path_24030" fill="none" stroke="gray"></path></g><path id="node_outline1170" fill="none" stroke="none" d="M516.5,152.5h113a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-113a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1170" fill="black"><text id="kity_text_10391" text-rendering="inherit" font-size="12" dy=".8em" y="153.70000004768372" x="516.5">Redis如何查看大KEY</text></g></g><g id="minder_node1172" display="none"><g id="node_expander1168" display="none" style="cursor: pointer;"><path id="kity_path_24026" fill="white" stroke="gray" d="M532.5,161.5A6,6,0,1,1,520.5,161.5A6,6,0,1,1,532.5,161.5"></path><path id="kity_path_24027" fill="none" stroke="gray"></path></g><path id="node_outline1169" fill="none" stroke="none" d="M532.5,125.5h578a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-578a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1169" fill="black"><text id="kity_text_10386" text-rendering="inherit" font-size="12" dy=".8em" y="126.70000004768372" x="532.5">1.redis-cli --bigkeys 查看5种数据类型大Key;</text><text id="kity_text_10387" text-rendering="inherit" font-size="12" dy=".8em" y="144.70000004768372" x="532.5">2.memory usage key 查看对应key的内存使用</text><text id="kity_text_10388" text-rendering="inherit" font-size="12" dy=".8em" y="162.70000004768372" x="532.5">3.debug object key 查看对应key的序列化后长度 只能看单个key</text><text id="kity_text_10389" text-rendering="inherit" font-size="12" dy=".8em" y="180.70000004768372" x="532.5">4.redis-rdb-tools工具。redis实例上执行bgsave，然后对dump出来的rdb文件进行分析，找到其中的大KEY</text></g></g><g id="minder_node1173" display="none"><g id="node_expander1171" display="none" style="cursor: pointer;"><path id="kity_path_24035" fill="white" stroke="gray" d="M516.5,169.5A6,6,0,1,1,504.5,169.5A6,6,0,1,1,516.5,169.5"></path><path id="kity_path_24036" fill="none" stroke="gray"></path></g><path id="node_outline1172" fill="none" stroke="none" d="M516.5,160.5h303a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-303a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1172" fill="black"><text id="kity_text_10395" text-rendering="inherit" font-size="12" dy=".8em" y="161.70000004768372" x="516.5">mysql大量数据，redis小量数据，怎么保证都是热点数据</text></g></g><g id="minder_node1174" display="none"><g id="node_expander1170" display="none" style="cursor: pointer;"><path id="kity_path_24032" fill="white" stroke="gray" d="M532.5,169.5A6,6,0,1,1,520.5,169.5A6,6,0,1,1,532.5,169.5"></path><path id="kity_path_24033" fill="none" stroke="gray"></path></g><path id="node_outline1171" fill="none" stroke="none" d="M532.5,160.5h73a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-73a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1171" fill="black"><text id="kity_text_10393" text-rendering="inherit" font-size="12" dy=".8em" y="161.70000004768372" x="532.5">内存淘汰策略</text></g></g><g id="minder_node1175" display="none"><g id="node_expander1174" display="none" style="cursor: pointer;"><path id="kity_path_24044" fill="white" stroke="gray" d="M516.5,177.5A6,6,0,1,1,504.5,177.5A6,6,0,1,1,516.5,177.5"></path><path id="kity_path_24045" fill="none" stroke="gray"></path></g><path id="node_outline1175" fill="none" stroke="none" d="M516.5,168.5h349a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-349a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1175" fill="black"><text id="kity_text_10410" text-rendering="inherit" font-size="12" dy=".8em" y="169.70000004768372" x="516.5">你们项目怎么保证双写一致性的问题，有哪些解决办法，对比过吗</text></g></g><g id="minder_node1176" display="none"><g id="node_expander1173" display="none" style="cursor: pointer;"><path id="kity_path_24041" fill="white" stroke="gray" d="M532.5,177.5A6,6,0,1,1,520.5,177.5A6,6,0,1,1,532.5,177.5"></path><path id="kity_path_24042" fill="none" stroke="gray"></path></g><path id="node_outline1174" fill="none" stroke="none" d="M532.5,105.5h1315a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-1315a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text1174" fill="black"><text id="kity_text_10401" text-rendering="inherit" font-size="12" dy=".8em" y="106.70000004768372" x="532.5">1.先更新db，再更新缓存：无法保证并发顺序，只能加锁，但是加锁影响性能</text><text id="kity_text_10402" text-rendering="inherit" font-size="12" dy=".8em" y="124.70000004768372" x="532.5">因为可能A先更新db，而B在更新db之前先更新了缓存，</text><text id="kity_text_10403" text-rendering="inherit" font-size="12" dy=".8em" y="142.70000004768372" x="532.5">2.先删除缓存，再更新db：可能出现脏数据，比如说 A和B两个请求，A写请求进来先删除缓存 而还没有更新db，而B读请求发现没有缓存就把查出来的数据放到redis中，而这个时侯A还没有更新db，B查出来的就是脏数据</text><text id="kity_text_10404" text-rendering="inherit" font-size="12" dy=".8em" y="160.70000004768372" x="532.5">缓存中的数据也是脏数据，这样数据就不一致了</text><text id="kity_text_10405" text-rendering="inherit" font-size="12" dy=".8em" y="178.70000004768372" x="532.5">这个方案还需要采用延时双删，就是 1 先删缓存，2 写数据库，3 等待个合理时间后再删除缓存。还可以解决mysql读写分离的主从延时 问题，具体对待多久看业务而定</text><text id="kity_text_10406" text-rendering="inherit" font-size="12" dy=".8em" y="196.70000004768372" x="532.5">这个问题相当于 B去查询数据，而从刚好还没有同步，B就是脏数据。如果影响吞吐量就异步去删，写不用阻塞。</text><text id="kity_text_10407" text-rendering="inherit" font-size="12" dy=".8em" y="214.70000004768372" x="532.5">3.先更新db，再删除缓存： 比如说A读请求，B写请求 可能出现你去删缓存，而缓存刚好失效，那么A读请求就会去把查询数据，B写请求更新数据删缓存更快，现在缓存没有了，A读请求把之前读的脏数据再写到缓存中，这就是脏数据</text><text id="kity_text_10408" text-rendering="inherit" font-size="12" dy=".8em" y="232.70000004768372" x="532.5">这个问题关键就是，A读请求比B写还慢，但是一般读都是比B快的。还可能出现删缓存失败的情况，需要重试，通过canal订阅binlog 去看哪些操作是需要缓存也要删除的。可以把这些消息放到mq中，然后定时去消费这些需要删缓存的操作再去删除</text></g></g><g id="minder_node1177" display="none"><g id="node_expander1172" display="none" style="cursor: pointer;"><path id="kity_path_24038" fill="white" stroke="gray" d="M548.5,177.5A6,6,0,1,1,536.5,177.5A6,6,0,1,1,548.5,177.5"></path><path id="kity_path_24039" fill="none" stroke="gray"></path></g><path id="node_outline1173" fill="none" stroke="none" d="M548.5,150.5h291a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-291a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1173" fill="black"><text id="kity_text_10397" text-rendering="inherit" font-size="12" dy=".8em" y="151.70000004768372" x="548.5">https://www.cnblogs.com/rjzheng/p/9041659.html</text><text id="kity_text_10398" text-rendering="inherit" font-size="12" dy=".8em" y="169.70000004768372" x="548.5">https://juejin.cn/post/6850418121754050567</text><text id="kity_text_10399" text-rendering="inherit" font-size="12" dy=".8em" y="187.70000004768372" x="548.5">https://zhuanlan.zhihu.com/p/58536781</text></g></g><g id="minder_node1178" display="none"><g id="node_expander1176" display="none" style="cursor: pointer;"><path id="kity_path_24050" fill="white" stroke="gray" d="M516.5,185.5A6,6,0,1,1,504.5,185.5A6,6,0,1,1,516.5,185.5"></path><path id="kity_path_24051" fill="none" stroke="gray"></path></g><path id="node_outline1177" fill="none" stroke="none" d="M516.5,176.5h186a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-186a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1177" fill="black"><text id="kity_text_10414" text-rendering="inherit" font-size="12" dy=".8em" y="177.70000004768372" x="516.5">缓存和DB之间怎么保证数据一致性</text></g></g><g id="minder_node1179" display="none"><g id="node_expander1175" display="none" style="cursor: pointer;"><path id="kity_path_24047" fill="white" stroke="gray" d="M532.5,185.5A6,6,0,1,1,520.5,185.5A6,6,0,1,1,532.5,185.5"></path><path id="kity_path_24048" fill="none" stroke="gray"></path></g><path id="node_outline1176" fill="none" stroke="none" d="M532.5,176.5h239a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-239a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1176" fill="black"><text id="kity_text_10412" text-rendering="inherit" font-size="12" dy=".8em" y="177.70000004768372" x="532.5">1.这个问题和上面是差不多，简单说说思想吧</text></g></g><g id="minder_node1180" display="none"><g id="node_expander1178" display="none" style="cursor: pointer;"><path id="kity_path_24056" fill="white" stroke="gray" d="M516.5,193.5A6,6,0,1,1,504.5,193.5A6,6,0,1,1,516.5,193.5"></path><path id="kity_path_24057" fill="none" stroke="gray"></path></g><path id="node_outline1179" fill="none" stroke="none" d="M516.5,184.5h173a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-173a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1179" fill="black"><text id="kity_text_10418" text-rendering="inherit" font-size="12" dy=".8em" y="185.70000004768372" x="516.5">你们项目redis的容灾你怎么做的</text></g></g><g id="minder_node1181" display="none"><g id="node_expander1177" display="none" style="cursor: pointer;"><path id="kity_path_24053" fill="white" stroke="gray" d="M532.5,193.5A6,6,0,1,1,520.5,193.5A6,6,0,1,1,532.5,193.5"></path><path id="kity_path_24054" fill="none" stroke="gray"></path></g><path id="node_outline1178" fill="none" stroke="none" d="M532.5,184.5h116a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-116a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1178" fill="black"><text id="kity_text_10416" text-rendering="inherit" font-size="12" dy=".8em" y="185.70000004768372" x="532.5">1.集群，1主2从3哨兵</text></g></g><g id="minder_node1182" display="none"><g id="node_expander1180" display="none" style="cursor: pointer;"><path id="kity_path_24062" fill="white" stroke="gray" d="M516.5,201.5A6,6,0,1,1,504.5,201.5A6,6,0,1,1,516.5,201.5"></path><path id="kity_path_24063" fill="none" stroke="gray"></path></g><path id="node_outline1181" fill="none" stroke="none" d="M516.5,192.5h246a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-246a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1181" fill="black"><text id="kity_text_10422" text-rendering="inherit" font-size="12" dy=".8em" y="193.70000004768372" x="516.5">我一次取出所有数据 使用keys * 有什么问题？</text></g></g><g id="minder_node1183" display="none"><g id="node_expander1179" display="none" style="cursor: pointer;"><path id="kity_path_24059" fill="white" stroke="gray" d="M532.5,201.5A6,6,0,1,1,520.5,201.5A6,6,0,1,1,532.5,201.5"></path><path id="kity_path_24060" fill="none" stroke="gray"></path></g><path id="node_outline1180" fill="none" stroke="none" d="M532.5,192.5h412a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-412a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1180" fill="black"><text id="kity_text_10420" text-rendering="inherit" font-size="12" dy=".8em" y="193.70000004768372" x="532.5">1.Redis单线程阻塞后面请求，类似线上服务不要执行keys *，可以分批取数据</text></g></g><g id="minder_node1184"><g id="node_expander2245" style="cursor: pointer;"><path id="kity_path_27257" fill="white" stroke="gray" d="M397.5,16139.5A6,6,0,1,1,385.5,16139.5A6,6,0,1,1,397.5,16139.5"></path><path id="kity_path_27258" fill="none" stroke="gray" d="M387,16139.5L396,16139.5"></path></g><path id="node_outline2246" fill="rgb(239, 238, 246)" stroke="rgb(123, 115, 191)" d="M401.5,16126.5h72a3,3,0,0,1,3,3v20a3,3,0,0,1,-3,3h-72a3,3,0,0,1,-3,-3v-20a3,3,0,0,1,3,-3z" stroke-width="1"></path><g id="node_text2246" fill="black"><text id="kity_text_13591" text-rendering="inherit" font-size="14" dy=".8em" y="16130.400000095367" x="418.5">5.java</text></g></g><g id="minder_node1185"><g id="node_expander1281" style="cursor: pointer;"><path id="kity_path_24365" fill="white" stroke="gray" d="M492.5,1404.5A6,6,0,1,1,480.5,1404.5A6,6,0,1,1,492.5,1404.5"></path><path id="kity_path_24366" fill="none" stroke="gray" d="M482,1404.5L491,1404.5"></path></g><path id="node_outline1282" fill="none" stroke="none" d="M497.5,1395.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z" stroke-width="3"></path><g id="node_text1282" fill="black"><text id="kity_text_10688" text-rendering="inherit" font-size="12" dy=".8em" y="1396.7000000476837" x="497.5">基础</text></g></g><g id="minder_node1186"><g id="node_expander1184" style="cursor: pointer;"><path id="kity_path_24074" fill="white" stroke="gray" d="M543.5,239.5A6,6,0,1,1,531.5,239.5A6,6,0,1,1,543.5,239.5"></path><path id="kity_path_24075" fill="none" stroke="gray" d="M533,239.5L542,239.5"></path></g><path id="node_outline1185" fill="none" stroke="none" d="M548.5,230.5h225a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-225a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1185" fill="black"><text id="kity_text_10430" text-rendering="inherit" font-size="12" dy=".8em" y="231.70000004768372" x="548.5">一个字节多少位，utf-8 一个汉字几个字节</text></g></g><g id="minder_node1187"><g id="node_expander1183" style="cursor: pointer;" display="none"><path id="kity_path_24071" fill="white" stroke="gray" d="M794.5,239.5A6,6,0,1,1,782.5,239.5A6,6,0,1,1,794.5,239.5"></path><path id="kity_path_24072" fill="none" stroke="gray"></path></g><path id="node_outline1184" fill="none" stroke="none" d="M799.5,230.5h263a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-263a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1184" fill="black"><text id="kity_text_10428" text-rendering="inherit" font-size="12" dy=".8em" y="231.70000004768372" x="799.5">1个字节1个byte是8位bit，Utf-8一个字三个字节&#xa0;</text></g></g><g id="minder_node1188"><g id="node_expander1199" style="cursor: pointer;"><path id="kity_path_24119" fill="white" stroke="gray" d="M543.5,379.5A6,6,0,1,1,531.5,379.5A6,6,0,1,1,543.5,379.5"></path><path id="kity_path_24120" fill="none" stroke="gray" d="M533,379.5L542,379.5"></path></g><path id="node_outline1200" fill="none" stroke="none" d="M548.5,370.5h82a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-82a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1200" fill="black"><text id="kity_text_10464" text-rendering="inherit" font-size="12" dy=".8em" y="371.7000000476837" x="548.5">string相关问题</text></g></g><g id="minder_node1189"><g id="node_expander1186" style="cursor: pointer;"><path id="kity_path_24080" fill="white" stroke="gray" d="M651.5,283.5A6,6,0,1,1,639.5,283.5A6,6,0,1,1,651.5,283.5"></path><path id="kity_path_24081" fill="none" stroke="gray" d="M641,283.5L650,283.5"></path></g><path id="node_outline1187" fill="none" stroke="none" d="M656.5,274.5h95a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-95a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1187" fill="black"><text id="kity_text_10436" text-rendering="inherit" font-size="12" dy=".8em" y="275.7000000476837" x="656.5">说说string常量池</text></g></g><g id="minder_node1190"><g id="node_expander1185" style="cursor: pointer;" display="none"><path id="kity_path_24077" fill="white" stroke="gray" d="M772.5,283.5A6,6,0,1,1,760.5,283.5A6,6,0,1,1,772.5,283.5"></path><path id="kity_path_24078" fill="none" stroke="gray"></path></g><path id="node_outline1186" fill="none" stroke="none" d="M777.5,256.5h465a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-465a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1186" fill="black"><text id="kity_text_10432" text-rendering="inherit" font-size="12" dy=".8em" y="257.7000000476837" x="777.5">常量池可理解为缓存 jvm避免重复创建相同的字符串而开了</text><text id="kity_text_10433" text-rendering="inherit" font-size="12" dy=".8em" y="275.7000000476837" x="777.5">一小片内存保存字符串常量 运行时常量池在jdk8是元数据区 字符串常量池还是在堆中，</text><text id="kity_text_10434" text-rendering="inherit" font-size="12" dy=".8em" y="293.7000000476837" x="777.5">虽然没有了永久代 使用字面量会直接放入常量池，new的不会</text></g></g><g id="minder_node1191"><g id="node_expander1188" style="cursor: pointer;"><path id="kity_path_24086" fill="white" stroke="gray" d="M651.5,327.5A6,6,0,1,1,639.5,327.5A6,6,0,1,1,651.5,327.5"></path><path id="kity_path_24087" fill="none" stroke="gray" d="M641,327.5L650,327.5"></path></g><path id="node_outline1189" fill="none" stroke="none" d="M656.5,318.5h261a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-261a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1189" fill="black"><text id="kity_text_10440" text-rendering="inherit" font-size="12" dy=".8em" y="319.7000000476837" x="656.5">String st1 = new String(“abc”);创建几个对象</text></g></g><g id="minder_node1192"><g id="node_expander1187" style="cursor: pointer;" display="none"><path id="kity_path_24083" fill="white" stroke="gray" d="M938.5,327.5A6,6,0,1,1,926.5,327.5A6,6,0,1,1,938.5,327.5"></path><path id="kity_path_24084" fill="none" stroke="gray"></path></g><path id="node_outline1188" fill="none" stroke="none" d="M943.5,318.5h527a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-527a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1188" fill="black"><text id="kity_text_10438" text-rendering="inherit" font-size="12" dy=".8em" y="319.7000000476837" x="943.5">1.在内存中创建两个对象，一个在堆内存，一个在常量池，堆内存对象是常量池对象的一个拷贝副本</text></g></g><g id="minder_node1193"><g id="node_expander1190" style="cursor: pointer;"><path id="kity_path_24092" fill="white" stroke="gray" d="M651.5,353.5A6,6,0,1,1,639.5,353.5A6,6,0,1,1,651.5,353.5"></path><path id="kity_path_24093" fill="none" stroke="gray" d="M641,353.5L650,353.5"></path></g><path id="node_outline1191" fill="none" stroke="none" d="M656.5,344.5h117a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-117a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1191" fill="black"><text id="kity_text_10444" text-rendering="inherit" font-size="12" dy=".8em" y="345.7000000476837" x="656.5">为什么string是final的</text></g></g><g id="minder_node1194"><g id="node_expander1189" style="cursor: pointer;" display="none"><path id="kity_path_24089" fill="white" stroke="gray" d="M794.5,353.5A6,6,0,1,1,782.5,353.5A6,6,0,1,1,794.5,353.5"></path><path id="kity_path_24090" fill="none" stroke="gray"></path></g><path id="node_outline1190" fill="none" stroke="none" d="M799.5,344.5h741a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-741a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1190" fill="black"><text id="kity_text_10442" text-rendering="inherit" font-size="12" dy=".8em" y="345.7000000476837" x="799.5">使用final关键词修饰可以避免string被修改，这样也保证了他是线程安全的&#xa0; 还有只有是不可变的才能满足常量池的需要，防止频繁计算hash</text></g></g><g id="minder_node1195"><g id="node_expander1192" style="cursor: pointer;"><path id="kity_path_24098" fill="white" stroke="gray" d="M651.5,379.5A6,6,0,1,1,639.5,379.5A6,6,0,1,1,651.5,379.5"></path><path id="kity_path_24099" fill="none" stroke="gray" d="M641,379.5L650,379.5"></path></g><path id="node_outline1193" fill="none" stroke="none" d="M656.5,370.5h84a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-84a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1193" fill="black"><text id="kity_text_10448" text-rendering="inherit" font-size="12" dy=".8em" y="371.7000000476837" x="656.5">说说intern方法</text></g></g><g id="minder_node1196"><g id="node_expander1191" style="cursor: pointer;" display="none"><path id="kity_path_24095" fill="white" stroke="gray" d="M761.5,379.5A6,6,0,1,1,749.5,379.5A6,6,0,1,1,761.5,379.5"></path><path id="kity_path_24096" fill="none" stroke="gray"></path></g><path id="node_outline1192" fill="none" stroke="none" d="M766.5,370.5h771a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-771a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1192" fill="black"><text id="kity_text_10446" text-rendering="inherit" font-size="12" dy=".8em" y="371.7000000476837" x="766.5">使用intern方法 会先去看常量池有没有这个字符串，有就直接返回引用，没有就新增并生成引用返回，这个方法可以把字符串运行时添加进常量池</text></g></g><g id="minder_node1197"><g id="node_expander1194" style="cursor: pointer;"><path id="kity_path_24104" fill="white" stroke="gray" d="M651.5,405.5A6,6,0,1,1,639.5,405.5A6,6,0,1,1,651.5,405.5"></path><path id="kity_path_24105" fill="none" stroke="gray" d="M641,405.5L650,405.5"></path></g><path id="node_outline1195" fill="none" stroke="none" d="M656.5,396.5h259a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-259a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1195" fill="black"><text id="kity_text_10452" text-rendering="inherit" font-size="12" dy=".8em" y="397.7000000476837" x="656.5">string和stringbuffer和stringbuilder的区别说说</text></g></g><g id="minder_node1198"><g id="node_expander1193" style="cursor: pointer;" display="none"><path id="kity_path_24101" fill="white" stroke="gray" d="M936.5,405.5A6,6,0,1,1,924.5,405.5A6,6,0,1,1,936.5,405.5"></path><path id="kity_path_24102" fill="none" stroke="gray"></path></g><path id="node_outline1194" fill="none" stroke="none" d="M941.5,396.5h484a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-484a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1194" fill="black"><text id="kity_text_10450" text-rendering="inherit" font-size="12" dy=".8em" y="397.7000000476837" x="941.5">首先string不可变,其他两个都是可变的,stringbuilder是非安全的,stringbuffer内使用了sync</text></g></g><g id="minder_node1199"><g id="node_expander1196" style="cursor: pointer;"><path id="kity_path_24110" fill="white" stroke="gray" d="M651.5,431.5A6,6,0,1,1,639.5,431.5A6,6,0,1,1,651.5,431.5"></path><path id="kity_path_24111" fill="none" stroke="gray" d="M641,431.5L650,431.5"></path></g><path id="node_outline1197" fill="none" stroke="none" d="M656.5,422.5h105a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-105a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1197" fill="black"><text id="kity_text_10456" text-rendering="inherit" font-size="12" dy=".8em" y="423.7000000476837" x="656.5">+和apend说说区别</text></g></g><g id="minder_node1200"><g id="node_expander1195" style="cursor: pointer;" display="none"><path id="kity_path_24107" fill="white" stroke="gray" d="M782.5,431.5A6,6,0,1,1,770.5,431.5A6,6,0,1,1,782.5,431.5"></path><path id="kity_path_24108" fill="none" stroke="gray"></path></g><path id="node_outline1196" fill="none" stroke="none" d="M787.5,422.5h437a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-437a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1196" fill="black"><text id="kity_text_10454" text-rendering="inherit" font-size="12" dy=".8em" y="423.7000000476837" x="787.5">对于字面量+变量 底层使用的是append来拼接的,会new stringbuilder性能不好，</text></g></g><g id="minder_node1201"><g id="node_expander1198" style="cursor: pointer;"><path id="kity_path_24116" fill="white" stroke="gray" d="M651.5,475.5A6,6,0,1,1,639.5,475.5A6,6,0,1,1,651.5,475.5"></path><path id="kity_path_24117" fill="none" stroke="gray" d="M641,475.5L650,475.5"></path></g><path id="node_outline1199" fill="none" stroke="none" d="M656.5,466.5h205a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-205a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1199" fill="black"><text id="kity_text_10462" text-rendering="inherit" font-size="12" dy=".8em" y="467.7000000476837" x="656.5">知道字符型常量和字符串常量的区别吗</text></g></g><g id="minder_node1202"><g id="node_expander1197" style="cursor: pointer;" display="none"><path id="kity_path_24113" fill="white" stroke="gray" d="M882.5,475.5A6,6,0,1,1,870.5,475.5A6,6,0,1,1,882.5,475.5"></path><path id="kity_path_24114" fill="none" stroke="gray"></path></g><path id="node_outline1198" fill="none" stroke="none" d="M887.5,448.5h694a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-694a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1198" fill="black"><text id="kity_text_10458" text-rendering="inherit" font-size="12" dy=".8em" y="449.7000000476837" x="887.5">（1）形式上: 字符常量是单引号引起的一个字符，字符串常量是双引号引起的若干个字符 </text><text id="kity_text_10459" text-rendering="inherit" font-size="12" dy=".8em" y="467.7000000476837" x="887.5">  （2）含义上: 字符常量相当于一个整形值( ASCII 值),可以参加表达式运算。字符串常量代表一个地址值(该字符串在内存中存放位置) </text><text id="kity_text_10460" text-rendering="inherit" font-size="12" dy=".8em" y="485.7000000476837" x="887.5">  （3）占内存大小：字符常量只占2个字节，字符串常量占若干个字节(至少一个字符结束标志) (注意：char在Java 中占两个字节)</text></g></g><g id="minder_node1203"><g id="node_expander1201" style="cursor: pointer;"><path id="kity_path_24125" fill="white" stroke="gray" d="M543.5,528.5A6,6,0,1,1,531.5,528.5A6,6,0,1,1,543.5,528.5"></path><path id="kity_path_24126" fill="none" stroke="gray" d="M533,528.5L542,528.5"></path></g><path id="node_outline1202" fill="none" stroke="none" d="M548.5,519.5h288a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-288a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1202" fill="black"><text id="kity_text_10469" text-rendering="inherit" font-size="12" dy=".8em" y="520.7000000476837" x="548.5">说说java是值传递还是引用传递，这两个有什么区别吗</text></g></g><g id="minder_node1204"><g id="node_expander1200" style="cursor: pointer;" display="none"><path id="kity_path_24122" fill="white" stroke="gray" d="M857.5,528.5A6,6,0,1,1,845.5,528.5A6,6,0,1,1,857.5,528.5"></path><path id="kity_path_24123" fill="none" stroke="gray"></path></g><path id="node_outline1201" fill="none" stroke="none" d="M862.5,510.5h600a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-600a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1201" fill="black"><text id="kity_text_10466" text-rendering="inherit" font-size="12" dy=".8em" y="511.7000000476837" x="862.5">在java世界中都是传值，传值我们对方法实参的改变都是改变他的拷贝，方法得到的是他的拷贝，不会改变原始。</text><text id="kity_text_10467" text-rendering="inherit" font-size="12" dy=".8em" y="529.7000000476837" x="862.5">而传引用会直接把引用地址传递而导致原始值被修改影响</text></g></g><g id="minder_node1205"><g id="node_expander1203" style="cursor: pointer;"><path id="kity_path_24131" fill="white" stroke="gray" d="M543.5,572.5A6,6,0,1,1,531.5,572.5A6,6,0,1,1,543.5,572.5"></path><path id="kity_path_24132" fill="none" stroke="gray" d="M533,572.5L542,572.5"></path></g><path id="node_outline1204" fill="none" stroke="none" d="M548.5,563.5h237a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-237a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1204" fill="black"><text id="kity_text_10474" text-rendering="inherit" font-size="12" dy=".8em" y="564.7000000476837" x="548.5">为什么重写equals方法要重写hashcode方法</text></g></g><g id="minder_node1206"><g id="node_expander1202" style="cursor: pointer;" display="none"><path id="kity_path_24128" fill="white" stroke="gray" d="M806.5,572.5A6,6,0,1,1,794.5,572.5A6,6,0,1,1,806.5,572.5"></path><path id="kity_path_24129" fill="none" stroke="gray"></path></g><path id="node_outline1203" fill="none" stroke="none" d="M811.5,554.5h949a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-949a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1203" fill="black"><text id="kity_text_10471" text-rendering="inherit" font-size="12" dy=".8em" y="555.7000000476837" x="811.5">equals比较的是对象值，hashcode计算的是对象的哈希值，哈希值是随机，两个对象equals等价 哈希值一定相等，而hash值相等的，equals不一定等价。</text><text id="kity_text_10472" text-rendering="inherit" font-size="12" dy=".8em" y="573.7000000476837" x="811.5">所以覆盖equals时也覆盖hashcode来保证对象等价时hash要相同，如果只覆盖任意一个的话就会导致在hashmap这些集合中存在两个相同对象而hashcode不同的情况，影响去重</text></g></g><g id="minder_node1207"><g id="node_expander1205" style="cursor: pointer;"><path id="kity_path_24137" fill="white" stroke="gray" d="M543.5,634.5A6,6,0,1,1,531.5,634.5A6,6,0,1,1,543.5,634.5"></path><path id="kity_path_24138" fill="none" stroke="gray" d="M533,634.5L542,634.5"></path></g><path id="node_outline1206" fill="none" stroke="none" d="M548.5,625.5h259a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-259a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1206" fill="black"><text id="kity_text_10481" text-rendering="inherit" font-size="12" dy=".8em" y="626.7000000476837" x="548.5">两个对象hashcode相等，他们是同一个对象吗，</text></g></g><g id="minder_node1208"><g id="node_expander1204" style="cursor: pointer;" display="none"><path id="kity_path_24134" fill="white" stroke="gray" d="M828.5,634.5A6,6,0,1,1,816.5,634.5A6,6,0,1,1,828.5,634.5"></path><path id="kity_path_24135" fill="none" stroke="gray"></path></g><path id="node_outline1205" fill="none" stroke="none" d="M833.5,598.5h215a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-215a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1205" fill="black"><text id="kity_text_10476" text-rendering="inherit" font-size="12" dy=".8em" y="599.7000000476837" x="833.5">(1)两个对象相等，hashcode一定相等 </text><text id="kity_text_10477" text-rendering="inherit" font-size="12" dy=".8em" y="617.7000000476837" x="833.5">(2)两个对象不等，hashcode不一定不等 </text><text id="kity_text_10478" text-rendering="inherit" font-size="12" dy=".8em" y="635.7000000476837" x="833.5">(3)hashcode相等，两个对象不一定相等 </text><text id="kity_text_10479" text-rendering="inherit" font-size="12" dy=".8em" y="653.7000000476837" x="833.5">(4)hashcode不等，两个对象一定不等</text></g></g><g id="minder_node1209"><g id="node_expander1207" style="cursor: pointer;"><path id="kity_path_24143" fill="white" stroke="gray" d="M543.5,687.5A6,6,0,1,1,531.5,687.5A6,6,0,1,1,543.5,687.5"></path><path id="kity_path_24144" fill="none" stroke="gray" d="M533,687.5L542,687.5"></path></g><path id="node_outline1208" fill="none" stroke="none" d="M548.5,678.5h217a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-217a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1208" fill="black"><text id="kity_text_10485" text-rendering="inherit" font-size="12" dy=".8em" y="679.7000000476837" x="548.5">可以重写父类的静态方法吗，静态变量呢</text></g></g><g id="minder_node1210"><g id="node_expander1206" style="cursor: pointer;" display="none"><path id="kity_path_24140" fill="white" stroke="gray" d="M786.5,687.5A6,6,0,1,1,774.5,687.5A6,6,0,1,1,786.5,687.5"></path><path id="kity_path_24141" fill="none" stroke="gray"></path></g><path id="node_outline1207" fill="none" stroke="none" d="M791.5,678.5h494a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-494a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1207" fill="black"><text id="kity_text_10483" text-rendering="inherit" font-size="12" dy=".8em" y="679.7000000476837" x="791.5">不可以，这样其实是隐藏，形式上是重写，其实并不是。只有成员变量和静态方法可以被隐藏</text></g></g><g id="minder_node1211"><g id="node_expander1209" style="cursor: pointer;"><path id="kity_path_24149" fill="white" stroke="gray" d="M543.5,722.5A6,6,0,1,1,531.5,722.5A6,6,0,1,1,543.5,722.5"></path><path id="kity_path_24150" fill="none" stroke="gray" d="M533,722.5L542,722.5"></path></g><path id="node_outline1210" fill="none" stroke="none" d="M548.5,713.5h228a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-228a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1210" fill="black"><text id="kity_text_10490" text-rendering="inherit" font-size="12" dy=".8em" y="714.7000000476837" x="548.5">final static 和static 修饰变量有什么区别吗</text></g></g><g id="minder_node1212"><g id="node_expander1208" style="cursor: pointer;" display="none"><path id="kity_path_24146" fill="white" stroke="gray" d="M797.5,722.5A6,6,0,1,1,785.5,722.5A6,6,0,1,1,797.5,722.5"></path><path id="kity_path_24147" fill="none" stroke="gray"></path></g><path id="node_outline1209" fill="none" stroke="none" d="M802.5,704.5h939a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-939a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1209" fill="black"><text id="kity_text_10487" text-rendering="inherit" font-size="12" dy=".8em" y="705.7000000476837" x="802.5">如果变量被static修饰，在类加载时如果没有指令给变量赋值，那么变量就是默认值,只初始化时正确赋值一次,</text><text id="kity_text_10488" text-rendering="inherit" font-size="12" dy=".8em" y="723.7000000476837" x="802.5">如果被final修饰,也就是说编译时值就定下来了，在编译时会被constantValue修饰，让变量在类加载准备期就被赋值，然后放入常量池，用到这个变量的地方都将被影响替换该值</text></g></g><g id="minder_node1213"><g id="node_expander1211" style="cursor: pointer;"><path id="kity_path_24155" fill="white" stroke="gray" d="M543.5,766.5A6,6,0,1,1,531.5,766.5A6,6,0,1,1,543.5,766.5"></path><path id="kity_path_24156" fill="none" stroke="gray" d="M533,766.5L542,766.5"></path></g><path id="node_outline1212" fill="none" stroke="none" d="M548.5,748.5h218a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-218a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1212" fill="black"><text id="kity_text_10495" text-rendering="inherit" font-size="12" dy=".8em" y="749.7000000476837" x="548.5">说说序列化和反序列化，怎么防止序列化</text><text id="kity_text_10496" text-rendering="inherit" font-size="12" dy=".8em" y="767.7000000476837" x="548.5">serialVersionUID作用?</text></g></g><g id="minder_node1214"><g id="node_expander1210" style="cursor: pointer;" display="none"><path id="kity_path_24152" fill="white" stroke="gray" d="M787.5,766.5A6,6,0,1,1,775.5,766.5A6,6,0,1,1,787.5,766.5"></path><path id="kity_path_24153" fill="none" stroke="gray"></path></g><path id="node_outline1211" fill="none" stroke="none" d="M792.5,748.5h861a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-861a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1211" fill="black"><text id="kity_text_10492" text-rendering="inherit" font-size="12" dy=".8em" y="749.7000000476837" x="792.5">序列化就是把对象转字节序列，反之即反序列化。序列化可以让对象在网络传输，让对象持久化在硬盘。</text><text id="kity_text_10493" text-rendering="inherit" font-size="12" dy=".8em" y="767.7000000476837" x="792.5">比如大量用户访问时创建了大量的session对象，就可以先序列化到硬盘上减少内存压力。我们可以所以transient关键字来序列化时忽略该值，反序列化时为默认值</text></g></g><g id="minder_node1215"><g id="node_expander1213" style="cursor: pointer;"><path id="kity_path_24161" fill="white" stroke="gray" d="M543.5,801.5A6,6,0,1,1,531.5,801.5A6,6,0,1,1,543.5,801.5"></path><path id="kity_path_24162" fill="none" stroke="gray" d="M533,801.5L542,801.5"></path></g><path id="node_outline1214" fill="none" stroke="none" d="M548.5,792.5h134a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-134a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1214" fill="black"><text id="kity_text_10500" text-rendering="inherit" font-size="12" dy=".8em" y="793.7000000476837" x="548.5">什么场景反序列化会失败</text></g></g><g id="minder_node1216"><g id="node_expander1212" style="cursor: pointer;" display="none"><path id="kity_path_24158" fill="white" stroke="gray" d="M703.5,801.5A6,6,0,1,1,691.5,801.5A6,6,0,1,1,703.5,801.5"></path><path id="kity_path_24159" fill="none" stroke="gray"></path></g><path id="node_outline1213" fill="none" stroke="none" d="M708.5,792.5h338a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-338a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1213" fill="black"><text id="kity_text_10498" text-rendering="inherit" font-size="12" dy=".8em" y="793.7000000476837" x="708.5">序列化ID：serialVersionUID不一致的时候，导致反序列化失败</text></g></g><g id="minder_node1217"><g id="node_expander1215" style="cursor: pointer;"><path id="kity_path_24167" fill="white" stroke="gray" d="M543.5,827.5A6,6,0,1,1,531.5,827.5A6,6,0,1,1,543.5,827.5"></path><path id="kity_path_24168" fill="none" stroke="gray" d="M533,827.5L542,827.5"></path></g><path id="node_outline1216" fill="none" stroke="none" d="M548.5,818.5h89a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-89a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1216" fill="black"><text id="kity_text_10504" text-rendering="inherit" font-size="12" dy=".8em" y="819.7000000476837" x="548.5">Integer会缓存吗</text></g></g><g id="minder_node1218"><g id="node_expander1214" style="cursor: pointer;" display="none"><path id="kity_path_24164" fill="white" stroke="gray" d="M658.5,827.5A6,6,0,1,1,646.5,827.5A6,6,0,1,1,658.5,827.5"></path><path id="kity_path_24165" fill="none" stroke="gray"></path></g><path id="node_outline1215" fill="none" stroke="none" d="M663.5,818.5h1172a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1172a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1215" fill="black"><text id="kity_text_10502" text-rendering="inherit" font-size="12" dy=".8em" y="819.7000000476837" x="663.5">可以，jvm优化了对Integer相同对象引用的重用和缓存。默认是-128-127之间，这个是默认的值，我们可以之间灵活调整。这个缓存会在Integer第一次初始化创建出来。除了integer还有byte short 不过这几个不能改变。</text></g></g><g id="minder_node1219"><g id="node_expander1217" style="cursor: pointer;"><path id="kity_path_24173" fill="white" stroke="gray" d="M543.5,853.5A6,6,0,1,1,531.5,853.5A6,6,0,1,1,543.5,853.5"></path><path id="kity_path_24174" fill="none" stroke="gray" d="M533,853.5L542,853.5"></path></g><path id="node_outline1218" fill="none" stroke="none" d="M548.5,844.5h110a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-110a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1218" fill="black"><text id="kity_text_10508" text-rendering="inherit" font-size="12" dy=".8em" y="845.7000000476837" x="548.5">说说类的初始化顺序</text></g></g><g id="minder_node1220"><g id="node_expander1216" style="cursor: pointer;" display="none"><path id="kity_path_24170" fill="white" stroke="gray" d="M679.5,853.5A6,6,0,1,1,667.5,853.5A6,6,0,1,1,679.5,853.5"></path><path id="kity_path_24171" fill="none" stroke="gray"></path></g><path id="node_outline1217" fill="none" stroke="none" d="M684.5,844.5h748a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-748a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1217" fill="black"><text id="kity_text_10506" text-rendering="inherit" font-size="12" dy=".8em" y="845.7000000476837" x="684.5">父类的静态变量和静态代码块，子类的静态变量和静态代码块，父类的普通成员变量 代码块 和构造器，子类的普通成员变量 代码块 和构造器</text></g></g><g id="minder_node1221"><g id="node_expander1219" style="cursor: pointer;"><path id="kity_path_24179" fill="white" stroke="gray" d="M543.5,879.5A6,6,0,1,1,531.5,879.5A6,6,0,1,1,543.5,879.5"></path><path id="kity_path_24180" fill="none" stroke="gray" d="M533,879.5L542,879.5"></path></g><path id="node_outline1220" fill="none" stroke="none" d="M548.5,870.5h93a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-93a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1220" fill="black"><text id="kity_text_10512" text-rendering="inherit" font-size="12" dy=".8em" y="871.7000000476837" x="548.5">说说==和equals</text></g></g><g id="minder_node1222"><g id="node_expander1218" style="cursor: pointer;" display="none"><path id="kity_path_24176" fill="white" stroke="gray" d="M662.5,879.5A6,6,0,1,1,650.5,879.5A6,6,0,1,1,662.5,879.5"></path><path id="kity_path_24177" fill="none" stroke="gray"></path></g><path id="node_outline1219" fill="none" stroke="none" d="M667.5,870.5h685a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-685a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1219" fill="black"><text id="kity_text_10510" text-rendering="inherit" font-size="12" dy=".8em" y="871.7000000476837" x="667.5">==对于基本数据类型比较的是值 对于引用类型比较的是内存地址，，equals是Object中的方法，比较的是引用对象值是否相等，</text></g></g><g id="minder_node1223"><g id="node_expander1221" style="cursor: pointer;"><path id="kity_path_24185" fill="white" stroke="gray" d="M543.5,914.5A6,6,0,1,1,531.5,914.5A6,6,0,1,1,543.5,914.5"></path><path id="kity_path_24186" fill="none" stroke="gray" d="M533,914.5L542,914.5"></path></g><path id="node_outline1222" fill="none" stroke="none" d="M548.5,905.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1222" fill="black"><text id="kity_text_10517" text-rendering="inherit" font-size="12" dy=".8em" y="906.7000000476837" x="548.5">说说深拷贝和浅拷贝</text></g></g><g id="minder_node1224"><g id="node_expander1220" style="cursor: pointer;" display="none"><path id="kity_path_24182" fill="white" stroke="gray" d="M678.5,914.5A6,6,0,1,1,666.5,914.5A6,6,0,1,1,678.5,914.5"></path><path id="kity_path_24183" fill="none" stroke="gray"></path></g><path id="node_outline1221" fill="none" stroke="none" d="M683.5,896.5h982a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-982a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1221" fill="black"><text id="kity_text_10514" text-rendering="inherit" font-size="12" dy=".8em" y="897.7000000476837" x="683.5">浅拷贝 对基本数据类型值拷贝 引用类型引用拷贝（实际还是同一个对象）的拷贝，只对拷贝对象复制&#xa0; 深拷贝是 基本数据类型还是值传递拷贝，而引用类型的是创建新对象 复制其内容。</text><text id="kity_text_10515" text-rendering="inherit" font-size="12" dy=".8em" y="915.7000000476837" x="683.5">这两种拷贝都要实现Object中的clone方法（只能对当前对象浅拷贝，传递引用），也就是实现Cloneable接口。</text></g></g><g id="minder_node1225"><g id="node_expander1223" style="cursor: pointer;"><path id="kity_path_24191" fill="white" stroke="gray" d="M543.5,949.5A6,6,0,1,1,531.5,949.5A6,6,0,1,1,543.5,949.5"></path><path id="kity_path_24192" fill="none" stroke="gray" d="M533,949.5L542,949.5"></path></g><path id="node_outline1224" fill="none" stroke="none" d="M548.5,940.5h73a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-73a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1224" fill="black"><text id="kity_text_10521" text-rendering="inherit" font-size="12" dy=".8em" y="941.7000000476837" x="548.5">再说说零拷贝</text></g></g><g id="minder_node1226"><g id="node_expander1222" style="cursor: pointer;" display="none"><path id="kity_path_24188" fill="white" stroke="gray" d="M642.5,949.5A6,6,0,1,1,630.5,949.5A6,6,0,1,1,642.5,949.5"></path><path id="kity_path_24189" fill="none" stroke="gray"></path></g><path id="node_outline1223" fill="none" stroke="none" d="M647.5,940.5h1231a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1231a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1223" fill="black"><text id="kity_text_10519" text-rendering="inherit" font-size="12" dy=".8em" y="941.7000000476837" x="647.5">零拷贝减少了内核态和用户态的上下文切换，减少了数据拷贝的次数，提高了性能，之前数据拷贝需要四次的，而实际上用户态缓冲区是没必要的，linux实现零拷贝是用DMA技术让数据拷贝不需要cpu参与，因为不在内存层面上拷贝</text></g></g><g id="minder_node1227"><g id="node_expander1225" style="cursor: pointer;"><path id="kity_path_24197" fill="white" stroke="gray" d="M543.5,984.5A6,6,0,1,1,531.5,984.5A6,6,0,1,1,543.5,984.5"></path><path id="kity_path_24198" fill="none" stroke="gray" d="M533,984.5L542,984.5"></path></g><path id="node_outline1226" fill="none" stroke="none" d="M548.5,975.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1226" fill="black"><text id="kity_text_10526" text-rendering="inherit" font-size="12" dy=".8em" y="976.7000000476837" x="548.5">说说实现深拷贝的过程。</text></g></g><g id="minder_node1228"><g id="node_expander1224" style="cursor: pointer;" display="none"><path id="kity_path_24194" fill="white" stroke="gray" d="M702.5,984.5A6,6,0,1,1,690.5,984.5A6,6,0,1,1,702.5,984.5"></path><path id="kity_path_24195" fill="none" stroke="gray"></path></g><path id="node_outline1225" fill="none" stroke="none" d="M707.5,966.5h738a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-738a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1225" fill="black"><text id="kity_text_10523" text-rendering="inherit" font-size="12" dy=".8em" y="967.7000000476837" x="707.5">1.声明实现Cloneable接口，重写clone方法，如A 和B都实现了接口cloneable，然后B是A的一个全局引用变量，通过A.b = b.clone来 实现</text><text id="kity_text_10524" text-rendering="inherit" font-size="12" dy=".8em" y="985.7000000476837" x="707.5">2.实现Serializable接口，通过序列化和反序列化字节流实现深拷贝</text></g></g><g id="minder_node1229"><g id="node_expander1227" style="cursor: pointer;"><path id="kity_path_24203" fill="white" stroke="gray" d="M543.5,1019.5A6,6,0,1,1,531.5,1019.5A6,6,0,1,1,543.5,1019.5"></path><path id="kity_path_24204" fill="none" stroke="gray" d="M533,1019.5L542,1019.5"></path></g><path id="node_outline1228" fill="none" stroke="none" d="M548.5,1010.5h317a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-317a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1228" fill="black"><text id="kity_text_10530" text-rendering="inherit" font-size="12" dy=".8em" y="1011.7000000476837" x="548.5">Java&#xa0;中定义一个不做事且没有参数的构造方法的作用知道吗</text></g></g><g id="minder_node1230"><g id="node_expander1226" style="cursor: pointer;" display="none"><path id="kity_path_24200" fill="white" stroke="gray" d="M886.5,1019.5A6,6,0,1,1,874.5,1019.5A6,6,0,1,1,886.5,1019.5"></path><path id="kity_path_24201" fill="none" stroke="gray"></path></g><path id="node_outline1227" fill="none" stroke="none" d="M891.5,1010.5h1052a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1052a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1227" fill="black"><text id="kity_text_10528" text-rendering="inherit" font-size="12" dy=".8em" y="1011.7000000476837" x="891.5">如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。</text></g></g><g id="minder_node1231"><g id="node_expander1229" style="cursor: pointer;"><path id="kity_path_24209" fill="white" stroke="gray" d="M543.5,1063.5A6,6,0,1,1,531.5,1063.5A6,6,0,1,1,543.5,1063.5"></path><path id="kity_path_24210" fill="none" stroke="gray" d="M533,1063.5L542,1063.5"></path></g><path id="node_outline1230" fill="none" stroke="none" d="M548.5,1054.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1230" fill="black"><text id="kity_text_10536" text-rendering="inherit" font-size="12" dy=".8em" y="1055.7000000476837" x="548.5">说说抽象类和普通类的区别</text></g></g><g id="minder_node1232"><g id="node_expander1228" style="cursor: pointer;" display="none"><path id="kity_path_24206" fill="white" stroke="gray" d="M714.5,1063.5A6,6,0,1,1,702.5,1063.5A6,6,0,1,1,714.5,1063.5"></path><path id="kity_path_24207" fill="none" stroke="gray"></path></g><path id="node_outline1229" fill="none" stroke="none" d="M719.5,1036.5h752a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-752a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1229" fill="black"><text id="kity_text_10532" text-rendering="inherit" font-size="12" dy=".8em" y="1037.7000000476837" x="719.5">1.抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。</text><text id="kity_text_10533" text-rendering="inherit" font-size="12" dy=".8em" y="1055.7000000476837" x="719.5">2.抽象类不能实例化创建对象；</text><text id="kity_text_10534" text-rendering="inherit" font-size="12" dy=".8em" y="1073.7000000476837" x="719.5">3.如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。</text></g></g><g id="minder_node1233"><g id="node_expander1231" style="cursor: pointer;"><path id="kity_path_24215" fill="white" stroke="gray" d="M543.5,1152.5A6,6,0,1,1,531.5,1152.5A6,6,0,1,1,543.5,1152.5"></path><path id="kity_path_24216" fill="none" stroke="gray" d="M533,1152.5L542,1152.5"></path></g><path id="node_outline1232" fill="none" stroke="none" d="M548.5,1143.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1232" fill="black"><text id="kity_text_10545" text-rendering="inherit" font-size="12" dy=".8em" y="1144.7000000476837" x="548.5">说说接口和抽象类的区别</text></g></g><g id="minder_node1234"><g id="node_expander1230" style="cursor: pointer;" display="none"><path id="kity_path_24212" fill="white" stroke="gray" d="M702.5,1152.5A6,6,0,1,1,690.5,1152.5A6,6,0,1,1,702.5,1152.5"></path><path id="kity_path_24213" fill="none" stroke="gray"></path></g><path id="node_outline1231" fill="none" stroke="none" d="M707.5,1098.5h1118a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1118a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1231" fill="black"><text id="kity_text_10538" text-rendering="inherit" font-size="12" dy=".8em" y="1099.7000000476837" x="707.5">1.抽象类可以有构造器，而接口不能有构造器，接口是完全抽象的，只能有方法声明</text><text id="kity_text_10539" text-rendering="inherit" font-size="12" dy=".8em" y="1117.7000000476837" x="707.5">2.抽象类除了不能实例化，和普通类没什么区别，而接口是完全不同的类型，也不能被实例化</text><text id="kity_text_10540" text-rendering="inherit" font-size="12" dy=".8em" y="1135.7000000476837" x="707.5">3.抽象类可以使用除private的修饰符，而接口默认使用且只能使用public</text><text id="kity_text_10541" text-rendering="inherit" font-size="12" dy=".8em" y="1153.7000000476837" x="707.5">4.接口更慢，因为需要寻找实现类</text><text id="kity_text_10542" text-rendering="inherit" font-size="12" dy=".8em" y="1171.7000000476837" x="707.5">5.抽象类中添加方法，可以编写方法的默认实现，而接口必须修改</text><text id="kity_text_10543" text-rendering="inherit" font-size="12" dy=".8em" y="1189.7000000476837" x="707.5">6.抽象类-子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。接口-子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现</text></g></g><g id="minder_node1235"><g id="node_expander1233" style="cursor: pointer;"><path id="kity_path_24221" fill="white" stroke="gray" d="M543.5,1223.5A6,6,0,1,1,531.5,1223.5A6,6,0,1,1,543.5,1223.5"></path><path id="kity_path_24222" fill="none" stroke="gray" d="M533,1223.5L542,1223.5"></path></g><path id="node_outline1234" fill="none" stroke="none" d="M548.5,1214.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1234" fill="black"><text id="kity_text_10549" text-rendering="inherit" font-size="12" dy=".8em" y="1215.7000000476837" x="548.5">抽象类和接口的场景？</text></g></g><g id="minder_node1236"><g id="node_expander1232" style="cursor: pointer;" display="none"><path id="kity_path_24218" fill="white" stroke="gray" d="M690.5,1223.5A6,6,0,1,1,678.5,1223.5A6,6,0,1,1,690.5,1223.5"></path><path id="kity_path_24219" fill="none" stroke="gray"></path></g><path id="node_outline1233" fill="none" stroke="none" d="M695.5,1214.5h478a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-478a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1233" fill="black"><text id="kity_text_10547" text-rendering="inherit" font-size="12" dy=".8em" y="1215.7000000476837" x="695.5">1.抽象类一般来复用代码，减少代码冗余。接口要来提取公共代码方法，增加系统灵活性。</text></g></g><g id="minder_node1237"><g id="node_expander1235" style="cursor: pointer;"><path id="kity_path_24227" fill="white" stroke="gray" d="M543.5,1249.5A6,6,0,1,1,531.5,1249.5A6,6,0,1,1,543.5,1249.5"></path><path id="kity_path_24228" fill="none" stroke="gray" d="M533,1249.5L542,1249.5"></path></g><path id="node_outline1236" fill="none" stroke="none" d="M548.5,1240.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1236" fill="black"><text id="kity_text_10553" text-rendering="inherit" font-size="12" dy=".8em" y="1241.7000000476837" x="548.5">抽象类和抽象方法的关系</text></g></g><g id="minder_node1238"><g id="node_expander1234" style="cursor: pointer;" display="none"><path id="kity_path_24224" fill="white" stroke="gray" d="M702.5,1249.5A6,6,0,1,1,690.5,1249.5A6,6,0,1,1,702.5,1249.5"></path><path id="kity_path_24225" fill="none" stroke="gray"></path></g><path id="node_outline1235" fill="none" stroke="none" d="M707.5,1240.5h777a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-777a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1235" fill="black"><text id="kity_text_10551" text-rendering="inherit" font-size="12" dy=".8em" y="1241.7000000476837" x="707.5">1.抽象类就是来继承扩展的，在java编程思想中说的是抽象类是包括抽象方法的类，虽然声明类为抽象类可以不包括抽象方法，但是这就没有意义了</text></g></g><g id="minder_node1239"><g id="node_expander1237" style="cursor: pointer;"><path id="kity_path_24233" fill="white" stroke="gray" d="M543.5,1275.5A6,6,0,1,1,531.5,1275.5A6,6,0,1,1,543.5,1275.5"></path><path id="kity_path_24234" fill="none" stroke="gray" d="M533,1275.5L542,1275.5"></path></g><path id="node_outline1238" fill="none" stroke="none" d="M548.5,1266.5h193a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-193a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1238" fill="black"><text id="kity_text_10557" text-rendering="inherit" font-size="12" dy=".8em" y="1267.7000000476837" x="548.5">抽象类可以定义静态方法和构造器吗</text></g></g><g id="minder_node1240"><g id="node_expander1236" style="cursor: pointer;" display="none"><path id="kity_path_24230" fill="white" stroke="gray" d="M762.5,1275.5A6,6,0,1,1,750.5,1275.5A6,6,0,1,1,762.5,1275.5"></path><path id="kity_path_24231" fill="none" stroke="gray"></path></g><path id="node_outline1237" fill="none" stroke="none" d="M767.5,1266.5h170a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-170a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1237" fill="black"><text id="kity_text_10555" text-rendering="inherit" font-size="12" dy=".8em" y="1267.7000000476837" x="767.5">抽象类可以有构造器、静态方法</text></g></g><g id="minder_node1241"><g id="node_expander1239" style="cursor: pointer;"><path id="kity_path_24239" fill="white" stroke="gray" d="M543.5,1310.5A6,6,0,1,1,531.5,1310.5A6,6,0,1,1,543.5,1310.5"></path><path id="kity_path_24240" fill="none" stroke="gray" d="M533,1310.5L542,1310.5"></path></g><path id="node_outline1240" fill="none" stroke="none" d="M548.5,1301.5h123a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-123a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1240" fill="black"><text id="kity_text_10562" text-rendering="inherit" font-size="12" dy=".8em" y="1302.7000000476837" x="548.5">.java文件里面都有什么</text></g></g><g id="minder_node1242"><g id="node_expander1238" style="cursor: pointer;" display="none"><path id="kity_path_24236" fill="white" stroke="gray" d="M692.5,1310.5A6,6,0,1,1,680.5,1310.5A6,6,0,1,1,692.5,1310.5"></path><path id="kity_path_24237" fill="none" stroke="gray"></path></g><path id="node_outline1239" fill="none" stroke="none" d="M697.5,1292.5h518a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-518a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1239" fill="black"><text id="kity_text_10559" text-rendering="inherit" font-size="12" dy=".8em" y="1293.7000000476837" x="697.5">1. 类名.java文件是保存源代码的文本文件，里面最多只能有一个public修饰的类，但可有多个类。</text><text id="kity_text_10560" text-rendering="inherit" font-size="12" dy=".8em" y="1311.7000000476837" x="697.5">2.可以通过javac 类名.java 编译该文件成 .class文件，java 类名运行该文件</text></g></g><g id="minder_node1243"><g id="node_expander1241" style="cursor: pointer;"><path id="kity_path_24245" fill="white" stroke="gray" d="M543.5,1372.5A6,6,0,1,1,531.5,1372.5A6,6,0,1,1,543.5,1372.5"></path><path id="kity_path_24246" fill="none" stroke="gray" d="M533,1372.5L542,1372.5"></path></g><path id="node_outline1242" fill="none" stroke="none" d="M548.5,1363.5h127a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-127a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1242" fill="black"><text id="kity_text_10569" text-rendering="inherit" font-size="12" dy=".8em" y="1364.7000000476837" x="548.5">.class文件里面都有什么</text></g></g><g id="minder_node1244"><g id="node_expander1240" style="cursor: pointer;" display="none"><path id="kity_path_24242" fill="white" stroke="gray" d="M696.5,1372.5A6,6,0,1,1,684.5,1372.5A6,6,0,1,1,696.5,1372.5"></path><path id="kity_path_24243" fill="none" stroke="gray"></path></g><path id="node_outline1241" fill="none" stroke="none" d="M701.5,1336.5h680a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-680a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1241" fill="black"><text id="kity_text_10564" text-rendering="inherit" font-size="12" dy=".8em" y="1337.7000000476837" x="701.5">1. 类名.class文件是编译后的二进制文件，里面保存了java源代码的二进制编码和class对象。</text><text id="kity_text_10565" text-rendering="inherit" font-size="12" dy=".8em" y="1355.7000000476837" x="701.5">2.类的所有信息都会在class文件中有描述。</text><text id="kity_text_10566" text-rendering="inherit" font-size="12" dy=".8em" y="1373.7000000476837" x="701.5">3.class文件的存在是java平台无关性的关键</text><text id="kity_text_10567" text-rendering="inherit" font-size="12" dy=".8em" y="1391.7000000476837" x="701.5">4.里面主要有版本号，常量池数据项，访问权限修饰符，还有让jvm识别的标识数，还有成员列表，方法列表，其他的记不清了。</text></g></g><g id="minder_node1245"><g id="node_expander1243" style="cursor: pointer;"><path id="kity_path_24251" fill="white" stroke="gray" d="M543.5,1479.5A6,6,0,1,1,531.5,1479.5A6,6,0,1,1,543.5,1479.5"></path><path id="kity_path_24252" fill="none" stroke="gray" d="M533,1479.5L542,1479.5"></path></g><path id="node_outline1244" fill="none" stroke="none" d="M548.5,1470.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1244" fill="black"><text id="kity_text_10579" text-rendering="inherit" font-size="12" dy=".8em" y="1471.7000000476837" x="548.5">final关键字的使用和作用？</text></g></g><g id="minder_node1246"><g id="node_expander1242" style="cursor: pointer;" display="none"><path id="kity_path_24248" fill="white" stroke="gray" d="M714.5,1479.5A6,6,0,1,1,702.5,1479.5A6,6,0,1,1,714.5,1479.5"></path><path id="kity_path_24249" fill="none" stroke="gray"></path></g><path id="node_outline1243" fill="none" stroke="none" d="M719.5,1416.5h1091a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-1091a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text1243" fill="black"><text id="kity_text_10571" text-rendering="inherit" font-size="12" dy=".8em" y="1417.7000000476837" x="719.5">1.变量。修饰基本数据类型变量时，变量初始化以后就不可以修改。修饰引用类型变量时，即对象时,引用在初始化后将永远指向一个内存地址, 不可修改. 但是该内存地址中保存的对象信息, 是可以进行修改的.</text><text id="kity_text_10572" text-rendering="inherit" font-size="12" dy=".8em" y="1435.7000000476837" x="719.5">final修饰的变量会指向一块固定的内存, 这块内存中的值不能改变.</text><text id="kity_text_10573" text-rendering="inherit" font-size="12" dy=".8em" y="1453.7000000476837" x="719.5">被final修饰的常量会在编译期进入常量池,</text><text id="kity_text_10574" text-rendering="inherit" font-size="12" dy=".8em" y="1471.7000000476837" x="719.5">JDK1.8以后, 通过内部类访问外部局部变量时, 无需显式把外部局部变量声明为final.</text><text id="kity_text_10575" text-rendering="inherit" font-size="12" dy=".8em" y="1489.7000000476837" x="719.5">2.方法。锁定方法, 不让任何继承类对其进行修改。还有一个作用是方法内联，提高效率，但是现在编译器已经做的足够好了</text><text id="kity_text_10576" text-rendering="inherit" font-size="12" dy=".8em" y="1507.7000000476837" x="719.5">3.类。当程序中有永远不会被继承的类时, 可以使用final关键字修饰</text><text id="kity_text_10577" text-rendering="inherit" font-size="12" dy=".8em" y="1525.7000000476837" x="719.5">被final修饰的类所有成员方法都将被隐式修饰为final方法.</text></g></g><g id="minder_node1247"><g id="node_expander1245" style="cursor: pointer;"><path id="kity_path_24257" fill="white" stroke="gray" d="M543.5,1586.5A6,6,0,1,1,531.5,1586.5A6,6,0,1,1,543.5,1586.5"></path><path id="kity_path_24258" fill="none" stroke="gray" d="M533,1586.5L542,1586.5"></path></g><path id="node_outline1246" fill="none" stroke="none" d="M548.5,1577.5h72a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-72a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1246" fill="black"><text id="kity_text_10586" text-rendering="inherit" font-size="12" dy=".8em" y="1578.7000000476837" x="548.5">内部类的作用</text></g></g><g id="minder_node1248"><g id="node_expander1244" style="cursor: pointer;" display="none"><path id="kity_path_24254" fill="white" stroke="gray" d="M641.5,1586.5A6,6,0,1,1,629.5,1586.5A6,6,0,1,1,641.5,1586.5"></path><path id="kity_path_24255" fill="none" stroke="gray"></path></g><path id="node_outline1245" fill="none" stroke="none" d="M646.5,1550.5h719a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-719a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1245" fill="black"><text id="kity_text_10581" text-rendering="inherit" font-size="12" dy=".8em" y="1551.7000000476837" x="646.5">1.功能内聚，对外屏蔽可见性，即不希望外部可见，减少对外暴露的接口，</text><text id="kity_text_10582" text-rendering="inherit" font-size="12" dy=".8em" y="1569.7000000476837" x="646.5">2.内部类使得多继承的解决方案变得完整，</text><text id="kity_text_10583" text-rendering="inherit" font-size="12" dy=".8em" y="1587.7000000476837" x="646.5">3.方便编写代码</text><text id="kity_text_10584" text-rendering="inherit" font-size="12" dy=".8em" y="1605.7000000476837" x="646.5">4.用内部类是因为内部类与所在外部类有一定的关系，往往只有该外部类调用此内部类。所以没有必要专门用一个Java文件存放这个类。</text></g></g><g id="minder_node1249"><g id="node_expander1247" style="cursor: pointer;"><path id="kity_path_24263" fill="white" stroke="gray" d="M543.5,1648.5A6,6,0,1,1,531.5,1648.5A6,6,0,1,1,543.5,1648.5"></path><path id="kity_path_24264" fill="none" stroke="gray" d="M533,1648.5L542,1648.5"></path></g><path id="node_outline1248" fill="none" stroke="none" d="M548.5,1639.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1248" fill="black"><text id="kity_text_10591" text-rendering="inherit" font-size="12" dy=".8em" y="1640.7000000476837" x="548.5">静态内部类有什么作用</text></g></g><g id="minder_node1250"><g id="node_expander1246" style="cursor: pointer;" display="none"><path id="kity_path_24260" fill="white" stroke="gray" d="M690.5,1648.5A6,6,0,1,1,678.5,1648.5A6,6,0,1,1,690.5,1648.5"></path><path id="kity_path_24261" fill="none" stroke="gray"></path></g><path id="node_outline1247" fill="none" stroke="none" d="M695.5,1630.5h509a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-509a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1247" fill="black"><text id="kity_text_10588" text-rendering="inherit" font-size="12" dy=".8em" y="1631.7000000476837" x="695.5">1.在没有外部类的对象的情况下，可以直接创建静态内部类的对象，通过外部类名.内部类名 获得</text><text id="kity_text_10589" text-rendering="inherit" font-size="12" dy=".8em" y="1649.7000000476837" x="695.5">2.一般如果内部类没有引用外部类的引用，可以使用静态内部类，减少引用</text></g></g><g id="minder_node1251"><g id="node_expander1249" style="cursor: pointer;"><path id="kity_path_24269" fill="white" stroke="gray" d="M543.5,1692.5A6,6,0,1,1,531.5,1692.5A6,6,0,1,1,543.5,1692.5"></path><path id="kity_path_24270" fill="none" stroke="gray" d="M533,1692.5L542,1692.5"></path></g><path id="node_outline1250" fill="none" stroke="none" d="M548.5,1683.5h204a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-204a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1250" fill="black"><text id="kity_text_10596" text-rendering="inherit" font-size="12" dy=".8em" y="1684.7000000476837" x="548.5">多线程情况下静态内部类有什么注意的</text></g></g><g id="minder_node1252"><g id="node_expander1248" style="cursor: pointer;" display="none"><path id="kity_path_24266" fill="white" stroke="gray" d="M773.5,1692.5A6,6,0,1,1,761.5,1692.5A6,6,0,1,1,773.5,1692.5"></path><path id="kity_path_24267" fill="none" stroke="gray"></path></g><path id="node_outline1249" fill="none" stroke="none" d="M778.5,1674.5h682a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-682a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1249" fill="black"><text id="kity_text_10593" text-rendering="inherit" font-size="12" dy=".8em" y="1675.7000000476837" x="778.5">1.线程安全问题，如果该静态方法操作了一个静态字段，则需要在静态方法中采用互斥访问的方式来对其进行安全处理。</text><text id="kity_text_10594" text-rendering="inherit" font-size="12" dy=".8em" y="1693.7000000476837" x="778.5">2.因为对于静态变量来说，类在加载的时候会占用同一个存储区，而每个线程都是公用这个存储区的，因此存在线程安全的问题。</text></g></g><g id="minder_node1253"><g id="node_expander1251" style="cursor: pointer;"><path id="kity_path_24275" fill="white" stroke="gray" d="M543.5,1736.5A6,6,0,1,1,531.5,1736.5A6,6,0,1,1,543.5,1736.5"></path><path id="kity_path_24276" fill="none" stroke="gray" d="M533,1736.5L542,1736.5"></path></g><path id="node_outline1252" fill="none" stroke="none" d="M548.5,1727.5h132a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-132a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1252" fill="black"><text id="kity_text_10601" text-rendering="inherit" font-size="12" dy=".8em" y="1728.7000000476837" x="548.5">匿名内部类的使用和作用</text></g></g><g id="minder_node1254"><g id="node_expander1250" style="cursor: pointer;" display="none"><path id="kity_path_24272" fill="white" stroke="gray" d="M701.5,1736.5A6,6,0,1,1,689.5,1736.5A6,6,0,1,1,701.5,1736.5"></path><path id="kity_path_24273" fill="none" stroke="gray"></path></g><path id="node_outline1251" fill="none" stroke="none" d="M706.5,1718.5h1706a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1706a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1251" fill="black"><text id="kity_text_10598" text-rendering="inherit" font-size="12" dy=".8em" y="1719.7000000476837" x="706.5">1.作用：匿名内部类是内部类的一种特殊情况。它只有一个实例,而且没有引用。所以，一般在能用内部类实现，但是实例只用一次的情况下使用它（可以减少资源开销）</text><text id="kity_text_10599" text-rendering="inherit" font-size="12" dy=".8em" y="1737.7000000476837" x="706.5">2.使用：匿名内部类必须继承一个父类(对象匿名类中继承抽象类，对于抽象类里面的抽象方法，必须要重写，对象抽象类里面的非抽象方法，可重写也可以不重写。)，或实现一个接口(实现了一个接口，创建了一个实现了该接口的类的对象，然后重写了这个接口中的方法。)，但最多只能继承一个父类，或者实现一个接口。</text></g></g><g id="minder_node1255"><g id="node_expander1253" style="cursor: pointer;"><path id="kity_path_24281" fill="white" stroke="gray" d="M543.5,1825.5A6,6,0,1,1,531.5,1825.5A6,6,0,1,1,543.5,1825.5"></path><path id="kity_path_24282" fill="none" stroke="gray" d="M533,1825.5L542,1825.5"></path></g><path id="node_outline1254" fill="none" stroke="none" d="M548.5,1816.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1254" fill="black"><text id="kity_text_10611" text-rendering="inherit" font-size="12" dy=".8em" y="1817.7000000476837" x="548.5">基本数据类型和分别多少位？</text></g></g><g id="minder_node1256"><g id="node_expander1252" style="cursor: pointer;" display="none"><path id="kity_path_24278" fill="white" stroke="gray" d="M726.5,1825.5A6,6,0,1,1,714.5,1825.5A6,6,0,1,1,726.5,1825.5"></path><path id="kity_path_24279" fill="none" stroke="gray"></path></g><path id="node_outline1253" fill="none" stroke="none" d="M731.5,1762.5h1028a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-1028a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text1253" fill="black"><text id="kity_text_10603" text-rendering="inherit" font-size="12" dy=".8em" y="1763.7000000476837" x="731.5">1.四个整数类型分别是byte(范围是-128-&gt;127，8位一个字节),short(16位两个字节，范围是负三万多到正三万多),int(32位4个字节， -21亿到+21亿),long(64位8个字节，数比较多，具体忘记了),</text><text id="kity_text_10604" text-rendering="inherit" font-size="12" dy=".8em" y="1781.7000000476837" x="731.5">2.两个浮点类型分别是float(&#xa0;单精度、32位(4个字节)&#xa0;),double是双精度、64位(8个字节),</text><text id="kity_text_10605" text-rendering="inherit" font-size="12" dy=".8em" y="1799.7000000476837" x="731.5">3.一个布尔类型是boolean(一位 true/false 默认false)</text><text id="kity_text_10606" text-rendering="inherit" font-size="12" dy=".8em" y="1817.7000000476837" x="731.5">stackoverflow看到的</text><text id="kity_text_10607" text-rendering="inherit" font-size="12" dy=".8em" y="1835.7000000476837" x="731.5">1).boolean在底层实际会调用int，int占4个字节，boolean类型占4个字节。</text><text id="kity_text_10608" text-rendering="inherit" font-size="12" dy=".8em" y="1853.7000000476837" x="731.5">2).boolean数组在底层会用到byte指令,byte占1个字节，boolean数组中的boolean占1个字节。</text><text id="kity_text_10609" text-rendering="inherit" font-size="12" dy=".8em" y="1871.7000000476837" x="731.5">4.一个字符类型是char(一个单一的 16 位 Unicode 字符，两个字节)</text></g></g><g id="minder_node1257"><g id="node_expander1258" style="cursor: pointer;"><path id="kity_path_24296" fill="white" stroke="gray" d="M543.5,1981.5A6,6,0,1,1,531.5,1981.5A6,6,0,1,1,543.5,1981.5"></path><path id="kity_path_24297" fill="none" stroke="gray" d="M533,1981.5L542,1981.5"></path></g><path id="node_outline1259" fill="none" stroke="none" d="M548.5,1972.5h48a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-48a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1259" fill="black"><text id="kity_text_10627" text-rendering="inherit" font-size="12" dy=".8em" y="1973.7000000476837" x="548.5">异常方面</text></g></g><g id="minder_node1258"><g id="node_expander1255" style="cursor: pointer;"><path id="kity_path_24287" fill="white" stroke="gray" d="M617.5,1941.5A6,6,0,1,1,605.5,1941.5A6,6,0,1,1,617.5,1941.5"></path><path id="kity_path_24288" fill="none" stroke="gray" d="M607,1941.5L616,1941.5"></path></g><path id="node_outline1256" fill="none" stroke="none" d="M622.5,1932.5h254a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-254a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1256" fill="black"><text id="kity_text_10619" text-rendering="inherit" font-size="12" dy=".8em" y="1933.7000000476837" x="622.5">java异常体系，平常开发经常遇到的异常有哪些</text></g></g><g id="minder_node1259"><g id="node_expander1254" style="cursor: pointer;" display="none"><path id="kity_path_24284" fill="white" stroke="gray" d="M897.5,1941.5A6,6,0,1,1,885.5,1941.5A6,6,0,1,1,897.5,1941.5"></path><path id="kity_path_24285" fill="none" stroke="gray"></path></g><path id="node_outline1255" fill="none" stroke="none" d="M902.5,1896.5h874a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-874a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1255" fill="black"><text id="kity_text_10613" text-rendering="inherit" font-size="12" dy=".8em" y="1897.7000000476837" x="902.5">1.程序处理错误分为error，exception。exception主要分运行时异常和受检异常，是程序可以处理的异常</text><text id="kity_text_10614" text-rendering="inherit" font-size="12" dy=".8em" y="1915.7000000476837" x="902.5">2.对于我们可以处理的异常，我们应该处理，而不应让主程序受异常影响而停止等，如出现了异常数据，我们可以先记录，再抛弃，不要让主程序和其他数据受影响。</text><text id="kity_text_10615" text-rendering="inherit" font-size="12" dy=".8em" y="1933.7000000476837" x="902.5">3.如IllegalArgumentException：参数非法</text><text id="kity_text_10616" text-rendering="inherit" font-size="12" dy=".8em" y="1951.7000000476837" x="902.5">4.ClassNotFoundException：在编译时无法找到指定的类。</text><text id="kity_text_10617" text-rendering="inherit" font-size="12" dy=".8em" y="1969.7000000476837" x="902.5">5.空指针等</text></g></g><g id="minder_node1260"><g id="node_expander1257" style="cursor: pointer;"><path id="kity_path_24293" fill="white" stroke="gray" d="M617.5,2021.5A6,6,0,1,1,605.5,2021.5A6,6,0,1,1,617.5,2021.5"></path><path id="kity_path_24294" fill="none" stroke="gray" d="M607,2021.5L616,2021.5"></path></g><path id="node_outline1258" fill="none" stroke="none" d="M622.5,2012.5h176a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-176a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1258" fill="black"><text id="kity_text_10625" text-rendering="inherit" font-size="12" dy=".8em" y="2013.7000000476837" x="622.5">检查时异常 和 运行时异常区别？</text></g></g><g id="minder_node1261"><g id="node_expander1256" style="cursor: pointer;" display="none"><path id="kity_path_24290" fill="white" stroke="gray" d="M819.5,2021.5A6,6,0,1,1,807.5,2021.5A6,6,0,1,1,819.5,2021.5"></path><path id="kity_path_24291" fill="none" stroke="gray"></path></g><path id="node_outline1257" fill="none" stroke="none" d="M824.5,1994.5h843a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-843a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1257" fill="black"><text id="kity_text_10621" text-rendering="inherit" font-size="12" dy=".8em" y="1995.7000000476837" x="824.5">1.最本质的区别是RuntimeException是运行时才会发生的异常, 而受检查异常是编译时异常,编译器会分析哪些异常会在执行一个方法或者构造函数的时候抛出。</text><text id="kity_text_10622" text-rendering="inherit" font-size="12" dy=".8em" y="2013.7000000476837" x="824.5">2.受检查的异常(checked exceptions),其必须被 try{}catch语句块所捕获,或者在方法签名里通过throws子句声明.受检查的异常必须在编译时被捕捉处理,</text><text id="kity_text_10623" text-rendering="inherit" font-size="12" dy=".8em" y="2031.7000000476837" x="824.5">3.运行时异常(runtime exceptions),需要程序员自己分析代码决定是否捕获和处理,比如 空指针,被0除...</text></g></g><g id="minder_node1262"><g id="node_expander1260" style="cursor: pointer;"><path id="kity_path_24302" fill="white" stroke="gray" d="M543.5,2083.5A6,6,0,1,1,531.5,2083.5A6,6,0,1,1,543.5,2083.5"></path><path id="kity_path_24303" fill="none" stroke="gray" d="M533,2083.5L542,2083.5"></path></g><path id="node_outline1261" fill="none" stroke="none" d="M548.5,2074.5h254a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-254a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1261" fill="black"><text id="kity_text_10633" text-rendering="inherit" font-size="12" dy=".8em" y="2075.7000000476837" x="548.5">java多态原理了解过吗，那说说动态的底层过程</text></g></g><g id="minder_node1263"><g id="node_expander1259" style="cursor: pointer;" display="none"><path id="kity_path_24299" fill="white" stroke="gray" d="M823.5,2083.5A6,6,0,1,1,811.5,2083.5A6,6,0,1,1,823.5,2083.5"></path><path id="kity_path_24300" fill="none" stroke="gray"></path></g><path id="node_outline1260" fill="none" stroke="none" d="M828.5,2056.5h790a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-790a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1260" fill="black"><text id="kity_text_10629" text-rendering="inherit" font-size="12" dy=".8em" y="2057.7000000476837" x="828.5">1.一般多态指的是运行时多态，运行时多态，也就是编译时不确定究竟调用哪个具体方法，一直延迟到运行时才能确定</text><text id="kity_text_10630" text-rendering="inherit" font-size="12" dy=".8em" y="2075.7000000476837" x="828.5">2.具体不是很清楚，只知道继承的多态和实现接口的多态底层指令是不一样的。在性能上，调用接口引用的方法通常总是比调用类的引用的方法要慢。</text><text id="kity_text_10631" text-rendering="inherit" font-size="12" dy=".8em" y="2093.7000000476837" x="828.5">3.jvm的知识了，我们可以聊聊jvm的知识</text></g></g><g id="minder_node1264"><g id="node_expander1262" style="cursor: pointer;"><path id="kity_path_24308" fill="white" stroke="gray" d="M543.5,2145.5A6,6,0,1,1,531.5,2145.5A6,6,0,1,1,543.5,2145.5"></path><path id="kity_path_24309" fill="none" stroke="gray" d="M533,2145.5L542,2145.5"></path></g><path id="node_outline1263" fill="none" stroke="none" d="M548.5,2136.5h110a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-110a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1263" fill="black"><text id="kity_text_10639" text-rendering="inherit" font-size="12" dy=".8em" y="2137.7000000476837" x="548.5">泛型擦除是什么意思</text></g></g><g id="minder_node1265"><g id="node_expander1261" style="cursor: pointer;" display="none"><path id="kity_path_24305" fill="white" stroke="gray" d="M679.5,2145.5A6,6,0,1,1,667.5,2145.5A6,6,0,1,1,679.5,2145.5"></path><path id="kity_path_24306" fill="none" stroke="gray"></path></g><path id="node_outline1262" fill="none" stroke="none" d="M684.5,2118.5h1505a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1505a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1262" fill="black"><text id="kity_text_10635" text-rendering="inherit" font-size="12" dy=".8em" y="2119.7000000476837" x="684.5">1.普遍意义上java中的泛型是伪泛型（仅于编译时类型检查，在运行时擦除类型信息），实际代码中会把实际类型参数的信息擦除掉了，如List&lt;String&gt;编译后成List，泛型附加的信息是看不到的</text><text id="kity_text_10636" text-rendering="inherit" font-size="12" dy=".8em" y="2137.7000000476837" x="684.5">2.在实际代码中 把泛型类型，泛型方法，使用特别的编码来编译器识别然后用占位符T替换，然后编译器就知道这个占位符，最后在使用时发现有对A&lt;String&gt;的使用，就把T占位符替成string，然后正常编译成类。大体是ArrayList&lt;String&gt;=&gt;ArrayList@T@=&gt;ArrayList@String@。</text><text id="kity_text_10637" text-rendering="inherit" font-size="12" dy=".8em" y="2155.7000000476837" x="684.5">3.关于为什么有这个，只知道是为了向前向后兼容，为了java的发展，才有的这个</text></g></g><g id="minder_node1266"><g id="node_expander1264" style="cursor: pointer;"><path id="kity_path_24314" fill="white" stroke="gray" d="M543.5,2198.5A6,6,0,1,1,531.5,2198.5A6,6,0,1,1,543.5,2198.5"></path><path id="kity_path_24315" fill="none" stroke="gray" d="M533,2198.5L542,2198.5"></path></g><path id="node_outline1265" fill="none" stroke="none" d="M548.5,2189.5h134a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-134a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1265" fill="black"><text id="kity_text_10644" text-rendering="inherit" font-size="12" dy=".8em" y="2190.7000000476837" x="548.5">泛型擦除会带来什么问题</text></g></g><g id="minder_node1267"><g id="node_expander1263" style="cursor: pointer;" display="none"><path id="kity_path_24311" fill="white" stroke="gray" d="M703.5,2198.5A6,6,0,1,1,691.5,2198.5A6,6,0,1,1,703.5,2198.5"></path><path id="kity_path_24312" fill="none" stroke="gray"></path></g><path id="node_outline1264" fill="none" stroke="none" d="M708.5,2180.5h555a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-555a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1264" fill="black"><text id="kity_text_10641" text-rendering="inherit" font-size="12" dy=".8em" y="2181.7000000476837" x="708.5">1.引用传递的问题,T在后期会被转object原始类型，而引用是不可以转义的，会受检异常不允许编译</text><text id="kity_text_10642" text-rendering="inherit" font-size="12" dy=".8em" y="2199.7000000476837" x="708.5">2.强制类型转换的问题，如我们可以通过反射往List&lt;Integer&gt;传String类型进去，而正常这是不允许的。</text></g></g><g id="minder_node1268"><g id="node_expander1266" style="cursor: pointer;"><path id="kity_path_24320" fill="white" stroke="gray" d="M543.5,2260.5A6,6,0,1,1,531.5,2260.5A6,6,0,1,1,543.5,2260.5"></path><path id="kity_path_24321" fill="none" stroke="gray" d="M533,2260.5L542,2260.5"></path></g><path id="node_outline1267" fill="none" stroke="none" d="M548.5,2251.5h156a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-156a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1267" fill="black"><text id="kity_text_10651" text-rendering="inherit" font-size="12" dy=".8em" y="2252.7000000476837" x="548.5">上面的问题有上面解决方案吗</text></g></g><g id="minder_node1269"><g id="node_expander1265" style="cursor: pointer;" display="none"><path id="kity_path_24317" fill="white" stroke="gray" d="M725.5,2260.5A6,6,0,1,1,713.5,2260.5A6,6,0,1,1,725.5,2260.5"></path><path id="kity_path_24318" fill="none" stroke="gray"></path></g><path id="node_outline1266" fill="none" stroke="none" d="M730.5,2224.5h684a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-684a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1266" fill="black"><text id="kity_text_10646" text-rendering="inherit" font-size="12" dy=".8em" y="2225.7000000476837" x="730.5">1.通过public class Test&lt;T extends Test&gt;{}，多了个 &lt;T extends Test&gt;。</text><text id="kity_text_10647" text-rendering="inherit" font-size="12" dy=".8em" y="2243.7000000476837" x="730.5">这是将基类重新规划的操作，就算被编译，虚拟机也会知道将数据转化为Test而不是直接用Object来直接进行替代。</text><text id="kity_text_10648" text-rendering="inherit" font-size="12" dy=".8em" y="2261.7000000476837" x="730.5">这样获取的数据全部人的父类其实都是来自于我们的Test了，你可以叫这个列表为Test家族。这是一个适合频繁读取的方案。</text><text id="kity_text_10649" text-rendering="inherit" font-size="12" dy=".8em" y="2279.7000000476837" x="730.5">2. 还有一种是 &lt;T super Test&gt;&#xa0;通过这样的方式比较适用于去存放上面所说的Test列表中的数据。这是一个适合频繁插入的方案。</text></g></g><g id="minder_node1270"><g id="node_expander1268" style="cursor: pointer;"><path id="kity_path_24326" fill="white" stroke="gray" d="M543.5,2322.5A6,6,0,1,1,531.5,2322.5A6,6,0,1,1,543.5,2322.5"></path><path id="kity_path_24327" fill="none" stroke="gray" d="M533,2322.5L542,2322.5"></path></g><path id="node_outline1269" fill="none" stroke="none" d="M548.5,2313.5h254a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-254a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1269" fill="black"><text id="kity_text_10656" text-rendering="inherit" font-size="12" dy=".8em" y="2314.7000000476837" x="548.5">泛型中参数化类型可以考虑继承关系吗，为什么</text></g></g><g id="minder_node1271"><g id="node_expander1267" style="cursor: pointer;" display="none"><path id="kity_path_24323" fill="white" stroke="gray" d="M823.5,2322.5A6,6,0,1,1,811.5,2322.5A6,6,0,1,1,823.5,2322.5"></path><path id="kity_path_24324" fill="none" stroke="gray"></path></g><path id="node_outline1268" fill="none" stroke="none" d="M828.5,2304.5h202a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-202a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1268" fill="black"><text id="kity_text_10653" text-rendering="inherit" font-size="12" dy=".8em" y="2305.7000000476837" x="828.5">1.泛型类可以考虑继承关系，</text><text id="kity_text_10654" text-rendering="inherit" font-size="12" dy=".8em" y="2323.7000000476837" x="828.5">2.泛型类可以扩展或实现其他泛型类。</text></g></g><g id="minder_node1272"><g id="node_expander1270" style="cursor: pointer;"><path id="kity_path_24332" fill="white" stroke="gray" d="M543.5,2375.5A6,6,0,1,1,531.5,2375.5A6,6,0,1,1,543.5,2375.5"></path><path id="kity_path_24333" fill="none" stroke="gray" d="M533,2375.5L542,2375.5"></path></g><path id="node_outline1271" fill="none" stroke="none" d="M548.5,2366.5h127a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-127a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1271" fill="black"><text id="kity_text_10662" text-rendering="inherit" font-size="12" dy=".8em" y="2367.7000000476837" x="548.5">static存在的意义是什么</text></g></g><g id="minder_node1273"><g id="node_expander1269" style="cursor: pointer;" display="none"><path id="kity_path_24329" fill="white" stroke="gray" d="M696.5,2375.5A6,6,0,1,1,684.5,2375.5A6,6,0,1,1,696.5,2375.5"></path><path id="kity_path_24330" fill="none" stroke="gray"></path></g><path id="node_outline1270" fill="none" stroke="none" d="M701.5,2348.5h787a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-787a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1270" fill="black"><text id="kity_text_10658" text-rendering="inherit" font-size="12" dy=".8em" y="2349.7000000476837" x="701.5">1.创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法</text><text id="kity_text_10659" text-rendering="inherit" font-size="12" dy=".8em" y="2367.7000000476837" x="701.5">2.用来形成静态代码块以优化程序性能，:只会在类加载的时候执行一次。很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</text><text id="kity_text_10660" text-rendering="inherit" font-size="12" dy=".8em" y="2385.7000000476837" x="701.5">3.static是被类的实例对象所共享。</text></g></g><g id="minder_node1274"><g id="node_expander1273" style="cursor: pointer;"><path id="kity_path_24341" fill="white" stroke="gray" d="M543.5,2437.5A6,6,0,1,1,531.5,2437.5A6,6,0,1,1,543.5,2437.5"></path><path id="kity_path_24342" fill="none" stroke="gray" d="M533,2437.5L542,2437.5"></path></g><path id="node_outline1274" fill="none" stroke="none" d="M548.5,2428.5h181a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-181a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1274" fill="black"><text id="kity_text_10670" text-rendering="inherit" font-size="12" dy=".8em" y="2429.7000000476837" x="548.5">final修饰是否可以是线程安全的？</text></g></g><g id="minder_node1275"><g id="node_expander1272" style="cursor: pointer;"><path id="kity_path_24338" fill="white" stroke="gray" d="M750.5,2437.5A6,6,0,1,1,738.5,2437.5A6,6,0,1,1,750.5,2437.5"></path><path id="kity_path_24339" fill="none" stroke="gray" d="M740,2437.5L749,2437.5"></path></g><path id="node_outline1273" fill="none" stroke="none" d="M755.5,2410.5h650a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-650a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1273" fill="black"><text id="kity_text_10666" text-rendering="inherit" font-size="12" dy=".8em" y="2411.7000000476837" x="755.5">1.可以，是线程安全的，被final修饰的是不可变域 这样的变量和引用在其他线程访问时它必须已经是创建并初始化好了的。</text><text id="kity_text_10667" text-rendering="inherit" font-size="12" dy=".8em" y="2429.7000000476837" x="755.5">final域的值，包括collection中引用的final对象，不需要使用synchronized在读取数据时可以保证是线程安全的，但是</text><text id="kity_text_10668" text-rendering="inherit" font-size="12" dy=".8em" y="2447.7000000476837" x="755.5">如果有一个对collection的final引用，array 或者其他可变的对象，在多线程访问的情况下仍然需要同步所有的访问</text></g></g><g id="minder_node1276"><g id="node_expander1271" style="cursor: pointer;" display="none"><path id="kity_path_24335" fill="white" stroke="gray" d="M1426.5,2437.5A6,6,0,1,1,1414.5,2437.5A6,6,0,1,1,1426.5,2437.5"></path><path id="kity_path_24336" fill="none" stroke="gray"></path></g><path id="node_outline1272" fill="none" stroke="none" d="M1431.5,2428.5h358a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-358a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1272" fill="black"><text id="kity_text_10664" text-rendering="inherit" font-size="12" dy=".8em" y="2429.7000000476837" x="1431.5">https://blog.csdn.net/xiaoxiaoxuanao/article/details/52573859</text></g></g><g id="minder_node1277"><g id="node_expander1275" style="cursor: pointer;"><path id="kity_path_24347" fill="white" stroke="gray" d="M543.5,2499.5A6,6,0,1,1,531.5,2499.5A6,6,0,1,1,543.5,2499.5"></path><path id="kity_path_24348" fill="none" stroke="gray" d="M533,2499.5L542,2499.5"></path></g><path id="node_outline1276" fill="none" stroke="none" d="M548.5,2490.5h262a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-262a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1276" fill="black"><text id="kity_text_10676" text-rendering="inherit" font-size="12" dy=".8em" y="2491.7000000476837" x="548.5">说一下final ,static, final static,修饰字段的区别？</text></g></g><g id="minder_node1278"><g id="node_expander1274" style="cursor: pointer;" display="none"><path id="kity_path_24344" fill="white" stroke="gray" d="M831.5,2499.5A6,6,0,1,1,819.5,2499.5A6,6,0,1,1,831.5,2499.5"></path><path id="kity_path_24345" fill="none" stroke="gray"></path></g><path id="node_outline1275" fill="none" stroke="none" d="M836.5,2472.5h1197a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1197a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1275" fill="black"><text id="kity_text_10672" text-rendering="inherit" font-size="12" dy=".8em" y="2473.7000000476837" x="836.5">1.static修饰的字段在类加载过程中的准备阶段被初始化为0或null等默认值，而后在初始化阶段（触发类构造器）才会被赋予代码中设定的值，如果没有设定值，那么它的值就为默认值。</text><text id="kity_text_10673" text-rendering="inherit" font-size="12" dy=".8em" y="2491.7000000476837" x="836.5">2.final修饰的字段在运行时被初始化（可以直接赋值，也可以在实例构造器中赋值），一旦赋值便不可更改；</text><text id="kity_text_10674" text-rendering="inherit" font-size="12" dy=".8em" y="2509.7000000476837" x="836.5">3.static final修饰的字段在Javac时生成ConstantValue属性，在类加载的准备阶段根据ConstantValue的值为该字段赋值，它没有默认值，必须显式地赋值，否则Javac时会报错。可以理解为在编译期即把结果放入了常量池中。</text></g></g><g id="minder_node1279"><g id="node_expander1277" style="cursor: pointer;"><path id="kity_path_24353" fill="white" stroke="gray" d="M543.5,2543.5A6,6,0,1,1,531.5,2543.5A6,6,0,1,1,543.5,2543.5"></path><path id="kity_path_24354" fill="none" stroke="gray" d="M533,2543.5L542,2543.5"></path></g><path id="node_outline1278" fill="none" stroke="none" d="M548.5,2534.5h125a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-125a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1278" fill="black"><text id="kity_text_10680" text-rendering="inherit" font-size="12" dy=".8em" y="2535.7000000476837" x="548.5">return continue break</text></g></g><g id="minder_node1280"><g id="node_expander1276" style="cursor: pointer;" display="none"><path id="kity_path_24350" fill="white" stroke="gray" d="M694.5,2543.5A6,6,0,1,1,682.5,2543.5A6,6,0,1,1,694.5,2543.5"></path><path id="kity_path_24351" fill="none" stroke="gray"></path></g><path id="node_outline1277" fill="none" stroke="none" d="M699.5,2534.5h533a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-533a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1277" fill="black"><text id="kity_text_10678" text-rendering="inherit" font-size="12" dy=".8em" y="2535.7000000476837" x="699.5">1.break 结束循环，执行后面的代码；continue 跳过这一次循环 执行下一次； return 退出执行方法&#xa0;</text></g></g><g id="minder_node1281"><g id="node_expander1280" style="cursor: pointer;"><path id="kity_path_24362" fill="white" stroke="gray" d="M543.5,2569.5A6,6,0,1,1,531.5,2569.5A6,6,0,1,1,543.5,2569.5"></path><path id="kity_path_24363" fill="none" stroke="gray" d="M533,2569.5L542,2569.5"></path></g><path id="node_outline1281" fill="none" stroke="none" d="M548.5,2560.5h171a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-171a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1281" fill="black"><text id="kity_text_10686" text-rendering="inherit" font-size="12" dy=".8em" y="2561.7000000476837" x="548.5">内部类编译后多少个class文件？</text></g></g><g id="minder_node1282"><g id="node_expander1279" style="cursor: pointer;"><path id="kity_path_24359" fill="white" stroke="gray" d="M740.5,2569.5A6,6,0,1,1,728.5,2569.5A6,6,0,1,1,740.5,2569.5"></path><path id="kity_path_24360" fill="none" stroke="gray" d="M730,2569.5L739,2569.5"></path></g><path id="node_outline1280" fill="none" stroke="none" d="M745.5,2560.5h569a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-569a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1280" fill="black"><text id="kity_text_10684" text-rendering="inherit" font-size="12" dy=".8em" y="2561.7000000476837" x="745.5">1.有几个内部类就有几个，名字是主类任何$内部类，如果是匿名内部类还有数字，因为匿名内部类可以类名</text></g></g><g id="minder_node1283"><g id="node_expander1278" style="cursor: pointer;" display="none"><path id="kity_path_24356" fill="white" stroke="gray" d="M1335.5,2569.5A6,6,0,1,1,1323.5,2569.5A6,6,0,1,1,1335.5,2569.5"></path><path id="kity_path_24357" fill="none" stroke="gray"></path></g><path id="node_outline1279" fill="none" stroke="none" d="M1340.5,2560.5h353a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-353a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1279" fill="black"><text id="kity_text_10682" text-rendering="inherit" font-size="12" dy=".8em" y="2561.7000000476837" x="1340.5">https://blog.csdn.net/qq_40028198/article/details/105345822</text></g></g><g id="minder_node1284"><g id="node_expander1327" style="cursor: pointer;"><path id="kity_path_24503" fill="white" stroke="gray" d="M492.5,3300.5A6,6,0,1,1,480.5,3300.5A6,6,0,1,1,492.5,3300.5"></path><path id="kity_path_24504" fill="none" stroke="gray" d="M482,3300.5L491,3300.5"></path></g><path id="node_outline1328" fill="none" stroke="none" d="M497.5,3291.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z" stroke-width="3"></path><g id="node_text1328" fill="black"><text id="kity_text_10824" text-rendering="inherit" font-size="12" dy=".8em" y="3292.7000000476837" x="497.5">进阶</text></g></g><g id="minder_node1285"><g id="node_expander1297" style="cursor: pointer;"><path id="kity_path_24413" fill="white" stroke="gray" d="M544.5,2728.5A6,6,0,1,1,532.5,2728.5A6,6,0,1,1,544.5,2728.5"></path><path id="kity_path_24414" fill="none" stroke="gray" d="M534,2728.5L543,2728.5"></path></g><path id="node_outline1298" fill="none" stroke="none" d="M549.5,2719.5h139a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-139a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1298" fill="black"><text id="kity_text_10728" text-rendering="inherit" font-size="12" dy=".8em" y="2720.7000000476837" x="549.5">代理(动态代理可关联aop)</text></g></g><g id="minder_node1286"><g id="node_expander1283" style="cursor: pointer;"><path id="kity_path_24371" fill="white" stroke="gray" d="M709.5,2614.5A6,6,0,1,1,697.5,2614.5A6,6,0,1,1,709.5,2614.5"></path><path id="kity_path_24372" fill="none" stroke="gray" d="M699,2614.5L708,2614.5"></path></g><path id="node_outline1284" fill="none" stroke="none" d="M714.5,2605.5h230a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-230a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1284" fill="black"><text id="kity_text_10694" text-rendering="inherit" font-size="12" dy=".8em" y="2606.7000000476837" x="714.5">知道代理模式吗，动态代理有几种实现方式</text></g></g><g id="minder_node1287"><g id="node_expander1282" style="cursor: pointer;" display="none"><path id="kity_path_24368" fill="white" stroke="gray" d="M965.5,2614.5A6,6,0,1,1,953.5,2614.5A6,6,0,1,1,965.5,2614.5"></path><path id="kity_path_24369" fill="none" stroke="gray"></path></g><path id="node_outline1283" fill="none" stroke="none" d="M970.5,2587.5h521a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-521a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1283" fill="black"><text id="kity_text_10690" text-rendering="inherit" font-size="12" dy=".8em" y="2588.7000000476837" x="970.5">使用代理对象来代替对真实对象的访问 在不修改原目标对象的前提下，提供扩展目标对象的功能，</text><text id="kity_text_10691" text-rendering="inherit" font-size="12" dy=".8em" y="2606.7000000476837" x="970.5">主要作用是在目标对象执行方法前后执行自定义的操作。</text><text id="kity_text_10692" text-rendering="inherit" font-size="12" dy=".8em" y="2624.7000000476837" x="970.5">JDK动态代理&#xa0;Cglib动态代理。动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</text></g></g><g id="minder_node1288"><g id="node_expander1285" style="cursor: pointer;"><path id="kity_path_24377" fill="white" stroke="gray" d="M709.5,2658.5A6,6,0,1,1,697.5,2658.5A6,6,0,1,1,709.5,2658.5"></path><path id="kity_path_24378" fill="none" stroke="gray" d="M699,2658.5L708,2658.5"></path></g><path id="node_outline1286" fill="none" stroke="none" d="M714.5,2649.5h175a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-175a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1286" fill="black"><text id="kity_text_10698" text-rendering="inherit" font-size="12" dy=".8em" y="2650.7000000476837" x="714.5">知道jdk动态代理吗，说一下原理</text></g></g><g id="minder_node1289"><g id="node_expander1284" style="cursor: pointer;" display="none"><path id="kity_path_24374" fill="white" stroke="gray" d="M910.5,2658.5A6,6,0,1,1,898.5,2658.5A6,6,0,1,1,910.5,2658.5"></path><path id="kity_path_24375" fill="none" stroke="gray"></path></g><path id="node_outline1285" fill="none" stroke="none" d="M915.5,2649.5h977a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-977a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1285" fill="black"><text id="kity_text_10696" text-rendering="inherit" font-size="12" dy=".8em" y="2650.7000000476837" x="915.5">jdk动态代理是通过反射来接收被代理类，使用jdk动态代理 被代理类需要至少实现一个接口，然后使用newProxyInstance()&#xa0;来获取代理对象。核心接口是InvocationHandler和Proxy。</text></g></g><g id="minder_node1290"><g id="node_expander1287" style="cursor: pointer;"><path id="kity_path_24383" fill="white" stroke="gray" d="M709.5,2684.5A6,6,0,1,1,697.5,2684.5A6,6,0,1,1,709.5,2684.5"></path><path id="kity_path_24384" fill="none" stroke="gray" d="M699,2684.5L708,2684.5"></path></g><path id="node_outline1288" fill="none" stroke="none" d="M714.5,2675.5h104a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-104a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1288" fill="black"><text id="kity_text_10702" text-rendering="inherit" font-size="12" dy=".8em" y="2676.7000000476837" x="714.5">jdk动态代理的步骤</text></g></g><g id="minder_node1291"><g id="node_expander1286" style="cursor: pointer;" display="none"><path id="kity_path_24380" fill="white" stroke="gray" d="M839.5,2684.5A6,6,0,1,1,827.5,2684.5A6,6,0,1,1,839.5,2684.5"></path><path id="kity_path_24381" fill="none" stroke="gray"></path></g><path id="node_outline1287" fill="none" stroke="none" d="M844.5,2675.5h504a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-504a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1287" fill="black"><text id="kity_text_10700" text-rendering="inherit" font-size="12" dy=".8em" y="2676.7000000476837" x="844.5">1.实现一个接口和接口实现类。2.重写invoke方法。3.对应newProxyInstance()来创建代理对象</text></g></g><g id="minder_node1292"><g id="node_expander1289" style="cursor: pointer;"><path id="kity_path_24389" fill="white" stroke="gray" d="M709.5,2710.5A6,6,0,1,1,697.5,2710.5A6,6,0,1,1,709.5,2710.5"></path><path id="kity_path_24390" fill="none" stroke="gray" d="M699,2710.5L708,2710.5"></path></g><path id="node_outline1290" fill="none" stroke="none" d="M714.5,2701.5h113a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-113a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1290" fill="black"><text id="kity_text_10706" text-rendering="inherit" font-size="12" dy=".8em" y="2702.7000000476837" x="714.5">cglib的原理简单说说</text></g></g><g id="minder_node1293"><g id="node_expander1288" style="cursor: pointer;" display="none"><path id="kity_path_24386" fill="white" stroke="gray" d="M848.5,2710.5A6,6,0,1,1,836.5,2710.5A6,6,0,1,1,848.5,2710.5"></path><path id="kity_path_24387" fill="none" stroke="gray"></path></g><path id="node_outline1289" fill="none" stroke="none" d="M853.5,2701.5h992a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-992a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1289" fill="black"><text id="kity_text_10704" text-rendering="inherit" font-size="12" dy=".8em" y="2702.7000000476837" x="853.5">cglib允许我们通过运行时对字节码操作和动态生成。cglib是通过继承的方式实现。核心是MethodInterceptor接口 和其中的intercept()方法【拦截增强目标类的方法】 和Enhancer对象。</text></g></g><g id="minder_node1294"><g id="node_expander1291" style="cursor: pointer;"><path id="kity_path_24395" fill="white" stroke="gray" d="M709.5,2736.5A6,6,0,1,1,697.5,2736.5A6,6,0,1,1,709.5,2736.5"></path><path id="kity_path_24396" fill="none" stroke="gray" d="M699,2736.5L708,2736.5"></path></g><path id="node_outline1292" fill="none" stroke="none" d="M714.5,2727.5h100a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-100a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1292" fill="black"><text id="kity_text_10710" text-rendering="inherit" font-size="12" dy=".8em" y="2728.7000000476837" x="714.5">cglib的步骤说一下</text></g></g><g id="minder_node1295"><g id="node_expander1290" style="cursor: pointer;" display="none"><path id="kity_path_24392" fill="white" stroke="gray" d="M835.5,2736.5A6,6,0,1,1,823.5,2736.5A6,6,0,1,1,835.5,2736.5"></path><path id="kity_path_24393" fill="none" stroke="gray"></path></g><path id="node_outline1291" fill="none" stroke="none" d="M840.5,2727.5h635a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-635a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1291" fill="black"><text id="kity_text_10708" text-rendering="inherit" font-size="12" dy=".8em" y="2728.7000000476837" x="840.5">1.定义一个类。2.重写MethodInterceptor接口的intercept方法 3.实例化Enhancer对象 并通过他的create创建代理对象</text></g></g><g id="minder_node1296"><g id="node_expander1293" style="cursor: pointer;"><path id="kity_path_24401" fill="white" stroke="gray" d="M709.5,2762.5A6,6,0,1,1,697.5,2762.5A6,6,0,1,1,709.5,2762.5"></path><path id="kity_path_24402" fill="none" stroke="gray" d="M699,2762.5L708,2762.5"></path></g><path id="node_outline1294" fill="none" stroke="none" d="M714.5,2753.5h143a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-143a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1294" fill="black"><text id="kity_text_10714" text-rendering="inherit" font-size="12" dy=".8em" y="2754.7000000476837" x="714.5">jdk动态代理和cglib的区别</text></g></g><g id="minder_node1297"><g id="node_expander1292" style="cursor: pointer;" display="none"><path id="kity_path_24398" fill="white" stroke="gray" d="M878.5,2762.5A6,6,0,1,1,866.5,2762.5A6,6,0,1,1,878.5,2762.5"></path><path id="kity_path_24399" fill="none" stroke="gray"></path></g><path id="node_outline1293" fill="none" stroke="none" d="M883.5,2753.5h1195a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1195a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1293" fill="black"><text id="kity_text_10712" text-rendering="inherit" font-size="12" dy=".8em" y="2754.7000000476837" x="883.5">JDK 动态代理只能代理实现了接口的类，而 CGLIB 可以代理未实现任何接口的类，但是不能对声明为 final的方法进行代理，因为 CGLIB 原理是动态生成被代理类的子类。效率来说因为jdk版本一直在更新 jdk动态代理更优秀点</text></g></g><g id="minder_node1298"><g id="node_expander1296" style="cursor: pointer;"><path id="kity_path_24410" fill="white" stroke="gray" d="M709.5,2842.5A6,6,0,1,1,697.5,2842.5A6,6,0,1,1,709.5,2842.5"></path><path id="kity_path_24411" fill="none" stroke="gray" d="M699,2842.5L708,2842.5"></path></g><path id="node_outline1297" fill="none" stroke="none" d="M714.5,2833.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1297" fill="black"><text id="kity_text_10726" text-rendering="inherit" font-size="12" dy=".8em" y="2834.7000000476837" x="714.5">静态代理和动态代理的区别？</text></g></g><g id="minder_node1299"><g id="node_expander1295" style="cursor: pointer;"><path id="kity_path_24407" fill="white" stroke="gray" d="M892.5,2842.5A6,6,0,1,1,880.5,2842.5A6,6,0,1,1,892.5,2842.5"></path><path id="kity_path_24408" fill="none" stroke="gray" d="M882,2842.5L891,2842.5"></path></g><path id="node_outline1296" fill="none" stroke="none" d="M897.5,2779.5h1501a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-1501a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text1296" fill="black"><text id="kity_text_10718" text-rendering="inherit" font-size="12" dy=".8em" y="2780.7000000476837" x="897.5">1.主要是根据加载被代理类的时机做区分将代理分为静态代理和动态代理。</text><text id="kity_text_10719" text-rendering="inherit" font-size="12" dy=".8em" y="2798.7000000476837" x="897.5">如果我们在代码编译时就确定了被代理的类是哪一个，那么就可以直接使用静态代理；如果不能确定，那么可以使用类的动态加载机制，在代码运行期间加载被代理的类这就是动态代理，aop就是使用动态代理</text><text id="kity_text_10720" text-rendering="inherit" font-size="12" dy=".8em" y="2816.7000000476837" x="897.5">2.静态代理</text><text id="kity_text_10721" text-rendering="inherit" font-size="12" dy=".8em" y="2834.7000000476837" x="897.5">需要显示声明代理对象，在编译期就生成了代理类。他的实现主要是需要一个公共接口、一个委托类、一个代理类。需要实现接口，对于代理的角色是固定的，如dao层有20个dao类，如果要对方法的访问权限进行代理，此时需要创建20个静态代理角色，引起类爆炸，造成代码冗余。</text><text id="kity_text_10722" text-rendering="inherit" font-size="12" dy=".8em" y="2852.7000000476837" x="897.5">3.动态代理</text><text id="kity_text_10723" text-rendering="inherit" font-size="12" dy=".8em" y="2870.7000000476837" x="897.5">程序运行时通过反射机制动态创建代理类。只需将被委托类作为参数传入即可，使用灵活。只是效率不是很优秀而已。</text><text id="kity_text_10724" text-rendering="inherit" font-size="12" dy=".8em" y="2888.7000000476837" x="897.5">动态代理在创建代理对象上更加的灵活，动态代理类的字节码在程序运行时，由Java反射机制动态产生。它会根据需要，通过反射机制在程序运行期，动态的为目标对象创建代理对象，无需程序员手动编写它的源代码。</text></g></g><g id="minder_node1300"><g id="node_expander1294" style="cursor: pointer;" display="none"><path id="kity_path_24404" fill="white" stroke="gray" d="M2419.5,2842.5A6,6,0,1,1,2407.5,2842.5A6,6,0,1,1,2419.5,2842.5"></path><path id="kity_path_24405" fill="none" stroke="gray"></path></g><path id="node_outline1295" fill="none" stroke="none" d="M2424.5,2828.5h267a5,5,0,0,1,5,5v18a5,5,0,0,1,-5,5h-267a5,5,0,0,1,-5,-5v-18a5,5,0,0,1,5,-5z"></path><g id="node_text1295" fill="black"><text id="kity_text_10716" text-rendering="inherit" font-size="12" dy=".8em" y="2834.7000000476837" x="2424.5">https://zhuanlan.zhihu.com/p/159112639</text></g><a id="kity_a_16937" xlink:href="https://blog.csdn.net/asd051377305/article/details/80490432?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&amp;spm=1001.2101.3001.4242" target="_blank" xlink:title="https://blog.csdn.net/asd051377305/article/details/80490432?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&amp;spm=1001.2101.3001.4242" style="cursor: pointer;"><path id="kity_path_16939" fill="rgba(255, 255, 255, 0)" stroke="none" d="M2671.5,2831.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16938" fill="#666" stroke="none" d="M2686.114,2847.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V2841.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C2681.766,2838.571,2683.168,2837.5,2684.836,2837.5h1.278c2.116,0,3.834,1.716,3.834,3.834V2843.89C2689.948,2846.008,2688.23,2847.724,2686.114,2847.724zM2674.612,2842.612c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S2684.265,2843.89,2683.558,2843.89H2675.89C2675.185,2843.89,2674.612,2843.319,2674.612,2842.612zM2672.056,2841.334V2843.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H2673.334C2671.216,2847.724,2669.5,2846.008,2669.5,2843.89V2841.334C2669.5,2839.216,2671.216,2837.5,2673.334,2837.5h1.278c1.667,0,3.071,1.071,3.599,2.556H2673.334C2672.629,2840.056,2672.056,2840.627,2672.056,2841.334z"></path></a></g><g id="minder_node1301"><g id="node_expander1319" style="cursor: pointer;"><path id="kity_path_24479" fill="white" stroke="gray" d="M544.5,3286.5A6,6,0,1,1,532.5,3286.5A6,6,0,1,1,544.5,3286.5"></path><path id="kity_path_24480" fill="none" stroke="gray" d="M534,3286.5L543,3286.5"></path></g><path id="node_outline1320" fill="none" stroke="none" d="M549.5,3277.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1320" fill="black"><text id="kity_text_10800" text-rendering="inherit" font-size="12" dy=".8em" y="3278.7000000476837" x="549.5">反射</text></g></g><g id="minder_node1302"><g id="node_expander1299" style="cursor: pointer;"><path id="kity_path_24419" fill="white" stroke="gray" d="M596.5,2922.5A6,6,0,1,1,584.5,2922.5A6,6,0,1,1,596.5,2922.5"></path><path id="kity_path_24420" fill="none" stroke="gray" d="M586,2922.5L595,2922.5"></path></g><path id="node_outline1300" fill="none" stroke="none" d="M601.5,2913.5h97a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-97a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1300" fill="black"><text id="kity_text_10732" text-rendering="inherit" font-size="12" dy=".8em" y="2914.7000000476837" x="601.5">反射的原理知道吗</text></g></g><g id="minder_node1303"><g id="node_expander1298" style="cursor: pointer;" display="none"><path id="kity_path_24416" fill="white" stroke="gray" d="M719.5,2922.5A6,6,0,1,1,707.5,2922.5A6,6,0,1,1,719.5,2922.5"></path><path id="kity_path_24417" fill="none" stroke="gray"></path></g><path id="node_outline1299" fill="none" stroke="none" d="M724.5,2913.5h1024a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1024a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1299" fill="black"><text id="kity_text_10730" text-rendering="inherit" font-size="12" dy=".8em" y="2914.7000000476837" x="724.5">代码都是先编译后运行，反射是在运行时操作对象，反射是通过native方法 操作反射对象 来映射到原始对象上， 反射的获取字段的值，构造方法，获取属性值 修改属性值 都是native方法实现的</text></g></g><g id="minder_node1304"><g id="node_expander1301" style="cursor: pointer;"><path id="kity_path_24425" fill="white" stroke="gray" d="M596.5,2984.5A6,6,0,1,1,584.5,2984.5A6,6,0,1,1,596.5,2984.5"></path><path id="kity_path_24426" fill="none" stroke="gray" d="M586,2984.5L595,2984.5"></path></g><path id="node_outline1302" fill="none" stroke="none" d="M601.5,2975.5h216a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-216a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1302" fill="black"><text id="kity_text_10740" text-rendering="inherit" font-size="12" dy=".8em" y="2976.7000000476837" x="601.5">new创建对象和反射创建对象有什么区别</text></g></g><g id="minder_node1305"><g id="node_expander1300" style="cursor: pointer;" display="none"><path id="kity_path_24422" fill="white" stroke="gray" d="M838.5,2984.5A6,6,0,1,1,826.5,2984.5A6,6,0,1,1,838.5,2984.5"></path><path id="kity_path_24423" fill="none" stroke="gray"></path></g><path id="node_outline1301" fill="none" stroke="none" d="M843.5,2939.5h1385a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1385a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1301" fill="black"><text id="kity_text_10734" text-rendering="inherit" font-size="12" dy=".8em" y="2940.7000000476837" x="843.5">1.首先这两个是有区别，new是得不到类的私有的</text><text id="kity_text_10735" text-rendering="inherit" font-size="12" dy=".8em" y="2958.7000000476837" x="843.5">2.反射可以不知道类名的情况下创建对象，而new不行，要不然都不知道创建哪个类了，也就是说new的对象在编译环境中要必须在类路径中有</text><text id="kity_text_10736" text-rendering="inherit" font-size="12" dy=".8em" y="2976.7000000476837" x="843.5">相当于new一个对象允许class文件还没加载进来，jvm虚拟机会自动检查内存中是否有这个class对象，若没有就通过类加载器加载进来，而newInstance()必须要确保class文件已经加载进内存中才能产生一个对象，这时需通过class.foName()方法加载class文件。</text><text id="kity_text_10737" text-rendering="inherit" font-size="12" dy=".8em" y="2994.7000000476837" x="843.5">3.new对象是使用静态编译，也就是启动时会把所有模块加载进去，反射是动态编译，启动时不加载，运行时按需加载。动态编译相比较静态编译具有速度快，节省系统资源，利于扩展的优点</text><text id="kity_text_10738" text-rendering="inherit" font-size="12" dy=".8em" y="3012.7000000476837" x="843.5">4.比如一个经常用框架中，设计者不知道我们会把哪些类放进去，所以是不知道类名，就不能new了，</text></g></g><g id="minder_node1306"><g id="node_expander1303" style="cursor: pointer;"><path id="kity_path_24431" fill="white" stroke="gray" d="M596.5,3100.5A6,6,0,1,1,584.5,3100.5A6,6,0,1,1,596.5,3100.5"></path><path id="kity_path_24432" fill="none" stroke="gray" d="M586,3100.5L595,3100.5"></path></g><path id="node_outline1304" fill="none" stroke="none" d="M601.5,3091.5h253a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-253a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1304" fill="black"><text id="kity_text_10750" text-rendering="inherit" font-size="12" dy=".8em" y="3092.7000000476837" x="601.5">那为什么要用反射，直接new不就行了，你说说</text></g></g><g id="minder_node1307"><g id="node_expander1302" style="cursor: pointer;" display="none"><path id="kity_path_24428" fill="white" stroke="gray" d="M875.5,3100.5A6,6,0,1,1,863.5,3100.5A6,6,0,1,1,875.5,3100.5"></path><path id="kity_path_24429" fill="none" stroke="gray"></path></g><path id="node_outline1303" fill="none" stroke="none" d="M880.5,3037.5h586a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-586a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text1303" fill="black"><text id="kity_text_10742" text-rendering="inherit" font-size="12" dy=".8em" y="3038.7000000476837" x="880.5">1.这主要从他们的区别可以看到</text><text id="kity_text_10743" text-rendering="inherit" font-size="12" dy=".8em" y="3056.7000000476837" x="880.5">2.我们通过new是无法进去对象的私有域的</text><text id="kity_text_10744" text-rendering="inherit" font-size="12" dy=".8em" y="3074.7000000476837" x="880.5">3.如果我们不知道类名，就无法new了，这个时侯反射就可以了</text><text id="kity_text_10745" text-rendering="inherit" font-size="12" dy=".8em" y="3092.7000000476837" x="880.5">4.总的来说，有了反射机制后，只需要在配置文件写上相应的类名称，再通过io流读取配置文件中的类名，</text><text id="kity_text_10746" text-rendering="inherit" font-size="12" dy=".8em" y="3110.7000000476837" x="880.5">即可通过class.forName()方法找出相应的class文件并加载进内存中，</text><text id="kity_text_10747" text-rendering="inherit" font-size="12" dy=".8em" y="3128.7000000476837" x="880.5">再通过newInstance()方法创建一个对象，此时的对象是一个Object类型的对象，需要转换成相对应的类类型。</text><text id="kity_text_10748" text-rendering="inherit" font-size="12" dy=".8em" y="3146.7000000476837" x="880.5">这样就可以在不修改源代码的情况下通过修改配置文件进行功能的更新和扩展了。</text></g></g><g id="minder_node1308"><g id="node_expander1305" style="cursor: pointer;"><path id="kity_path_24437" fill="white" stroke="gray" d="M596.5,3216.5A6,6,0,1,1,584.5,3216.5A6,6,0,1,1,596.5,3216.5"></path><path id="kity_path_24438" fill="none" stroke="gray" d="M586,3216.5L595,3216.5"></path></g><path id="node_outline1306" fill="none" stroke="none" d="M601.5,3207.5h181a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-181a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1306" fill="black"><text id="kity_text_10758" text-rendering="inherit" font-size="12" dy=".8em" y="3208.7000000476837" x="601.5">反射创建对象和对象实例化一样吗</text></g></g><g id="minder_node1309"><g id="node_expander1304" style="cursor: pointer;" display="none"><path id="kity_path_24434" fill="white" stroke="gray" d="M803.5,3216.5A6,6,0,1,1,791.5,3216.5A6,6,0,1,1,803.5,3216.5"></path><path id="kity_path_24435" fill="none" stroke="gray"></path></g><path id="node_outline1305" fill="none" stroke="none" d="M808.5,3171.5h862a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-862a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1305" fill="black"><text id="kity_text_10752" text-rendering="inherit" font-size="12" dy=".8em" y="3172.7000000476837" x="808.5">不一样</text><text id="kity_text_10753" text-rendering="inherit" font-size="12" dy=".8em" y="3190.7000000476837" x="808.5">//1.获取Class对象,只是得到一个class对象实例</text><text id="kity_text_10754" text-rendering="inherit" font-size="12" dy=".8em" y="3208.7000000476837" x="808.5">Class clazz = Class.forName("com.xxx.Person");  </text><text id="kity_text_10755" text-rendering="inherit" font-size="12" dy=".8em" y="3226.7000000476837" x="808.5">//2. 利用Class对象的newInstance方法创建一个类的实例，这里才是对类实例化，初始化对象属性等等，使用newInstance类一定要加载，即Class.forName("xx")</text><text id="kity_text_10756" text-rendering="inherit" font-size="12" dy=".8em" y="3244.7000000476837" x="808.5">Object obj =  clazz.newInstance();</text></g></g><g id="minder_node1310"><g id="node_expander1307" style="cursor: pointer;"><path id="kity_path_24443" fill="white" stroke="gray" d="M596.5,3332.5A6,6,0,1,1,584.5,3332.5A6,6,0,1,1,596.5,3332.5"></path><path id="kity_path_24444" fill="none" stroke="gray" d="M586,3332.5L595,3332.5"></path></g><path id="node_outline1308" fill="none" stroke="none" d="M601.5,3323.5h194a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-194a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1308" fill="black"><text id="kity_text_10768" text-rendering="inherit" font-size="12" dy=".8em" y="3324.7000000476837" x="601.5">说说通过反射可以得到类的哪些信息</text></g></g><g id="minder_node1311"><g id="node_expander1306" style="cursor: pointer;" display="none"><path id="kity_path_24440" fill="white" stroke="gray" d="M816.5,3332.5A6,6,0,1,1,804.5,3332.5A6,6,0,1,1,816.5,3332.5"></path><path id="kity_path_24441" fill="none" stroke="gray"></path></g><path id="node_outline1307" fill="none" stroke="none" d="M821.5,3269.5h781a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-781a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text1307" fill="black"><text id="kity_text_10760" text-rendering="inherit" font-size="12" dy=".8em" y="3270.7000000476837" x="821.5">每一个类都有一个Class对象，反射可以得到这个类运行时的信息，类是动态加载的，而反射可以在编译时期提供类信息。</text><text id="kity_text_10761" text-rendering="inherit" font-size="12" dy=".8em" y="3288.7000000476837" x="821.5">反射可以在运行时得到类的对象，在运行时判断对象的类，在运行时得到对象的属性，方法，构造方法。反射会影响性能，比直接执行的命令要慢。</text><text id="kity_text_10762" text-rendering="inherit" font-size="12" dy=".8em" y="3306.7000000476837" x="821.5">反射的三种方法 对象实例.class&#xa0; Class.forName() ，</text><text id="kity_text_10763" text-rendering="inherit" font-size="12" dy=".8em" y="3324.7000000476837" x="821.5">反射可以获取类的私有方法和属性，获取父类的私有方法和属性</text><text id="kity_text_10764" text-rendering="inherit" font-size="12" dy=".8em" y="3342.7000000476837" x="821.5">1.Constructor类-表示某一个类的构造方法</text><text id="kity_text_10765" text-rendering="inherit" font-size="12" dy=".8em" y="3360.7000000476837" x="821.5">2.Filed-代表某一个类的成员变量</text><text id="kity_text_10766" text-rendering="inherit" font-size="12" dy=".8em" y="3378.7000000476837" x="821.5">3.Method-表示某一个类的成员方法</text></g></g><g id="minder_node1312"><g id="node_expander1309" style="cursor: pointer;"><path id="kity_path_24449" fill="white" stroke="gray" d="M596.5,3439.5A6,6,0,1,1,584.5,3439.5A6,6,0,1,1,596.5,3439.5"></path><path id="kity_path_24450" fill="none" stroke="gray" d="M586,3439.5L595,3439.5"></path></g><path id="node_outline1310" fill="none" stroke="none" d="M601.5,3430.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1310" fill="black"><text id="kity_text_10775" text-rendering="inherit" font-size="12" dy=".8em" y="3431.7000000476837" x="601.5">反射效率问题有考虑吗</text></g></g><g id="minder_node1313"><g id="node_expander1308" style="cursor: pointer;" display="none"><path id="kity_path_24446" fill="white" stroke="gray" d="M743.5,3439.5A6,6,0,1,1,731.5,3439.5A6,6,0,1,1,743.5,3439.5"></path><path id="kity_path_24447" fill="none" stroke="gray"></path></g><path id="node_outline1309" fill="none" stroke="none" d="M748.5,3403.5h958a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-958a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1309" fill="black"><text id="kity_text_10770" text-rendering="inherit" font-size="12" dy=".8em" y="3404.7000000476837" x="748.5">1.反射的确是会影响效率，因为需要更多的参数校验而且无法反射方法内联，内联就是在把调用代码放入调用函数中。还会有一定的方法封装和解封操作，太具体的我也不是很清楚了</text><text id="kity_text_10771" text-rendering="inherit" font-size="12" dy=".8em" y="3422.7000000476837" x="748.5">调用反射时，首先会创建 Class 对象，然后获取其 Method 对象，调用 invoke 方法。获取反射方法时，有两个方法，getMethod 和 getDeclaredMethod，</text><text id="kity_text_10772" text-rendering="inherit" font-size="12" dy=".8em" y="3440.7000000476837" x="748.5">2.反射中 getMethod() 会先检查方法的可见性，检查方法权限，然后递归查找父类方法，然后获取本身方法Method对象，返回方法的拷贝</text><text id="kity_text_10773" text-rendering="inherit" font-size="12" dy=".8em" y="3458.7000000476837" x="748.5">3.http://www.imooc.com/article/293679</text></g></g><g id="minder_node1314"><g id="node_expander1311" style="cursor: pointer;"><path id="kity_path_24455" fill="white" stroke="gray" d="M596.5,3501.5A6,6,0,1,1,584.5,3501.5A6,6,0,1,1,596.5,3501.5"></path><path id="kity_path_24456" fill="none" stroke="gray" d="M586,3501.5L595,3501.5"></path></g><path id="node_outline1312" fill="none" stroke="none" d="M601.5,3492.5h182a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-182a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1312" fill="black"><text id="kity_text_10780" text-rendering="inherit" font-size="12" dy=".8em" y="3493.7000000476837" x="601.5">你刚刚说方法内联，说一下是什么</text></g></g><g id="minder_node1315"><g id="node_expander1310" style="cursor: pointer;" display="none"><path id="kity_path_24452" fill="white" stroke="gray" d="M804.5,3501.5A6,6,0,1,1,792.5,3501.5A6,6,0,1,1,804.5,3501.5"></path><path id="kity_path_24453" fill="none" stroke="gray"></path></g><path id="node_outline1311" fill="none" stroke="none" d="M809.5,3483.5h623a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-623a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1311" fill="black"><text id="kity_text_10777" text-rendering="inherit" font-size="12" dy=".8em" y="3484.7000000476837" x="809.5">1.方法内联是即时编译过程中遇到方法调用时，直接编译目标方法的方法体，并替换原方法调用。减少函数调用的技术</text><text id="kity_text_10778" text-rendering="inherit" font-size="12" dy=".8em" y="3502.7000000476837" x="809.5">2.调用方函数代码"复制"到调用方函数中</text></g></g><g id="minder_node1316"><g id="node_expander1313" style="cursor: pointer;"><path id="kity_path_24461" fill="white" stroke="gray" d="M596.5,3536.5A6,6,0,1,1,584.5,3536.5A6,6,0,1,1,596.5,3536.5"></path><path id="kity_path_24462" fill="none" stroke="gray" d="M586,3536.5L595,3536.5"></path></g><path id="node_outline1314" fill="none" stroke="none" d="M601.5,3527.5h170a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-170a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1314" fill="black"><text id="kity_text_10784" text-rendering="inherit" font-size="12" dy=".8em" y="3528.7000000476837" x="601.5">反射怎么获取实例的私有属性值</text></g></g><g id="minder_node1317"><g id="node_expander1312" style="cursor: pointer;" display="none"><path id="kity_path_24458" fill="white" stroke="gray" d="M792.5,3536.5A6,6,0,1,1,780.5,3536.5A6,6,0,1,1,792.5,3536.5"></path><path id="kity_path_24459" fill="none" stroke="gray"></path></g><path id="node_outline1313" fill="none" stroke="none" d="M797.5,3527.5h189a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-189a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1313" fill="black"><text id="kity_text_10782" text-rendering="inherit" font-size="12" dy=".8em" y="3528.7000000476837" x="797.5">1.将属性的 accessible 设置为 true&#xa0;</text></g></g><g id="minder_node1318"><g id="node_expander1315" style="cursor: pointer;"><path id="kity_path_24467" fill="white" stroke="gray" d="M596.5,3589.5A6,6,0,1,1,584.5,3589.5A6,6,0,1,1,596.5,3589.5"></path><path id="kity_path_24468" fill="none" stroke="gray" d="M586,3589.5L595,3589.5"></path></g><path id="node_outline1316" fill="none" stroke="none" d="M601.5,3580.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1316" fill="black"><text id="kity_text_10791" text-rendering="inherit" font-size="12" dy=".8em" y="3581.7000000476837" x="601.5">如何通过反射构建对象实例？</text></g></g><g id="minder_node1319"><g id="node_expander1314" style="cursor: pointer;" display="none"><path id="kity_path_24464" fill="white" stroke="gray" d="M779.5,3589.5A6,6,0,1,1,767.5,3589.5A6,6,0,1,1,779.5,3589.5"></path><path id="kity_path_24465" fill="none" stroke="gray"></path></g><path id="node_outline1315" fill="none" stroke="none" d="M784.5,3553.5h642a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-642a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1315" fill="black"><text id="kity_text_10786" text-rendering="inherit" font-size="12" dy=".8em" y="3554.7000000476837" x="784.5">1.Class.newInstance() 但是需要空参的构造函数，因为本质是执行了类对象的默认的空参的构造函数，没有就会报错。</text><text id="kity_text_10787" text-rendering="inherit" font-size="12" dy=".8em" y="3572.7000000476837" x="784.5">2. 获取类对象的构造方法来实例化，可以获取指定的构造方法 也可以获取全部然后遍历。然后通过构造方法创建实例对象</text><text id="kity_text_10788" text-rendering="inherit" font-size="12" dy=".8em" y="3590.7000000476837" x="784.5">Constroctor constroctor = clazz.getConstructor(String.class,Integer.class);&#xa0;&#xa0;</text><text id="kity_text_10789" text-rendering="inherit" font-size="12" dy=".8em" y="3608.7000000476837" x="784.5">Object obj = constroctor.newInstance("name", 18);</text></g></g><g id="minder_node1320"><g id="node_expander1318" style="cursor: pointer;"><path id="kity_path_24476" fill="white" stroke="gray" d="M596.5,3651.5A6,6,0,1,1,584.5,3651.5A6,6,0,1,1,596.5,3651.5"></path><path id="kity_path_24477" fill="none" stroke="gray" d="M586,3651.5L595,3651.5"></path></g><path id="node_outline1319" fill="none" stroke="none" d="M601.5,3642.5h206a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-206a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1319" fill="black"><text id="kity_text_10798" text-rendering="inherit" font-size="12" dy=".8em" y="3643.7000000476837" x="601.5">Class.forName和classloader的区别？</text></g></g><g id="minder_node1321"><g id="node_expander1317" style="cursor: pointer;"><path id="kity_path_24473" fill="white" stroke="gray" d="M828.5,3651.5A6,6,0,1,1,816.5,3651.5A6,6,0,1,1,828.5,3651.5"></path><path id="kity_path_24474" fill="none" stroke="gray" d="M818,3651.5L827,3651.5"></path></g><path id="node_outline1318" fill="none" stroke="none" d="M833.5,3633.5h678a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-678a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1318" fill="black"><text id="kity_text_10795" text-rendering="inherit" font-size="12" dy=".8em" y="3634.7000000476837" x="833.5">1.Class.forName除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块，默认是需要初始化。</text><text id="kity_text_10796" text-rendering="inherit" font-size="12" dy=".8em" y="3652.7000000476837" x="833.5">classloader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容，只有在newInstance才会去执行static块。</text></g></g><g id="minder_node1322"><g id="node_expander1316" style="cursor: pointer;" display="none"><path id="kity_path_24470" fill="white" stroke="gray" d="M1532.5,3651.5A6,6,0,1,1,1520.5,3651.5A6,6,0,1,1,1532.5,3651.5"></path><path id="kity_path_24471" fill="none" stroke="gray"></path></g><path id="node_outline1317" fill="none" stroke="none" d="M1537.5,3642.5h241a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-241a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1317" fill="black"><text id="kity_text_10793" text-rendering="inherit" font-size="12" dy=".8em" y="3643.7000000476837" x="1537.5">https://www.jianshu.com/p/2dbfec55c987</text></g></g><g id="minder_node1323"><g id="node_expander1321" style="cursor: pointer;"><path id="kity_path_24485" fill="white" stroke="gray" d="M544.5,3731.5A6,6,0,1,1,532.5,3731.5A6,6,0,1,1,544.5,3731.5"></path><path id="kity_path_24486" fill="none" stroke="gray" d="M534,3731.5L543,3731.5"></path></g><path id="node_outline1322" fill="none" stroke="none" d="M549.5,3722.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1322" fill="black"><text id="kity_text_10809" text-rendering="inherit" font-size="12" dy=".8em" y="3723.7000000476837" x="549.5">java定时任务的实现有了解吗</text></g></g><g id="minder_node1324"><g id="node_expander1320" style="cursor: pointer;" display="none"><path id="kity_path_24482" fill="white" stroke="gray" d="M727.5,3731.5A6,6,0,1,1,715.5,3731.5A6,6,0,1,1,727.5,3731.5"></path><path id="kity_path_24483" fill="none" stroke="gray"></path></g><path id="node_outline1321" fill="none" stroke="none" d="M732.5,3677.5h1020a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1020a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1321" fill="black"><text id="kity_text_10802" text-rendering="inherit" font-size="12" dy=".8em" y="3678.7000000476837" x="732.5">一般用的是jdk自带的这两种单机版，我大概说一下很具体的源码有点忘记。</text><text id="kity_text_10803" text-rendering="inherit" font-size="12" dy=".8em" y="3696.7000000476837" x="732.5">1.Timer：</text><text id="kity_text_10804" text-rendering="inherit" font-size="12" dy=".8em" y="3714.7000000476837" x="732.5">初始化Timer的时候,timer内部会启动一个线程，并且初始化一个优先级队列，该优先级队列使用了最小堆的技术来将最早执行时间的任务放在堆顶.</text><text id="kity_text_10805" text-rendering="inherit" font-size="12" dy=".8em" y="3732.7000000476837" x="732.5">调用schedule方法的时候,其实就是生成一个任务然后插入到该优先级队列中。</text><text id="kity_text_10806" text-rendering="inherit" font-size="12" dy=".8em" y="3750.7000000476837" x="732.5">内部的线程会从优先级队列的堆顶获取任务，获取到任务后，先判断执行时间是否到了，如果到了先设置下一次的执行时间并调整堆，然后执行任务。如果没到执行时间那线程就休眠一段时间。</text><text id="kity_text_10807" text-rendering="inherit" font-size="12" dy=".8em" y="3768.7000000476837" x="732.5">2.ScheduledThreadPoolExecutor</text></g></g><g id="minder_node1325"><g id="node_expander1323" style="cursor: pointer;"><path id="kity_path_24491" fill="white" stroke="gray" d="M544.5,3820.5A6,6,0,1,1,532.5,3820.5A6,6,0,1,1,544.5,3820.5"></path><path id="kity_path_24492" fill="none" stroke="gray" d="M534,3820.5L543,3820.5"></path></g><path id="node_outline1324" fill="none" stroke="none" d="M549.5,3811.5h215a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-215a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1324" fill="black"><text id="kity_text_10815" text-rendering="inherit" font-size="12" dy=".8em" y="3812.7000000476837" x="549.5">new和newInstance有区别吗，什么区别</text></g></g><g id="minder_node1326"><g id="node_expander1322" style="cursor: pointer;" display="none"><path id="kity_path_24488" fill="white" stroke="gray" d="M785.5,3820.5A6,6,0,1,1,773.5,3820.5A6,6,0,1,1,785.5,3820.5"></path><path id="kity_path_24489" fill="none" stroke="gray"></path></g><path id="node_outline1323" fill="none" stroke="none" d="M790.5,3793.5h1175a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1175a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1323" fill="black"><text id="kity_text_10811" text-rendering="inherit" font-size="12" dy=".8em" y="3794.7000000476837" x="790.5">1.使用newInstance时候，就必须保证：1、这个类已经加载；2、这个类已经连接了。而完成上面两个步骤的正是class的静态方法forName（）方法，这个静态方法调用了启动类加载器（就是加载javaAPI的那个加载器）。</text><text id="kity_text_10812" text-rendering="inherit" font-size="12" dy=".8em" y="3812.7000000476837" x="790.5">2.newInstance实际上是把new这个方式分解为两步,即，先调用class的加载方法加载某个类，然后实例化。这样可以在调用class的静态加载方法forName时获得更好的灵活性。</text><text id="kity_text_10813" text-rendering="inherit" font-size="12" dy=".8em" y="3830.7000000476837" x="790.5">3.new只能实现具体类的实例化，不适合接口编程，而且new是强类型的，我们实例化需要知道具体类，而newInstance是弱类型，未知类的实例化效率高，框架中广泛应用</text></g></g><g id="minder_node1327"><g id="node_expander1326" style="cursor: pointer;"><path id="kity_path_24500" fill="white" stroke="gray" d="M544.5,3873.5A6,6,0,1,1,532.5,3873.5A6,6,0,1,1,544.5,3873.5"></path><path id="kity_path_24501" fill="none" stroke="gray" d="M534,3873.5L543,3873.5"></path></g><path id="node_outline1327" fill="none" stroke="none" d="M549.5,3864.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1327" fill="black"><text id="kity_text_10822" text-rendering="inherit" font-size="12" dy=".8em" y="3865.7000000476837" x="549.5">注解</text></g></g><g id="minder_node1328"><g id="node_expander1325" style="cursor: pointer;"><path id="kity_path_24497" fill="white" stroke="gray" d="M596.5,3873.5A6,6,0,1,1,584.5,3873.5A6,6,0,1,1,596.5,3873.5"></path><path id="kity_path_24498" fill="none" stroke="gray" d="M586,3873.5L595,3873.5"></path></g><path id="node_outline1326" fill="none" stroke="none" d="M601.5,3864.5h181a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-181a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1326" fill="black"><text id="kity_text_10820" text-rendering="inherit" font-size="12" dy=".8em" y="3865.7000000476837" x="601.5">说说注解，怎么自定义一个注解呢</text></g></g><g id="minder_node1329"><g id="node_expander1324" style="cursor: pointer;" display="none"><path id="kity_path_24494" fill="white" stroke="gray" d="M803.5,3873.5A6,6,0,1,1,791.5,3873.5A6,6,0,1,1,803.5,3873.5"></path><path id="kity_path_24495" fill="none" stroke="gray"></path></g><path id="node_outline1325" fill="none" stroke="none" d="M808.5,3855.5h828a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-828a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1325" fill="black"><text id="kity_text_10817" text-rendering="inherit" font-size="12" dy=".8em" y="3856.7000000476837" x="808.5">一般自定义一个注解是在类前加上@Intrface 注解中可以定义成员变量，还可以添加默认值。</text><text id="kity_text_10818" text-rendering="inherit" font-size="12" dy=".8em" y="3874.7000000476837" x="808.5">在类上还可以加如@Target注解表明 作用于什么类 方法 字段 。表明注解是否有继承性，表明注解的存在时间，是在class文件中 可以运行时获取还是不允许</text></g></g><g id="minder_node1330"><g id="node_expander1336" style="cursor: pointer;"><path id="kity_path_24530" fill="white" stroke="gray" d="M492.5,3907.5A6,6,0,1,1,480.5,3907.5A6,6,0,1,1,492.5,3907.5"></path><path id="kity_path_24531" fill="none" stroke="gray" d="M482,3907.5L491,3907.5M486.5,3903L486.5,3912"></path></g><path id="node_outline1337" fill="none" stroke="none" d="M497.5,3898.5h11a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-11a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z" stroke-width="3"></path><g id="node_text1337" fill="black"><text id="kity_text_10846" text-rendering="inherit" font-size="12" dy=".8em" y="3899.7000000476837" x="497.5">io</text></g></g><g id="minder_node1331" display="none"><g id="node_expander1335" style="cursor: pointer;" display="none"><path id="kity_path_24527" fill="white" stroke="gray" d="M529.5,3907.5A6,6,0,1,1,517.5,3907.5A6,6,0,1,1,529.5,3907.5"></path><path id="kity_path_24528" fill="none" stroke="gray" d="M519,3907.5L528,3907.5"></path></g><path id="node_outline1336" fill="none" stroke="none" d="M529.5,3898.5h67a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-67a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1336" fill="black"><text id="kity_text_10844" text-rendering="inherit" font-size="12" dy=".8em" y="3899.7000000476837" x="529.5">AIOBIONIO</text></g></g><g id="minder_node1332" display="none"><g id="node_expander1332" style="cursor: pointer;" display="none"><path id="kity_path_24518" fill="white" stroke="gray" d="M545.5,3891.5A6,6,0,1,1,533.5,3891.5A6,6,0,1,1,545.5,3891.5"></path><path id="kity_path_24519" fill="none" stroke="gray" d="M535,3891.5L544,3891.5"></path></g><path id="node_outline1333" fill="none" stroke="none" d="M545.5,3882.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1333" fill="black"><text id="kity_text_10838" text-rendering="inherit" font-size="12" dy=".8em" y="3883.7000000476837" x="545.5">基础</text></g></g><g id="minder_node1333" display="none"><g id="node_expander1329" style="cursor: pointer;" display="none"><path id="kity_path_24509" fill="white" stroke="gray" d="M561.5,3875.5A6,6,0,1,1,549.5,3875.5A6,6,0,1,1,561.5,3875.5"></path><path id="kity_path_24510" fill="none" stroke="gray" d="M551,3875.5L560,3875.5"></path></g><path id="node_outline1330" fill="none" stroke="none" d="M561.5,3866.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1330" fill="black"><text id="kity_text_10832" text-rendering="inherit" font-size="12" dy=".8em" y="3867.7000000476837" x="561.5">说说字符流和字节流的区别</text></g></g><g id="minder_node1334" display="none"><g id="node_expander1328" style="cursor: pointer;" display="none"><path id="kity_path_24506" fill="white" stroke="gray" d="M577.5,3875.5A6,6,0,1,1,565.5,3875.5A6,6,0,1,1,577.5,3875.5"></path><path id="kity_path_24507" fill="none" stroke="gray"></path></g><path id="node_outline1329" fill="none" stroke="none" d="M577.5,3830.5h1194a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1194a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1329" fill="black"><text id="kity_text_10826" text-rendering="inherit" font-size="12" dy=".8em" y="3831.7000000476837" x="577.5">Java中一切都是字节流，没有字符流，字符只是根据编码对字节流进行翻译的结果。字符流是由Java虚拟机将字节转换得到的</text><text id="kity_text_10827" text-rendering="inherit" font-size="12" dy=".8em" y="3849.7000000476837" x="577.5">音频、视频等媒体文件用字节流比较好</text><text id="kity_text_10828" text-rendering="inherit" font-size="12" dy=".8em" y="3867.7000000476837" x="577.5">涉及到字符，中文文本的话使用字符流比较好</text><text id="kity_text_10829" text-rendering="inherit" font-size="12" dy=".8em" y="3885.7000000476837" x="577.5">1.字节流：字节流读取的时候，读到一个字节就返回一个字节</text><text id="kity_text_10830" text-rendering="inherit" font-size="12" dy=".8em" y="3903.7000000476837" x="577.5">2.字符流：字符流使用了字节流读到一个或多个字节（中文对应的字节 数是两个，在 UTF-8 中是 3 个字节），字符流是由 Java 虚拟机将字节转化为 2 个字节的 Unicode 字符为单位的字符而成的， 它对多国语言支持性比较好</text></g></g><g id="minder_node1335" display="none"><g id="node_expander1330" style="cursor: pointer;" display="none"><path id="kity_path_24512" fill="white" stroke="gray" d="M561.5,3883.5A6,6,0,1,1,549.5,3883.5A6,6,0,1,1,561.5,3883.5"></path><path id="kity_path_24513" fill="none" stroke="gray"></path></g><path id="node_outline1331" fill="none" stroke="none" d="M561.5,3874.5h108a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-108a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1331" fill="black"><text id="kity_text_10834" text-rendering="inherit" font-size="12" dy=".8em" y="3875.7000000476837" x="561.5">BIO / NIO&#xa0;的区别呢</text></g></g><g id="minder_node1336" display="none"><g id="node_expander1331" style="cursor: pointer;" display="none"><path id="kity_path_24515" fill="white" stroke="gray" d="M561.5,3891.5A6,6,0,1,1,549.5,3891.5A6,6,0,1,1,561.5,3891.5"></path><path id="kity_path_24516" fill="none" stroke="gray"></path></g><path id="node_outline1332" fill="none" stroke="none" d="M561.5,3882.5h276a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-276a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1332" fill="black"><text id="kity_text_10836" text-rendering="inherit" font-size="12" dy=".8em" y="3883.7000000476837" x="561.5">如果 NIO 的 channel 一直为空，cpu 是否会飙高？</text></g></g><g id="minder_node1337" display="none"><g id="node_expander1333" style="cursor: pointer;" display="none"><path id="kity_path_24521" fill="white" stroke="gray" d="M545.5,3899.5A6,6,0,1,1,533.5,3899.5A6,6,0,1,1,545.5,3899.5"></path><path id="kity_path_24522" fill="none" stroke="gray"></path></g><path id="node_outline1334" fill="none" stroke="none" d="M545.5,3890.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1334" fill="black"><text id="kity_text_10840" text-rendering="inherit" font-size="12" dy=".8em" y="3891.7000000476837" x="545.5">进阶</text></g></g><g id="minder_node1338" display="none"><g id="node_expander1334" style="cursor: pointer;" display="none"><path id="kity_path_24524" fill="white" stroke="gray" d="M545.5,3907.5A6,6,0,1,1,533.5,3907.5A6,6,0,1,1,545.5,3907.5"></path><path id="kity_path_24525" fill="none" stroke="gray"></path></g><path id="node_outline1335" fill="none" stroke="none" d="M545.5,3898.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1335" fill="black"><text id="kity_text_10842" text-rendering="inherit" font-size="12" dy=".8em" y="3899.7000000476837" x="545.5">场景</text></g></g><g id="minder_node1339"><g id="node_expander1697" style="cursor: pointer;"><path id="kity_path_25613" fill="white" stroke="gray" d="M492.5,10485.5A6,6,0,1,1,480.5,10485.5A6,6,0,1,1,492.5,10485.5"></path><path id="kity_path_25614" fill="none" stroke="gray" d="M482,10485.5L491,10485.5"></path></g><path id="node_outline1698" fill="none" stroke="none" d="M497.5,10476.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z" stroke-width="3"></path><g id="node_text1698" fill="black"><text id="kity_text_12019" text-rendering="inherit" font-size="12" dy=".8em" y="10477.700000047684" x="497.5">并发</text></g></g><g id="minder_node1340"><g id="node_expander1396" style="cursor: pointer;"><path id="kity_path_24710" fill="white" stroke="gray" d="M544.5,4882.5A6,6,0,1,1,532.5,4882.5A6,6,0,1,1,544.5,4882.5"></path><path id="kity_path_24711" fill="none" stroke="gray" d="M534,4882.5L543,4882.5"></path></g><path id="node_outline1397" fill="none" stroke="none" d="M549.5,4873.5h72a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-72a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1397" fill="black"><text id="kity_text_11045" text-rendering="inherit" font-size="12" dy=".8em" y="4874.700000047684" x="549.5">多线程和基础</text></g></g><g id="minder_node1341"><g id="node_expander1338" style="cursor: pointer;"><path id="kity_path_24536" fill="white" stroke="gray" d="M642.5,3961.5A6,6,0,1,1,630.5,3961.5A6,6,0,1,1,642.5,3961.5"></path><path id="kity_path_24537" fill="none" stroke="gray" d="M632,3961.5L641,3961.5"></path></g><path id="node_outline1339" fill="none" stroke="none" d="M647.5,3952.5h98a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-98a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1339" fill="black"><text id="kity_text_10853" text-rendering="inherit" font-size="12" dy=".8em" y="3953.7000000476837" x="647.5">先说说进程和线程</text></g></g><g id="minder_node1342"><g id="node_expander1337" style="cursor: pointer;" display="none"><path id="kity_path_24533" fill="white" stroke="gray" d="M766.5,3961.5A6,6,0,1,1,754.5,3961.5A6,6,0,1,1,766.5,3961.5"></path><path id="kity_path_24534" fill="none" stroke="gray"></path></g><path id="node_outline1338" fill="none" stroke="none" d="M771.5,3925.5h698a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-698a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1338" fill="black"><text id="kity_text_10848" text-rendering="inherit" font-size="12" dy=".8em" y="3926.7000000476837" x="771.5">1.</text><text id="kity_text_10849" text-rendering="inherit" font-size="12" dy=".8em" y="3944.7000000476837" x="771.5">通俗易懂的说就是</text><text id="kity_text_10850" text-rendering="inherit" font-size="12" dy=".8em" y="3962.7000000476837" x="771.5">进程：你启动微信，这就是一个进程</text><text id="kity_text_10851" text-rendering="inherit" font-size="12" dy=".8em" y="3980.7000000476837" x="771.5">线程：你启动微信后，给好友发了一条消息，就是线程在后台跑，同进程中的多个线程共享进程资源，也就是可以访问共享内存变量</text></g></g><g id="minder_node1343"><g id="node_expander1340" style="cursor: pointer;"><path id="kity_path_24542" fill="white" stroke="gray" d="M642.5,4023.5A6,6,0,1,1,630.5,4023.5A6,6,0,1,1,642.5,4023.5"></path><path id="kity_path_24543" fill="none" stroke="gray" d="M632,4023.5L641,4023.5"></path></g><path id="node_outline1341" fill="none" stroke="none" d="M647.5,4014.5h228a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-228a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1341" fill="black"><text id="kity_text_10858" text-rendering="inherit" font-size="12" dy=".8em" y="4015.7000000476837" x="647.5">进程fork多个子进程和使用多线程的区别？</text></g></g><g id="minder_node1344"><g id="node_expander1339" style="cursor: pointer;" display="none"><path id="kity_path_24539" fill="white" stroke="gray" d="M896.5,4023.5A6,6,0,1,1,884.5,4023.5A6,6,0,1,1,896.5,4023.5"></path><path id="kity_path_24540" fill="none" stroke="gray"></path></g><path id="node_outline1340" fill="none" stroke="none" d="M901.5,4005.5h399a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-399a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1340" fill="black"><text id="kity_text_10855" text-rendering="inherit" font-size="12" dy=".8em" y="4006.7000000476837" x="901.5">1.多进程-实质上没有高效的利用CPU，而且占内存比较多，进程之间不影响</text><text id="kity_text_10856" text-rendering="inherit" font-size="12" dy=".8em" y="4024.7000000476837" x="901.5">2.多线程-占内存少，CPU利用率高，线程会影响进程</text></g></g><g id="minder_node1345"><g id="node_expander1343" style="cursor: pointer;"><path id="kity_path_24551" fill="white" stroke="gray" d="M642.5,4131.5A6,6,0,1,1,630.5,4131.5A6,6,0,1,1,642.5,4131.5"></path><path id="kity_path_24552" fill="none" stroke="gray" d="M632,4131.5L641,4131.5"></path></g><path id="node_outline1344" fill="none" stroke="none" d="M647.5,4122.5h192a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-192a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1344" fill="black"><text id="kity_text_10869" text-rendering="inherit" font-size="12" dy=".8em" y="4123.700000047684" x="647.5">那你说说线程的几种状态和生命周期</text></g></g><g id="minder_node1346"><g id="node_expander1342" style="cursor: pointer;"><path id="kity_path_24548" fill="white" stroke="gray" d="M860.5,4131.5A6,6,0,1,1,848.5,4131.5A6,6,0,1,1,860.5,4131.5"></path><path id="kity_path_24549" fill="none" stroke="gray" d="M850,4131.5L859,4131.5"></path></g><path id="node_outline1343" fill="none" stroke="none" d="M865.5,4077.5h871a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-871a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1343" fill="black"><text id="kity_text_10862" text-rendering="inherit" font-size="12" dy=".8em" y="4078.7000000476837" x="865.5">1.NEW（新创建）：实例化一个Thread，</text><text id="kity_text_10863" text-rendering="inherit" font-size="12" dy=".8em" y="4096.700000047684" x="865.5">2.RUNNABLE（可运行） ：调用了start() ，有可能正在运行也有可能在等待资源中，</text><text id="kity_text_10864" text-rendering="inherit" font-size="12" dy=".8em" y="4114.700000047684" x="865.5">3.BLOCKED（被阻塞） ：阻塞状态线程正等待锁的释放</text><text id="kity_text_10865" text-rendering="inherit" font-size="12" dy=".8em" y="4132.700000047684" x="865.5">4.WAITING（等待） ：处于等待状态的线程变成RUNNABLE状态需要其他线程唤醒 进入等待状态的方法，Object.wait()。Thread.join()。LockSupport.park()</text><text id="kity_text_10866" text-rendering="inherit" font-size="12" dy=".8em" y="4150.700000047684" x="865.5">5.TIMED_WAITING（计时等待）：等待一个具体的时间，时间到后会被自动唤醒。进入等待的方法sleep。wait。Thread.join(xxx)。LockSupport.parkNanos(xxx)</text><text id="kity_text_10867" text-rendering="inherit" font-size="12" dy=".8em" y="4168.700000047684" x="865.5">6.TERMINATED（被终止）：正常run执行完成 或者没有捕获的异常终止</text></g></g><g id="minder_node1347"><g id="node_expander1341" style="cursor: pointer;" display="none"><path id="kity_path_24545" fill="white" stroke="gray" d="M1757.5,4131.5A6,6,0,1,1,1745.5,4131.5A6,6,0,1,1,1757.5,4131.5"></path><path id="kity_path_24546" fill="none" stroke="gray"></path></g><path id="node_outline1342" fill="none" stroke="none" d="M1762.5,4049.5h200a5,5,0,0,1,5,5v154a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-154a5,5,0,0,1,5,-5z"></path><g id="node_text1342" fill="black"><text id="kity_text_10860" text-rendering="inherit" font-size="12" dy=".8em" y="4196.700000047684" x="1837.5">分支主题</text></g><image id="kity_image_17058" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20201117000636824.png" x="1762.5" y="4052.5" width="200" height="141"></image></g><g id="minder_node1348"><g id="node_expander1345" style="cursor: pointer;"><path id="kity_path_24557" fill="white" stroke="gray" d="M642.5,4248.5A6,6,0,1,1,630.5,4248.5A6,6,0,1,1,642.5,4248.5"></path><path id="kity_path_24558" fill="none" stroke="gray" d="M632,4248.5L641,4248.5"></path></g><path id="node_outline1346" fill="none" stroke="none" d="M647.5,4239.5h97a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-97a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1346" fill="black"><text id="kity_text_10875" text-rendering="inherit" font-size="12" dy=".8em" y="4240.700000047684" x="647.5">并行，并发，串行</text></g></g><g id="minder_node1349"><g id="node_expander1344" style="cursor: pointer;" display="none"><path id="kity_path_24554" fill="white" stroke="gray" d="M765.5,4248.5A6,6,0,1,1,753.5,4248.5A6,6,0,1,1,765.5,4248.5"></path><path id="kity_path_24555" fill="none" stroke="gray"></path></g><path id="node_outline1345" fill="none" stroke="none" d="M770.5,4221.5h841a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-841a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1345" fill="black"><text id="kity_text_10871" text-rendering="inherit" font-size="12" dy=".8em" y="4222.700000047684" x="770.5">1.并行：是指具备同时处理多个任务的能力。</text><text id="kity_text_10872" text-rendering="inherit" font-size="12" dy=".8em" y="4240.700000047684" x="770.5">2.并发：是指具备处理多个任务的能力，但不一定要同时。多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</text><text id="kity_text_10873" text-rendering="inherit" font-size="12" dy=".8em" y="4258.700000047684" x="770.5">3.串行：任务一个一个按照顺序的运行，需要等待上一个执行完成</text></g></g><g id="minder_node1350"><g id="node_expander1347" style="cursor: pointer;"><path id="kity_path_24563" fill="white" stroke="gray" d="M642.5,4319.5A6,6,0,1,1,630.5,4319.5A6,6,0,1,1,642.5,4319.5"></path><path id="kity_path_24564" fill="none" stroke="gray" d="M632,4319.5L641,4319.5"></path></g><path id="node_outline1348" fill="none" stroke="none" d="M647.5,4310.5h74a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-74a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1348" fill="black"><text id="kity_text_10882" text-rendering="inherit" font-size="12" dy=".8em" y="4311.700000047684" x="647.5">说说线程调度</text></g></g><g id="minder_node1351"><g id="node_expander1346" style="cursor: pointer;" display="none"><path id="kity_path_24560" fill="white" stroke="gray" d="M742.5,4319.5A6,6,0,1,1,730.5,4319.5A6,6,0,1,1,742.5,4319.5"></path><path id="kity_path_24561" fill="none" stroke="gray"></path></g><path id="node_outline1347" fill="none" stroke="none" d="M747.5,4283.5h624a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-624a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1347" fill="black"><text id="kity_text_10877" text-rendering="inherit" font-size="12" dy=".8em" y="4284.700000047684" x="747.5">1.用的比较多的是两种任务调度策略</text><text id="kity_text_10878" text-rendering="inherit" font-size="12" dy=".8em" y="4302.700000047684" x="747.5">抢占式：系统来控制每一条线程 的时间片 切换等，有些多 有些少，这样不会因为某一条线程的阻塞而导致所有受影响</text><text id="kity_text_10879" text-rendering="inherit" font-size="12" dy=".8em" y="4320.700000047684" x="747.5">协同式：某一条线程执行完以后 释放资源 系统通知 切换线程 执行，如果这一条线程阻塞，那么剩下的都会受影响</text><text id="kity_text_10880" text-rendering="inherit" font-size="12" dy=".8em" y="4338.700000047684" x="747.5">2.jvm是用线程优先级的概念的，java使用的是抢占式调度，按照优先级来分配cpu时间片。</text></g></g><g id="minder_node1352"><g id="node_expander1349" style="cursor: pointer;"><path id="kity_path_24569" fill="white" stroke="gray" d="M642.5,4417.5A6,6,0,1,1,630.5,4417.5A6,6,0,1,1,642.5,4417.5"></path><path id="kity_path_24570" fill="none" stroke="gray" d="M632,4417.5L641,4417.5"></path></g><path id="node_outline1350" fill="none" stroke="none" d="M647.5,4408.5h288a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-288a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1350" fill="black"><text id="kity_text_10891" text-rendering="inherit" font-size="12" dy=".8em" y="4409.700000047684" x="647.5">那你说说创建线程有哪些方式，他们有什么主要区别吗</text></g></g><g id="minder_node1353"><g id="node_expander1348" style="cursor: pointer;" display="none"><path id="kity_path_24566" fill="white" stroke="gray" d="M956.5,4417.5A6,6,0,1,1,944.5,4417.5A6,6,0,1,1,956.5,4417.5"></path><path id="kity_path_24567" fill="none" stroke="gray"></path></g><path id="node_outline1349" fill="none" stroke="none" d="M961.5,4363.5h861a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-861a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1349" fill="black"><text id="kity_text_10884" text-rendering="inherit" font-size="12" dy=".8em" y="4364.700000047684" x="961.5">1.实现runable接口，重写run方法，没有返回值</text><text id="kity_text_10885" text-rendering="inherit" font-size="12" dy=".8em" y="4382.700000047684" x="961.5">2.继承thread类，重写run方法，无返回值</text><text id="kity_text_10886" text-rendering="inherit" font-size="12" dy=".8em" y="4400.700000047684" x="961.5">3.实现callable接口，通过FutureTask/Future来创建有返回值的Thread线程，通过executor来执行</text><text id="kity_text_10887" text-rendering="inherit" font-size="12" dy=".8em" y="4418.700000047684" x="961.5">简单点说就是 实现callable接口重写call方法，再实例化FutureTask/Future,构造参数是 callable，然后Thread(futuretask).start 启动，通过future.get获取返回值</text><text id="kity_text_10888" text-rendering="inherit" font-size="12" dy=".8em" y="4436.700000047684" x="961.5">4.通过线程池来创建，</text><text id="kity_text_10889" text-rendering="inherit" font-size="12" dy=".8em" y="4454.700000047684" x="961.5">5.通过spring注解@Async来实现，(不熟悉就说前四种)</text></g></g><g id="minder_node1354"><g id="node_expander1351" style="cursor: pointer;"><path id="kity_path_24575" fill="white" stroke="gray" d="M642.5,4524.5A6,6,0,1,1,630.5,4524.5A6,6,0,1,1,642.5,4524.5"></path><path id="kity_path_24576" fill="none" stroke="gray" d="M632,4524.5L641,4524.5"></path></g><path id="node_outline1352" fill="none" stroke="none" d="M647.5,4515.5h124a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-124a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1352" fill="black"><text id="kity_text_10899" text-rendering="inherit" font-size="12" dy=".8em" y="4516.700000047684" x="647.5">&#xa0;如何优雅的关闭线程？</text></g></g><g id="minder_node1355"><g id="node_expander1350" style="cursor: pointer;" display="none"><path id="kity_path_24572" fill="white" stroke="gray" d="M792.5,4524.5A6,6,0,1,1,780.5,4524.5A6,6,0,1,1,792.5,4524.5"></path><path id="kity_path_24573" fill="none" stroke="gray"></path></g><path id="node_outline1351" fill="none" stroke="none" d="M797.5,4479.5h792a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-792a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1351" fill="black"><text id="kity_text_10893" text-rendering="inherit" font-size="12" dy=".8em" y="4480.700000047684" x="797.5">1.</text><text id="kity_text_10894" text-rendering="inherit" font-size="12" dy=".8em" y="4498.700000047684" x="797.5">stop方法，可以终止线程，但是这个方法标记了个@Deprecated，是一个被废弃的方法</text><text id="kity_text_10895" text-rendering="inherit" font-size="12" dy=".8em" y="4516.700000047684" x="797.5">两阶段终止：第一个阶段设置中断标志interrupt() 中断线程，表示这个线程需要被中断，&#xa0;</text><text id="kity_text_10896" text-rendering="inherit" font-size="12" dy=".8em" y="4534.700000047684" x="797.5">第二阶段就是当线程检测到中断状态(isInterrupted() )后，再去执行中断后的清理逻辑。我们也可以自定义标志位，就可以不依赖线程自身的中断标记</text><text id="kity_text_10897" text-rendering="inherit" font-size="12" dy=".8em" y="4552.700000047684" x="797.5">但是如果线程在阻塞状态，需要唤醒然后再中断</text></g></g><g id="minder_node1356"><g id="node_expander1353" style="cursor: pointer;"><path id="kity_path_24581" fill="white" stroke="gray" d="M642.5,4622.5A6,6,0,1,1,630.5,4622.5A6,6,0,1,1,642.5,4622.5"></path><path id="kity_path_24582" fill="none" stroke="gray" d="M632,4622.5L641,4622.5"></path></g><path id="node_outline1354" fill="none" stroke="none" d="M647.5,4613.5h314a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-314a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1354" fill="black"><text id="kity_text_10907" text-rendering="inherit" font-size="12" dy=".8em" y="4614.700000047684" x="647.5">Java并发采用的是共享变量吗。为什么会出现线程安全问题</text></g></g><g id="minder_node1357"><g id="node_expander1352" style="cursor: pointer;" display="none"><path id="kity_path_24578" fill="white" stroke="gray" d="M982.5,4622.5A6,6,0,1,1,970.5,4622.5A6,6,0,1,1,982.5,4622.5"></path><path id="kity_path_24579" fill="none" stroke="gray"></path></g><path id="node_outline1353" fill="none" stroke="none" d="M987.5,4577.5h956a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-956a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1353" fill="black"><text id="kity_text_10901" text-rendering="inherit" font-size="12" dy=".8em" y="4578.700000047684" x="987.5">1.</text><text id="kity_text_10902" text-rendering="inherit" font-size="12" dy=".8em" y="4596.700000047684" x="987.5">java世界用的是共享内存变量</text><text id="kity_text_10903" text-rendering="inherit" font-size="12" dy=".8em" y="4614.700000047684" x="987.5">2.</text><text id="kity_text_10904" text-rendering="inherit" font-size="12" dy=".8em" y="4632.700000047684" x="987.5">在多线程中，每个线程的执行顺序，是无法预测不可控制的，那么在对数据进行读写的时候便存在由于读写顺序多乱而造成数据混乱错误的可能性。造成线程不安全</text><text id="kity_text_10905" text-rendering="inherit" font-size="12" dy=".8em" y="4650.700000047684" x="987.5">多个线程可以同时安全调用的代码称为线程安全。 如果一段代码是线程安全的，则它不包含竞争条件。 仅当多个线程更新共享资源时，才会出现争用条件。那我们就需要合理的处理</text></g></g><g id="minder_node1358"><g id="node_expander1355" style="cursor: pointer;"><path id="kity_path_24587" fill="white" stroke="gray" d="M642.5,4765.5A6,6,0,1,1,630.5,4765.5A6,6,0,1,1,642.5,4765.5"></path><path id="kity_path_24588" fill="none" stroke="gray" d="M632,4765.5L641,4765.5"></path></g><path id="node_outline1356" fill="none" stroke="none" d="M647.5,4756.5h146a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-146a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1356" fill="black"><text id="kity_text_10920" text-rendering="inherit" font-size="12" dy=".8em" y="4757.700000047684" x="647.5">说说线程通信的方式有哪些</text></g></g><g id="minder_node1359"><g id="node_expander1354" style="cursor: pointer;" display="none"><path id="kity_path_24584" fill="white" stroke="gray" d="M814.5,4765.5A6,6,0,1,1,802.5,4765.5A6,6,0,1,1,814.5,4765.5"></path><path id="kity_path_24585" fill="none" stroke="gray"></path></g><path id="node_outline1355" fill="none" stroke="none" d="M819.5,4675.5h1260a5,5,0,0,1,5,5v170a5,5,0,0,1,-5,5h-1260a5,5,0,0,1,-5,-5v-170a5,5,0,0,1,5,-5z"></path><g id="node_text1355" fill="black"><text id="kity_text_10909" text-rendering="inherit" font-size="12" dy=".8em" y="4676.700000047684" x="819.5">1.等待/通知机制</text><text id="kity_text_10910" text-rendering="inherit" font-size="12" dy=".8em" y="4694.700000047684" x="819.5">object的 wait()释放锁 进入等待(阻塞)状态，前提是先获取到锁 ，notify()唤醒等待的线程，但不一定抢到锁 , notifyall()唤醒所有正在等待相应对象锁的线程，使它们进入就绪队列，以便在当前线程释放锁后竞争锁，进而得到CPU的执行。</text><text id="kity_text_10911" text-rendering="inherit" font-size="12" dy=".8em" y="4712.700000047684" x="819.5">condition的 await()释放锁，唤醒后进入就绪态 被中断或者超时异常, singal() 唤醒一个等待线程 ,sinalAll()唤醒所有等待线程</text><text id="kity_text_10912" text-rendering="inherit" font-size="12" dy=".8em" y="4730.700000047684" x="819.5">2.锁和同步</text><text id="kity_text_10913" text-rendering="inherit" font-size="12" dy=".8em" y="4748.700000047684" x="819.5">使用锁让线程之间按照一定的顺序执行。</text><text id="kity_text_10914" text-rendering="inherit" font-size="12" dy=".8em" y="4766.700000047684" x="819.5">3.</text><text id="kity_text_10915" text-rendering="inherit" font-size="12" dy=".8em" y="4784.700000047684" x="819.5">join()是thread类方法，让当前线程陷入“等待”状态，等join的这个线程执行完成后，再继续执行当前线程。</text><text id="kity_text_10916" text-rendering="inherit" font-size="12" dy=".8em" y="4802.700000047684" x="819.5">sleep() 让当前线程睡眠一段时间，但是不释放锁</text><text id="kity_text_10917" text-rendering="inherit" font-size="12" dy=".8em" y="4820.700000047684" x="819.5">4.</text><text id="kity_text_10918" text-rendering="inherit" font-size="12" dy=".8em" y="4838.700000047684" x="819.5">volatile，信号量</text></g></g><g id="minder_node1360"><g id="node_expander1357" style="cursor: pointer;"><path id="kity_path_24593" fill="white" stroke="gray" d="M642.5,4881.5A6,6,0,1,1,630.5,4881.5A6,6,0,1,1,642.5,4881.5"></path><path id="kity_path_24594" fill="none" stroke="gray" d="M632,4881.5L641,4881.5"></path></g><path id="node_outline1358" fill="none" stroke="none" d="M647.5,4872.5h162a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-162a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1358" fill="black"><text id="kity_text_10925" text-rendering="inherit" font-size="12" dy=".8em" y="4873.700000047684" x="647.5">thread 和runable的区别 说说</text></g></g><g id="minder_node1361"><g id="node_expander1356" style="cursor: pointer;" display="none"><path id="kity_path_24590" fill="white" stroke="gray" d="M830.5,4881.5A6,6,0,1,1,818.5,4881.5A6,6,0,1,1,830.5,4881.5"></path><path id="kity_path_24591" fill="none" stroke="gray"></path></g><path id="node_outline1357" fill="none" stroke="none" d="M835.5,4863.5h771a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-771a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1357" fill="black"><text id="kity_text_10922" text-rendering="inherit" font-size="12" dy=".8em" y="4864.700000047684" x="835.5">1.</text><text id="kity_text_10923" text-rendering="inherit" font-size="12" dy=".8em" y="4882.700000047684" x="835.5">thread和runable本质是就是一个实现关系 ，thread实现了runable，提供了更多的采用方法和变量 ，我们创建线程，继承thread 实现runable，</text></g></g><g id="minder_node1362"><g id="node_expander1359" style="cursor: pointer;"><path id="kity_path_24599" fill="white" stroke="gray" d="M642.5,4943.5A6,6,0,1,1,630.5,4943.5A6,6,0,1,1,642.5,4943.5"></path><path id="kity_path_24600" fill="none" stroke="gray" d="M632,4943.5L641,4943.5"></path></g><path id="node_outline1360" fill="none" stroke="none" d="M647.5,4934.5h175a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-175a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1360" fill="black"><text id="kity_text_10932" text-rendering="inherit" font-size="12" dy=".8em" y="4935.700000047684" x="647.5">runable 和callable的区别知道吗</text></g></g><g id="minder_node1363"><g id="node_expander1358" style="cursor: pointer;" display="none"><path id="kity_path_24596" fill="white" stroke="gray" d="M843.5,4943.5A6,6,0,1,1,831.5,4943.5A6,6,0,1,1,843.5,4943.5"></path><path id="kity_path_24597" fill="none" stroke="gray"></path></g><path id="node_outline1359" fill="none" stroke="none" d="M848.5,4907.5h707a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-707a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1359" fill="black"><text id="kity_text_10927" text-rendering="inherit" font-size="12" dy=".8em" y="4908.700000047684" x="848.5">1.</text><text id="kity_text_10928" text-rendering="inherit" font-size="12" dy=".8em" y="4926.700000047684" x="848.5">runnable的核心是run方法，没有返回值，callable的核心是cell方法，是有返回值的，而且cell是可以抛异常，</text><text id="kity_text_10929" text-rendering="inherit" font-size="12" dy=".8em" y="4944.700000047684" x="848.5">runnable接口 可以传递给线程对象thread来执行任务，还可以作为线程池ExecutorService.execute(runnable)的入参来执行任务</text><text id="kity_text_10930" text-rendering="inherit" font-size="12" dy=".8em" y="4962.700000047684" x="848.5">callable的对象可以作为线程池的submit()的入参。 代码见备注</text></g><g id="kity_g_16991" style="cursor: pointer;"><path id="kity_path_16992" fill="none" stroke="none" d="M1542,4935h12a2,2,0,0,1,2,2v13a2,2,0,0,1,-2,2h-12a2,2,0,0,1,-2,-2v-13a2,2,0,0,1,2,-2z"></path><path id="kity_path_16993" fill="black" stroke="none" d="M1551,4946H1545V4945h6L1551,4946L1551,4946zM1551,4944H1545V4943h6V4944zM1551,4942H1545V4941h6V4942zM1550.5,4948H1544V4939h8v7.5M1551,4949l2,-2V4938H1543v11"></path></g></g><g id="minder_node1364"><g id="node_expander1361" style="cursor: pointer;"><path id="kity_path_24605" fill="white" stroke="gray" d="M642.5,5014.5A6,6,0,1,1,630.5,5014.5A6,6,0,1,1,642.5,5014.5"></path><path id="kity_path_24606" fill="none" stroke="gray" d="M632,5014.5L641,5014.5"></path></g><path id="node_outline1362" fill="none" stroke="none" d="M647.5,5005.5h114a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-114a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1362" fill="black"><text id="kity_text_10938" text-rendering="inherit" font-size="12" dy=".8em" y="5006.700000047684" x="647.5">sleep和wait的区别？</text></g></g><g id="minder_node1365"><g id="node_expander1360" style="cursor: pointer;" display="none"><path id="kity_path_24602" fill="white" stroke="gray" d="M782.5,5014.5A6,6,0,1,1,770.5,5014.5A6,6,0,1,1,782.5,5014.5"></path><path id="kity_path_24603" fill="none" stroke="gray"></path></g><path id="node_outline1361" fill="none" stroke="none" d="M787.5,4987.5h646a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-646a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1361" fill="black"><text id="kity_text_10934" text-rendering="inherit" font-size="12" dy=".8em" y="4988.700000047684" x="787.5">1.</text><text id="kity_text_10935" text-rendering="inherit" font-size="12" dy=".8em" y="5006.700000047684" x="787.5">sleep不释放锁，wait释放锁，sleep是thread静态方法，wait是object类方法，sleep需要捕获异常 而wait不需要捕获异常</text><text id="kity_text_10936" text-rendering="inherit" font-size="12" dy=".8em" y="5024.700000047684" x="787.5">wait需要在同步代码块中，而sleep没有这个要求</text></g></g><g id="minder_node1366"><g id="node_expander1363" style="cursor: pointer;"><path id="kity_path_24611" fill="white" stroke="gray" d="M642.5,5076.5A6,6,0,1,1,630.5,5076.5A6,6,0,1,1,642.5,5076.5"></path><path id="kity_path_24612" fill="none" stroke="gray" d="M632,5076.5L641,5076.5"></path></g><path id="node_outline1364" fill="none" stroke="none" d="M647.5,5067.5h93a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-93a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1364" fill="black"><text id="kity_text_10944" text-rendering="inherit" font-size="12" dy=".8em" y="5068.700000047684" x="647.5">run和start的区别</text></g></g><g id="minder_node1367"><g id="node_expander1362" style="cursor: pointer;" display="none"><path id="kity_path_24608" fill="white" stroke="gray" d="M761.5,5076.5A6,6,0,1,1,749.5,5076.5A6,6,0,1,1,761.5,5076.5"></path><path id="kity_path_24609" fill="none" stroke="gray"></path></g><path id="node_outline1363" fill="none" stroke="none" d="M766.5,5049.5h585a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-585a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1363" fill="black"><text id="kity_text_10940" text-rendering="inherit" font-size="12" dy=".8em" y="5050.700000047684" x="766.5">1.</text><text id="kity_text_10941" text-rendering="inherit" font-size="12" dy=".8em" y="5068.700000047684" x="766.5">start()让线程进入就绪状态，启动一个线程 等待分配时间片执行。当得到资源调度准备执行时才执行run方法，</text><text id="kity_text_10942" text-rendering="inherit" font-size="12" dy=".8em" y="5086.700000047684" x="766.5">而run只是thread一个普通方法，直接调用不会启动线程去线程，比如说在main中run 还是在主线程中执行，</text></g></g><g id="minder_node1368"><g id="node_expander1365" style="cursor: pointer;"><path id="kity_path_24617" fill="white" stroke="gray" d="M642.5,5156.5A6,6,0,1,1,630.5,5156.5A6,6,0,1,1,642.5,5156.5"></path><path id="kity_path_24618" fill="none" stroke="gray" d="M632,5156.5L641,5156.5"></path></g><path id="node_outline1366" fill="none" stroke="none" d="M647.5,5147.5h230a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-230a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1366" fill="black"><text id="kity_text_10952" text-rendering="inherit" font-size="12" dy=".8em" y="5148.700000047684" x="647.5">线程中断是什么意思，线程阻塞是什么意思</text></g></g><g id="minder_node1369"><g id="node_expander1364" style="cursor: pointer;" display="none"><path id="kity_path_24614" fill="white" stroke="gray" d="M898.5,5156.5A6,6,0,1,1,886.5,5156.5A6,6,0,1,1,898.5,5156.5"></path><path id="kity_path_24615" fill="none" stroke="gray"></path></g><path id="node_outline1365" fill="none" stroke="none" d="M903.5,5111.5h1656a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1656a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1365" fill="black"><text id="kity_text_10946" text-rendering="inherit" font-size="12" dy=".8em" y="5112.700000047684" x="903.5">1.</text><text id="kity_text_10947" text-rendering="inherit" font-size="12" dy=".8em" y="5130.700000047684" x="903.5">线程中断：通知线程不再执行后续流程，而在java中中断线程可以通过就是提供中断信号量来中断非阻塞状态的线程。也可以使用thread.interrupt()的相关方法 如测试线程是否已经中断，，查看当前中断信号并且清除中断信号。同步锁是不可以中断的，不抛出异常会阻塞等待。</text><text id="kity_text_10948" text-rendering="inherit" font-size="12" dy=".8em" y="5148.700000047684" x="903.5">在RUNNABLE中的线程 interrupt 仅设置线程的中断标志，我们自己处理响应中断。 WAITING 状态 在等待队列阻塞，等待唤醒，一旦被中断，直接抛异常，所以&#xa0; wait、sleep、join 须处理受检中断异常 InterruptException因为这些方法会阻塞线程，而如果在阻塞期间收到中断，你也应当提供中断的处理逻辑。</text><text id="kity_text_10949" text-rendering="inherit" font-size="12" dy=".8em" y="5166.700000047684" x="903.5">BLOCKED 对于中断请求不做额外响应，仅仅设置一下中断标志位，具体什么时候处理中断需要程序自己去循环检测判断。</text><text id="kity_text_10950" text-rendering="inherit" font-size="12" dy=".8em" y="5184.700000047684" x="903.5">线程阻塞：当线程尝试获取一个已经被持有的对象锁的时侯，这个线程就会阻塞，不需要显式唤醒，不响应中断。</text></g></g><g id="minder_node1370"><g id="node_expander1367" style="cursor: pointer;"><path id="kity_path_24623" fill="white" stroke="gray" d="M642.5,5218.5A6,6,0,1,1,630.5,5218.5A6,6,0,1,1,642.5,5218.5"></path><path id="kity_path_24624" fill="none" stroke="gray" d="M632,5218.5L641,5218.5"></path></g><path id="node_outline1368" fill="none" stroke="none" d="M647.5,5209.5h134a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-134a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1368" fill="black"><text id="kity_text_10956" text-rendering="inherit" font-size="12" dy=".8em" y="5210.700000047684" x="647.5">怎么唤醒一个阻塞的线程</text></g></g><g id="minder_node1371"><g id="node_expander1366" style="cursor: pointer;" display="none"><path id="kity_path_24620" fill="white" stroke="gray" d="M802.5,5218.5A6,6,0,1,1,790.5,5218.5A6,6,0,1,1,802.5,5218.5"></path><path id="kity_path_24621" fill="none" stroke="gray"></path></g><path id="node_outline1367" fill="none" stroke="none" d="M807.5,5209.5h1266a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1266a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1367" fill="black"><text id="kity_text_10954" text-rendering="inherit" font-size="12" dy=".8em" y="5210.700000047684" x="807.5">1.如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统</text></g></g><g id="minder_node1372"><g id="node_expander1369" style="cursor: pointer;"><path id="kity_path_24629" fill="white" stroke="gray" d="M642.5,5271.5A6,6,0,1,1,630.5,5271.5A6,6,0,1,1,642.5,5271.5"></path><path id="kity_path_24630" fill="none" stroke="gray" d="M632,5271.5L641,5271.5"></path></g><path id="node_outline1370" fill="none" stroke="none" d="M647.5,5262.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1370" fill="black"><text id="kity_text_10963" text-rendering="inherit" font-size="12" dy=".8em" y="5263.700000047684" x="647.5">java线程中断原理知道？</text></g></g><g id="minder_node1373"><g id="node_expander1368" style="cursor: pointer;" display="none"><path id="kity_path_24626" fill="white" stroke="gray" d="M801.5,5271.5A6,6,0,1,1,789.5,5271.5A6,6,0,1,1,801.5,5271.5"></path><path id="kity_path_24627" fill="none" stroke="gray"></path></g><path id="node_outline1369" fill="none" stroke="none" d="M806.5,5235.5h1013a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1013a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1369" fill="black"><text id="kity_text_10958" text-rendering="inherit" font-size="12" dy=".8em" y="5236.700000047684" x="806.5">1.java是协作式中断， “协作“是指在中断发生时，系统（JVM）会改变中断标记，但并不强制应用程序中断。</text><text id="kity_text_10959" text-rendering="inherit" font-size="12" dy=".8em" y="5254.700000047684" x="806.5">对应用程序来说，需要主动检查中断标记，通过中断并不能直接终止另一个线程，而需要被中断的线程自己处理中断。并最终决定是否中断。 </text><text id="kity_text_10960" text-rendering="inherit" font-size="12" dy=".8em" y="5272.700000047684" x="806.5">2.每个线程对象里都有一个boolean类型的标识,这些最终都是通过native方法来完成，代表着是否有中断请求（该中断请求可以来自所有线程，包括被中断的线程本身）。</text><text id="kity_text_10961" text-rendering="inherit" font-size="12" dy=".8em" y="5290.700000047684" x="806.5">如，当线程t1想中断线程t2，只需要在线程t1中将线程t2对象的中断标识置为true，然后线程2可以选择在合适的时候处理该中断请求，甚至可以不理会该请求，就像这个线程没有被中断一样。</text></g></g><g id="minder_node1374"><g id="node_expander1372" style="cursor: pointer;"><path id="kity_path_24638" fill="white" stroke="gray" d="M642.5,5351.5A6,6,0,1,1,630.5,5351.5A6,6,0,1,1,642.5,5351.5"></path><path id="kity_path_24639" fill="none" stroke="gray" d="M632,5351.5L641,5351.5"></path></g><path id="node_outline1373" fill="none" stroke="none" d="M647.5,5342.5h240a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-240a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1373" fill="black"><text id="kity_text_10972" text-rendering="inherit" font-size="12" dy=".8em" y="5343.700000047684" x="647.5">那怎么处理线程中断的异常呢，有什么原则吗</text></g></g><g id="minder_node1375"><g id="node_expander1371" style="cursor: pointer;"><path id="kity_path_24635" fill="white" stroke="gray" d="M908.5,5351.5A6,6,0,1,1,896.5,5351.5A6,6,0,1,1,908.5,5351.5"></path><path id="kity_path_24636" fill="none" stroke="gray" d="M898,5351.5L907,5351.5"></path></g><path id="node_outline1372" fill="none" stroke="none" d="M913.5,5315.5h1474a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1474a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1372" fill="black"><text id="kity_text_10967" text-rendering="inherit" font-size="12" dy=".8em" y="5316.700000047684" x="913.5">1.一般当可能阻塞的方法声明中有抛出InterruptedException则暗示该方法是可中断的，如BlockingQueue#put、Object#wait、Thread#sleep等，如果程序捕获到这些可中断的阻塞方法抛出的InterruptedException或检测到中断后，中断信息该处理一般有以下两个通用原则：</text><text id="kity_text_10968" text-rendering="inherit" font-size="12" dy=".8em" y="5334.700000047684" x="913.5">2.遇到的是可中断的阻塞方法抛出InterruptedException，可以继续向方法调用栈的上层抛出该异常，如果是检测到中断，则可清除中断状态并抛出InterruptedException，使当前方法也成为一个可中断的方法。</text><text id="kity_text_10969" text-rendering="inherit" font-size="12" dy=".8em" y="5352.700000047684" x="913.5">我们就可以捕捉到中断异常，并根据实际情况对该线程从阻塞方法中异常退出而进行一些处理。</text><text id="kity_text_10970" text-rendering="inherit" font-size="12" dy=".8em" y="5370.700000047684" x="913.5">3.若不太方便在方法上抛出InterruptedException异常，比如要实现方法签名上没有throws InterruptedException，可以捕获可中断方法的InterruptedException并通过Thread.currentThread.interrupt()来重新设置中断状态，重新设置中断线程</text></g></g><g id="minder_node1376"><g id="node_expander1370" style="cursor: pointer;" display="none"><path id="kity_path_24632" fill="white" stroke="gray" d="M2408.5,5351.5A6,6,0,1,1,2396.5,5351.5A6,6,0,1,1,2408.5,5351.5"></path><path id="kity_path_24633" fill="none" stroke="gray"></path></g><path id="node_outline1371" fill="none" stroke="none" d="M2413.5,5342.5h231a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-231a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1371" fill="black"><text id="kity_text_10965" text-rendering="inherit" font-size="12" dy=".8em" y="5343.700000047684" x="2413.5">https://zhuanlan.zhihu.com/p/27857336</text></g></g><g id="minder_node1377"><g id="node_expander1395" style="cursor: pointer;"><path id="kity_path_24707" fill="white" stroke="gray" d="M642.5,5804.5A6,6,0,1,1,630.5,5804.5A6,6,0,1,1,642.5,5804.5"></path><path id="kity_path_24708" fill="none" stroke="gray" d="M632,5804.5L641,5804.5"></path></g><path id="node_outline1396" fill="none" stroke="none" d="M647.5,5795.5h71a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-71a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1396" fill="black"><text id="kity_text_11043" text-rendering="inherit" font-size="12" dy=".8em" y="5796.700000047684" x="647.5">ThreadLocal</text></g></g><g id="minder_node1378"><g id="node_expander1374" style="cursor: pointer;"><path id="kity_path_24644" fill="white" stroke="gray" d="M739.5,5440.5A6,6,0,1,1,727.5,5440.5A6,6,0,1,1,739.5,5440.5"></path><path id="kity_path_24645" fill="none" stroke="gray" d="M729,5440.5L738,5440.5"></path></g><path id="node_outline1375" fill="none" stroke="none" d="M744.5,5431.5h192a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-192a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1375" fill="black"><text id="kity_text_10980" text-rendering="inherit" font-size="12" dy=".8em" y="5432.700000047684" x="744.5">你知道ThreadLocal吗，可以做什么</text></g></g><g id="minder_node1379"><g id="node_expander1373" style="cursor: pointer;" display="none"><path id="kity_path_24641" fill="white" stroke="gray" d="M957.5,5440.5A6,6,0,1,1,945.5,5440.5A6,6,0,1,1,957.5,5440.5"></path><path id="kity_path_24642" fill="none" stroke="gray"></path></g><path id="node_outline1374" fill="none" stroke="none" d="M962.5,5395.5h1666a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1666a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1374" fill="black"><text id="kity_text_10974" text-rendering="inherit" font-size="12" dy=".8em" y="5396.700000047684" x="962.5">1.</text><text id="kity_text_10975" text-rendering="inherit" font-size="12" dy=".8em" y="5414.700000047684" x="962.5">可以做线程消息隔离，如session，和用户请求等，实现同一线程下多个类之间的数据传递 基本场景就是共享变量会对线程安全造成影响，它的思想是让每个线程都使用自己的“共享资源”，各自使用各自的，又互相不影响到彼此即让多个线程间达到隔离的状态，这样也不会出现线程安全问题。这是属于空间换时间</text><text id="kity_text_10976" text-rendering="inherit" font-size="12" dy=".8em" y="5432.700000047684" x="962.5">为每个线程提供一个自己独有的变量拷贝，无锁的情况下保障线程安全。</text><text id="kity_text_10977" text-rendering="inherit" font-size="12" dy=".8em" y="5450.700000047684" x="962.5">2.</text><text id="kity_text_10978" text-rendering="inherit" font-size="12" dy=".8em" y="5468.700000047684" x="962.5">本质上是每个thread实例引用的threadLocalMap,也就是说每个不同的线程都拥有专属于自己的数据容器，threadLocal只适用于 共享对象会造成线程安全 的业务场景</text></g></g><g id="minder_node1380"><g id="node_expander1376" style="cursor: pointer;"><path id="kity_path_24650" fill="white" stroke="gray" d="M739.5,5529.5A6,6,0,1,1,727.5,5529.5A6,6,0,1,1,739.5,5529.5"></path><path id="kity_path_24651" fill="none" stroke="gray" d="M729,5529.5L738,5529.5"></path></g><path id="node_outline1377" fill="none" stroke="none" d="M744.5,5520.5h146a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-146a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1377" fill="black"><text id="kity_text_10987" text-rendering="inherit" font-size="12" dy=".8em" y="5521.700000047684" x="744.5">说说他的get方法和set方法</text></g></g><g id="minder_node1381"><g id="node_expander1375" style="cursor: pointer;" display="none"><path id="kity_path_24647" fill="white" stroke="gray" d="M911.5,5529.5A6,6,0,1,1,899.5,5529.5A6,6,0,1,1,911.5,5529.5"></path><path id="kity_path_24648" fill="none" stroke="gray"></path></g><path id="node_outline1376" fill="none" stroke="none" d="M916.5,5493.5h1618a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1618a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1376" fill="black"><text id="kity_text_10982" text-rendering="inherit" font-size="12" dy=".8em" y="5494.700000047684" x="916.5">1.set：设置在当前线程中threadLocal变量的值</text><text id="kity_text_10983" text-rendering="inherit" font-size="12" dy=".8em" y="5512.700000047684" x="916.5">先获取当前实例对象thread 通过当前线程实例获取thread维护的ThreadLocalMap对象，若threadLocalMap不为null,则以threadLocal实例为key,值为value的键值对存入threadLocalMap,若threadLocalMap为null的话，就新建threadLocalMap然后在以threadLocal为键，值为value的键值对存入即可。</text><text id="kity_text_10984" text-rendering="inherit" font-size="12" dy=".8em" y="5530.700000047684" x="916.5">2.get 获取当前线程中threadLocal变量的值</text><text id="kity_text_10985" text-rendering="inherit" font-size="12" dy=".8em" y="5548.700000047684" x="916.5">通过当前线程thread实例获取到它所维护的threadLocalMap，然后以当前threadLocal实例为key获取该map中的键值对（Entry），若Entry不为null则返回Entry的value。如果获取threadLocalMap为null或者Entry为null的话，就以当前threadLocal为Key，value为null存入map后，并返回null。</text></g></g><g id="minder_node1382"><g id="node_expander1378" style="cursor: pointer;"><path id="kity_path_24656" fill="white" stroke="gray" d="M739.5,5591.5A6,6,0,1,1,727.5,5591.5A6,6,0,1,1,739.5,5591.5"></path><path id="kity_path_24657" fill="none" stroke="gray" d="M729,5591.5L738,5591.5"></path></g><path id="node_outline1379" fill="none" stroke="none" d="M744.5,5582.5h155a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-155a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1379" fill="black"><text id="kity_text_10992" text-rendering="inherit" font-size="12" dy=".8em" y="5583.700000047684" x="744.5">说说ThreadLocal的底层结构</text></g></g><g id="minder_node1383"><g id="node_expander1377" style="cursor: pointer;" display="none"><path id="kity_path_24653" fill="white" stroke="gray" d="M920.5,5591.5A6,6,0,1,1,908.5,5591.5A6,6,0,1,1,920.5,5591.5"></path><path id="kity_path_24654" fill="none" stroke="gray"></path></g><path id="node_outline1378" fill="none" stroke="none" d="M925.5,5573.5h1647a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1647a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1378" fill="black"><text id="kity_text_10989" text-rendering="inherit" font-size="12" dy=".8em" y="5574.700000047684" x="925.5">1.每个thread类内部维护threadlocals成员，这个成员是threadlocalmap类型的，threadlocalmap是threadlocal的内部类，本质上的操作都是在threadlocalmap上操作的，threadlocalmap内部维护着一个entry类型的table数组，他的长度是2的幂次方，并且他是一个弱引用，因为它继承了WeakReference 。</text><text id="kity_text_10990" text-rendering="inherit" font-size="12" dy=".8em" y="5592.700000047684" x="925.5">这个entry是以threadlocal为key object为value的K-V，也就是这个map是以threadlocal为key,object为value的K-V 。</text></g></g><g id="minder_node1384"><g id="node_expander1381" style="cursor: pointer;"><path id="kity_path_24665" fill="white" stroke="gray" d="M739.5,5685.5A6,6,0,1,1,727.5,5685.5A6,6,0,1,1,739.5,5685.5"></path><path id="kity_path_24666" fill="none" stroke="gray" d="M729,5685.5L738,5685.5"></path></g><path id="node_outline1382" fill="none" stroke="none" d="M744.5,5676.5h293a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-293a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1382" fill="black"><text id="kity_text_11001" text-rendering="inherit" font-size="12" dy=".8em" y="5677.700000047684" x="744.5">他有存在哪些问题，你说了内存泄漏 那他是怎么解决的</text></g></g><g id="minder_node1385"><g id="node_expander1380" style="cursor: pointer;"><path id="kity_path_24662" fill="white" stroke="gray" d="M1058.5,5685.5A6,6,0,1,1,1046.5,5685.5A6,6,0,1,1,1058.5,5685.5"></path><path id="kity_path_24663" fill="none" stroke="gray" d="M1048,5685.5L1057,5685.5"></path></g><path id="node_outline1381" fill="none" stroke="none" d="M1063.5,5649.5h1298a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1298a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1381" fill="black"><text id="kity_text_10996" text-rendering="inherit" font-size="12" dy=".8em" y="5650.700000047684" x="1063.5">1.</text><text id="kity_text_10997" text-rendering="inherit" font-size="12" dy=".8em" y="5668.700000047684" x="1063.5">entry中的key是弱引用，也就是说entry中的key指向threadlocal的引用是弱引用，当栈中的threadlocal指向堆中的threadlocal引用为null时，当GC时堆中的threadlocal就在可达性分析中没有引用链可以访问它了，那么threadlocal就会被回收，</text><text id="kity_text_10998" text-rendering="inherit" font-size="12" dy=".8em" y="5686.700000047684" x="1063.5">这个时侯map就会出现key为null的entry，我们就无法访问这些key为Null的entry了，就永远无法回收，造成了内存泄漏。除非当前线程停止，但是我们肯定是要用线程池的，为了线程复用，不会让他去停止，</text><text id="kity_text_10999" text-rendering="inherit" font-size="12" dy=".8em" y="5704.700000047684" x="1063.5">需要我们自己显式的在处理完代码逻辑以后调用remove方法，</text></g></g><g id="minder_node1386"><g id="node_expander1379" style="cursor: pointer;" display="none"><path id="kity_path_24659" fill="white" stroke="gray" d="M2382.5,5686A6,6,0,1,1,2370.5,5686A6,6,0,1,1,2382.5,5686"></path><path id="kity_path_24660" fill="none" stroke="gray"></path></g><path id="node_outline1380" fill="none" stroke="none" d="M2387.5,5618.5h200a5,5,0,0,1,5,5v125a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-125a5,5,0,0,1,5,-5z"></path><g id="node_text1380" fill="black"><text id="kity_text_10994" text-rendering="inherit" font-size="12" dy=".8em" y="5736.700000047684" x="2462.5">分支主题</text></g><image id="kity_image_17059" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210505102231.png" x="2387.5" y="5621.5" width="200" height="112"></image></g><g id="minder_node1387"><g id="node_expander1383" style="cursor: pointer;"><path id="kity_path_24671" fill="white" stroke="gray" d="M739.5,5796.5A6,6,0,1,1,727.5,5796.5A6,6,0,1,1,739.5,5796.5"></path><path id="kity_path_24672" fill="none" stroke="gray" d="M729,5796.5L738,5796.5"></path></g><path id="node_outline1384" fill="none" stroke="none" d="M744.5,5787.5h108a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-108a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1384" fill="black"><text id="kity_text_11008" text-rendering="inherit" font-size="12" dy=".8em" y="5788.700000047684" x="744.5">为什么使用弱引用？</text></g></g><g id="minder_node1388"><g id="node_expander1382" style="cursor: pointer;" display="none"><path id="kity_path_24668" fill="white" stroke="gray" d="M873.5,5796.5A6,6,0,1,1,861.5,5796.5A6,6,0,1,1,873.5,5796.5"></path><path id="kity_path_24669" fill="none" stroke="gray"></path></g><path id="node_outline1383" fill="none" stroke="none" d="M878.5,5760.5h793a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-793a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1383" fill="black"><text id="kity_text_11003" text-rendering="inherit" font-size="12" dy=".8em" y="5761.700000047684" x="878.5">1.如果使用强引用</text><text id="kity_text_11004" text-rendering="inherit" font-size="12" dy=".8em" y="5779.700000047684" x="878.5">那么当我们把threadlocal栈引用置null后，但是因为entry强引用threadlocal,在GC时，threadlocal依然可达，并不会回收，还是造成了内存泄漏</text><text id="kity_text_11005" text-rendering="inherit" font-size="12" dy=".8em" y="5797.700000047684" x="878.5">2.如果使用弱引用</text><text id="kity_text_11006" text-rendering="inherit" font-size="12" dy=".8em" y="5815.700000047684" x="878.5">使用弱引用虽然会造成内存泄漏，但是在threadlocal的生命周期中，set get remove都针对key为null的脏数据进行处理，尽量保证了不出现内存泄漏</text></g></g><g id="minder_node1389"><g id="node_expander1386" style="cursor: pointer;"><path id="kity_path_24680" fill="white" stroke="gray" d="M739.5,5894.5A6,6,0,1,1,727.5,5894.5A6,6,0,1,1,739.5,5894.5"></path><path id="kity_path_24681" fill="none" stroke="gray" d="M729,5894.5L738,5894.5"></path></g><path id="node_outline1387" fill="none" stroke="none" d="M744.5,5885.5h61a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-61a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1387" fill="black"><text id="kity_text_11019" text-rendering="inherit" font-size="12" dy=".8em" y="5886.700000047684" x="744.5">如何扩容？</text></g></g><g id="minder_node1390"><g id="node_expander1385" style="cursor: pointer;"><path id="kity_path_24677" fill="white" stroke="gray" d="M826.5,5894.5A6,6,0,1,1,814.5,5894.5A6,6,0,1,1,826.5,5894.5"></path><path id="kity_path_24678" fill="none" stroke="gray" d="M816,5894.5L825,5894.5"></path></g><path id="node_outline1386" fill="none" stroke="none" d="M831.5,5840.5h721a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-721a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1386" fill="black"><text id="kity_text_11012" text-rendering="inherit" font-size="12" dy=".8em" y="5841.700000047684" x="831.5">1.确定初始大小和加载因子</text><text id="kity_text_11013" text-rendering="inherit" font-size="12" dy=".8em" y="5859.700000047684" x="831.5">在第一个set时会创建一个容量16的threadlocalmap，然后加载因子为 2/3 ，此时hash表的可用容量是10=16*(2/3)</text><text id="kity_text_11014" text-rendering="inherit" font-size="12" dy=".8em" y="5877.700000047684" x="831.5">2. 扩容</text><text id="kity_text_11015" text-rendering="inherit" font-size="12" dy=".8em" y="5895.700000047684" x="831.5">当size&gt;可用容量时，就会通过resize扩容，新创建一个两倍原来数组的新数组，然后遍历老数组，</text><text id="kity_text_11016" text-rendering="inherit" font-size="12" dy=".8em" y="5913.700000047684" x="831.5">在扩容的时侯如果遇到了脏entry 就会让value为null，方便GC回收，解决内存泄漏问题，然后重新确认entry在数组的位置，插入新数组</text><text id="kity_text_11017" text-rendering="inherit" font-size="12" dy=".8em" y="5931.700000047684" x="831.5">然后重新数组hash表的可用容量和size</text></g></g><g id="minder_node1391"><g id="node_expander1384" style="cursor: pointer;" display="none"><path id="kity_path_24674" fill="white" stroke="gray" d="M1573.5,5894.5A6,6,0,1,1,1561.5,5894.5A6,6,0,1,1,1573.5,5894.5"></path><path id="kity_path_24675" fill="none" stroke="gray"></path></g><path id="node_outline1385" fill="none" stroke="none" d="M1578.5,5885.5h802a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-802a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1385" fill="black"><text id="kity_text_11010" text-rendering="inherit" font-size="12" dy=".8em" y="5886.700000047684" x="1578.5">https://www.codercc.com/backend/basic/juc/concurrent-container/ThreadLocal.html#_1-threadlocal%E7%9A%84%E7%AE%80%E4%BB%8B</text></g></g><g id="minder_node1392"><g id="node_expander1388" style="cursor: pointer;"><path id="kity_path_24686" fill="white" stroke="gray" d="M739.5,6001.5A6,6,0,1,1,727.5,6001.5A6,6,0,1,1,739.5,6001.5"></path><path id="kity_path_24687" fill="none" stroke="gray" d="M729,6001.5L738,6001.5"></path></g><path id="node_outline1389" fill="none" stroke="none" d="M744.5,5992.5h187a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-187a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1389" fill="black"><text id="kity_text_11027" text-rendering="inherit" font-size="12" dy=".8em" y="5993.700000047684" x="744.5">ThreadLocl怎么解决hash冲突的，</text></g></g><g id="minder_node1393"><g id="node_expander1387" style="cursor: pointer;" display="none"><path id="kity_path_24683" fill="white" stroke="gray" d="M952.5,6001.5A6,6,0,1,1,940.5,6001.5A6,6,0,1,1,952.5,6001.5"></path><path id="kity_path_24684" fill="none" stroke="gray"></path></g><path id="node_outline1388" fill="none" stroke="none" d="M957.5,5956.5h1436a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1436a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1388" fill="black"><text id="kity_text_11021" text-rendering="inherit" font-size="12" dy=".8em" y="5957.700000047684" x="957.5">1.</text><text id="kity_text_11022" text-rendering="inherit" font-size="12" dy=".8em" y="5975.700000047684" x="957.5">ThreadLocalMap 中使用开放地址法来处理散列冲突，而 HashMap 中使用的分离链表法。之所以采用不同的方式主要是因为：在 ThreadLocalMap 中的散列值分散的十分均匀，很少会出现冲突。并且 ThreadLocalMap 经常需要清除无用的对象，使用纯数组更加方便。</text><text id="kity_text_11023" text-rendering="inherit" font-size="12" dy=".8em" y="5993.700000047684" x="957.5">开放定址法不会去创建链表，如果有冲突时，会尝试去数组中寻找其他位置，直到寻找到一个空的位置，寻找空位一般是 线性探测法，从冲突位置开始寻找，找到尾，再从数组头开始找</text><text id="kity_text_11024" text-rendering="inherit" font-size="12" dy=".8em" y="6011.700000047684" x="957.5">2.为什么均匀分布</text><text id="kity_text_11025" text-rendering="inherit" font-size="12" dy=".8em" y="6029.700000047684" x="957.5">是因为用了一个AtomicInteger加一个特殊值，具体忘记了，这个特殊值可以让hash表中的每一个值都均匀分布，叫斐波那契hash</text></g></g><g id="minder_node1394"><g id="node_expander1390" style="cursor: pointer;"><path id="kity_path_24692" fill="white" stroke="gray" d="M739.5,6072.5A6,6,0,1,1,727.5,6072.5A6,6,0,1,1,739.5,6072.5"></path><path id="kity_path_24693" fill="none" stroke="gray" d="M729,6072.5L738,6072.5"></path></g><path id="node_outline1391" fill="none" stroke="none" d="M744.5,6063.5h160a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-160a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1391" fill="black"><text id="kity_text_11032" text-rendering="inherit" font-size="12" dy=".8em" y="6064.700000047684" x="744.5">你说说ThreadLocl的使用场景</text></g></g><g id="minder_node1395"><g id="node_expander1389" style="cursor: pointer;" display="none"><path id="kity_path_24689" fill="white" stroke="gray" d="M925.5,6072.5A6,6,0,1,1,913.5,6072.5A6,6,0,1,1,925.5,6072.5"></path><path id="kity_path_24690" fill="none" stroke="gray"></path></g><path id="node_outline1390" fill="none" stroke="none" d="M930.5,6054.5h792a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-792a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1390" fill="black"><text id="kity_text_11029" text-rendering="inherit" font-size="12" dy=".8em" y="6055.700000047684" x="930.5">1.</text><text id="kity_text_11030" text-rendering="inherit" font-size="12" dy=".8em" y="6073.700000047684" x="930.5">做线程信息隔离，当线程共享变量出现线程安全时就可以用threadlocal，如数据库连接，每一个用户的session会话，，需要防止用户信息错乱，还要</text></g></g><g id="minder_node1396"><g id="node_expander1391" style="cursor: pointer;" display="none"><path id="kity_path_24695" fill="white" stroke="gray" d="M739.5,6107.5A6,6,0,1,1,727.5,6107.5A6,6,0,1,1,739.5,6107.5"></path><path id="kity_path_24696" fill="none" stroke="gray"></path></g><path id="node_outline1392" fill="none" stroke="none" d="M744.5,6098.5h167a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-167a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1392" fill="black"><text id="kity_text_11034" text-rendering="inherit" font-size="12" dy=".8em" y="6099.700000047684" x="744.5">知道ThreadLocal逃逸是什么吗</text></g></g><g id="minder_node1397"><g id="node_expander1392" style="cursor: pointer;" display="none"><path id="kity_path_24698" fill="white" stroke="gray" d="M739.5,6133.5A6,6,0,1,1,727.5,6133.5A6,6,0,1,1,739.5,6133.5"></path><path id="kity_path_24699" fill="none" stroke="gray"></path></g><path id="node_outline1393" fill="none" stroke="none" d="M744.5,6124.5h149a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-149a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1393" fill="black"><text id="kity_text_11036" text-rendering="inherit" font-size="12" dy=".8em" y="6125.700000047684" x="744.5">为什么会有threadlocal逃逸</text></g></g><g id="minder_node1398"><g id="node_expander1394" style="cursor: pointer;"><path id="kity_path_24704" fill="white" stroke="gray" d="M739.5,6168.5A6,6,0,1,1,727.5,6168.5A6,6,0,1,1,739.5,6168.5"></path><path id="kity_path_24705" fill="none" stroke="gray" d="M729,6168.5L738,6168.5"></path></g><path id="node_outline1395" fill="none" stroke="none" d="M744.5,6159.5h314a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-314a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1395" fill="black"><text id="kity_text_11041" text-rendering="inherit" font-size="12" dy=".8em" y="6160.700000047684" x="744.5">ThreadLocal使用后一定要remove吗，不remove会怎么样</text></g></g><g id="minder_node1399"><g id="node_expander1393" style="cursor: pointer;" display="none"><path id="kity_path_24701" fill="white" stroke="gray" d="M1079.5,6168.5A6,6,0,1,1,1067.5,6168.5A6,6,0,1,1,1079.5,6168.5"></path><path id="kity_path_24702" fill="none" stroke="gray"></path></g><path id="node_outline1394" fill="none" stroke="none" d="M1084.5,6150.5h1013a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1013a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1394" fill="black"><text id="kity_text_11038" text-rendering="inherit" font-size="12" dy=".8em" y="6151.700000047684" x="1084.5">1.需要我们在代码层面上处理，即处理后逻辑后确保调用remove，如果处理不当可能处理数据蹿用。如后端调接口获取用户信息，然后使用ThreadLocal保存，使用后remove掉。</text><text id="kity_text_11039" text-rendering="inherit" font-size="12" dy=".8em" y="6169.700000047684" x="1084.5">因为一次操作可能有多个地方使用这个信息，这么做算是一次缓存。但是如果中间操作报错，remove代码没有执行，那么下个用户进来，发现ThreadLocal有数据，直接取来用，则发生错误。</text></g></g><g id="minder_node1400"><g id="node_expander1415" style="cursor: pointer;"><path id="kity_path_24767" fill="white" stroke="gray" d="M544.5,6473.5A6,6,0,1,1,532.5,6473.5A6,6,0,1,1,544.5,6473.5"></path><path id="kity_path_24768" fill="none" stroke="gray" d="M534,6473.5L543,6473.5"></path></g><path id="node_outline1416" fill="none" stroke="none" d="M549.5,6464.5h62a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-62a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1416" fill="black"><text id="kity_text_11105" text-rendering="inherit" font-size="12" dy=".8em" y="6465.700000047684" x="549.5">并发关键字</text></g></g><g id="minder_node1401"><g id="node_expander1414" style="cursor: pointer;"><path id="kity_path_24764" fill="white" stroke="gray" d="M632.5,6473.5A6,6,0,1,1,620.5,6473.5A6,6,0,1,1,632.5,6473.5"></path><path id="kity_path_24765" fill="none" stroke="gray" d="M622,6473.5L631,6473.5"></path></g><path id="node_outline1415" fill="none" stroke="none" d="M637.5,6464.5h115a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-115a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1415" fill="black"><text id="kity_text_11103" text-rendering="inherit" font-size="12" dy=".8em" y="6465.700000047684" x="637.5">volatile等一系列问题</text></g></g><g id="minder_node1402"><g id="node_expander1398" style="cursor: pointer;"><path id="kity_path_24716" fill="white" stroke="gray" d="M773.5,6220.5A6,6,0,1,1,761.5,6220.5A6,6,0,1,1,773.5,6220.5"></path><path id="kity_path_24717" fill="none" stroke="gray" d="M763,6220.5L772,6220.5"></path></g><path id="node_outline1399" fill="none" stroke="none" d="M778.5,6211.5h78a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-78a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1399" fill="black"><text id="kity_text_11051" text-rendering="inherit" font-size="12" dy=".8em" y="6212.700000047684" x="778.5">说说volatile？</text></g></g><g id="minder_node1403"><g id="node_expander1397" style="cursor: pointer;" display="none"><path id="kity_path_24713" fill="white" stroke="gray" d="M877.5,6220.5A6,6,0,1,1,865.5,6220.5A6,6,0,1,1,877.5,6220.5"></path><path id="kity_path_24714" fill="none" stroke="gray"></path></g><path id="node_outline1398" fill="none" stroke="none" d="M882.5,6193.5h786a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-786a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1398" fill="black"><text id="kity_text_11047" text-rendering="inherit" font-size="12" dy=".8em" y="6194.700000047684" x="882.5">1.</text><text id="kity_text_11048" text-rendering="inherit" font-size="12" dy=".8em" y="6212.700000047684" x="882.5">volatile相当于轻量级的同步锁，是针对共享变量修饰变量的，他的作用就是保证了内存的可见性和有序，但是没有保证原子性，</text><text id="kity_text_11049" text-rendering="inherit" font-size="12" dy=".8em" y="6230.700000047684" x="882.5">被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，也就是直接从主存中获取，写也是直接写到主存，从而避免出现数据脏读的现象。</text></g></g><g id="minder_node1404"><g id="node_expander1400" style="cursor: pointer;"><path id="kity_path_24722" fill="white" stroke="gray" d="M773.5,6291.5A6,6,0,1,1,761.5,6291.5A6,6,0,1,1,773.5,6291.5"></path><path id="kity_path_24723" fill="none" stroke="gray" d="M763,6291.5L772,6291.5"></path></g><path id="node_outline1401" fill="none" stroke="none" d="M778.5,6282.5h114a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-114a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1401" fill="black"><text id="kity_text_11058" text-rendering="inherit" font-size="12" dy=".8em" y="6283.700000047684" x="778.5">知道volatile的原理？</text></g></g><g id="minder_node1405"><g id="node_expander1399" style="cursor: pointer;" display="none"><path id="kity_path_24719" fill="white" stroke="gray" d="M913.5,6291.5A6,6,0,1,1,901.5,6291.5A6,6,0,1,1,913.5,6291.5"></path><path id="kity_path_24720" fill="none" stroke="gray"></path></g><path id="node_outline1400" fill="none" stroke="none" d="M918.5,6255.5h1280a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1280a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1400" fill="black"><text id="kity_text_11053" text-rendering="inherit" font-size="12" dy=".8em" y="6256.700000047684" x="918.5">1.</text><text id="kity_text_11054" text-rendering="inherit" font-size="12" dy=".8em" y="6274.700000047684" x="918.5">被volatile修饰的共享变量在写操作时会多出LOCK前缀，处理器为了性能原因，都会把主存中的数据读到自己内部缓存中进行操作，但是并没有说操作完就写回主存中，而volatile可以让缓存中的数据操作完写回主存中，</text><text id="kity_text_11055" text-rendering="inherit" font-size="12" dy=".8em" y="6292.700000047684" x="918.5">而为了防止写回主存中后，其他处理器自己的缓存还是老数据，而LOCK前缀可以让其他处理器缓存中的数据失效，主要实现是通过缓存一致性来实现的，也就是说，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，</text><text id="kity_text_11056" text-rendering="inherit" font-size="12" dy=".8em" y="6310.700000047684" x="918.5">如果发现自己缓存数据内存地址被修改了，就把自己的缓存数据设无效，下次读的时侯直接去主存中读，这样每次都是最新的值，就可以让每一个线程获取的都是最新的值</text></g></g><g id="minder_node1406"><g id="node_expander1402" style="cursor: pointer;"><path id="kity_path_24728" fill="white" stroke="gray" d="M773.5,6344.5A6,6,0,1,1,761.5,6344.5A6,6,0,1,1,773.5,6344.5"></path><path id="kity_path_24729" fill="none" stroke="gray" d="M763,6344.5L772,6344.5"></path></g><path id="node_outline1403" fill="none" stroke="none" d="M778.5,6335.5h186a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-186a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1403" fill="black"><text id="kity_text_11062" text-rendering="inherit" font-size="12" dy=".8em" y="6336.700000047684" x="778.5">volatile保证线程安全的哪些方面？</text></g></g><g id="minder_node1407"><g id="node_expander1401" style="cursor: pointer;" display="none"><path id="kity_path_24725" fill="white" stroke="gray" d="M985.5,6344.5A6,6,0,1,1,973.5,6344.5A6,6,0,1,1,985.5,6344.5"></path><path id="kity_path_24726" fill="none" stroke="gray"></path></g><path id="node_outline1402" fill="none" stroke="none" d="M990.5,6335.5h335a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-335a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1402" fill="black"><text id="kity_text_11060" text-rendering="inherit" font-size="12" dy=".8em" y="6336.700000047684" x="990.5">1.实现变量在多个线程间可见，保证内存可见性和禁止指令重排</text></g></g><g id="minder_node1408"><g id="node_expander1404" style="cursor: pointer;"><path id="kity_path_24734" fill="white" stroke="gray" d="M773.5,6451.5A6,6,0,1,1,761.5,6451.5A6,6,0,1,1,773.5,6451.5"></path><path id="kity_path_24735" fill="none" stroke="gray" d="M763,6451.5L772,6451.5"></path></g><path id="node_outline1405" fill="none" stroke="none" d="M778.5,6442.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1405" fill="black"><text id="kity_text_11075" text-rendering="inherit" font-size="12" dy=".8em" y="6443.700000047684" x="778.5">说说禁止指令重排？</text></g></g><g id="minder_node1409"><g id="node_expander1403" style="cursor: pointer;" display="none"><path id="kity_path_24731" fill="white" stroke="gray" d="M908.5,6451.5A6,6,0,1,1,896.5,6451.5A6,6,0,1,1,908.5,6451.5"></path><path id="kity_path_24732" fill="none" stroke="gray"></path></g><path id="node_outline1404" fill="none" stroke="none" d="M913.5,6361.5h1413a5,5,0,0,1,5,5v170a5,5,0,0,1,-5,5h-1413a5,5,0,0,1,-5,-5v-170a5,5,0,0,1,5,-5z"></path><g id="node_text1404" fill="black"><text id="kity_text_11064" text-rendering="inherit" font-size="12" dy=".8em" y="6362.700000047684" x="913.5">1.</text><text id="kity_text_11065" text-rendering="inherit" font-size="12" dy=".8em" y="6380.700000047684" x="913.5">volatile阻止重排volatile 变量周围的读写指令，因为操作变量，写后读，读后写，写后写 是会影响结果的，而volatile禁止重排序的这个规则就是 happens before规则，先行发生担保规则，</text><text id="kity_text_11066" text-rendering="inherit" font-size="12" dy=".8em" y="6398.700000047684" x="913.5">这个规则就是说对一个volatile的写操作先行发生对这个变量的读操作，而底层是通过内存屏障来实现的，也就是说被volatile修饰的变量 会在相应位置插入内存屏障，而硬件层面内存屏障有读屏障和写屏障，主要作用是</text><text id="kity_text_11067" text-rendering="inherit" font-size="12" dy=".8em" y="6416.700000047684" x="913.5">阻止屏障两边的指令重排序，强制把缓存区的数据写回主存。JVM选择的是比较保守的内存屏障规则，大概思路是下面</text><text id="kity_text_11068" text-rendering="inherit" font-size="12" dy=".8em" y="6434.700000047684" x="913.5">1）在每一个volatile写操作之前插入一个禁止写排序屏障，</text><text id="kity_text_11069" text-rendering="inherit" font-size="12" dy=".8em" y="6452.700000047684" x="913.5">2）在每一个volatile写操作后插入一个禁止读排序屏障</text><text id="kity_text_11070" text-rendering="inherit" font-size="12" dy=".8em" y="6470.700000047684" x="913.5">3）在每一个volatile读操作后插入一个禁止读排序屏障</text><text id="kity_text_11071" text-rendering="inherit" font-size="12" dy=".8em" y="6488.700000047684" x="913.5">4）在每一个volatile读操作后插入一个禁止写排序屏障</text><text id="kity_text_11072" text-rendering="inherit" font-size="12" dy=".8em" y="6506.700000047684" x="913.5">最后实现效果就是volatile变量和普通变量的排序规则就是 如果第一个操作是volatile读，无论第二个操作是什么都不能重排序。如果第二个操作是volatile是写，无论第一个操作是什么，都不能重排。如果第一个操作是volatile写，第二个操作是volatile读，那不能重排</text><text id="kity_text_11073" text-rendering="inherit" font-size="12" dy=".8em" y="6524.700000047684" x="913.5">这些不符合要求的重排序就会被编译器重排序规则和处理器内存屏障插入策略禁止。</text></g></g><g id="minder_node1410"><g id="node_expander1406" style="cursor: pointer;"><path id="kity_path_24740" fill="white" stroke="gray" d="M773.5,6567.5A6,6,0,1,1,761.5,6567.5A6,6,0,1,1,773.5,6567.5"></path><path id="kity_path_24741" fill="none" stroke="gray" d="M763,6567.5L772,6567.5"></path></g><path id="node_outline1407" fill="none" stroke="none" d="M778.5,6558.5h139a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-139a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1407" fill="black"><text id="kity_text_11080" text-rendering="inherit" font-size="12" dy=".8em" y="6559.700000047684" x="778.5">volatile的使用场景有哪些</text></g></g><g id="minder_node1411"><g id="node_expander1405" style="cursor: pointer;" display="none"><path id="kity_path_24737" fill="white" stroke="gray" d="M938.5,6567.5A6,6,0,1,1,926.5,6567.5A6,6,0,1,1,938.5,6567.5"></path><path id="kity_path_24738" fill="none" stroke="gray"></path></g><path id="node_outline1406" fill="none" stroke="none" d="M943.5,6549.5h972a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-972a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1406" fill="black"><text id="kity_text_11077" text-rendering="inherit" font-size="12" dy=".8em" y="6550.700000047684" x="943.5">1.volatile和synchronized在保证内存可见和顺序性功能是一样，也就是说volatile当作轻量级锁来使用，但是只能针对单个volatile变量的读/写。而锁可以让一片临界区代码都有原子性</text><text id="kity_text_11078" text-rendering="inherit" font-size="12" dy=".8em" y="6568.700000047684" x="943.5">volatile可以来实现单例模式的双重校验锁</text></g></g><g id="minder_node1412"><g id="node_expander1408" style="cursor: pointer;"><path id="kity_path_24746" fill="white" stroke="gray" d="M773.5,6602.5A6,6,0,1,1,761.5,6602.5A6,6,0,1,1,773.5,6602.5"></path><path id="kity_path_24747" fill="none" stroke="gray" d="M763,6602.5L772,6602.5"></path></g><path id="node_outline1409" fill="none" stroke="none" d="M778.5,6593.5h360a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-360a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1409" fill="black"><text id="kity_text_11084" text-rendering="inherit" font-size="12" dy=".8em" y="6594.700000047684" x="778.5">除了在volatile当中使用了内存屏障，JAVA还有哪里使用了内存屏障</text></g></g><g id="minder_node1413"><g id="node_expander1407" style="cursor: pointer;" display="none"><path id="kity_path_24743" fill="white" stroke="gray" d="M1159.5,6602.5A6,6,0,1,1,1147.5,6602.5A6,6,0,1,1,1159.5,6602.5"></path><path id="kity_path_24744" fill="none" stroke="gray"></path></g><path id="node_outline1408" fill="none" stroke="none" d="M1164.5,6593.5h1199a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1199a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1408" fill="black"><text id="kity_text_11082" text-rendering="inherit" font-size="12" dy=".8em" y="6594.700000047684" x="1164.5">1.final也有用到内存屏障，写 final 域的重排序规则会要求译编器在 final 域的写之后，构造函数 return 之前，插入一个 StoreStore 障屏。读 final 域的重排序规则要求编译器在读 final 域的操作前面插入一个 LoadLoad 屏障。</text></g></g><g id="minder_node1414"><g id="node_expander1411" style="cursor: pointer;"><path id="kity_path_24755" fill="white" stroke="gray" d="M773.5,6637.5A6,6,0,1,1,761.5,6637.5A6,6,0,1,1,773.5,6637.5"></path><path id="kity_path_24756" fill="none" stroke="gray" d="M763,6637.5L772,6637.5"></path></g><path id="node_outline1412" fill="none" stroke="none" d="M778.5,6628.5h248a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-248a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1412" fill="black"><text id="kity_text_11091" text-rendering="inherit" font-size="12" dy=".8em" y="6629.700000047684" x="778.5">new一个对象 如果不禁止指令重排 会发生什么</text></g></g><g id="minder_node1415"><g id="node_expander1410" style="cursor: pointer;"><path id="kity_path_24752" fill="white" stroke="gray" d="M1047.5,6637.5A6,6,0,1,1,1035.5,6637.5A6,6,0,1,1,1047.5,6637.5"></path><path id="kity_path_24753" fill="none" stroke="gray" d="M1037,6637.5L1046,6637.5"></path></g><path id="node_outline1411" fill="none" stroke="none" d="M1052.5,6619.5h965a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-965a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1411" fill="black"><text id="kity_text_11088" text-rendering="inherit" font-size="12" dy=".8em" y="6620.700000047684" x="1052.5">1.比如说 instance = new Singleton()，如果不使用volatile 可能导致&#xa0;分配内存&#xa0;; 初始化对象; 指向分配的内存地址时 这三个重排序，就可以导致返回一个还没有初始化完成的变量</text><text id="kity_text_11089" text-rendering="inherit" font-size="12" dy=".8em" y="6638.700000047684" x="1052.5">比如在双重校验锁中 我们的变量不声明成votile就会发生这种结果</text></g><g id="kity_g_16994" style="cursor: pointer;"><path id="kity_path_16995" fill="none" stroke="none" d="M2004,6629h12a2,2,0,0,1,2,2v13a2,2,0,0,1,-2,2h-12a2,2,0,0,1,-2,-2v-13a2,2,0,0,1,2,-2z"></path><path id="kity_path_16996" fill="black" stroke="none" d="M2013,6640H2007V6639h6L2013,6640L2013,6640zM2013,6638H2007V6637h6V6638zM2013,6636H2007V6635h6V6636zM2012.5,6642H2006V6633h8v7.5M2013,6643l2,-2V6632H2005v11"></path></g></g><g id="minder_node1416"><g id="node_expander1409" style="cursor: pointer;" display="none"><path id="kity_path_24749" fill="white" stroke="gray" d="M2038.5,6637.5A6,6,0,1,1,2026.5,6637.5A6,6,0,1,1,2038.5,6637.5"></path><path id="kity_path_24750" fill="none" stroke="gray"></path></g><path id="node_outline1410" fill="none" stroke="none" d="M2043.5,6628.5h295a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-295a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1410" fill="black"><text id="kity_text_11086" text-rendering="inherit" font-size="12" dy=".8em" y="6629.700000047684" x="2043.5">http://concurrent.redspider.group/article/02/8.html</text></g></g><g id="minder_node1417"><g id="node_expander1413" style="cursor: pointer;"><path id="kity_path_24761" fill="white" stroke="gray" d="M773.5,6726.5A6,6,0,1,1,761.5,6726.5A6,6,0,1,1,773.5,6726.5"></path><path id="kity_path_24762" fill="none" stroke="gray" d="M763,6726.5L772,6726.5"></path></g><path id="node_outline1414" fill="none" stroke="none" d="M778.5,6717.5h178a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-178a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1414" fill="black"><text id="kity_text_11101" text-rendering="inherit" font-size="12" dy=".8em" y="6718.700000047684" x="778.5">volatile和synchronized的区别？</text></g></g><g id="minder_node1418"><g id="node_expander1412" style="cursor: pointer;" display="none"><path id="kity_path_24758" fill="white" stroke="gray" d="M977.5,6726.5A6,6,0,1,1,965.5,6726.5A6,6,0,1,1,977.5,6726.5"></path><path id="kity_path_24759" fill="none" stroke="gray"></path></g><path id="node_outline1413" fill="none" stroke="none" d="M982.5,6663.5h1180a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-1180a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text1413" fill="black"><text id="kity_text_11093" text-rendering="inherit" font-size="12" dy=".8em" y="6664.700000047684" x="982.5">1.</text><text id="kity_text_11094" text-rendering="inherit" font-size="12" dy=".8em" y="6682.700000047684" x="982.5">volatile保证了共享变量的有序性，内存可见性，但是不保证原子性，比如i++</text><text id="kity_text_11095" text-rendering="inherit" font-size="12" dy=".8em" y="6700.700000047684" x="982.5">synchronized可以保证有序性，内存可见性，原子性</text><text id="kity_text_11096" text-rendering="inherit" font-size="12" dy=".8em" y="6718.700000047684" x="982.5">2.</text><text id="kity_text_11097" text-rendering="inherit" font-size="12" dy=".8em" y="6736.700000047684" x="982.5">由于volatile仅仅保证对单个volatile变量的读/写具有原子性，而监视器锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。在功能上，监视器锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势</text><text id="kity_text_11098" text-rendering="inherit" font-size="12" dy=".8em" y="6754.700000047684" x="982.5">3.可以换个方案</text><text id="kity_text_11099" text-rendering="inherit" font-size="12" dy=".8em" y="6772.700000047684" x="982.5">volatile + synchronized&#xa0; 或者 JUC下面的使用原子类替代 volatile</text></g></g><g id="minder_node1419"><g id="node_expander1457" style="cursor: pointer;"><path id="kity_path_24893" fill="white" stroke="gray" d="M544.5,7957.5A6,6,0,1,1,532.5,7957.5A6,6,0,1,1,544.5,7957.5"></path><path id="kity_path_24894" fill="none" stroke="gray" d="M534,7957.5L543,7957.5"></path></g><path id="node_outline1458" fill="none" stroke="none" d="M549.5,7948.5h14a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-14a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1458" fill="black"><text id="kity_text_11258" text-rendering="inherit" font-size="12" dy=".8em" y="7949.700000047684" x="549.5">锁</text></g></g><g id="minder_node1420"><g id="node_expander1444" style="cursor: pointer;"><path id="kity_path_24854" fill="white" stroke="gray" d="M584.5,7426.5A6,6,0,1,1,572.5,7426.5A6,6,0,1,1,584.5,7426.5"></path><path id="kity_path_24855" fill="none" stroke="gray" d="M574,7426.5L583,7426.5"></path></g><path id="node_outline1445" fill="none" stroke="none" d="M589.5,7417.5h149a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-149a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1445" fill="black"><text id="kity_text_11214" text-rendering="inherit" font-size="12" dy=".8em" y="7418.700000047684" x="589.5">synchronized等一系列问题</text></g></g><g id="minder_node1421"><g id="node_expander1417" style="cursor: pointer;"><path id="kity_path_24773" fill="white" stroke="gray" d="M759.5,6834.5A6,6,0,1,1,747.5,6834.5A6,6,0,1,1,759.5,6834.5"></path><path id="kity_path_24774" fill="none" stroke="gray" d="M749,6834.5L758,6834.5"></path></g><path id="node_outline1418" fill="none" stroke="none" d="M764.5,6825.5h288a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-288a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1418" fill="black"><text id="kity_text_11112" text-rendering="inherit" font-size="12" dy=".8em" y="6826.700000047684" x="764.5">说说synchrinized，可以用在哪些地方，有什么区别？</text></g></g><g id="minder_node1422"><g id="node_expander1416" style="cursor: pointer;" display="none"><path id="kity_path_24770" fill="white" stroke="gray" d="M1073.5,6834.5A6,6,0,1,1,1061.5,6834.5A6,6,0,1,1,1073.5,6834.5"></path><path id="kity_path_24771" fill="none" stroke="gray"></path></g><path id="node_outline1417" fill="none" stroke="none" d="M1078.5,6798.5h776a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-776a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1417" fill="black"><text id="kity_text_11107" text-rendering="inherit" font-size="12" dy=".8em" y="6799.700000047684" x="1078.5">1.</text><text id="kity_text_11108" text-rendering="inherit" font-size="12" dy=".8em" y="6817.700000047684" x="1078.5">可以放在实例方法或者静态方法上&#xa0; 实例方法 比如 synchronized void method 锁 类的实例对象， 静态方法上，锁当前的class对象</text><text id="kity_text_11109" text-rendering="inherit" font-size="12" dy=".8em" y="6835.700000047684" x="1078.5">可以放在代码块上，锁当前括号中的该类实例对象，如this.xx。锁括号中的class对象 xx.class。也可以锁某一个实例对象，如string a = xx,&#xa0; syn(a)</text><text id="kity_text_11110" text-rendering="inherit" font-size="12" dy=".8em" y="6853.700000047684" x="1078.5">如果锁的是class对象， new 多少个实例对象 都是属于同一个类，会被锁，</text></g></g><g id="minder_node1423"><g id="node_expander1419" style="cursor: pointer;"><path id="kity_path_24779" fill="white" stroke="gray" d="M759.5,6986.5A6,6,0,1,1,747.5,6986.5A6,6,0,1,1,759.5,6986.5"></path><path id="kity_path_24780" fill="none" stroke="gray" d="M749,6986.5L758,6986.5"></path></g><path id="node_outline1420" fill="none" stroke="none" d="M764.5,6977.5h382a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-382a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1420" fill="black"><text id="kity_text_11127" text-rendering="inherit" font-size="12" dy=".8em" y="6978.700000047684" x="764.5">说说sychronzied原理，为什么他消耗比较大，jdk8做了什么优化知道吗</text></g></g><g id="minder_node1424"><g id="node_expander1418" style="cursor: pointer;" display="none"><path id="kity_path_24776" fill="white" stroke="gray" d="M1167.5,6986.5A6,6,0,1,1,1155.5,6986.5A6,6,0,1,1,1167.5,6986.5"></path><path id="kity_path_24777" fill="none" stroke="gray"></path></g><path id="node_outline1419" fill="none" stroke="none" d="M1172.5,6878.5h1571a5,5,0,0,1,5,5v206a5,5,0,0,1,-5,5h-1571a5,5,0,0,1,-5,-5v-206a5,5,0,0,1,5,-5z"></path><g id="node_text1419" fill="black"><text id="kity_text_11114" text-rendering="inherit" font-size="12" dy=".8em" y="6879.700000047684" x="1172.5">1.synchonized可以保证同一时刻共享变量只被同一线程访问，保证了原子性，内存可见性，顺序性</text><text id="kity_text_11115" text-rendering="inherit" font-size="12" dy=".8em" y="6897.700000047684" x="1172.5">当同步一个方法时，通过反编译可以看到JVM在方法的flags加上 ACC_SYNCHONIZED的标记符，表面方法是线程同步的。当同步代码块时，JVM会在开始和结束有monitorenter和monitorexit指令&#xa0; 主要是维持了一个加锁的记录器，每次得到锁就+1，释放锁就-1，为0说明锁没有没有线程持有。</text><text id="kity_text_11116" text-rendering="inherit" font-size="12" dy=".8em" y="6915.700000047684" x="1172.5">而标记符和监控进入和监控退出都是通过monitor实现的，monitor有个特点是互斥的</text><text id="kity_text_11117" text-rendering="inherit" font-size="12" dy=".8em" y="6933.700000047684" x="1172.5">相当于当线程执行有ACC_SYNCHRONI标志的方法，需要获得monitor锁。当线程执行到monitor指令的时候加锁需要得到对象的监视器释放锁的时侯就释放监视器，其他在阻塞的线程就可以重新去获取监视器。</text><text id="kity_text_11118" text-rendering="inherit" font-size="12" dy=".8em" y="6951.700000047684" x="1172.5">他们的加锁解锁的记录器也是实现synchronized可重入的关键，因为加锁+1释放锁-1，为0说明当前锁没有被持有嘛，然后不为0的时侯 只有同一把锁才能这次+1，然后怎么知道是同一把锁主要是通过对象头的Mark Word信息的线程id知道的，</text><text id="kity_text_11119" text-rendering="inherit" font-size="12" dy=".8em" y="6969.700000047684" x="1172.5">刚刚说了监视器嘛，然后每一个对象都有一个监视器关联着，监视器在底层就是ObjectMonitor，里面记录着指向线程的指针，该线程重入的次数，等待队列的线程等消息，而获取监视器的线程进入owner区域，计数器+1 退出就-1，</text><text id="kity_text_11120" text-rendering="inherit" font-size="12" dy=".8em" y="6987.700000047684" x="1172.5">没有获的线程进入同步队列等待释放再获取，方法执行完毕以后，将monitor的owner置null，然后释放锁，这就保证了原子性和可见性，</text><text id="kity_text_11121" text-rendering="inherit" font-size="12" dy=".8em" y="7005.700000047684" x="1172.5">synchronized保证了每个时刻都只有一个线程访问同步代码块，也就确定了线程执行同步代码块是分先后顺序的，保证了有序性。因为指令重排不会影响单线程的执行结果</text><text id="kity_text_11122" text-rendering="inherit" font-size="12" dy=".8em" y="7023.700000047684" x="1172.5">2.然后刚刚说了对象头的信息嘛，对象头的mark word中有存放对象锁的信息，重量级锁的monitor的指针，所以这样加了同步锁以后 也就知道了这个对象的监视器是被哪个线程获取的了</text><text id="kity_text_11123" text-rendering="inherit" font-size="12" dy=".8em" y="7041.700000047684" x="1172.5">3.重量级锁是因为以前 锁同一时刻只有一个线程能够获得对象的监视器（monitor），从而进入到同步代码块或者同步方法之中，即表现为互斥性（排它性）。</text><text id="kity_text_11124" text-rendering="inherit" font-size="12" dy=".8em" y="7059.700000047684" x="1172.5">效率低下，每次只能通过一个线程，监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的，他的性能消耗比较大。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因&#xa0;</text><text id="kity_text_11125" text-rendering="inherit" font-size="12" dy=".8em" y="7077.700000047684" x="1172.5">4.在jdk6之前，syn是重量级锁，就java8对同步锁做了很多优化提高了效率，有了偏向锁，轻量级锁，重量级锁，这些基本都是基于CAS和对象头来做的</text></g></g><g id="minder_node1425"><g id="node_expander1422" style="cursor: pointer;"><path id="kity_path_24788" fill="white" stroke="gray" d="M759.5,7138.5A6,6,0,1,1,747.5,7138.5A6,6,0,1,1,759.5,7138.5"></path><path id="kity_path_24789" fill="none" stroke="gray" d="M749,7138.5L758,7138.5"></path></g><path id="node_outline1423" fill="none" stroke="none" d="M764.5,7129.5h165a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-165a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1423" fill="black"><text id="kity_text_11136" text-rendering="inherit" font-size="12" dy=".8em" y="7130.700000047684" x="764.5">sychronized核心组件和作用？</text></g></g><g id="minder_node1426"><g id="node_expander1421" style="cursor: pointer;"><path id="kity_path_24785" fill="white" stroke="gray" d="M950.5,7138.5A6,6,0,1,1,938.5,7138.5A6,6,0,1,1,950.5,7138.5"></path><path id="kity_path_24786" fill="none" stroke="gray" d="M940,7138.5L949,7138.5"></path></g><path id="node_outline1422" fill="none" stroke="none" d="M955.5,7102.5h477a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-477a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1422" fill="black"><text id="kity_text_11131" text-rendering="inherit" font-size="12" dy=".8em" y="7103.700000047684" x="955.5">1.Wait Set：那些调用 wait 方法被阻塞的线程被放置在这里；</text><text id="kity_text_11132" text-rendering="inherit" font-size="12" dy=".8em" y="7121.700000047684" x="955.5">2.Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；</text><text id="kity_text_11133" text-rendering="inherit" font-size="12" dy=".8em" y="7139.700000047684" x="955.5">3.Entry List：Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中；</text><text id="kity_text_11134" text-rendering="inherit" font-size="12" dy=".8em" y="7157.700000047684" x="955.5">4.Owner：当前已经获取到锁资源的线程被称为 Owner，他们的区域叫Owner区域</text></g></g><g id="minder_node1427"><g id="node_expander1420" style="cursor: pointer;" display="none"><path id="kity_path_24782" fill="white" stroke="gray" d="M1453.5,7138.5A6,6,0,1,1,1441.5,7138.5A6,6,0,1,1,1453.5,7138.5"></path><path id="kity_path_24783" fill="none" stroke="gray"></path></g><path id="node_outline1421" fill="none" stroke="none" d="M1458.5,7129.5h365a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-365a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1421" fill="black"><text id="kity_text_11129" text-rendering="inherit" font-size="12" dy=".8em" y="7130.700000047684" x="1458.5">https://blog.csdn.net/sinat_36184075/article/details/104824883</text></g></g><g id="minder_node1428"><g id="node_expander1424" style="cursor: pointer;"><path id="kity_path_24794" fill="white" stroke="gray" d="M759.5,7200.5A6,6,0,1,1,747.5,7200.5A6,6,0,1,1,759.5,7200.5"></path><path id="kity_path_24795" fill="none" stroke="gray" d="M749,7200.5L758,7200.5"></path></g><path id="node_outline1425" fill="none" stroke="none" d="M764.5,7191.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1425" fill="black"><text id="kity_text_11141" text-rendering="inherit" font-size="12" dy=".8em" y="7192.700000047684" x="764.5">知道锁升级吗，锁可以降级吗</text></g></g><g id="minder_node1429"><g id="node_expander1423" style="cursor: pointer;" display="none"><path id="kity_path_24791" fill="white" stroke="gray" d="M942.5,7200.5A6,6,0,1,1,930.5,7200.5A6,6,0,1,1,942.5,7200.5"></path><path id="kity_path_24792" fill="none" stroke="gray"></path></g><path id="node_outline1424" fill="none" stroke="none" d="M947.5,7182.5h1268a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1268a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1424" fill="black"><text id="kity_text_11138" text-rendering="inherit" font-size="12" dy=".8em" y="7183.700000047684" x="947.5">1.</text><text id="kity_text_11139" text-rendering="inherit" font-size="12" dy=".8em" y="7201.700000047684" x="947.5">同步锁随着竞争情况逐渐升级，锁的升级很容易发生。锁降级发生的条件会比较苛刻，锁降级发生在Stop The World期间，当JVM进入安全点的时候，会检查是否有闲置的锁，然后进行降级。是基于HotSpot JVM来说的，其他的VM不清楚</text></g></g><g id="minder_node1430"><g id="node_expander1428" style="cursor: pointer;"><path id="kity_path_24806" fill="white" stroke="gray" d="M759.5,7397.5A6,6,0,1,1,747.5,7397.5A6,6,0,1,1,759.5,7397.5"></path><path id="kity_path_24807" fill="none" stroke="gray" d="M749,7397.5L758,7397.5"></path></g><path id="node_outline1429" fill="none" stroke="none" d="M764.5,7388.5h210a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-210a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1429" fill="black"><text id="kity_text_11169" text-rendering="inherit" font-size="12" dy=".8em" y="7389.700000047684" x="764.5">说一下synchronized锁升级的这个过程</text></g></g><g id="minder_node1431"><g id="node_expander1427" style="cursor: pointer;"><path id="kity_path_24803" fill="white" stroke="gray" d="M995.5,7397.5A6,6,0,1,1,983.5,7397.5A6,6,0,1,1,995.5,7397.5"></path><path id="kity_path_24804" fill="none" stroke="gray" d="M985,7397.5L994,7397.5"></path></g><path id="node_outline1428" fill="none" stroke="none" d="M1000.5,7226.5h1690a5,5,0,0,1,5,5v332a5,5,0,0,1,-5,5h-1690a5,5,0,0,1,-5,-5v-332a5,5,0,0,1,5,-5z"></path><g id="node_text1428" fill="black"><text id="kity_text_11149" text-rendering="inherit" font-size="12" dy=".8em" y="7227.700000047684" x="1000.5">1.</text><text id="kity_text_11150" text-rendering="inherit" font-size="12" dy=".8em" y="7245.700000047684" x="1000.5">无锁：没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。如果没有冲突就修改成功并退出，否则就会继续循环尝试</text><text id="kity_text_11151" text-rendering="inherit" font-size="12" dy=".8em" y="7263.700000047684" x="1000.5">2.</text><text id="kity_text_11152" text-rendering="inherit" font-size="12" dy=".8em" y="7281.700000047684" x="1000.5">偏向锁：大部分锁被同一线程获取，在资源无竞争情况下消除了同步语句，连CAS操作都不做了，提高了程序的运行性能。偏向锁重点关注锁重入这一块</text><text id="kity_text_11153" text-rendering="inherit" font-size="12" dy=".8em" y="7299.700000047684" x="1000.5">原理：</text><text id="kity_text_11154" text-rendering="inherit" font-size="12" dy=".8em" y="7317.700000047684" x="1000.5">1)锁的获取 主要是通过设置对象头中的栈帧中锁信息，因为线程在第一次进入(代码块)会在mark word 里存储偏向锁的线程 ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。</text><text id="kity_text_11155" text-rendering="inherit" font-size="12" dy=".8em" y="7335.700000047684" x="1000.5">如果是的话说明该线程已获取锁，后续不再进行CAS来加解锁。如果不是 尝试CAS，成功 说明mark word锁信息已被新线程替换，依然是偏向锁，如果不成功，设置偏向锁标记为0，轻量级锁标记为00，升级为轻量级锁</text><text id="kity_text_11156" text-rendering="inherit" font-size="12" dy=".8em" y="7353.700000047684" x="1000.5">2)锁的释放 线程不主动释放偏向锁，偏向锁使用了一种等到竞争出现才释放锁的机制。</text><text id="kity_text_11157" text-rendering="inherit" font-size="12" dy=".8em" y="7371.700000047684" x="1000.5">3)锁的升级 偏向升轻量级 大概过程 是在一个安全点暂停拥有偏向锁的线程，然后检查持有偏向锁的线程如果不处于活动状态，将对象头设置成无锁状态；否则 然后遍历偏向对象的锁记录&#xa0; 要么将当前锁升级成轻量级锁，要么重新设置mark word偏向其他线程，要么恢复无锁，唤醒被停止的线程。</text><text id="kity_text_11158" text-rendering="inherit" font-size="12" dy=".8em" y="7389.700000047684" x="1000.5">4) 如果应用程序里所有的锁通常处于竞争状态，那么偏向锁就会是一种累赘,可以关闭偏向锁</text><text id="kity_text_11159" text-rendering="inherit" font-size="12" dy=".8em" y="7407.700000047684" x="1000.5">3.</text><text id="kity_text_11160" text-rendering="inherit" font-size="12" dy=".8em" y="7425.700000047684" x="1000.5">轻量级锁：多个线程在不同时段获取同一把锁，即不存在锁竞争的情况，也就没有线程阻塞。其他线程会通过自旋的形式尝试获取锁。</text><text id="kity_text_11161" text-rendering="inherit" font-size="12" dy=".8em" y="7443.700000047684" x="1000.5">1）原理：加锁 线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁</text><text id="kity_text_11162" text-rendering="inherit" font-size="12" dy=".8em" y="7461.700000047684" x="1000.5">JDK采用适应性自旋，线程如果自旋成功了，则下次自旋的次数会更多，否则，则自旋的次数就会减少。如果自旋到一定程度，依然没有获取到锁，称为自旋失败，那么这个线程会阻塞。同时这个锁就会升级成重量级锁。</text><text id="kity_text_11163" text-rendering="inherit" font-size="12" dy=".8em" y="7479.700000047684" x="1000.5">2）释放 使用CAS操作将锁记录空间替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</text><text id="kity_text_11164" text-rendering="inherit" font-size="12" dy=".8em" y="7497.700000047684" x="1000.5">3）升级 轻量级升重量级 当自旋超过一定的次数时，轻量级锁便会升级为重量级锁（锁膨胀）。当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁</text><text id="kity_text_11165" text-rendering="inherit" font-size="12" dy=".8em" y="7515.700000047684" x="1000.5">4.</text><text id="kity_text_11166" text-rendering="inherit" font-size="12" dy=".8em" y="7533.700000047684" x="1000.5">重量级锁：当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己。线程竞争不会再通过自旋，不会消耗CPU，但是阻塞会让响应时间变慢，</text><text id="kity_text_11167" text-rendering="inherit" font-size="12" dy=".8em" y="7551.700000047684" x="1000.5">原理：重量级锁通过对象内部的监视器实现，而 monitor 的本质是依赖于底层操作系统实现，操作系统实现线程之间的切换需要从用户态切换到内核态，切换成本非常高。</text></g></g><g id="minder_node1432"><g id="node_expander1425" style="cursor: pointer;" display="none"><path id="kity_path_24797" fill="white" stroke="gray" d="M2711.5,7318.5A6,6,0,1,1,2699.5,7318.5A6,6,0,1,1,2711.5,7318.5"></path><path id="kity_path_24798" fill="none" stroke="gray"></path></g><path id="node_outline1426" fill="none" stroke="none" d="M2716.5,7291.5h326a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1426" fill="black"><text id="kity_text_11143" text-rendering="inherit" font-size="12" dy=".8em" y="7292.700000047684" x="2716.5">http://concurrent.redspider.group/article/02/9.html</text><text id="kity_text_11144" text-rendering="inherit" font-size="12" dy=".8em" y="7310.700000047684" x="2716.5">https://blog.csdn.net/sifanchao/article/details/84144141</text><text id="kity_text_11145" text-rendering="inherit" font-size="12" dy=".8em" y="7328.700000047684" x="2716.5">https://juejin.cn/post/6844903813665538062#heading-8</text></g></g><g id="minder_node1433"><g id="node_expander1426" style="cursor: pointer;" display="none"><path id="kity_path_24800" fill="white" stroke="gray" d="M2711.5,7429A6,6,0,1,1,2699.5,7429A6,6,0,1,1,2711.5,7429"></path><path id="kity_path_24801" fill="none" stroke="gray"></path></g><path id="node_outline1427" fill="none" stroke="none" d="M2716.5,7353.5h200a5,5,0,0,1,5,5v141a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-141a5,5,0,0,1,5,-5z"></path><g id="node_text1427" fill="black"><text id="kity_text_11147" text-rendering="inherit" font-size="12" dy=".8em" y="7487.700000047684" x="2791.5">分支主题</text></g><image id="kity_image_17060" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210503160813.png" x="2716.5" y="7356.5" width="200" height="128"></image></g><g id="minder_node1434"><g id="node_expander1430" style="cursor: pointer;"><path id="kity_path_24812" fill="white" stroke="gray" d="M759.5,7585.5A6,6,0,1,1,747.5,7585.5A6,6,0,1,1,759.5,7585.5"></path><path id="kity_path_24813" fill="none" stroke="gray" d="M749,7585.5L758,7585.5"></path></g><path id="node_outline1431" fill="none" stroke="none" d="M764.5,7576.5h122a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-122a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1431" fill="black"><text id="kity_text_11173" text-rendering="inherit" font-size="12" dy=".8em" y="7577.700000047684" x="764.5">说说偏向锁升级和原理</text></g></g><g id="minder_node1435"><g id="node_expander1429" style="cursor: pointer;" display="none"><path id="kity_path_24809" fill="white" stroke="gray" d="M907.5,7585.5A6,6,0,1,1,895.5,7585.5A6,6,0,1,1,907.5,7585.5"></path><path id="kity_path_24810" fill="none" stroke="gray"></path></g><path id="node_outline1430" fill="none" stroke="none" d="M912.5,7576.5h37a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-37a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1430" fill="black"><text id="kity_text_11171" text-rendering="inherit" font-size="12" dy=".8em" y="7577.700000047684" x="912.5">看上面</text></g></g><g id="minder_node1436"><g id="node_expander1432" style="cursor: pointer;"><path id="kity_path_24818" fill="white" stroke="gray" d="M759.5,7611.5A6,6,0,1,1,747.5,7611.5A6,6,0,1,1,759.5,7611.5"></path><path id="kity_path_24819" fill="none" stroke="gray" d="M749,7611.5L758,7611.5"></path></g><path id="node_outline1433" fill="none" stroke="none" d="M764.5,7602.5h241a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-241a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1433" fill="black"><text id="kity_text_11177" text-rendering="inherit" font-size="12" dy=".8em" y="7603.700000047684" x="764.5">那你说说偏向锁和轻量级锁的本质区别是什么</text></g></g><g id="minder_node1437"><g id="node_expander1431" style="cursor: pointer;" display="none"><path id="kity_path_24815" fill="white" stroke="gray" d="M1026.5,7611.5A6,6,0,1,1,1014.5,7611.5A6,6,0,1,1,1026.5,7611.5"></path><path id="kity_path_24816" fill="none" stroke="gray"></path></g><path id="node_outline1432" fill="none" stroke="none" d="M1031.5,7602.5h590a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-590a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1432" fill="black"><text id="kity_text_11175" text-rendering="inherit" font-size="12" dy=".8em" y="7603.700000047684" x="1031.5">1.轻量级的锁在锁获取和释放需要执行多次CAS的操作，而偏向锁只需要置换ThreadID的时候依赖一次CAS操作</text></g></g><g id="minder_node1438"><g id="node_expander1435" style="cursor: pointer;"><path id="kity_path_24827" fill="white" stroke="gray" d="M759.5,7722.5A6,6,0,1,1,747.5,7722.5A6,6,0,1,1,759.5,7722.5"></path><path id="kity_path_24828" fill="none" stroke="gray" d="M749,7722.5L758,7722.5"></path></g><path id="node_outline1436" fill="none" stroke="none" d="M764.5,7713.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1436" fill="black"><text id="kity_text_11188" text-rendering="inherit" font-size="12" dy=".8em" y="7714.700000047684" x="764.5">说说上面锁状态的区别</text></g></g><g id="minder_node1439"><g id="node_expander1433" style="cursor: pointer;" display="none"><path id="kity_path_24821" fill="white" stroke="gray" d="M906.5,7665A6,6,0,1,1,894.5,7665A6,6,0,1,1,906.5,7665"></path><path id="kity_path_24822" fill="none" stroke="gray"></path></g><path id="node_outline1434" fill="none" stroke="none" d="M911.5,7629.5h200a5,5,0,0,1,5,5v61a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-61a5,5,0,0,1,5,-5z"></path><g id="node_text1434" fill="black"><text id="kity_text_11179" text-rendering="inherit" font-size="12" dy=".8em" y="7683.700000047684" x="986.5">分支主题</text></g><image id="kity_image_17061" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210329102853.png" x="911.5" y="7632.5" width="200" height="48"></image></g><g id="minder_node1440"><g id="node_expander1434" style="cursor: pointer;" display="none"><path id="kity_path_24824" fill="white" stroke="gray" d="M906.5,7762.5A6,6,0,1,1,894.5,7762.5A6,6,0,1,1,906.5,7762.5"></path><path id="kity_path_24825" fill="none" stroke="gray"></path></g><path id="node_outline1435" fill="none" stroke="none" d="M911.5,7708.5h732a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-732a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1435" fill="black"><text id="kity_text_11181" text-rendering="inherit" font-size="12" dy=".8em" y="7709.700000047684" x="911.5">1.偏向锁 针对的是锁仅会被同一线程持有的状况。</text><text id="kity_text_11182" text-rendering="inherit" font-size="12" dy=".8em" y="7727.700000047684" x="911.5">只会在第一次请求锁时采用CAS操作并将锁对象的标记字段记录为当前线程地址。在此后的运行过程中，持有偏向锁的线程无需加锁操作。</text><text id="kity_text_11183" text-rendering="inherit" font-size="12" dy=".8em" y="7745.700000047684" x="911.5">2.轻量级锁 针对的是多个线程在不同时间段申请同一把锁的情况。</text><text id="kity_text_11184" text-rendering="inherit" font-size="12" dy=".8em" y="7763.700000047684" x="911.5">采用CAS操作，将锁对象标记字段替换为一个指针，指向当前线程栈上的一块空间，存储着锁对象原本的标记字段。</text><text id="kity_text_11185" text-rendering="inherit" font-size="12" dy=".8em" y="7781.700000047684" x="911.5">3.重量级锁&#xa0; 会阻塞、唤醒请求加锁的线程。 针对的是多个线程同时竞争同一把锁的情况。</text><text id="kity_text_11186" text-rendering="inherit" font-size="12" dy=".8em" y="7799.700000047684" x="911.5">JVM采用自适应自旋避免重量级，来避免在面对非常小的同步代码块时，仍会被阻塞和唤醒的状况。</text></g></g><g id="minder_node1441"><g id="node_expander1437" style="cursor: pointer;"><path id="kity_path_24833" fill="white" stroke="gray" d="M759.5,7841.5A6,6,0,1,1,747.5,7841.5A6,6,0,1,1,759.5,7841.5"></path><path id="kity_path_24834" fill="none" stroke="gray" d="M749,7841.5L758,7841.5"></path></g><path id="node_outline1438" fill="none" stroke="none" d="M764.5,7832.5h254a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-254a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1438" fill="black"><text id="kity_text_11193" text-rendering="inherit" font-size="12" dy=".8em" y="7833.700000047684" x="764.5">JVM有没有说怎么关闭偏向锁，为什么要关闭？</text></g></g><g id="minder_node1442"><g id="node_expander1436" style="cursor: pointer;" display="none"><path id="kity_path_24830" fill="white" stroke="gray" d="M1039.5,7841.5A6,6,0,1,1,1027.5,7841.5A6,6,0,1,1,1039.5,7841.5"></path><path id="kity_path_24831" fill="none" stroke="gray"></path></g><path id="node_outline1437" fill="none" stroke="none" d="M1044.5,7823.5h443a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-443a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1437" fill="black"><text id="kity_text_11190" text-rendering="inherit" font-size="12" dy=".8em" y="7824.700000047684" x="1044.5">1.-XX:-UseBiasedLocking //关闭偏向锁（默认打开）</text><text id="kity_text_11191" text-rendering="inherit" font-size="12" dy=".8em" y="7842.700000047684" x="1044.5">2.当锁竞争大量存在，基本不会有一个线程多次获取锁的情况存在，看业务情况而定</text></g></g><g id="minder_node1443"><g id="node_expander1439" style="cursor: pointer;"><path id="kity_path_24839" fill="white" stroke="gray" d="M759.5,7894.5A6,6,0,1,1,747.5,7894.5A6,6,0,1,1,759.5,7894.5"></path><path id="kity_path_24840" fill="none" stroke="gray" d="M749,7894.5L758,7894.5"></path></g><path id="node_outline1440" fill="none" stroke="none" d="M764.5,7885.5h369a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-369a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1440" fill="black"><text id="kity_text_11199" text-rendering="inherit" font-size="12" dy=".8em" y="7886.700000047684" x="764.5">有看到加了synchronized的字节码文件和没加synchronized的区别吗</text></g></g><g id="minder_node1444"><g id="node_expander1438" style="cursor: pointer;" display="none"><path id="kity_path_24836" fill="white" stroke="gray" d="M1154.5,7894.5A6,6,0,1,1,1142.5,7894.5A6,6,0,1,1,1154.5,7894.5"></path><path id="kity_path_24837" fill="none" stroke="gray"></path></g><path id="node_outline1439" fill="none" stroke="none" d="M1159.5,7867.5h1105a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1105a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1439" fill="black"><text id="kity_text_11195" text-rendering="inherit" font-size="12" dy=".8em" y="7868.700000047684" x="1159.5">1.有看到，syn加在方法和代码块不一样，简单来说就是</text><text id="kity_text_11196" text-rendering="inherit" font-size="12" dy=".8em" y="7886.700000047684" x="1159.5">2.加在方法：通过反编译的字节码可以看到 在methodA上有一个ACC_SYNCHRONIZED 标志 说明方法是同步的</text><text id="kity_text_11197" text-rendering="inherit" font-size="12" dy=".8em" y="7904.700000047684" x="1159.5">3.加在代码块：同步代码块主要是monitorenter和monitorexit指令，monitorenter和monitorexit两个指令 维护着一个加锁 释放锁的记录器  这个对象得到锁就+1，释放锁就-1  只到为0 其他线程就可以执行了</text></g></g><g id="minder_node1445"><g id="node_expander1441" style="cursor: pointer;"><path id="kity_path_24845" fill="white" stroke="gray" d="M759.5,7947.5A6,6,0,1,1,747.5,7947.5A6,6,0,1,1,759.5,7947.5"></path><path id="kity_path_24846" fill="none" stroke="gray" d="M749,7947.5L758,7947.5"></path></g><path id="node_outline1442" fill="none" stroke="none" d="M764.5,7938.5h208a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-208a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1442" fill="black"><text id="kity_text_11204" text-rendering="inherit" font-size="12" dy=".8em" y="7939.700000047684" x="764.5">synchronized可以被中断吗？为什么？</text></g></g><g id="minder_node1446"><g id="node_expander1440" style="cursor: pointer;" display="none"><path id="kity_path_24842" fill="white" stroke="gray" d="M993.5,7947.5A6,6,0,1,1,981.5,7947.5A6,6,0,1,1,993.5,7947.5"></path><path id="kity_path_24843" fill="none" stroke="gray"></path></g><path id="node_outline1441" fill="none" stroke="none" d="M998.5,7929.5h418a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-418a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1441" fill="black"><text id="kity_text_11201" text-rendering="inherit" font-size="12" dy=".8em" y="7930.700000047684" x="998.5">1.不可以，syn等待不可中断，相当于A和B，A等待B释放锁时，A不可以中断。</text><text id="kity_text_11202" text-rendering="inherit" font-size="12" dy=".8em" y="7948.700000047684" x="998.5">2.sync方法可中断，相当于只有A一直拿着锁，A是可以被中断的</text></g></g><g id="minder_node1447"><g id="node_expander1443" style="cursor: pointer;"><path id="kity_path_24851" fill="white" stroke="gray" d="M759.5,8018.5A6,6,0,1,1,747.5,8018.5A6,6,0,1,1,759.5,8018.5"></path><path id="kity_path_24852" fill="none" stroke="gray" d="M749,8018.5L758,8018.5"></path></g><path id="node_outline1444" fill="none" stroke="none" d="M764.5,8009.5h376a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-376a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1444" fill="black"><text id="kity_text_11212" text-rendering="inherit" font-size="12" dy=".8em" y="8010.700000047684" x="764.5">为什么synchronized演变成重量级锁后性能会下降？为什么到内核态？</text></g></g><g id="minder_node1448"><g id="node_expander1442" style="cursor: pointer;" display="none"><path id="kity_path_24848" fill="white" stroke="gray" d="M1161.5,8018.5A6,6,0,1,1,1149.5,8018.5A6,6,0,1,1,1161.5,8018.5"></path><path id="kity_path_24849" fill="none" stroke="gray"></path></g><path id="node_outline1443" fill="none" stroke="none" d="M1166.5,7973.5h432a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-432a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1443" fill="black"><text id="kity_text_11206" text-rendering="inherit" font-size="12" dy=".8em" y="7974.700000047684" x="1166.5">1.偏向锁和轻量级锁都是在用户态</text><text id="kity_text_11207" text-rendering="inherit" font-size="12" dy=".8em" y="7992.700000047684" x="1166.5">重量级锁实现</text><text id="kity_text_11208" text-rendering="inherit" font-size="12" dy=".8em" y="8010.700000047684" x="1166.5">synchronized——monitorenter/monitorexit——lock/unlock——mutex lock</text><text id="kity_text_11209" text-rendering="inherit" font-size="12" dy=".8em" y="8028.700000047684" x="1166.5">重量级锁需要到OS的内核态，很耗性能</text><text id="kity_text_11210" text-rendering="inherit" font-size="12" dy=".8em" y="8046.700000047684" x="1166.5">2.保护OS，有的指令不能让用户执行</text></g></g><g id="minder_node1449"><g id="node_expander1446" style="cursor: pointer;"><path id="kity_path_24860" fill="white" stroke="gray" d="M584.5,8098.5A6,6,0,1,1,572.5,8098.5A6,6,0,1,1,584.5,8098.5"></path><path id="kity_path_24861" fill="none" stroke="gray" d="M574,8098.5L583,8098.5"></path></g><path id="node_outline1447" fill="none" stroke="none" d="M589.5,8089.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1447" fill="black"><text id="kity_text_11220" text-rendering="inherit" font-size="12" dy=".8em" y="8090.700000047684" x="589.5">可重入锁是什么意思？</text></g></g><g id="minder_node1450"><g id="node_expander1445" style="cursor: pointer;" display="none"><path id="kity_path_24857" fill="white" stroke="gray" d="M731.5,8098.5A6,6,0,1,1,719.5,8098.5A6,6,0,1,1,731.5,8098.5"></path><path id="kity_path_24858" fill="none" stroke="gray"></path></g><path id="node_outline1446" fill="none" stroke="none" d="M736.5,8071.5h693a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-693a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1446" fill="black"><text id="kity_text_11216" text-rendering="inherit" font-size="12" dy=".8em" y="8072.700000047684" x="736.5">1.</text><text id="kity_text_11217" text-rendering="inherit" font-size="12" dy=".8em" y="8090.700000047684" x="736.5">可重复调用同一把锁，同一个对象或者class 在外层使用锁之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入锁</text><text id="kity_text_11218" text-rendering="inherit" font-size="12" dy=".8em" y="8108.700000047684" x="736.5">同一锁程中，线程不需要再次获取同一把锁</text></g></g><g id="minder_node1451"><g id="node_expander1448" style="cursor: pointer;"><path id="kity_path_24866" fill="white" stroke="gray" d="M584.5,8160.5A6,6,0,1,1,572.5,8160.5A6,6,0,1,1,584.5,8160.5"></path><path id="kity_path_24867" fill="none" stroke="gray" d="M574,8160.5L583,8160.5"></path></g><path id="node_outline1449" fill="none" stroke="none" d="M589.5,8151.5h146a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-146a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1449" fill="black"><text id="kity_text_11226" text-rendering="inherit" font-size="12" dy=".8em" y="8152.700000047684" x="589.5">可重入锁怎么实现的？原理</text></g></g><g id="minder_node1452"><g id="node_expander1447" style="cursor: pointer;" display="none"><path id="kity_path_24863" fill="white" stroke="gray" d="M756.5,8160.5A6,6,0,1,1,744.5,8160.5A6,6,0,1,1,756.5,8160.5"></path><path id="kity_path_24864" fill="none" stroke="gray"></path></g><path id="node_outline1448" fill="none" stroke="none" d="M761.5,8133.5h1462a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1462a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1448" fill="black"><text id="kity_text_11222" text-rendering="inherit" font-size="12" dy=".8em" y="8134.700000047684" x="761.5">1.主要是通过对象的监视器中维护的一个计数器来实现可重入</text><text id="kity_text_11223" text-rendering="inherit" font-size="12" dy=".8em" y="8152.700000047684" x="761.5">&#xa0;每个对象维护着一个记录着被锁次数的计数器。未被锁定的对象的该计数器为0，当一个线程获得锁（执行monitorenter）后，该计数器自增1 。当同一个线程释放锁（执行monitorexit指令）的时候，计数器自减1。当计数器为0的时候。锁将被释放，其他线程便可以获得锁。</text><text id="kity_text_11224" text-rendering="inherit" font-size="12" dy=".8em" y="8170.700000047684" x="761.5">&#xa0;Synchronized先天具有重入性。每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一。ReentrantLock也是可重入的</text></g></g><g id="minder_node1453"><g id="node_expander1450" style="cursor: pointer;"><path id="kity_path_24872" fill="white" stroke="gray" d="M584.5,8213.5A6,6,0,1,1,572.5,8213.5A6,6,0,1,1,584.5,8213.5"></path><path id="kity_path_24873" fill="none" stroke="gray" d="M574,8213.5L583,8213.5"></path></g><path id="node_outline1451" fill="none" stroke="none" d="M589.5,8204.5h175a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-175a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1451" fill="black"><text id="kity_text_11231" text-rendering="inherit" font-size="12" dy=".8em" y="8205.700000047684" x="589.5">monitor对象(监视器)有哪些属性</text></g></g><g id="minder_node1454"><g id="node_expander1449" style="cursor: pointer;" display="none"><path id="kity_path_24869" fill="white" stroke="gray" d="M785.5,8213.5A6,6,0,1,1,773.5,8213.5A6,6,0,1,1,785.5,8213.5"></path><path id="kity_path_24870" fill="none" stroke="gray"></path></g><path id="node_outline1450" fill="none" stroke="none" d="M790.5,8195.5h1091a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1091a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1450" fill="black"><text id="kity_text_11228" text-rendering="inherit" font-size="12" dy=".8em" y="8196.700000047684" x="790.5">1.</text><text id="kity_text_11229" text-rendering="inherit" font-size="12" dy=".8em" y="8214.700000047684" x="790.5">HotSpot虚拟机中，Monitor是由ObjectMonitor实现的。主要是记录owner线程获取锁的次数，指向持有监视器对象的线程指针，存放wait状态的线程队列，锁的重入次数，存放等待锁释放的阻塞线程队列</text></g></g><g id="minder_node1455"><g id="node_expander1452" style="cursor: pointer;"><path id="kity_path_24878" fill="white" stroke="gray" d="M584.5,8311.5A6,6,0,1,1,572.5,8311.5A6,6,0,1,1,584.5,8311.5"></path><path id="kity_path_24879" fill="none" stroke="gray" d="M574,8311.5L583,8311.5"></path></g><path id="node_outline1453" fill="none" stroke="none" d="M589.5,8302.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1453" fill="black"><text id="kity_text_11242" text-rendering="inherit" font-size="12" dy=".8em" y="8303.700000047684" x="589.5">自旋锁是什么，什么原理</text></g></g><g id="minder_node1456"><g id="node_expander1451" style="cursor: pointer;" display="none"><path id="kity_path_24875" fill="white" stroke="gray" d="M743.5,8311.5A6,6,0,1,1,731.5,8311.5A6,6,0,1,1,743.5,8311.5"></path><path id="kity_path_24876" fill="none" stroke="gray"></path></g><path id="node_outline1452" fill="none" stroke="none" d="M748.5,8239.5h1136a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-1136a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text1452" fill="black"><text id="kity_text_11233" text-rendering="inherit" font-size="12" dy=".8em" y="8240.700000047684" x="748.5">1.原理</text><text id="kity_text_11234" text-rendering="inherit" font-size="12" dy=".8em" y="8258.700000047684" x="748.5">当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取(占用)，那么此线程就无法获取到这把锁，尝试获取锁的线程不会立刻阻塞，该线程将会等待，间隔一段时间后采用循环会再次尝试获取该锁。</text><text id="kity_text_11235" text-rendering="inherit" font-size="12" dy=".8em" y="8276.700000047684" x="748.5">2.优缺点</text><text id="kity_text_11236" text-rendering="inherit" font-size="12" dy=".8em" y="8294.700000047684" x="748.5">1）自旋锁不会使线程状态发生切换，一直处于用户态，减少线程上下文切换的消耗，减少线程的阻塞，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗。</text><text id="kity_text_11237" text-rendering="inherit" font-size="12" dy=".8em" y="8312.700000047684" x="748.5">非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。&#xa0;</text><text id="kity_text_11238" text-rendering="inherit" font-size="12" dy=".8em" y="8330.700000047684" x="748.5">2）如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，消耗cpu。可能会带来“线程饥饿”的情况。</text><text id="kity_text_11239" text-rendering="inherit" font-size="12" dy=".8em" y="8348.700000047684" x="748.5">3.</text><text id="kity_text_11240" text-rendering="inherit" font-size="12" dy=".8em" y="8366.700000047684" x="748.5">JDK中，自旋操作默认10次，我们可以通过参数“-XX:PreBlockSpin”来设置，当超过来此参数的值，则会使用传统的线程挂起方式来等待锁释放。</text></g></g><g id="minder_node1457"><g id="node_expander1454" style="cursor: pointer;"><path id="kity_path_24884" fill="white" stroke="gray" d="M584.5,8409.5A6,6,0,1,1,572.5,8409.5A6,6,0,1,1,584.5,8409.5"></path><path id="kity_path_24885" fill="none" stroke="gray" d="M574,8409.5L583,8409.5"></path></g><path id="node_outline1455" fill="none" stroke="none" d="M589.5,8400.5h84a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-84a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1455" fill="black"><text id="kity_text_11247" text-rendering="inherit" font-size="12" dy=".8em" y="8401.700000047684" x="589.5">自适应自旋锁？</text></g></g><g id="minder_node1458"><g id="node_expander1453" style="cursor: pointer;" display="none"><path id="kity_path_24881" fill="white" stroke="gray" d="M694.5,8409.5A6,6,0,1,1,682.5,8409.5A6,6,0,1,1,694.5,8409.5"></path><path id="kity_path_24882" fill="none" stroke="gray"></path></g><path id="node_outline1454" fill="none" stroke="none" d="M699.5,8391.5h637a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-637a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1454" fill="black"><text id="kity_text_11244" text-rendering="inherit" font-size="12" dy=".8em" y="8392.700000047684" x="699.5">1.JDK 1.6引入的，默认开启的</text><text id="kity_text_11245" text-rendering="inherit" font-size="12" dy=".8em" y="8410.700000047684" x="699.5">适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。</text></g></g><g id="minder_node1459"><g id="node_expander1456" style="cursor: pointer;"><path id="kity_path_24890" fill="white" stroke="gray" d="M584.5,8489.5A6,6,0,1,1,572.5,8489.5A6,6,0,1,1,584.5,8489.5"></path><path id="kity_path_24891" fill="none" stroke="gray" d="M574,8489.5L583,8489.5"></path></g><path id="node_outline1457" fill="none" stroke="none" d="M589.5,8480.5h253a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-253a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1457" fill="black"><text id="kity_text_11256" text-rendering="inherit" font-size="12" dy=".8em" y="8481.700000047684" x="589.5">锁粒度是什么？锁粗化是什么？锁消除是什么？</text></g></g><g id="minder_node1460"><g id="node_expander1455" style="cursor: pointer;" display="none"><path id="kity_path_24887" fill="white" stroke="gray" d="M863.5,8489.5A6,6,0,1,1,851.5,8489.5A6,6,0,1,1,863.5,8489.5"></path><path id="kity_path_24888" fill="none" stroke="gray"></path></g><path id="node_outline1456" fill="none" stroke="none" d="M868.5,8435.5h1360a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1360a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1456" fill="black"><text id="kity_text_11249" text-rendering="inherit" font-size="12" dy=".8em" y="8436.700000047684" x="868.5">1.锁粒度 加锁的范围，比如，concurrentHashMap的分段锁，锁段和锁整个对象完全不一样，粒度小并发力度更强</text><text id="kity_text_11250" text-rendering="inherit" font-size="12" dy=".8em" y="8454.700000047684" x="868.5">2.锁粗化</text><text id="kity_text_11251" text-rendering="inherit" font-size="12" dy=".8em" y="8472.700000047684" x="868.5">锁粗化就是 JVM 检测到一串零碎的操作都对同一个对象加锁，则会把加锁同步的范围粗化到整个操作序列的外部。</text><text id="kity_text_11252" text-rendering="inherit" font-size="12" dy=".8em" y="8490.700000047684" x="868.5">比如说 我们实例化一个stringBuffer，然后这同一个对象重复调用append，比如s.append(1) s.append(2) s.append(3)，而append是加锁的，将会锁粗化，在第一次 append() 前至 最后一个 append() 后只需要加一次锁就可以了。</text><text id="kity_text_11253" text-rendering="inherit" font-size="12" dy=".8em" y="8508.700000047684" x="868.5">3.锁消除</text><text id="kity_text_11254" text-rendering="inherit" font-size="12" dy=".8em" y="8526.700000047684" x="868.5">锁消除就是编译器运行时，对一些被检测到不可能存在共享数据竞争的锁进行消除。如果判断一段代码中，堆上的数据不会逃逸出去从而被其他线程访问到，则可以把他们当做栈上的数据对待，认为它们是线程私有的，不必要加锁。主要通过逃逸分析来判定.</text></g></g><g id="minder_node1461"><g id="node_expander1475" style="cursor: pointer;"><path id="kity_path_24947" fill="white" stroke="gray" d="M544.5,8972.5A6,6,0,1,1,532.5,8972.5A6,6,0,1,1,544.5,8972.5"></path><path id="kity_path_24948" fill="none" stroke="gray" d="M534,8972.5L543,8972.5"></path></g><path id="node_outline1476" fill="none" stroke="none" d="M549.5,8963.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1476" fill="black"><text id="kity_text_11305" text-rendering="inherit" font-size="12" dy=".8em" y="8964.700000047684" x="549.5">AQS</text></g></g><g id="minder_node1462"><g id="node_expander1460" style="cursor: pointer;"><path id="kity_path_24902" fill="white" stroke="gray" d="M596.5,8648.5A6,6,0,1,1,584.5,8648.5A6,6,0,1,1,596.5,8648.5"></path><path id="kity_path_24903" fill="none" stroke="gray" d="M586,8648.5L595,8648.5"></path></g><path id="node_outline1461" fill="none" stroke="none" d="M601.5,8639.5h123a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-123a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1461" fill="black"><text id="kity_text_11269" text-rendering="inherit" font-size="12" dy=".8em" y="8640.700000047684" x="601.5">AQS知道吗，简单说说</text></g></g><g id="minder_node1463"><g id="node_expander1459" style="cursor: pointer;"><path id="kity_path_24899" fill="white" stroke="gray" d="M745.5,8648.5A6,6,0,1,1,733.5,8648.5A6,6,0,1,1,745.5,8648.5"></path><path id="kity_path_24900" fill="none" stroke="gray" d="M735,8648.5L744,8648.5"></path></g><path id="node_outline1460" fill="none" stroke="none" d="M750.5,8594.5h1508a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1508a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1460" fill="black"><text id="kity_text_11262" text-rendering="inherit" font-size="12" dy=".8em" y="8595.700000047684" x="750.5">1.AQS是一个juc并发包下的同步器，juc下大部分锁都是基于同步器实现的，如reentrantlock。同步器内部维护了一个被valatile修饰的int的state同步状态，这个state就是共享资源，0表示没被线程持有，&gt;0表示已经被线程占有，可重入也是基于这个state，</text><text id="kity_text_11263" text-rendering="inherit" font-size="12" dy=".8em" y="8613.700000047684" x="750.5">同步状态的更新都是通过CAS来更新，并且子类只能通过调用getstate和setstste来获取和设置，他们都被final修饰，这样是为了不让子类重新定义state逻辑，而内部对同步状态的维护是通过自旋+CAS。</text><text id="kity_text_11264" text-rendering="inherit" font-size="12" dy=".8em" y="8631.700000047684" x="750.5">通过一个等待状态的值标识线程到底是因为什么进入同步队列。内部维护一个FIFO的虚拟队列，实现线程的等待排队。</text><text id="kity_text_11265" text-rendering="inherit" font-size="12" dy=".8em" y="8649.700000047684" x="750.5">队列中的节点存储线程信息，上节点，下节点，进入队列状态标识符。并且同步器的两个指针head和tail分别指向头节点和尾节点，方便来管理节点的出队和入队。线程的阻塞和唤醒是通过LockSupport来实现的，主要是通过调用这个类的park()和unpark()来维护阻塞入队和唤醒出队。</text><text id="kity_text_11266" text-rendering="inherit" font-size="12" dy=".8em" y="8667.700000047684" x="750.5">2.AQS更加访问资源的方式又分为独占(reentrantlock)和共享(读写锁中的读锁)</text><text id="kity_text_11267" text-rendering="inherit" font-size="12" dy=".8em" y="8685.700000047684" x="750.5">3.而线程状态标识符主要是有四种，(1)表明线程需要被唤醒，资源已经准备好了，就等着锁释放。(2)表示线程获取锁的请求取消了，可能中断之类的。(3)线程在同步队类中等待唤醒&#xa0; (4)共享模式的状态传播</text></g></g><g id="minder_node1464"><g id="node_expander1458" style="cursor: pointer;" display="none"><path id="kity_path_24896" fill="white" stroke="gray" d="M2279.5,8649A6,6,0,1,1,2267.5,8649A6,6,0,1,1,2279.5,8649"></path><path id="kity_path_24897" fill="none" stroke="gray"></path></g><path id="node_outline1459" fill="none" stroke="none" d="M2284.5,8550.5h200a5,5,0,0,1,5,5v187a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-187a5,5,0,0,1,5,-5z"></path><g id="node_text1459" fill="black"><text id="kity_text_11260" text-rendering="inherit" font-size="12" dy=".8em" y="8730.700000047684" x="2359.5">分支主题</text></g><image id="kity_image_17062" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210329183025.png" x="2284.5" y="8553.5" width="200" height="174"></image></g><g id="minder_node1465"><g id="node_expander1464" style="cursor: pointer;"><path id="kity_path_24914" fill="white" stroke="gray" d="M596.5,8933.5A6,6,0,1,1,584.5,8933.5A6,6,0,1,1,596.5,8933.5"></path><path id="kity_path_24915" fill="none" stroke="gray" d="M586,8933.5L595,8933.5"></path></g><path id="node_outline1465" fill="none" stroke="none" d="M601.5,8924.5h170a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-170a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1465" fill="black"><text id="kity_text_11277" text-rendering="inherit" font-size="12" dy=".8em" y="8925.700000047684" x="601.5">AQS的底层数据结构组成知道吗</text></g></g><g id="minder_node1466"><g id="node_expander1463" style="cursor: pointer;"><path id="kity_path_24911" fill="white" stroke="gray" d="M792.5,8933.5A6,6,0,1,1,780.5,8933.5A6,6,0,1,1,792.5,8933.5"></path><path id="kity_path_24912" fill="none" stroke="gray" d="M782,8933.5L791,8933.5"></path></g><path id="node_outline1464" fill="none" stroke="none" d="M797.5,8924.5h723a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-723a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1464" fill="black"><text id="kity_text_11275" text-rendering="inherit" font-size="12" dy=".8em" y="8925.700000047684" x="797.5">AQS内部有3个对象，一个是state（用于计数器，类似gc的回收计数器），一个是线程标记（当前线程是谁加锁的），一个是同步队列。</text></g></g><g id="minder_node1467"><g id="node_expander1461" style="cursor: pointer;" display="none"><path id="kity_path_24905" fill="white" stroke="gray" d="M1541.5,8841.5A6,6,0,1,1,1529.5,8841.5A6,6,0,1,1,1541.5,8841.5"></path><path id="kity_path_24906" fill="none" stroke="gray"></path></g><path id="node_outline1462" fill="none" stroke="none" d="M1546.5,8755.5h200a5,5,0,0,1,5,5v162a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-162a5,5,0,0,1,5,-5z"></path><g id="node_text1462" fill="black"><text id="kity_text_11271" text-rendering="inherit" font-size="12" dy=".8em" y="8910.700000047684" x="1636.5">juc</text></g><image id="kity_image_17063" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210329144829.png" x="1546.5" y="8758.5" width="200" height="149"></image></g><g id="minder_node1468"><g id="node_expander1462" style="cursor: pointer;" display="none"><path id="kity_path_24908" fill="white" stroke="gray" d="M1541.5,9023.5A6,6,0,1,1,1529.5,9023.5A6,6,0,1,1,1541.5,9023.5"></path><path id="kity_path_24909" fill="none" stroke="gray"></path></g><path id="node_outline1463" fill="none" stroke="none" d="M1546.5,8935.5h200a5,5,0,0,1,5,5v166a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-166a5,5,0,0,1,5,-5z"></path><g id="node_text1463" fill="black"><text id="kity_text_11273" text-rendering="inherit" font-size="12" dy=".8em" y="9094.700000047684" x="1622.5">同步队列</text></g><image id="kity_image_17064" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210330103154.png" x="1546.5" y="8938.5" width="200" height="153"></image></g><g id="minder_node1469"><g id="node_expander1467" style="cursor: pointer;"><path id="kity_path_24923" fill="white" stroke="gray" d="M596.5,9137.5A6,6,0,1,1,584.5,9137.5A6,6,0,1,1,596.5,9137.5"></path><path id="kity_path_24924" fill="none" stroke="gray" d="M586,9137.5L595,9137.5"></path></g><path id="node_outline1468" fill="none" stroke="none" d="M601.5,9128.5h61a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-61a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1468" fill="black"><text id="kity_text_11284" text-rendering="inherit" font-size="12" dy=".8em" y="9129.700000047684" x="601.5">条件队列呢</text></g></g><g id="minder_node1470"><g id="node_expander1466" style="cursor: pointer;"><path id="kity_path_24920" fill="white" stroke="gray" d="M683.5,9137.5A6,6,0,1,1,671.5,9137.5A6,6,0,1,1,683.5,9137.5"></path><path id="kity_path_24921" fill="none" stroke="gray" d="M673,9137.5L682,9137.5"></path></g><path id="node_outline1467" fill="none" stroke="none" d="M688.5,9119.5h1189a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1189a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1467" fill="black"><text id="kity_text_11281" text-rendering="inherit" font-size="12" dy=".8em" y="9120.700000047684" x="688.5">1.condition队列是AQS中的一个内部类，通过conditionObject实现，这个队列主要用于等待条件的成立，当条件成立时，其它线程将signal这个队列中的元素，将其移动到AQS的队列中，等待占有锁的线程释放锁后被唤醒。</text><text id="kity_text_11282" text-rendering="inherit" font-size="12" dy=".8em" y="9138.700000047684" x="688.5">比如在 BlockingQueue中的实现中，当队列为空时，获取元素的线程阻塞在notEmpty条件上，一旦队列中添加了一个元素，将通知notEmpty条件，将其队列中的元素移动到AQS队列中等待被唤醒。</text></g></g><g id="minder_node1471"><g id="node_expander1465" style="cursor: pointer;" display="none"><path id="kity_path_24917" fill="white" stroke="gray" d="M1898.5,9137.5A6,6,0,1,1,1886.5,9137.5A6,6,0,1,1,1898.5,9137.5"></path><path id="kity_path_24918" fill="none" stroke="gray"></path></g><path id="node_outline1466" fill="none" stroke="none" d="M1903.5,9128.5h336a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-336a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1466" fill="black"><text id="kity_text_11279" text-rendering="inherit" font-size="12" dy=".8em" y="9129.700000047684" x="1903.5">https://blog.csdn.net/disiwei1012/article/details/78596731</text></g></g><g id="minder_node1472"><g id="node_expander1469" style="cursor: pointer;"><path id="kity_path_24929" fill="white" stroke="gray" d="M596.5,9181.5A6,6,0,1,1,584.5,9181.5A6,6,0,1,1,596.5,9181.5"></path><path id="kity_path_24930" fill="none" stroke="gray" d="M586,9181.5L595,9181.5"></path></g><path id="node_outline1470" fill="none" stroke="none" d="M601.5,9172.5h230a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-230a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1470" fill="black"><text id="kity_text_11289" text-rendering="inherit" font-size="12" dy=".8em" y="9173.700000047684" x="601.5">知道AQS中的set state是什么时侯调用的吗</text></g></g><g id="minder_node1473"><g id="node_expander1468" style="cursor: pointer;" display="none"><path id="kity_path_24926" fill="white" stroke="gray" d="M852.5,9181.5A6,6,0,1,1,840.5,9181.5A6,6,0,1,1,852.5,9181.5"></path><path id="kity_path_24927" fill="none" stroke="gray"></path></g><path id="node_outline1469" fill="none" stroke="none" d="M857.5,9163.5h675a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-675a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1469" fill="black"><text id="kity_text_11286" text-rendering="inherit" font-size="12" dy=".8em" y="9164.700000047684" x="857.5">1.独占模式中尝试获取同步状态时会调用setState()，不过是会先判断state是否为0。共享模式也会在尝试获取同步状态时调用。</text><text id="kity_text_11287" text-rendering="inherit" font-size="12" dy=".8em" y="9182.700000047684" x="857.5">更具体一定如reentrantlock中调用tryAcquire()时就会调用CAS设置同步状态，</text></g></g><g id="minder_node1474"><g id="node_expander1472" style="cursor: pointer;"><path id="kity_path_24938" fill="white" stroke="gray" d="M596.5,9234.5A6,6,0,1,1,584.5,9234.5A6,6,0,1,1,596.5,9234.5"></path><path id="kity_path_24939" fill="none" stroke="gray" d="M586,9234.5L595,9234.5"></path></g><path id="node_outline1473" fill="none" stroke="none" d="M601.5,9225.5h122a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-122a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1473" fill="black"><text id="kity_text_11297" text-rendering="inherit" font-size="12" dy=".8em" y="9226.700000047684" x="601.5">AQS的响应中断有几种</text></g></g><g id="minder_node1475"><g id="node_expander1471" style="cursor: pointer;"><path id="kity_path_24935" fill="white" stroke="gray" d="M744.5,9234.5A6,6,0,1,1,732.5,9234.5A6,6,0,1,1,744.5,9234.5"></path><path id="kity_path_24936" fill="none" stroke="gray" d="M734,9234.5L743,9234.5"></path></g><path id="node_outline1472" fill="none" stroke="none" d="M749.5,9207.5h1184a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1184a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1472" fill="black"><text id="kity_text_11293" text-rendering="inherit" font-size="12" dy=".8em" y="9208.700000047684" x="749.5">1.抢占式中断和协作式中断。协作式中断 就是设置一个中断标志位，不停地检查这个标志位的状态，如果检查到线程中断，就中断线程。</text><text id="kity_text_11294" text-rendering="inherit" font-size="12" dy=".8em" y="9226.700000047684" x="749.5">在AQS中如果在自旋中发现中断标志位为true，就不会去获取锁，而是抛出异常中断，具体处理异常中断逻辑需要我们自己去实现，异常补救什么的，比如存个日志表之类的</text><text id="kity_text_11295" text-rendering="inherit" font-size="12" dy=".8em" y="9244.700000047684" x="749.5">对于Object.wait()、Thread.join、Thread.sleep方法都是会清除中断标志位，locksupport.park是不会清除。并且如果线程进入了等待队列, 那么你就算设置中断了, 他还是会继续等待, 直到被unPark才会判断线程的终止状态</text></g></g><g id="minder_node1476"><g id="node_expander1470" style="cursor: pointer;" display="none"><path id="kity_path_24932" fill="white" stroke="gray" d="M1954.5,9234.5A6,6,0,1,1,1942.5,9234.5A6,6,0,1,1,1954.5,9234.5"></path><path id="kity_path_24933" fill="none" stroke="gray"></path></g><path id="node_outline1471" fill="none" stroke="none" d="M1959.5,9225.5h334a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-334a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1471" fill="black"><text id="kity_text_11291" text-rendering="inherit" font-size="12" dy=".8em" y="9226.700000047684" x="1959.5">https://blog.csdn.net/aesop_wubo/article/details/7570678</text></g></g><g id="minder_node1477"><g id="node_expander1474" style="cursor: pointer;"><path id="kity_path_24944" fill="white" stroke="gray" d="M596.5,9296.5A6,6,0,1,1,584.5,9296.5A6,6,0,1,1,596.5,9296.5"></path><path id="kity_path_24945" fill="none" stroke="gray" d="M586,9296.5L595,9296.5"></path></g><path id="node_outline1475" fill="none" stroke="none" d="M601.5,9287.5h111a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-111a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1475" fill="black"><text id="kity_text_11303" text-rendering="inherit" font-size="12" dy=".8em" y="9288.700000047684" x="601.5">AQS的核心原理说说</text></g></g><g id="minder_node1478"><g id="node_expander1473" style="cursor: pointer;" display="none"><path id="kity_path_24941" fill="white" stroke="gray" d="M733.5,9296.5A6,6,0,1,1,721.5,9296.5A6,6,0,1,1,733.5,9296.5"></path><path id="kity_path_24942" fill="none" stroke="gray"></path></g><path id="node_outline1474" fill="none" stroke="none" d="M738.5,9269.5h1550a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1550a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1474" fill="black"><text id="kity_text_11299" text-rendering="inherit" font-size="12" dy=".8em" y="9270.700000047684" x="738.5">1.</text><text id="kity_text_11300" text-rendering="inherit" font-size="12" dy=".8em" y="9288.700000047684" x="738.5">如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就有这么一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到同步队列中。</text><text id="kity_text_11301" text-rendering="inherit" font-size="12" dy=".8em" y="9306.700000047684" x="738.5">这个同步队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个同步队列的一个结点（Node）来实现锁的分配。</text></g></g><g id="minder_node1479"><g id="node_expander1498" style="cursor: pointer;"><path id="kity_path_25016" fill="white" stroke="gray" d="M544.5,9790.5A6,6,0,1,1,532.5,9790.5A6,6,0,1,1,544.5,9790.5"></path><path id="kity_path_25017" fill="none" stroke="gray" d="M534,9790.5L543,9790.5"></path></g><path id="node_outline1499" fill="none" stroke="none" d="M549.5,9781.5h37a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-37a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1499" fill="black"><text id="kity_text_11374" text-rendering="inherit" font-size="12" dy=".8em" y="9782.700000047684" x="549.5">并发系</text></g></g><g id="minder_node1480"><g id="node_expander1477" style="cursor: pointer;"><path id="kity_path_24953" fill="white" stroke="gray" d="M607.5,9349.5A6,6,0,1,1,595.5,9349.5A6,6,0,1,1,607.5,9349.5"></path><path id="kity_path_24954" fill="none" stroke="gray" d="M597,9349.5L606,9349.5"></path></g><path id="node_outline1478" fill="none" stroke="none" d="M612.5,9340.5h91a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-91a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1478" fill="black"><text id="kity_text_11310" text-rendering="inherit" font-size="12" dy=".8em" y="9341.700000047684" x="612.5">condition知道吗</text></g></g><g id="minder_node1481"><g id="node_expander1476" style="cursor: pointer;" display="none"><path id="kity_path_24950" fill="white" stroke="gray" d="M724.5,9349.5A6,6,0,1,1,712.5,9349.5A6,6,0,1,1,724.5,9349.5"></path><path id="kity_path_24951" fill="none" stroke="gray"></path></g><path id="node_outline1477" fill="none" stroke="none" d="M729.5,9331.5h993a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-993a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1477" fill="black"><text id="kity_text_11307" text-rendering="inherit" font-size="12" dy=".8em" y="9332.700000047684" x="729.5">1.condition条件队列是在AQS内部维护的，可以和object一样实现等待通知，比原生object更灵活。condition和lock搭配使用</text><text id="kity_text_11308" text-rendering="inherit" font-size="12" dy=".8em" y="9350.700000047684" x="729.5">Condition能够支持多个等待队列（new 多个Condition对象），而Object方式只能支持一个；Condition能够支持超时时间的设置，而Object不支持；支持不响应中断，不对中断做处理。</text></g></g><g id="minder_node1482"><g id="node_expander1479" style="cursor: pointer;"><path id="kity_path_24959" fill="white" stroke="gray" d="M607.5,9510.5A6,6,0,1,1,595.5,9510.5A6,6,0,1,1,607.5,9510.5"></path><path id="kity_path_24960" fill="none" stroke="gray" d="M597,9510.5L606,9510.5"></path></g><path id="node_outline1480" fill="none" stroke="none" d="M612.5,9501.5h242a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-242a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1480" fill="black"><text id="kity_text_11328" text-rendering="inherit" font-size="12" dy=".8em" y="9502.700000047684" x="612.5">condition和wait/notify/notifyAll有什么区别</text></g></g><g id="minder_node1483"><g id="node_expander1478" style="cursor: pointer;" display="none"><path id="kity_path_24956" fill="white" stroke="gray" d="M875.5,9510.5A6,6,0,1,1,863.5,9510.5A6,6,0,1,1,875.5,9510.5"></path><path id="kity_path_24957" fill="none" stroke="gray"></path></g><path id="node_outline1479" fill="none" stroke="none" d="M880.5,9375.5h1043a5,5,0,0,1,5,5v260a5,5,0,0,1,-5,5h-1043a5,5,0,0,1,-5,-5v-260a5,5,0,0,1,5,-5z"></path><g id="node_text1479" fill="black"><text id="kity_text_11312" text-rendering="inherit" font-size="12" dy=".8em" y="9376.700000047684" x="880.5">1.object</text><text id="kity_text_11313" text-rendering="inherit" font-size="12" dy=".8em" y="9394.700000047684" x="880.5">(1)wait() public final native void wait()</text><text id="kity_text_11314" text-rendering="inherit" font-size="12" dy=".8em" y="9412.700000047684" x="880.5">object()方法，释放锁，线程等待，直到被唤醒 才继续执行。所以需要先得到锁。让当前线程 (Thread.concurrentThread() 方法所返回的线程) 释放对象锁并进入等待（阻塞）状态</text><text id="kity_text_11315" text-rendering="inherit" font-size="12" dy=".8em" y="9430.700000047684" x="880.5">(2)notify&#xa0; public final native void notify()</text><text id="kity_text_11316" text-rendering="inherit" font-size="12" dy=".8em" y="9448.700000047684" x="880.5">object()方法唤醒等待的线程，并不是唤醒了就一定能得到锁</text><text id="kity_text_11317" text-rendering="inherit" font-size="12" dy=".8em" y="9466.700000047684" x="880.5">(3)notifyAll() public final native void notifyAll()</text><text id="kity_text_11318" text-rendering="inherit" font-size="12" dy=".8em" y="9484.700000047684" x="880.5">object()方法，唤醒等待的所有线程，并不是唤醒了就一定能得到锁。唤醒所有正在等待相应对象锁的线程，使它们进入就绪队列，以便在当前线程释放锁后竞争锁，进而得到CPU的执行。</text><text id="kity_text_11319" text-rendering="inherit" font-size="12" dy=".8em" y="9502.700000047684" x="880.5">2.condition</text><text id="kity_text_11320" text-rendering="inherit" font-size="12" dy=".8em" y="9520.700000047684" x="880.5">(1)await() boolean await(long time, TimeUnit unit) throws InterruptedException</text><text id="kity_text_11321" text-rendering="inherit" font-size="12" dy=".8em" y="9538.700000047684" x="880.5">Condition的方法。释放锁，唤醒后进入就绪态。造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。InterruptedException - 如果当前线程被中断抛出这个异常或者超时</text><text id="kity_text_11322" text-rendering="inherit" font-size="12" dy=".8em" y="9556.700000047684" x="880.5">(2)signal()&#xa0; void signal()</text><text id="kity_text_11323" text-rendering="inherit" font-size="12" dy=".8em" y="9574.700000047684" x="880.5">Condition的方法。唤醒一个等待线程。如果所有的线程都在等待此条件，则选择其中的一个唤醒。</text><text id="kity_text_11324" text-rendering="inherit" font-size="12" dy=".8em" y="9592.700000047684" x="880.5">(3)signalAll() void signalAll()</text><text id="kity_text_11325" text-rendering="inherit" font-size="12" dy=".8em" y="9610.700000047684" x="880.5">Condition的方法。唤醒所有等待线程。如果所有的线程都在等待此条件，则唤醒所有线程。</text><text id="kity_text_11326" text-rendering="inherit" font-size="12" dy=".8em" y="9628.700000047684" x="880.5"> </text></g></g><g id="minder_node1484"><g id="node_expander1482" style="cursor: pointer;"><path id="kity_path_24968" fill="white" stroke="gray" d="M607.5,9688.5A6,6,0,1,1,595.5,9688.5A6,6,0,1,1,607.5,9688.5"></path><path id="kity_path_24969" fill="none" stroke="gray" d="M597,9688.5L606,9688.5"></path></g><path id="node_outline1483" fill="none" stroke="none" d="M612.5,9679.5h115a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-115a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1483" fill="black"><text id="kity_text_11336" text-rendering="inherit" font-size="12" dy=".8em" y="9680.700000047684" x="612.5">condition底层知道吗</text></g></g><g id="minder_node1485"><g id="node_expander1481" style="cursor: pointer;"><path id="kity_path_24965" fill="white" stroke="gray" d="M748.5,9688.5A6,6,0,1,1,736.5,9688.5A6,6,0,1,1,748.5,9688.5"></path><path id="kity_path_24966" fill="none" stroke="gray" d="M738,9688.5L747,9688.5"></path></g><path id="node_outline1482" fill="none" stroke="none" d="M753.5,9661.5h1197a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1197a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1482" fill="black"><text id="kity_text_11332" text-rendering="inherit" font-size="12" dy=".8em" y="9662.700000047684" x="753.5">1.condition底层复用了AQS的node节点，和同步队列的node是一样的,只不过条件队列是单向的，除了尾节点，从头节点都指向下一个node节点。也就是condition是AQS的一个静态内部类，一个同步器可以有多个条件队列。</text><text id="kity_text_11333" text-rendering="inherit" font-size="12" dy=".8em" y="9680.700000047684" x="753.5">每一个condition对象都包含一个等待队列，conditionobject通过头尾指针来管理Node节点，我们需要多个条件队列只需要实例化几个condition就可以了。而获取锁失败的线程 和调用await的线程会尾插进入</text><text id="kity_text_11334" text-rendering="inherit" font-size="12" dy=".8em" y="9698.700000047684" x="753.5">条件队列，也就是说头节点是等待时间最长的&#xa0;</text></g></g><g id="minder_node1486"><g id="node_expander1480" style="cursor: pointer;" display="none"><path id="kity_path_24962" fill="white" stroke="gray" d="M1971.5,9688.5A6,6,0,1,1,1959.5,9688.5A6,6,0,1,1,1971.5,9688.5"></path><path id="kity_path_24963" fill="none" stroke="gray"></path></g><path id="node_outline1481" fill="none" stroke="none" d="M1976.5,9653.5h200a5,5,0,0,1,5,5v60a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-60a5,5,0,0,1,5,-5z"></path><g id="node_text1481" fill="black"><text id="kity_text_11330" text-rendering="inherit" font-size="12" dy=".8em" y="9706.700000047684" x="2051.5">条件队列</text></g><image id="kity_image_17065" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210330110405.png" x="1976.5" y="9656.5" width="200" height="47"></image></g><g id="minder_node1487"><g id="node_expander1487" style="cursor: pointer;"><path id="kity_path_24983" fill="white" stroke="gray" d="M607.5,9858.5A6,6,0,1,1,595.5,9858.5A6,6,0,1,1,607.5,9858.5"></path><path id="kity_path_24984" fill="none" stroke="gray" d="M597,9858.5L606,9858.5"></path></g><path id="node_outline1488" fill="none" stroke="none" d="M612.5,9849.5h158a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-158a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1488" fill="black"><text id="kity_text_11348" text-rendering="inherit" font-size="12" dy=".8em" y="9850.700000047684" x="612.5">知道condition的await原理吗</text></g></g><g id="minder_node1488"><g id="node_expander1486" style="cursor: pointer;"><path id="kity_path_24980" fill="white" stroke="gray" d="M791.5,9858.5A6,6,0,1,1,779.5,9858.5A6,6,0,1,1,791.5,9858.5"></path><path id="kity_path_24981" fill="none" stroke="gray" d="M781,9858.5L790,9858.5"></path></g><path id="node_outline1487" fill="none" stroke="none" d="M796.5,9831.5h932a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-932a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1487" fill="black"><text id="kity_text_11344" text-rendering="inherit" font-size="12" dy=".8em" y="9832.700000047684" x="796.5">1.await相当于把条件队列中的首节点（获取了锁的节点）移动到Condition的等待队列中</text><text id="kity_text_11345" text-rendering="inherit" font-size="12" dy=".8em" y="9850.700000047684" x="796.5">(1)调用await首先会把当前线程包装Node，尾插入到等待队列中。 释放当前线程所占用的lock，在释放的过程中会唤醒同步队列中的下一个节点。然后当前线程进入条件队列。</text><text id="kity_text_11346" text-rendering="inherit" font-size="12" dy=".8em" y="9868.700000047684" x="796.5">(2)进入条件队列后 从await退出 前提是其他线程唤醒或者中断。 然后自旋获取同步状态直到成功&#xa0; 获取lock成功。也就是说在退出await是获取到condition关联的lock</text></g></g><g id="minder_node1489"><g id="node_expander1484" style="cursor: pointer;"><path id="kity_path_24974" fill="white" stroke="gray" d="M1749.5,9792.5A6,6,0,1,1,1737.5,9792.5A6,6,0,1,1,1749.5,9792.5"></path><path id="kity_path_24975" fill="none" stroke="gray" d="M1739,9792.5L1748,9792.5M1743.5,9788L1743.5,9797"></path></g><path id="node_outline1485" fill="none" stroke="none" d="M1754.5,9732.5h200a5,5,0,0,1,5,5v110a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-110a5,5,0,0,1,5,-5z"></path><g id="node_text1485" fill="black"><text id="kity_text_11340" text-rendering="inherit" font-size="12" dy=".8em" y="9835.700000047684" x="1817.5">进入等待队列</text></g><image id="kity_image_17066" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20201126190722844.png" x="1754.5" y="9735.5" width="200" height="97"></image></g><g id="minder_node1490" display="none"><g id="node_expander1483" style="cursor: pointer;" display="none"><path id="kity_path_24971" fill="white" stroke="gray" d="M1975.5,9792.5A6,6,0,1,1,1963.5,9792.5A6,6,0,1,1,1975.5,9792.5"></path><path id="kity_path_24972" fill="none" stroke="gray"></path></g><path id="node_outline1484" fill="none" stroke="none" d="M1975.5,9778.5h79a5,5,0,0,1,5,5v18a5,5,0,0,1,-5,5h-79a5,5,0,0,1,-5,-5v-18a5,5,0,0,1,5,-5z"></path><g id="node_text1484" fill="black"><text id="kity_text_11338" text-rendering="inherit" font-size="12" dy=".8em" y="9784.700000047684" x="1975.5">分支主题</text></g><a id="kity_a_16940" xlink:href="https://www.codercc.com/backend/basic/juc/lock/condition.html#_2-2-await%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" target="_blank" xlink:title="https://www.codercc.com/backend/basic/juc/lock/condition.html#_2-2-await%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" style="cursor: pointer;"><path id="kity_path_16942" fill="rgba(255, 255, 255, 0)" stroke="none" d="M2034.5,9781.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16941" fill="#666" stroke="none" d="M2049.114,9797.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V9791.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C2044.766,9788.571,2046.168,9787.5,2047.836,9787.5h1.278c2.116,0,3.834,1.716,3.834,3.834V9793.89C2052.948,9796.008,2051.23,9797.724,2049.114,9797.724zM2037.612,9792.612c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S2047.265,9793.89,2046.558,9793.89H2038.89C2038.185,9793.89,2037.612,9793.319,2037.612,9792.612zM2035.056,9791.334V9793.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H2036.334C2034.216,9797.724,2032.5,9796.008,2032.5,9793.89V9791.334C2032.5,9789.216,2034.216,9787.5,2036.334,9787.5h1.278c1.667,0,3.071,1.071,3.599,2.556H2036.334C2035.629,9790.056,2035.056,9790.627,2035.056,9791.334z"></path></a></g><g id="minder_node1491"><g id="node_expander1485" style="cursor: pointer;" display="none"><path id="kity_path_24977" fill="white" stroke="gray" d="M1749.5,9923A6,6,0,1,1,1737.5,9923A6,6,0,1,1,1749.5,9923"></path><path id="kity_path_24978" fill="none" stroke="gray"></path></g><path id="node_outline1486" fill="none" stroke="none" d="M1754.5,9860.5h200a5,5,0,0,1,5,5v115a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-115a5,5,0,0,1,5,-5z"></path><g id="node_text1486" fill="black"><text id="kity_text_11342" text-rendering="inherit" font-size="12" dy=".8em" y="9968.700000047684" x="1817.5">进入同步队列</text></g><image id="kity_image_17067" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20201126204423990.png" x="1754.5" y="9863.5" width="200" height="102"></image></g><g id="minder_node1492"><g id="node_expander1489" style="cursor: pointer;"><path id="kity_path_24989" fill="white" stroke="gray" d="M607.5,10010.5A6,6,0,1,1,595.5,10010.5A6,6,0,1,1,607.5,10010.5"></path><path id="kity_path_24990" fill="none" stroke="gray" d="M597,10010.5L606,10010.5"></path></g><path id="node_outline1490" fill="none" stroke="none" d="M612.5,10001.5h102a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-102a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1490" fill="black"><text id="kity_text_11353" text-rendering="inherit" font-size="12" dy=".8em" y="10002.700000047684" x="612.5">signal()原理说说？</text></g></g><g id="minder_node1493"><g id="node_expander1488" style="cursor: pointer;" display="none"><path id="kity_path_24986" fill="white" stroke="gray" d="M735.5,10010.5A6,6,0,1,1,723.5,10010.5A6,6,0,1,1,735.5,10010.5"></path><path id="kity_path_24987" fill="none" stroke="gray"></path></g><path id="node_outline1489" fill="none" stroke="none" d="M740.5,9992.5h710a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-710a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1489" fill="black"><text id="kity_text_11350" text-rendering="inherit" font-size="12" dy=".8em" y="9993.700000047684" x="740.5">1.调用condition的signal或者signalAll方法可以将等待队列中等待时间最长的节点移动到同步队列中，使得该节点能够有机会获得lock</text><text id="kity_text_11351" text-rendering="inherit" font-size="12" dy=".8em" y="10011.700000047684" x="740.5">每次调用condition的signal方法是将头节点移动到同步队列中。</text></g></g><g id="minder_node1494"><g id="node_expander1491" style="cursor: pointer;"><path id="kity_path_24995" fill="white" stroke="gray" d="M607.5,10045.5A6,6,0,1,1,595.5,10045.5A6,6,0,1,1,607.5,10045.5"></path><path id="kity_path_24996" fill="none" stroke="gray" d="M597,10045.5L606,10045.5"></path></g><path id="node_outline1492" fill="none" stroke="none" d="M612.5,10036.5h146a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-146a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1492" fill="black"><text id="kity_text_11357" text-rendering="inherit" font-size="12" dy=".8em" y="10037.700000047684" x="612.5">知道LockSupport是什么吗</text></g></g><g id="minder_node1495"><g id="node_expander1490" style="cursor: pointer;" display="none"><path id="kity_path_24992" fill="white" stroke="gray" d="M779.5,10045.5A6,6,0,1,1,767.5,10045.5A6,6,0,1,1,779.5,10045.5"></path><path id="kity_path_24993" fill="none" stroke="gray"></path></g><path id="node_outline1491" fill="none" stroke="none" d="M784.5,10036.5h493a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-493a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1491" fill="black"><text id="kity_text_11355" text-rendering="inherit" font-size="12" dy=".8em" y="10037.700000047684" x="784.5">1.LockSupprot工具类是用来阻塞线程和唤醒线程。主要是park（休眠）和unpark(唤醒)方法</text></g></g><g id="minder_node1496"><g id="node_expander1494" style="cursor: pointer;"><path id="kity_path_25004" fill="white" stroke="gray" d="M607.5,10089.5A6,6,0,1,1,595.5,10089.5A6,6,0,1,1,607.5,10089.5"></path><path id="kity_path_25005" fill="none" stroke="gray" d="M597,10089.5L606,10089.5"></path></g><path id="node_outline1495" fill="none" stroke="none" d="M612.5,10080.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1495" fill="black"><text id="kity_text_11365" text-rendering="inherit" font-size="12" dy=".8em" y="10081.700000047684" x="612.5">LockSupport有什么功能</text></g></g><g id="minder_node1497"><g id="node_expander1493" style="cursor: pointer;"><path id="kity_path_25001" fill="white" stroke="gray" d="M766.5,10089.5A6,6,0,1,1,754.5,10089.5A6,6,0,1,1,766.5,10089.5"></path><path id="kity_path_25002" fill="none" stroke="gray" d="M756,10089.5L765,10089.5"></path></g><path id="node_outline1494" fill="none" stroke="none" d="M771.5,10062.5h731a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-731a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1494" fill="black"><text id="kity_text_11361" text-rendering="inherit" font-size="12" dy=".8em" y="10063.700000047684" x="771.5">1.阻塞当前线程 或者指定时间，如果调用unpark方法或者当前线程被中断，才能从park()方法中返回</text><text id="kity_text_11362" text-rendering="inherit" font-size="12" dy=".8em" y="10081.700000047684" x="771.5">2.入参增加一个Object对象，用来获取记录导致线程阻塞的阻塞对象，方便进行问题排查；比如 park(blocker)，blocker传人string进去，</text><text id="kity_text_11363" text-rendering="inherit" font-size="12" dy=".8em" y="10099.700000047684" x="771.5">然后jps 查看java pid 然后jstack pid 可以看到等待的对象数据信息</text></g></g><g id="minder_node1498"><g id="node_expander1492" style="cursor: pointer;" display="none"><path id="kity_path_24998" fill="white" stroke="gray" d="M1523.5,10089.5A6,6,0,1,1,1511.5,10089.5A6,6,0,1,1,1523.5,10089.5"></path><path id="kity_path_24999" fill="none" stroke="gray"></path></g><path id="node_outline1493" fill="none" stroke="none" d="M1528.5,10080.5h326a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1493" fill="black"><text id="kity_text_11359" text-rendering="inherit" font-size="12" dy=".8em" y="10081.700000047684" x="1528.5">https://juejin.cn/post/6844903608140431373#heading-8</text></g></g><g id="minder_node1499"><g id="node_expander1497" style="cursor: pointer;"><path id="kity_path_25013" fill="white" stroke="gray" d="M607.5,10231.5A6,6,0,1,1,595.5,10231.5A6,6,0,1,1,607.5,10231.5"></path><path id="kity_path_25014" fill="none" stroke="gray" d="M597,10231.5L606,10231.5"></path></g><path id="node_outline1498" fill="none" stroke="none" d="M612.5,10222.5h281a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-281a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1498" fill="black"><text id="kity_text_11372" text-rendering="inherit" font-size="12" dy=".8em" y="10223.700000047684" x="612.5">LockSupport和synchronized的阻塞唤醒有什么区别</text></g></g><g id="minder_node1500"><g id="node_expander1496" style="cursor: pointer;"><path id="kity_path_25010" fill="white" stroke="gray" d="M914.5,10231.5A6,6,0,1,1,902.5,10231.5A6,6,0,1,1,914.5,10231.5"></path><path id="kity_path_25011" fill="none" stroke="gray" d="M904,10231.5L913,10231.5"></path></g><path id="node_outline1497" fill="none" stroke="none" d="M919.5,10213.5h688a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-688a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1497" fill="black"><text id="kity_text_11369" text-rendering="inherit" font-size="12" dy=".8em" y="10214.700000047684" x="919.5">1.synchronzed致使线程阻塞，线程会进入到BLOCKED状态，而调用LockSupprt方法阻塞线程会致使线程进入到WAITING状态。</text><text id="kity_text_11370" text-rendering="inherit" font-size="12" dy=".8em" y="10232.700000047684" x="919.5">2.unpark函数可以将指定线程Thread唤醒。而notify随机唤醒在此对象监视器上等待的单个线程。</text></g></g><g id="minder_node1501"><g id="node_expander1495" style="cursor: pointer;" display="none"><path id="kity_path_25007" fill="white" stroke="gray" d="M1628.5,10231.5A6,6,0,1,1,1616.5,10231.5A6,6,0,1,1,1628.5,10231.5"></path><path id="kity_path_25008" fill="none" stroke="gray"></path></g><path id="node_outline1496" fill="none" stroke="none" d="M1633.5,10124.5h200a5,5,0,0,1,5,5v204a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-204a5,5,0,0,1,5,-5z"></path><g id="node_text1496" fill="black"><text id="kity_text_11367" text-rendering="inherit" font-size="12" dy=".8em" y="10321.700000047684" x="1708.5">分支主题</text></g><image id="kity_image_17068" xlink:href="https://img-blog.csdnimg.cn/20190626175301934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly96aGFuZ2JveWkuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70" x="1633.5" y="10127.5" width="200" height="191"></image></g><g id="minder_node1502"><g id="node_expander1519" style="cursor: pointer;"><path id="kity_path_25079" fill="white" stroke="gray" d="M544.5,10912.5A6,6,0,1,1,532.5,10912.5A6,6,0,1,1,544.5,10912.5"></path><path id="kity_path_25080" fill="none" stroke="gray" d="M534,10912.5L543,10912.5"></path></g><path id="node_outline1520" fill="none" stroke="none" d="M549.5,10903.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1520" fill="black"><text id="kity_text_11452" text-rendering="inherit" font-size="12" dy=".8em" y="10904.700000047684" x="549.5">并发系锁</text></g></g><g id="minder_node1503"><g id="node_expander1512" style="cursor: pointer;"><path id="kity_path_25058" fill="white" stroke="gray" d="M620.5,10640.5A6,6,0,1,1,608.5,10640.5A6,6,0,1,1,620.5,10640.5"></path><path id="kity_path_25059" fill="none" stroke="gray" d="M610,10640.5L619,10640.5"></path></g><path id="node_outline1513" fill="none" stroke="none" d="M625.5,10631.5h156a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-156a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1513" fill="black"><text id="kity_text_11422" text-rendering="inherit" font-size="12" dy=".8em" y="10632.700000047684" x="625.5">ReentrantLock的一系列问题</text></g></g><g id="minder_node1504"><g id="node_expander1501" style="cursor: pointer;"><path id="kity_path_25025" fill="white" stroke="gray" d="M802.5,10445.5A6,6,0,1,1,790.5,10445.5A6,6,0,1,1,802.5,10445.5"></path><path id="kity_path_25026" fill="none" stroke="gray" d="M792,10445.5L801,10445.5"></path></g><path id="node_outline1502" fill="none" stroke="none" d="M807.5,10436.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1502" fill="black"><text id="kity_text_11390" text-rendering="inherit" font-size="12" dy=".8em" y="10437.700000047684" x="807.5">说一下ReentrantLock的原理</text></g></g><g id="minder_node1505"><g id="node_expander1500" style="cursor: pointer;"><path id="kity_path_25022" fill="white" stroke="gray" d="M985.5,10445.5A6,6,0,1,1,973.5,10445.5A6,6,0,1,1,985.5,10445.5"></path><path id="kity_path_25023" fill="none" stroke="gray" d="M975,10445.5L984,10445.5"></path></g><path id="node_outline1501" fill="none" stroke="none" d="M990.5,10346.5h1951a5,5,0,0,1,5,5v188a5,5,0,0,1,-5,5h-1951a5,5,0,0,1,-5,-5v-188a5,5,0,0,1,5,-5z"></path><g id="node_text1501" fill="black"><text id="kity_text_11378" text-rendering="inherit" font-size="12" dy=".8em" y="10347.700000047684" x="990.5">1.支持重入性，表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞。重入性的加锁，先通过获取内部AQS的state 如果为0，说明该锁能被该线程获取，调用CAS设置同步状态和当前锁的持有者。如果不为0，先检查占锁的是否为该线程，如果是的话，再次获取state+1，返回ture。否则返回false，说明没有获取</text><text id="kity_text_11379" text-rendering="inherit" font-size="12" dy=".8em" y="10365.700000047684" x="990.5">到同步状态，就构造节点信息添加到同步队列中。</text><text id="kity_text_11380" text-rendering="inherit" font-size="12" dy=".8em" y="10383.700000047684" x="990.5">释放锁，首先getstate获取该实例同步状态state -1，然后判断 state是否为0，为0才返回true，锁被成功释放，如果不为0，说明锁没有完全释放，返回false。也就是锁被重入多少次 就要释放多少次，才算成功。</text><text id="kity_text_11381" text-rendering="inherit" font-size="12" dy=".8em" y="10401.700000047684" x="990.5">2.公平非公平，公平锁的获取请求顺序满足FIFO。非公平锁可能刚释放就又获取。在reentrantlock中，可以通过构造函数传true构造公平锁，默认是非公平锁，是为了通过系统吞吐量。公平锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁则不一定，有可能刚释放锁的线程能再次获取到锁。</text><text id="kity_text_11382" text-rendering="inherit" font-size="12" dy=".8em" y="10419.700000047684" x="990.5">公平锁比非公平锁多了个方法用来判断当前节点在同步队列中是否有前驱节点的判断，如果有前驱节点说明有线程比当前线程更早的请求资源，根据公平性，当前线程请求资源失败</text><text id="kity_text_11383" text-rendering="inherit" font-size="12" dy=".8em" y="10437.700000047684" x="990.5">非公平：</text><text id="kity_text_11384" text-rendering="inherit" font-size="12" dy=".8em" y="10455.700000047684" x="990.5">(1).非公平锁加锁先尝试CAS获取同步状态，如果成功就设置该线程为owner直接返回，失败就tryAcquire()去获取锁。(2).获取当前线程，获取同步状态state 如果为0，然后尝试CAS去AQS队列中把状态从0变1，如果成功就设置owner直接返回ture 获取锁成功。如果是该线程为再重入的，state+1，更新state，返回ture。</text><text id="kity_text_11385" text-rendering="inherit" font-size="12" dy=".8em" y="10473.700000047684" x="990.5">(3).如果上一步返回false，先构造一个同步队列的节点，包含当前线程实例的信息，如果队列不为空，CAS的把新节点作为尾节点添加同步队列 成功了就把之前的尾节点的后节点设置为当前线程实例构造的新节点。如果为空 说明当前等待队列中没有等待线程，就构造一个新同步队列节点并CAS到队列头节点，然后for死循环把当前实例节点加入到队列中，直到更新成功</text><text id="kity_text_11386" text-rendering="inherit" font-size="12" dy=".8em" y="10491.700000047684" x="990.5">(4).线程进入队列，通过一个for死循环，当获取到当前节点的前驱节点为头节点并且尝试加锁成功。并且成功就说明当前节点为头节点，然后把头节点的后节点设置为null方便GC，然后退出死循环</text><text id="kity_text_11387" text-rendering="inherit" font-size="12" dy=".8em" y="10509.700000047684" x="990.5">公平：和非公平锁一样，除了没有上面第一步一来就CAS获取同步状态，其他都一样，大概说明白就行了。</text><text id="kity_text_11388" text-rendering="inherit" font-size="12" dy=".8em" y="10527.700000047684" x="990.5">3.公平非公平释放锁就是 锁的可重入，整体流程说明白就行了</text></g></g><g id="minder_node1506"><g id="node_expander1499" style="cursor: pointer;" display="none"><path id="kity_path_25019" fill="white" stroke="gray" d="M2962.5,10445.5A6,6,0,1,1,2950.5,10445.5A6,6,0,1,1,2962.5,10445.5"></path><path id="kity_path_25020" fill="none" stroke="gray"></path></g><path id="node_outline1500" fill="none" stroke="none" d="M2967.5,10436.5h326a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1500" fill="black"><text id="kity_text_11376" text-rendering="inherit" font-size="12" dy=".8em" y="10437.700000047684" x="2967.5">https://juejin.cn/post/6844903832791547918#heading-5</text></g></g><g id="minder_node1507"><g id="node_expander1503" style="cursor: pointer;"><path id="kity_path_25031" fill="white" stroke="gray" d="M802.5,10606.5A6,6,0,1,1,790.5,10606.5A6,6,0,1,1,802.5,10606.5"></path><path id="kity_path_25032" fill="none" stroke="gray" d="M792,10606.5L801,10606.5"></path></g><path id="node_outline1504" fill="none" stroke="none" d="M807.5,10597.5h339a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-339a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1504" fill="black"><text id="kity_text_11399" text-rendering="inherit" font-size="12" dy=".8em" y="10598.700000047684" x="807.5">那你知道ReentrantLock和synchronized的区别吗，使用场景呢</text></g></g><g id="minder_node1508"><g id="node_expander1502" style="cursor: pointer;" display="none"><path id="kity_path_25028" fill="white" stroke="gray" d="M1167.5,10606.5A6,6,0,1,1,1155.5,10606.5A6,6,0,1,1,1167.5,10606.5"></path><path id="kity_path_25029" fill="none" stroke="gray"></path></g><path id="node_outline1503" fill="none" stroke="none" d="M1172.5,10552.5h937a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-937a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1503" fill="black"><text id="kity_text_11392" text-rendering="inherit" font-size="12" dy=".8em" y="10553.700000047684" x="1172.5">1.</text><text id="kity_text_11393" text-rendering="inherit" font-size="12" dy=".8em" y="10571.700000047684" x="1172.5">reentrantlock实现依赖AQS，支持超时和尝试获取锁和响应中断，需要显式调用解锁，可重入</text><text id="kity_text_11394" text-rendering="inherit" font-size="12" dy=".8em" y="10589.700000047684" x="1172.5">synchronized实现依赖对象监视器，不灵活，可重入，不支持锁响应中断</text><text id="kity_text_11395" text-rendering="inherit" font-size="12" dy=".8em" y="10607.700000047684" x="1172.5">2.场景</text><text id="kity_text_11396" text-rendering="inherit" font-size="12" dy=".8em" y="10625.700000047684" x="1172.5">现在对synchronized的优化也很多，大体性能差不多，在竞争不激烈的情况下，synchronized性能还要更好，都是大部分还是推荐reentrantlock，都是实习生一定要记得解锁，</text><text id="kity_text_11397" text-rendering="inherit" font-size="12" dy=".8em" y="10643.700000047684" x="1172.5">而且对异常的处理上，synchronized在异常时自动释放锁，不会因为这个导致死锁问题，而reentrantlock就不行，需要unlock</text></g></g><g id="minder_node1509"><g id="node_expander1505" style="cursor: pointer;"><path id="kity_path_25037" fill="white" stroke="gray" d="M802.5,10695.5A6,6,0,1,1,790.5,10695.5A6,6,0,1,1,802.5,10695.5"></path><path id="kity_path_25038" fill="none" stroke="gray" d="M792,10695.5L801,10695.5"></path></g><path id="node_outline1506" fill="none" stroke="none" d="M807.5,10686.5h299a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-299a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1506" fill="black"><text id="kity_text_11405" text-rendering="inherit" font-size="12" dy=".8em" y="10687.700000047684" x="807.5">ReentrantLock有什么特点呢，他是公平的还是非公平的</text></g></g><g id="minder_node1510"><g id="node_expander1504" style="cursor: pointer;" display="none"><path id="kity_path_25034" fill="white" stroke="gray" d="M1127.5,10695.5A6,6,0,1,1,1115.5,10695.5A6,6,0,1,1,1127.5,10695.5"></path><path id="kity_path_25035" fill="none" stroke="gray"></path></g><path id="node_outline1505" fill="none" stroke="none" d="M1132.5,10668.5h613a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-613a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1505" fill="black"><text id="kity_text_11401" text-rendering="inherit" font-size="12" dy=".8em" y="10669.700000047684" x="1132.5">1.默认非公平，因为性能更好，避免上下文切换，但是可以通过构造函数传ture构造公平</text><text id="kity_text_11402" text-rendering="inherit" font-size="12" dy=".8em" y="10687.700000047684" x="1132.5">公平锁为了保证时间上的绝对顺序，需要频繁的上下文切换，而非公平锁会降低一定的上下文切换，降低性能开销。</text><text id="kity_text_11403" text-rendering="inherit" font-size="12" dy=".8em" y="10705.700000047684" x="1132.5">非公平锁有可能刚释放锁的线程下次继续获取该锁，则有可能导致其他线程永远无法获取到锁，造成“饥饿”现象。</text></g></g><g id="minder_node1511"><g id="node_expander1507" style="cursor: pointer;"><path id="kity_path_25043" fill="white" stroke="gray" d="M802.5,10748.5A6,6,0,1,1,790.5,10748.5A6,6,0,1,1,802.5,10748.5"></path><path id="kity_path_25044" fill="none" stroke="gray" d="M792,10748.5L801,10748.5"></path></g><path id="node_outline1508" fill="none" stroke="none" d="M807.5,10739.5h217a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-217a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1508" fill="black"><text id="kity_text_11410" text-rendering="inherit" font-size="12" dy=".8em" y="10740.700000047684" x="807.5">为什么公平锁的效率比非公平锁的效率低</text></g></g><g id="minder_node1512"><g id="node_expander1506" style="cursor: pointer;" display="none"><path id="kity_path_25040" fill="white" stroke="gray" d="M1045.5,10748.5A6,6,0,1,1,1033.5,10748.5A6,6,0,1,1,1045.5,10748.5"></path><path id="kity_path_25041" fill="none" stroke="gray"></path></g><path id="node_outline1507" fill="none" stroke="none" d="M1050.5,10730.5h782a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-782a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1507" fill="black"><text id="kity_text_11407" text-rendering="inherit" font-size="12" dy=".8em" y="10731.700000047684" x="1050.5">1.比如说在reentrantlock中非公平锁比公平锁加锁多了一个CAS尝试设置owner，如果成功直接返回ture，不走下面流程，而公平锁都会走后续流程</text><text id="kity_text_11408" text-rendering="inherit" font-size="12" dy=".8em" y="10749.700000047684" x="1050.5">公平锁为了保持时间一致，就算锁资源空闲，总会去队列中拿第一个节点线程，这样上下文切换是消耗很大的。</text></g></g><g id="minder_node1513"><g id="node_expander1509" style="cursor: pointer;"><path id="kity_path_25049" fill="white" stroke="gray" d="M802.5,10792.5A6,6,0,1,1,790.5,10792.5A6,6,0,1,1,802.5,10792.5"></path><path id="kity_path_25050" fill="none" stroke="gray" d="M792,10792.5L801,10792.5"></path></g><path id="node_outline1510" fill="none" stroke="none" d="M807.5,10783.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1510" fill="black"><text id="kity_text_11415" text-rendering="inherit" font-size="12" dy=".8em" y="10784.700000047684" x="807.5">非公平一定不公平吗？</text></g></g><g id="minder_node1514"><g id="node_expander1508" style="cursor: pointer;" display="none"><path id="kity_path_25046" fill="white" stroke="gray" d="M949.5,10792.5A6,6,0,1,1,937.5,10792.5A6,6,0,1,1,949.5,10792.5"></path><path id="kity_path_25047" fill="none" stroke="gray"></path></g><path id="node_outline1509" fill="none" stroke="none" d="M954.5,10774.5h961a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-961a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1509" fill="black"><text id="kity_text_11412" text-rendering="inherit" font-size="12" dy=".8em" y="10775.700000047684" x="954.5">1.</text><text id="kity_text_11413" text-rendering="inherit" font-size="12" dy=".8em" y="10793.700000047684" x="954.5">当头节点线程释放锁以后，AQS同步队列外部没有线程来争抢锁，并且头节点线程在释放锁以后，自己也不需要获取锁了，那么就肯定是后继节点得到锁，并且它还是等待时间最长的</text></g></g><g id="minder_node1515"><g id="node_expander1511" style="cursor: pointer;"><path id="kity_path_25055" fill="white" stroke="gray" d="M802.5,10836.5A6,6,0,1,1,790.5,10836.5A6,6,0,1,1,802.5,10836.5"></path><path id="kity_path_25056" fill="none" stroke="gray" d="M792,10836.5L801,10836.5"></path></g><path id="node_outline1512" fill="none" stroke="none" d="M807.5,10827.5h180a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-180a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1512" fill="black"><text id="kity_text_11420" text-rendering="inherit" font-size="12" dy=".8em" y="10828.700000047684" x="807.5">ReentrantLock可被中断？为什么</text></g></g><g id="minder_node1516"><g id="node_expander1510" style="cursor: pointer;" display="none"><path id="kity_path_25052" fill="white" stroke="gray" d="M1008.5,10836.5A6,6,0,1,1,996.5,10836.5A6,6,0,1,1,1008.5,10836.5"></path><path id="kity_path_25053" fill="none" stroke="gray"></path></g><path id="node_outline1511" fill="none" stroke="none" d="M1013.5,10818.5h566a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-566a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1511" fill="black"><text id="kity_text_11417" text-rendering="inherit" font-size="12" dy=".8em" y="10819.700000047684" x="1013.5">1.可。使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情</text><text id="kity_text_11418" text-rendering="inherit" font-size="12" dy=".8em" y="10837.700000047684" x="1013.5">2.lock不能中断，可以用带超时参数的tryLock()，线程等待期间被中断抛异常，避免死锁</text></g></g><g id="minder_node1517"><g id="node_expander1514" style="cursor: pointer;"><path id="kity_path_25064" fill="white" stroke="gray" d="M620.5,10889.5A6,6,0,1,1,608.5,10889.5A6,6,0,1,1,620.5,10889.5"></path><path id="kity_path_25065" fill="none" stroke="gray" d="M610,10889.5L619,10889.5"></path></g><path id="node_outline1515" fill="none" stroke="none" d="M625.5,10880.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1515" fill="black"><text id="kity_text_11428" text-rendering="inherit" font-size="12" dy=".8em" y="10881.700000047684" x="625.5">读写锁的特点呢</text></g></g><g id="minder_node1518"><g id="node_expander1513" style="cursor: pointer;" display="none"><path id="kity_path_25061" fill="white" stroke="gray" d="M731.5,10889.5A6,6,0,1,1,719.5,10889.5A6,6,0,1,1,731.5,10889.5"></path><path id="kity_path_25062" fill="none" stroke="gray"></path></g><path id="node_outline1514" fill="none" stroke="none" d="M736.5,10862.5h565a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-565a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1514" fill="black"><text id="kity_text_11424" text-rendering="inherit" font-size="12" dy=".8em" y="10863.700000047684" x="736.5">1.</text><text id="kity_text_11425" text-rendering="inherit" font-size="12" dy=".8em" y="10881.700000047684" x="736.5">读写锁允许同一时刻被多个读线程访问，但是在写线程访问时，所有的读线程和其他的写线程都会被阻塞。</text><text id="kity_text_11426" text-rendering="inherit" font-size="12" dy=".8em" y="10899.700000047684" x="736.5">支持公平非公平，支持锁重入，支持锁降级</text></g></g><g id="minder_node1519"><g id="node_expander1516" style="cursor: pointer;"><path id="kity_path_25070" fill="white" stroke="gray" d="M620.5,11032.5A6,6,0,1,1,608.5,11032.5A6,6,0,1,1,620.5,11032.5"></path><path id="kity_path_25071" fill="none" stroke="gray" d="M610,11032.5L619,11032.5"></path></g><path id="node_outline1517" fill="none" stroke="none" d="M625.5,11023.5h98a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-98a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1517" fill="black"><text id="kity_text_11443" text-rendering="inherit" font-size="12" dy=".8em" y="11024.700000047684" x="625.5">说说读写锁的原理</text></g></g><g id="minder_node1520"><g id="node_expander1515" style="cursor: pointer;" display="none"><path id="kity_path_25067" fill="white" stroke="gray" d="M744.5,11032.5A6,6,0,1,1,732.5,11032.5A6,6,0,1,1,744.5,11032.5"></path><path id="kity_path_25068" fill="none" stroke="gray"></path></g><path id="node_outline1516" fill="none" stroke="none" d="M749.5,10924.5h1325a5,5,0,0,1,5,5v206a5,5,0,0,1,-5,5h-1325a5,5,0,0,1,-5,-5v-206a5,5,0,0,1,5,-5z"></path><g id="node_text1516" fill="black"><text id="kity_text_11430" text-rendering="inherit" font-size="12" dy=".8em" y="10925.700000047684" x="749.5">1.写锁是排它锁，读锁是共享锁，</text><text id="kity_text_11431" text-rendering="inherit" font-size="12" dy=".8em" y="10943.700000047684" x="749.5">1.1写锁获取：</text><text id="kity_text_11432" text-rendering="inherit" font-size="12" dy=".8em" y="10961.700000047684" x="749.5">(1).首先获取当前线程和写锁同步状态和写锁获取次数，如果state!=0 然后判断读锁是否被获取和写锁是否为当前线程，否就获取写锁失败，是就获取写锁成功并设置state，并且这个过程支持可重入</text><text id="kity_text_11433" text-rendering="inherit" font-size="12" dy=".8em" y="10979.700000047684" x="749.5">(2).如果state=0，说明写锁未被然后线程获取，当前线程获取写锁，设置为owner，增加写状态，返回true，获取成功。同步状态是通过32位int变量， 高16位是读次数，低16位是写次数。</text><text id="kity_text_11434" text-rendering="inherit" font-size="12" dy=".8em" y="10997.700000047684" x="749.5">1.2写锁释放：(1).因为写状态是低16位，直接减就可以得到当前写同步状态，如果为0就释放，不为0更新同步状态，</text><text id="kity_text_11435" text-rendering="inherit" font-size="12" dy=".8em" y="11015.700000047684" x="749.5">1.3读锁的获取和释放：实现共享需要重写AQS的tryAcquireShared方法和tryReleaseShared方法</text><text id="kity_text_11436" text-rendering="inherit" font-size="12" dy=".8em" y="11033.700000047684" x="749.5">读锁获取：</text><text id="kity_text_11437" text-rendering="inherit" font-size="12" dy=".8em" y="11051.700000047684" x="749.5">(1)首先和写锁获取一样，判断同步状态和当前线程，如果写锁已被获取&#xa0; 就直接返回获取失败。判断读锁是否需要公平和读锁持有数是否成功最大值，超过就报错。否则获取读状态成功，CAS更新读状态成功，然后看线程是否是第一次获取 支持可重入&#xa0;</text><text id="kity_text_11438" text-rendering="inherit" font-size="12" dy=".8em" y="11069.700000047684" x="749.5">&#xa0;(2)如果条件不满足就调用方法自旋再次获取读锁。</text><text id="kity_text_11439" text-rendering="inherit" font-size="12" dy=".8em" y="11087.700000047684" x="749.5">读锁释放：(1)如果当前线程是第一个获取读锁线程 直接获取同步状态减去读状态 然后CAS更新。否则自旋CAS更新锁同步状态。记录读锁次数的是通过threadlocal的holdcounter来记录每一个线程读锁状态次数。</text><text id="kity_text_11440" text-rendering="inherit" font-size="12" dy=".8em" y="11105.700000047684" x="749.5">2.锁降级 写锁降读锁，读锁无法升级写锁</text><text id="kity_text_11441" text-rendering="inherit" font-size="12" dy=".8em" y="11123.700000047684" x="749.5">就是线程A ，A获取写锁，A再获取读锁，A释放写锁，,其它线程无法获取写锁， 这个过程了保证了数据的可见性，</text></g></g><g id="minder_node1521"><g id="node_expander1518" style="cursor: pointer;"><path id="kity_path_25076" fill="white" stroke="gray" d="M620.5,11184.5A6,6,0,1,1,608.5,11184.5A6,6,0,1,1,620.5,11184.5"></path><path id="kity_path_25077" fill="none" stroke="gray" d="M610,11184.5L619,11184.5"></path></g><path id="node_outline1519" fill="none" stroke="none" d="M625.5,11175.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1519" fill="black"><text id="kity_text_11450" text-rendering="inherit" font-size="12" dy=".8em" y="11176.700000047684" x="625.5">读写锁的状态？</text></g></g><g id="minder_node1522"><g id="node_expander1517" style="cursor: pointer;" display="none"><path id="kity_path_25073" fill="white" stroke="gray" d="M731.5,11184.5A6,6,0,1,1,719.5,11184.5A6,6,0,1,1,731.5,11184.5"></path><path id="kity_path_25074" fill="none" stroke="gray"></path></g><path id="node_outline1518" fill="none" stroke="none" d="M736.5,11148.5h871a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-871a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1518" fill="black"><text id="kity_text_11445" text-rendering="inherit" font-size="12" dy=".8em" y="11149.700000047684" x="736.5">1.Cancelled：由于超时或中断，节点已被取消；</text><text id="kity_text_11446" text-rendering="inherit" font-size="12" dy=".8em" y="11167.700000047684" x="736.5">2.Signal：表示下一个节点是通过park阻塞的，需要通过unpark唤醒；</text><text id="kity_text_11447" text-rendering="inherit" font-size="12" dy=".8em" y="11185.700000047684" x="736.5">3.Condition：表示线程在等待条件变量（先获取锁，加入到条件等待队列，然后释放锁，等待条件变量满足条件再加入同步队列；只有重新获取锁之后才能返回）；</text><text id="kity_text_11448" text-rendering="inherit" font-size="12" dy=".8em" y="11203.700000047684" x="736.5">4.Propagate：表示后续结点会传播唤醒的操作，共享模式下起作用。</text></g></g><g id="minder_node1523"><g id="node_expander1538" style="cursor: pointer;"><path id="kity_path_25136" fill="white" stroke="gray" d="M544.5,11405.5A6,6,0,1,1,532.5,11405.5A6,6,0,1,1,544.5,11405.5"></path><path id="kity_path_25137" fill="none" stroke="gray" d="M534,11405.5L543,11405.5"></path></g><path id="node_outline1539" fill="none" stroke="none" d="M549.5,11396.5h23a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-23a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1539" fill="black"><text id="kity_text_11498" text-rendering="inherit" font-size="12" dy=".8em" y="11397.700000047684" x="549.5">CAS</text></g></g><g id="minder_node1524"><g id="node_expander1521" style="cursor: pointer;"><path id="kity_path_25085" fill="white" stroke="gray" d="M593.5,11247.5A6,6,0,1,1,581.5,11247.5A6,6,0,1,1,593.5,11247.5"></path><path id="kity_path_25086" fill="none" stroke="gray" d="M583,11247.5L592,11247.5"></path></g><path id="node_outline1522" fill="none" stroke="none" d="M598.5,11238.5h95a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-95a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1522" fill="black"><text id="kity_text_11457" text-rendering="inherit" font-size="12" dy=".8em" y="11239.700000047684" x="598.5">那你简单说说CAS</text></g></g><g id="minder_node1525"><g id="node_expander1520" style="cursor: pointer;" display="none"><path id="kity_path_25082" fill="white" stroke="gray" d="M714.5,11247.5A6,6,0,1,1,702.5,11247.5A6,6,0,1,1,714.5,11247.5"></path><path id="kity_path_25083" fill="none" stroke="gray"></path></g><path id="node_outline1521" fill="none" stroke="none" d="M719.5,11229.5h1109a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1109a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1521" fill="black"><text id="kity_text_11454" text-rendering="inherit" font-size="12" dy=".8em" y="11230.700000047684" x="719.5">1.CAS是一种乐观锁策略，是硬件指令级别的操作，CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。</text><text id="kity_text_11455" text-rendering="inherit" font-size="12" dy=".8em" y="11248.700000047684" x="719.5">如果不匹配，说明该值已经被其他线程修改过，直接返回原值。CAS可以保证当多个线程操作一个变量，只有一个可以操作成功。失败了可以继续尝试，也可以挂起</text></g></g><g id="minder_node1526"><g id="node_expander1523" style="cursor: pointer;"><path id="kity_path_25091" fill="white" stroke="gray" d="M593.5,11309.5A6,6,0,1,1,581.5,11309.5A6,6,0,1,1,593.5,11309.5"></path><path id="kity_path_25092" fill="none" stroke="gray" d="M583,11309.5L592,11309.5"></path></g><path id="node_outline1524" fill="none" stroke="none" d="M598.5,11300.5h192a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-192a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1524" fill="black"><text id="kity_text_11464" text-rendering="inherit" font-size="12" dy=".8em" y="11301.700000047684" x="598.5">说说CAS会有什么问题？解决思路？</text></g></g><g id="minder_node1527"><g id="node_expander1522" style="cursor: pointer;" display="none"><path id="kity_path_25088" fill="white" stroke="gray" d="M811.5,11309.5A6,6,0,1,1,799.5,11309.5A6,6,0,1,1,811.5,11309.5"></path><path id="kity_path_25089" fill="none" stroke="gray"></path></g><path id="node_outline1523" fill="none" stroke="none" d="M816.5,11273.5h1499a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1499a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1523" fill="black"><text id="kity_text_11459" text-rendering="inherit" font-size="12" dy=".8em" y="11274.700000047684" x="816.5">1.ABA，就是值变为A 再变为B 再变为A。CAS检查就会发现没有修改过。可以通过版本号来解决。在juc的原子类atomic包中都是CAS乐观锁来解决线程安全问题。atomic包下有复合变量类解决这个问题，就是通过给变量打戳。</text><text id="kity_text_11460" text-rendering="inherit" font-size="12" dy=".8em" y="11292.700000047684" x="816.5">2.自旋时间过长，使用CAS时非阻塞同步，也就是说不会将线程挂起，会自旋（无非就是一个死循环）进行下一次尝试，如果这里自旋时间过长对性能是很大的消耗</text><text id="kity_text_11461" text-rendering="inherit" font-size="12" dy=".8em" y="11310.700000047684" x="816.5">3.只能保证一个共享变量的原子操作，当对一个共享变量执行操作时CAS能保证其原子性，如果对多个共享变量进行操作,CAS就不能保证其原子性，解决方案是利用对象整合多个共享变量，即一个类中的成员变量就是这几个共享变量。然后将这个对象做CAS操作就可以保证其原子性。</text><text id="kity_text_11462" text-rendering="inherit" font-size="12" dy=".8em" y="11328.700000047684" x="816.5">4.在读多写少情况下，乐观锁CAS性能好</text></g></g><g id="minder_node1528"><g id="node_expander1526" style="cursor: pointer;"><path id="kity_path_25100" fill="white" stroke="gray" d="M593.5,11380.5A6,6,0,1,1,581.5,11380.5A6,6,0,1,1,593.5,11380.5"></path><path id="kity_path_25101" fill="none" stroke="gray" d="M583,11380.5L592,11380.5"></path></g><path id="node_outline1527" fill="none" stroke="none" d="M598.5,11371.5h143a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-143a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1527" fill="black"><text id="kity_text_11472" text-rendering="inherit" font-size="12" dy=".8em" y="11372.700000047684" x="598.5">CAS的原理实现有了解过吗</text></g></g><g id="minder_node1529"><g id="node_expander1525" style="cursor: pointer;"><path id="kity_path_25097" fill="white" stroke="gray" d="M762.5,11380.5A6,6,0,1,1,750.5,11380.5A6,6,0,1,1,762.5,11380.5"></path><path id="kity_path_25098" fill="none" stroke="gray" d="M752,11380.5L761,11380.5"></path></g><path id="node_outline1526" fill="none" stroke="none" d="M767.5,11353.5h1633a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1633a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1526" fill="black"><text id="kity_text_11468" text-rendering="inherit" font-size="12" dy=".8em" y="11354.700000047684" x="767.5">1.java的cas基于Unsafe类，底层是cpp调用为指令添加lock前缀。而lock前缀，会锁定缓存，在执行期间还会锁定总线。并禁止重排序和强制写缓存区数据写回主存，保证数据一致性。</text><text id="kity_text_11469" text-rendering="inherit" font-size="12" dy=".8em" y="11372.700000047684" x="767.5">2.而保证原子性会通过总线锁和缓存锁来实现。总线锁就是通过处理器在总线上通过lock前缀信号来把其他处理器前期阻塞，让该处理器独占共享内存，这个过程开销很大，有些会使用缓存锁。缓存锁 就是缓存一致性协议，让处理器获取变量从主存中获取，自己的变量副本失效，这样每次的变量都是最新的。</text><text id="kity_text_11470" text-rendering="inherit" font-size="12" dy=".8em" y="11390.700000047684" x="767.5">3.这里面每一个处理器也会通过嗅探机制观察总线数据和自己来看看数据是否过期。</text></g></g><g id="minder_node1530"><g id="node_expander1524" style="cursor: pointer;" display="none"><path id="kity_path_25094" fill="white" stroke="gray" d="M2421.5,11380.5A6,6,0,1,1,2409.5,11380.5A6,6,0,1,1,2421.5,11380.5"></path><path id="kity_path_25095" fill="none" stroke="gray"></path></g><path id="node_outline1525" fill="none" stroke="none" d="M2426.5,11371.5h260a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-260a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1525" fill="black"><text id="kity_text_11466" text-rendering="inherit" font-size="12" dy=".8em" y="11372.700000047684" x="2426.5">https://juejin.cn/post/6844903797408399374</text></g></g><g id="minder_node1531"><g id="node_expander1528" style="cursor: pointer;"><path id="kity_path_25106" fill="white" stroke="gray" d="M593.5,11433.5A6,6,0,1,1,581.5,11433.5A6,6,0,1,1,593.5,11433.5"></path><path id="kity_path_25107" fill="none" stroke="gray" d="M583,11433.5L592,11433.5"></path></g><path id="node_outline1529" fill="none" stroke="none" d="M598.5,11424.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1529" fill="black"><text id="kity_text_11477" text-rendering="inherit" font-size="12" dy=".8em" y="11425.700000047684" x="598.5">嗅探机制是个啥</text></g></g><g id="minder_node1532"><g id="node_expander1527" style="cursor: pointer;" display="none"><path id="kity_path_25103" fill="white" stroke="gray" d="M704.5,11433.5A6,6,0,1,1,692.5,11433.5A6,6,0,1,1,704.5,11433.5"></path><path id="kity_path_25104" fill="none" stroke="gray"></path></g><path id="node_outline1528" fill="none" stroke="none" d="M709.5,11415.5h1189a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1189a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1528" fill="black"><text id="kity_text_11474" text-rendering="inherit" font-size="12" dy=".8em" y="11416.700000047684" x="709.5">1.</text><text id="kity_text_11475" text-rendering="inherit" font-size="12" dy=".8em" y="11434.700000047684" x="709.5">每个处理器会通过嗅探器来监控总线上的数据来检查自己缓存内的数据是否过期，如果发现自己缓存行对应的地址被修改了，就会将此缓存行置为无效。当处理器对此数据进行操作时，就会重新从主内存中读取数据到缓存行。</text></g></g><g id="minder_node1533"><g id="node_expander1530" style="cursor: pointer;"><path id="kity_path_25112" fill="white" stroke="gray" d="M593.5,11468.5A6,6,0,1,1,581.5,11468.5A6,6,0,1,1,593.5,11468.5"></path><path id="kity_path_25113" fill="none" stroke="gray" d="M583,11468.5L592,11468.5"></path></g><path id="node_outline1531" fill="none" stroke="none" d="M598.5,11459.5h108a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-108a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1531" fill="black"><text id="kity_text_11481" text-rendering="inherit" font-size="12" dy=".8em" y="11460.700000047684" x="598.5">频繁CAS会有问题吗</text></g></g><g id="minder_node1534"><g id="node_expander1529" style="cursor: pointer;" display="none"><path id="kity_path_25109" fill="white" stroke="gray" d="M727.5,11468.5A6,6,0,1,1,715.5,11468.5A6,6,0,1,1,727.5,11468.5"></path><path id="kity_path_25110" fill="none" stroke="gray"></path></g><path id="node_outline1530" fill="none" stroke="none" d="M732.5,11459.5h281a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-281a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1530" fill="black"><text id="kity_text_11479" text-rendering="inherit" font-size="12" dy=".8em" y="11460.700000047684" x="732.5">1.可能会因为底层频繁调用cas的指令而导致总线风暴</text></g></g><g id="minder_node1535"><g id="node_expander1533" style="cursor: pointer;"><path id="kity_path_25121" fill="white" stroke="gray" d="M593.5,11503.5A6,6,0,1,1,581.5,11503.5A6,6,0,1,1,593.5,11503.5"></path><path id="kity_path_25122" fill="none" stroke="gray" d="M583,11503.5L592,11503.5"></path></g><path id="node_outline1534" fill="none" stroke="none" d="M598.5,11494.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1534" fill="black"><text id="kity_text_11488" text-rendering="inherit" font-size="12" dy=".8em" y="11495.700000047684" x="598.5">那你知道总线风暴吗，说说看</text></g></g><g id="minder_node1536"><g id="node_expander1532" style="cursor: pointer;"><path id="kity_path_25118" fill="white" stroke="gray" d="M776.5,11503.5A6,6,0,1,1,764.5,11503.5A6,6,0,1,1,776.5,11503.5"></path><path id="kity_path_25119" fill="none" stroke="gray" d="M766,11503.5L775,11503.5"></path></g><path id="node_outline1533" fill="none" stroke="none" d="M781.5,11485.5h1030a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1030a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1533" fill="black"><text id="kity_text_11485" text-rendering="inherit" font-size="12" dy=".8em" y="11486.700000047684" x="781.5">1.在java中 cas是基与Unsafe类，底层是cpp调用汇编指令实现，如果在短时间内产生大量的cas操作在加上 volatile的嗅探机制则会不断地占用总线带宽，导致总线流量激增，就会产生总线风暴。</text><text id="kity_text_11486" text-rendering="inherit" font-size="12" dy=".8em" y="11504.700000047684" x="781.5">2.缓存一致性协议会触发嗅探器进行数据传播。当有大量的volatile 和cas 进行数据修改的时候就会产大量嗅探消息。</text></g></g><g id="minder_node1537"><g id="node_expander1531" style="cursor: pointer;" display="none"><path id="kity_path_25115" fill="white" stroke="gray" d="M1832.5,11503.5A6,6,0,1,1,1820.5,11503.5A6,6,0,1,1,1832.5,11503.5"></path><path id="kity_path_25116" fill="none" stroke="gray"></path></g><path id="node_outline1532" fill="none" stroke="none" d="M1837.5,11494.5h318a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-318a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1532" fill="black"><text id="kity_text_11483" text-rendering="inherit" font-size="12" dy=".8em" y="11495.700000047684" x="1837.5">https://www.cnblogs.com/jiagoujishu/p/13744544.html</text></g></g><g id="minder_node1538"><g id="node_expander1535" style="cursor: pointer;"><path id="kity_path_25127" fill="white" stroke="gray" d="M593.5,11538.5A6,6,0,1,1,581.5,11538.5A6,6,0,1,1,593.5,11538.5"></path><path id="kity_path_25128" fill="none" stroke="gray" d="M583,11538.5L592,11538.5"></path></g><path id="node_outline1536" fill="none" stroke="none" d="M598.5,11529.5h71a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-71a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1536" fill="black"><text id="kity_text_11492" text-rendering="inherit" font-size="12" dy=".8em" y="11530.700000047684" x="598.5">CAS的缺点？</text></g></g><g id="minder_node1539"><g id="node_expander1534" style="cursor: pointer;" display="none"><path id="kity_path_25124" fill="white" stroke="gray" d="M690.5,11538.5A6,6,0,1,1,678.5,11538.5A6,6,0,1,1,690.5,11538.5"></path><path id="kity_path_25125" fill="none" stroke="gray"></path></g><path id="node_outline1535" fill="none" stroke="none" d="M695.5,11529.5h92a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-92a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1535" fill="black"><text id="kity_text_11490" text-rendering="inherit" font-size="12" dy=".8em" y="11530.700000047684" x="695.5">和cas的问题一样</text></g></g><g id="minder_node1540"><g id="node_expander1537" style="cursor: pointer;"><path id="kity_path_25133" fill="white" stroke="gray" d="M593.5,11564.5A6,6,0,1,1,581.5,11564.5A6,6,0,1,1,593.5,11564.5"></path><path id="kity_path_25134" fill="none" stroke="gray" d="M583,11564.5L592,11564.5"></path></g><path id="node_outline1538" fill="none" stroke="none" d="M598.5,11555.5h239a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-239a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1538" fill="black"><text id="kity_text_11496" text-rendering="inherit" font-size="12" dy=".8em" y="11556.700000047684" x="598.5">CAS是在硬件方面实现的还是软件方面实现的</text></g></g><g id="minder_node1541"><g id="node_expander1536" style="cursor: pointer;" display="none"><path id="kity_path_25130" fill="white" stroke="gray" d="M858.5,11564.5A6,6,0,1,1,846.5,11564.5A6,6,0,1,1,858.5,11564.5"></path><path id="kity_path_25131" fill="none" stroke="gray"></path></g><path id="node_outline1537" fill="none" stroke="none" d="M863.5,11555.5h58a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-58a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1537" fill="black"><text id="kity_text_11494" text-rendering="inherit" font-size="12" dy=".8em" y="11556.700000047684" x="863.5">1.硬件方面</text></g></g><g id="minder_node1542"><g id="node_expander1557" style="cursor: pointer;"><path id="kity_path_25193" fill="white" stroke="gray" d="M544.5,11838.5A6,6,0,1,1,532.5,11838.5A6,6,0,1,1,544.5,11838.5"></path><path id="kity_path_25194" fill="none" stroke="gray" d="M534,11838.5L543,11838.5"></path></g><path id="node_outline1558" fill="none" stroke="none" d="M549.5,11829.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1558" fill="black"><text id="kity_text_11551" text-rendering="inherit" font-size="12" dy=".8em" y="11830.700000047684" x="549.5">并发容器</text></g></g><g id="minder_node1543"><g id="node_expander1541" style="cursor: pointer;"><path id="kity_path_25145" fill="white" stroke="gray" d="M620.5,11635.5A6,6,0,1,1,608.5,11635.5A6,6,0,1,1,620.5,11635.5"></path><path id="kity_path_25146" fill="none" stroke="gray" d="M610,11635.5L619,11635.5"></path></g><path id="node_outline1542" fill="none" stroke="none" d="M625.5,11626.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1542" fill="black"><text id="kity_text_11509" text-rendering="inherit" font-size="12" dy=".8em" y="11627.700000047684" x="625.5">你知道哪些阻塞队列</text></g></g><g id="minder_node1544"><g id="node_expander1540" style="cursor: pointer;"><path id="kity_path_25142" fill="white" stroke="gray" d="M755.5,11635.5A6,6,0,1,1,743.5,11635.5A6,6,0,1,1,755.5,11635.5"></path><path id="kity_path_25143" fill="none" stroke="gray" d="M745,11635.5L754,11635.5"></path></g><path id="node_outline1541" fill="none" stroke="none" d="M760.5,11581.5h588a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-588a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1541" fill="black"><text id="kity_text_11502" text-rendering="inherit" font-size="12" dy=".8em" y="11582.700000047684" x="760.5">1.</text><text id="kity_text_11503" text-rendering="inherit" font-size="12" dy=".8em" y="11600.700000047684" x="760.5">ArrayBlockingQueue 底层是数组，有界队列，如果我们要使用生产者-消费者模式，这是非常好的选择。</text><text id="kity_text_11504" text-rendering="inherit" font-size="12" dy=".8em" y="11618.700000047684" x="760.5">LinkedBlockingQueue 底层是链表，可以当做无界和有界队列来使用，所以大家不要以为它就是无界队列。</text><text id="kity_text_11505" text-rendering="inherit" font-size="12" dy=".8em" y="11636.700000047684" x="760.5">DelayQueue 延时队列</text><text id="kity_text_11506" text-rendering="inherit" font-size="12" dy=".8em" y="11654.700000047684" x="760.5">SynchronousQueue 本身不带有空间来存储任何元素，使用上可以选择公平模式和非公平模式。</text><text id="kity_text_11507" text-rendering="inherit" font-size="12" dy=".8em" y="11672.700000047684" x="760.5">PriorityBlockingQueue 是无界队列，基于数组，数据结构为二叉堆，数组第一个也是树的根节点总是最小值。</text></g></g><g id="minder_node1545"><g id="node_expander1539" style="cursor: pointer;" display="none"><path id="kity_path_25139" fill="white" stroke="gray" d="M1369.5,11635.5A6,6,0,1,1,1357.5,11635.5A6,6,0,1,1,1369.5,11635.5"></path><path id="kity_path_25140" fill="none" stroke="gray"></path></g><path id="node_outline1540" fill="none" stroke="none" d="M1374.5,11626.5h322a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-322a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1540" fill="black"><text id="kity_text_11500" text-rendering="inherit" font-size="12" dy=".8em" y="11627.700000047684" x="1374.5">https://www.javadoop.com/post/java-concurrent-queue</text></g></g><g id="minder_node1546"><g id="node_expander1543" style="cursor: pointer;"><path id="kity_path_25151" fill="white" stroke="gray" d="M620.5,11724.5A6,6,0,1,1,608.5,11724.5A6,6,0,1,1,620.5,11724.5"></path><path id="kity_path_25152" fill="none" stroke="gray" d="M610,11724.5L619,11724.5"></path></g><path id="node_outline1544" fill="none" stroke="none" d="M625.5,11715.5h144a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-144a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1544" fill="black"><text id="kity_text_11515" text-rendering="inherit" font-size="12" dy=".8em" y="11716.700000047684" x="625.5">阻塞队列是怎么实现阻塞的</text></g></g><g id="minder_node1547"><g id="node_expander1542" style="cursor: pointer;" display="none"><path id="kity_path_25148" fill="white" stroke="gray" d="M790.5,11724.5A6,6,0,1,1,778.5,11724.5A6,6,0,1,1,790.5,11724.5"></path><path id="kity_path_25149" fill="none" stroke="gray"></path></g><path id="node_outline1543" fill="none" stroke="none" d="M795.5,11697.5h1783a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1783a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1543" fill="black"><text id="kity_text_11511" text-rendering="inherit" font-size="12" dy=".8em" y="11698.700000047684" x="795.5">1.阻塞队列主要是通过Lock锁的多条件（Condition）阻塞控制。比如在ArrayBlockingQueue中，主要是通过reentrantlock+两个监视器实现，这两个监视器的作用相当于标记分组，当该线程是put操作时，给他加上监视器notFull,标记这个线程是一个生产者；当线程是take操作时，给他加上监视器notEmpty，标记这个线程是消费者。</text><text id="kity_text_11512" text-rendering="inherit" font-size="12" dy=".8em" y="11716.700000047684" x="795.5">put：1.先拿锁，没拿到的自旋竞争，拿到的会先看队列是否满了，满了就阻塞这个线程，标记为生产者，同时释放锁，等待被消费者线程唤醒。2.如果队列没满 就把元素put到队列。3.唤醒一个标记为消费者的线程。</text><text id="kity_text_11513" text-rendering="inherit" font-size="12" dy=".8em" y="11734.700000047684" x="795.5">take:1.和put一样也是要先拿锁，没有自旋，拿到继续，然后判断队列是否空，空就阻塞这个线程并标记为消费者线程，同时释放锁，等待生产者线程唤醒。2.如果没有空就出队。3.唤醒一个标记为生产者的线程</text></g></g><g id="minder_node1548"><g id="node_expander1545" style="cursor: pointer;"><path id="kity_path_25157" fill="white" stroke="gray" d="M620.5,11786.5A6,6,0,1,1,608.5,11786.5A6,6,0,1,1,620.5,11786.5"></path><path id="kity_path_25158" fill="none" stroke="gray" d="M610,11786.5L619,11786.5"></path></g><path id="node_outline1546" fill="none" stroke="none" d="M625.5,11777.5h202a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-202a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1546" fill="black"><text id="kity_text_11521" text-rendering="inherit" font-size="12" dy=".8em" y="11778.700000047684" x="625.5">take，poll的区别，put，offer的区别</text></g></g><g id="minder_node1549"><g id="node_expander1544" style="cursor: pointer;" display="none"><path id="kity_path_25154" fill="white" stroke="gray" d="M848.5,11786.5A6,6,0,1,1,836.5,11786.5A6,6,0,1,1,848.5,11786.5"></path><path id="kity_path_25155" fill="none" stroke="gray"></path></g><path id="node_outline1545" fill="none" stroke="none" d="M853.5,11759.5h1333a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1333a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1545" fill="black"><text id="kity_text_11517" text-rendering="inherit" font-size="12" dy=".8em" y="11760.700000047684" x="853.5">1.BlockingQueue 对于不能立即满足但可能在将来某一时刻可以满足的操作，处理方式不同。</text><text id="kity_text_11518" text-rendering="inherit" font-size="12" dy=".8em" y="11778.700000047684" x="853.5">take和poll都是移除操作，当使用take时如果条件不满足就，在成功之前 无限期地阻塞当前线程，如果在等待被中断会抛中断异常。 而poll 如果指定参数就可以放弃前只在给定的最大时间限制内阻塞 如果中断抛异常，或者返回ture或flase一个特殊值。</text><text id="kity_text_11519" text-rendering="inherit" font-size="12" dy=".8em" y="11796.700000047684" x="853.5">put，offer插入操作，put也是会在成功之前限期地阻塞当前线程。而offer 和poll是一样的，</text></g></g><g id="minder_node1550"><g id="node_expander1547" style="cursor: pointer;"><path id="kity_path_25163" fill="white" stroke="gray" d="M620.5,11830.5A6,6,0,1,1,608.5,11830.5A6,6,0,1,1,620.5,11830.5"></path><path id="kity_path_25164" fill="none" stroke="gray" d="M610,11830.5L619,11830.5"></path></g><path id="node_outline1548" fill="none" stroke="none" d="M625.5,11821.5h162a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-162a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1548" fill="black"><text id="kity_text_11525" text-rendering="inherit" font-size="12" dy=".8em" y="11822.700000047684" x="625.5">让你实现阻塞队列 你怎么实现</text></g></g><g id="minder_node1551"><g id="node_expander1546" style="cursor: pointer;" display="none"><path id="kity_path_25160" fill="white" stroke="gray" d="M808.5,11830.5A6,6,0,1,1,796.5,11830.5A6,6,0,1,1,808.5,11830.5"></path><path id="kity_path_25161" fill="none" stroke="gray"></path></g><path id="node_outline1547" fill="none" stroke="none" d="M813.5,11821.5h231a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-231a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1547" fill="black"><text id="kity_text_11523" text-rendering="inherit" font-size="12" dy=".8em" y="11822.700000047684" x="813.5">https://zhuanlan.zhihu.com/p/64156753</text></g></g><g id="minder_node1552"><g id="node_expander1549" style="cursor: pointer;"><path id="kity_path_25169" fill="white" stroke="gray" d="M620.5,11883.5A6,6,0,1,1,608.5,11883.5A6,6,0,1,1,620.5,11883.5"></path><path id="kity_path_25170" fill="none" stroke="gray" d="M610,11883.5L619,11883.5"></path></g><path id="node_outline1550" fill="none" stroke="none" d="M625.5,11874.5h181a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-181a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1550" fill="black"><text id="kity_text_11532" text-rendering="inherit" font-size="12" dy=".8em" y="11875.700000047684" x="625.5">怎么实现一个线程安全的阻塞队列</text></g></g><g id="minder_node1553"><g id="node_expander1548" style="cursor: pointer;" display="none"><path id="kity_path_25166" fill="white" stroke="gray" d="M827.5,11883.5A6,6,0,1,1,815.5,11883.5A6,6,0,1,1,827.5,11883.5"></path><path id="kity_path_25167" fill="none" stroke="gray"></path></g><path id="node_outline1549" fill="none" stroke="none" d="M832.5,11847.5h722a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-722a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1549" fill="black"><text id="kity_text_11527" text-rendering="inherit" font-size="12" dy=".8em" y="11848.700000047684" x="832.5">1.参考ArrayBlockQueue</text><text id="kity_text_11528" text-rendering="inherit" font-size="12" dy=".8em" y="11866.700000047684" x="832.5">(1)定义队列，底层存储结构，最大大小的信息，用reentrantlock来实现互斥，condition来实现阻塞和唤醒，用来标记生产者和消费者，</text><text id="kity_text_11529" text-rendering="inherit" font-size="12" dy=".8em" y="11884.700000047684" x="832.5">(2)添加时先lock,判断队列是否满，满就condition await 等待队列未满条件满足，没满就添加，最后unlock。</text><text id="kity_text_11530" text-rendering="inherit" font-size="12" dy=".8em" y="11902.700000047684" x="832.5">(3)删除时 先lock，判断队列是否为空，空就condition await，等待队列非空条件满足，然后删除， 并唤醒生产者</text></g></g><g id="minder_node1554"><g id="node_expander1552" style="cursor: pointer;"><path id="kity_path_25178" fill="white" stroke="gray" d="M620.5,11963.5A6,6,0,1,1,608.5,11963.5A6,6,0,1,1,620.5,11963.5"></path><path id="kity_path_25179" fill="none" stroke="gray" d="M610,11963.5L619,11963.5"></path></g><path id="node_outline1553" fill="none" stroke="none" d="M625.5,11954.5h253a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-253a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1553" fill="black"><text id="kity_text_11541" text-rendering="inherit" font-size="12" dy=".8em" y="11955.700000047684" x="625.5">说一下ArrayBlockQueue,底层结构?并发原理？</text></g></g><g id="minder_node1555"><g id="node_expander1551" style="cursor: pointer;"><path id="kity_path_25175" fill="white" stroke="gray" d="M899.5,11963.5A6,6,0,1,1,887.5,11963.5A6,6,0,1,1,899.5,11963.5"></path><path id="kity_path_25176" fill="none" stroke="gray" d="M889,11963.5L898,11963.5"></path></g><path id="node_outline1552" fill="none" stroke="none" d="M904.5,11927.5h1526a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1526a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1552" fill="black"><text id="kity_text_11536" text-rendering="inherit" font-size="12" dy=".8em" y="11928.700000047684" x="904.5">1.ArrayBlockingQueue 是 BlockingQueue 接口的有界队列实现类，底层采用数组来实现。并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作，最主要组成是两个condition和Reentrantlock。为了保证线程安全，采用的是ReentrantLock lock，</text><text id="kity_text_11537" text-rendering="inherit" font-size="12" dy=".8em" y="11946.700000047684" x="904.5">为了保证可阻塞式的插入删除数据利用的是Condition，当获取数据的消费者线程被阻塞时会将该线程放置到notEmpty等待队列中，当插入数据的生产者线程被阻塞时，会将该线程放置到notFull等待队列中。</text><text id="kity_text_11538" text-rendering="inherit" font-size="12" dy=".8em" y="11964.700000047684" x="904.5">ArrayBlockingQueue 实现并发同步的原理就是，读操作和写操作都需要获取到 AQS 独占锁才能进行操作。如果队列为空，这个时候读操作的线程进入到读线程队列排队，等待写线程写入新的元素，然后唤醒读线程队列的第一个等待线程。</text><text id="kity_text_11539" text-rendering="inherit" font-size="12" dy=".8em" y="11982.700000047684" x="904.5">如果队列已满，这个时候写操作的线程进入到写线程队列排队，等待读线程将队列元素移除腾出空间，然后唤醒写线程队列的第一个等待线程。</text></g></g><g id="minder_node1556"><g id="node_expander1550" style="cursor: pointer;" display="none"><path id="kity_path_25172" fill="white" stroke="gray" d="M2451.5,11963.5A6,6,0,1,1,2439.5,11963.5A6,6,0,1,1,2451.5,11963.5"></path><path id="kity_path_25173" fill="none" stroke="gray"></path></g><path id="node_outline1551" fill="none" stroke="none" d="M2456.5,11954.5h322a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-322a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1551" fill="black"><text id="kity_text_11534" text-rendering="inherit" font-size="12" dy=".8em" y="11955.700000047684" x="2456.5">https://www.javadoop.com/post/java-concurrent-queue</text></g></g><g id="minder_node1557"><g id="node_expander1554" style="cursor: pointer;"><path id="kity_path_25184" fill="white" stroke="gray" d="M620.5,12016.5A6,6,0,1,1,608.5,12016.5A6,6,0,1,1,620.5,12016.5"></path><path id="kity_path_25185" fill="none" stroke="gray" d="M610,12016.5L619,12016.5"></path></g><path id="node_outline1555" fill="none" stroke="none" d="M625.5,12007.5h197a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-197a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1555" fill="black"><text id="kity_text_11545" text-rendering="inherit" font-size="12" dy=".8em" y="12008.700000047684" x="625.5">LinkedBlockingQueue结构？原理？</text></g></g><g id="minder_node1558"><g id="node_expander1553" style="cursor: pointer;" display="none"><path id="kity_path_25181" fill="white" stroke="gray" d="M843.5,12016.5A6,6,0,1,1,831.5,12016.5A6,6,0,1,1,843.5,12016.5"></path><path id="kity_path_25182" fill="none" stroke="gray"></path></g><path id="node_outline1554" fill="none" stroke="none" d="M848.5,12007.5h1702a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1702a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1554" fill="black"><text id="kity_text_11543" text-rendering="inherit" font-size="12" dy=".8em" y="12008.700000047684" x="848.5">1基于链表实现的有界队列，按照先进先出（FIFO）的原则对元素进行排序。内部使用的是ReentrantLock + ConditionObject实现的同步机制.和ArrayBlockingQueue的区别是ArrayBlockingQueue内部维护的是一个数组，通过数组下标来维护队列，而LinkedBlockingQueue维护的是一个链表，通过Node来维护队列。</text></g></g><g id="minder_node1559"><g id="node_expander1556" style="cursor: pointer;"><path id="kity_path_25190" fill="white" stroke="gray" d="M620.5,12042.5A6,6,0,1,1,608.5,12042.5A6,6,0,1,1,620.5,12042.5"></path><path id="kity_path_25191" fill="none" stroke="gray" d="M610,12042.5L619,12042.5"></path></g><path id="node_outline1557" fill="none" stroke="none" d="M625.5,12033.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1557" fill="black"><text id="kity_text_11549" text-rendering="inherit" font-size="12" dy=".8em" y="12034.700000047684" x="625.5">知道实现延时队列吗</text></g></g><g id="minder_node1560"><g id="node_expander1555" style="cursor: pointer;" display="none"><path id="kity_path_25187" fill="white" stroke="gray" d="M755.5,12042.5A6,6,0,1,1,743.5,12042.5A6,6,0,1,1,755.5,12042.5"></path><path id="kity_path_25188" fill="none" stroke="gray"></path></g><path id="node_outline1556" fill="none" stroke="none" d="M760.5,12033.5h286a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-286a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1556" fill="black"><text id="kity_text_11547" text-rendering="inherit" font-size="12" dy=".8em" y="12034.700000047684" x="760.5">可以使用DelayQueue来实现，需要实现Delayed接口</text></g></g><g id="minder_node1561"><g id="node_expander1617" style="cursor: pointer;"><path id="kity_path_25373" fill="white" stroke="gray" d="M544.5,13385.5A6,6,0,1,1,532.5,13385.5A6,6,0,1,1,544.5,13385.5"></path><path id="kity_path_25374" fill="none" stroke="gray" d="M534,13385.5L543,13385.5"></path></g><path id="node_outline1618" fill="none" stroke="none" d="M549.5,13376.5h38a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-38a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1618" fill="black"><text id="kity_text_11759" text-rendering="inherit" font-size="12" dy=".8em" y="13377.700000047684" x="549.5">线程池</text></g></g><g id="minder_node1562"><g id="node_expander1580" style="cursor: pointer;"><path id="kity_path_25262" fill="white" stroke="gray" d="M608.5,12621.5A6,6,0,1,1,596.5,12621.5A6,6,0,1,1,608.5,12621.5"></path><path id="kity_path_25263" fill="none" stroke="gray" d="M598,12621.5L607,12621.5"></path></g><path id="node_outline1581" fill="none" stroke="none" d="M613.5,12612.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1581" fill="black"><text id="kity_text_11647" text-rendering="inherit" font-size="12" dy=".8em" y="12613.700000047684" x="613.5">基础</text></g></g><g id="minder_node1563"><g id="node_expander1559" style="cursor: pointer;"><path id="kity_path_25199" fill="white" stroke="gray" d="M659.5,12068.5A6,6,0,1,1,647.5,12068.5A6,6,0,1,1,659.5,12068.5"></path><path id="kity_path_25200" fill="none" stroke="gray" d="M649,12068.5L658,12068.5"></path></g><path id="node_outline1560" fill="none" stroke="none" d="M664.5,12059.5h193a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-193a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1560" fill="black"><text id="kity_text_11555" text-rendering="inherit" font-size="12" dy=".8em" y="12060.700000047684" x="664.5">创建线程池有哪些方式？主要区别？</text></g></g><g id="minder_node1564"><g id="node_expander1558" style="cursor: pointer;" display="none"><path id="kity_path_25196" fill="white" stroke="gray" d="M878.5,12068.5A6,6,0,1,1,866.5,12068.5A6,6,0,1,1,878.5,12068.5"></path><path id="kity_path_25197" fill="none" stroke="gray"></path></g><path id="node_outline1559" fill="none" stroke="none" d="M883.5,12059.5h276a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-276a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1559" fill="black"><text id="kity_text_11553" text-rendering="inherit" font-size="12" dy=".8em" y="12060.700000047684" x="883.5">1.线程池工具executors和threadpoolexecutor原生</text></g></g><g id="minder_node1565"><g id="node_expander1561" style="cursor: pointer;"><path id="kity_path_25205" fill="white" stroke="gray" d="M659.5,12130.5A6,6,0,1,1,647.5,12130.5A6,6,0,1,1,659.5,12130.5"></path><path id="kity_path_25206" fill="none" stroke="gray" d="M649,12130.5L658,12130.5"></path></g><path id="node_outline1562" fill="none" stroke="none" d="M664.5,12121.5h122a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-122a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1562" fill="black"><text id="kity_text_11563" text-rendering="inherit" font-size="12" dy=".8em" y="12122.700000047684" x="664.5">线程池有哪些类型说说</text></g></g><g id="minder_node1566"><g id="node_expander1560" style="cursor: pointer;" display="none"><path id="kity_path_25202" fill="white" stroke="gray" d="M807.5,12130.5A6,6,0,1,1,795.5,12130.5A6,6,0,1,1,807.5,12130.5"></path><path id="kity_path_25203" fill="none" stroke="gray"></path></g><path id="node_outline1561" fill="none" stroke="none" d="M812.5,12085.5h506a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-506a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1561" fill="black"><text id="kity_text_11557" text-rendering="inherit" font-size="12" dy=".8em" y="12086.700000047684" x="812.5">1.常见的下面四种</text><text id="kity_text_11558" text-rendering="inherit" font-size="12" dy=".8em" y="12104.700000047684" x="812.5">Executors.newCachedThreadPool() core是0，所有都可回收</text><text id="kity_text_11559" text-rendering="inherit" font-size="12" dy=".8em" y="12122.700000047684" x="812.5">Executors.newFixedThreadPool() 固定大小，core=max；都不可回收</text><text id="kity_text_11560" text-rendering="inherit" font-size="12" dy=".8em" y="12140.700000047684" x="812.5">Executors.newScheduledThreadPool() 定时任务的线程池</text><text id="kity_text_11561" text-rendering="inherit" font-size="12" dy=".8em" y="12158.700000047684" x="812.5">Executors.newSingleThreadExecutor() 单线程的线程池，后台从队列里面获取任务，挨个执行</text></g></g><g id="minder_node1567"><g id="node_expander1564" style="cursor: pointer;"><path id="kity_path_25214" fill="white" stroke="gray" d="M659.5,12327.5A6,6,0,1,1,647.5,12327.5A6,6,0,1,1,659.5,12327.5"></path><path id="kity_path_25215" fill="none" stroke="gray" d="M649,12327.5L658,12327.5"></path></g><path id="node_outline1565" fill="none" stroke="none" d="M664.5,12318.5h314a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-314a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1565" fill="black"><text id="kity_text_11584" text-rendering="inherit" font-size="12" dy=".8em" y="12319.700000047684" x="664.5">这几种线程池的使用场景知道吗，你们使用的是什么线程池</text></g></g><g id="minder_node1568"><g id="node_expander1563" style="cursor: pointer;"><path id="kity_path_25211" fill="white" stroke="gray" d="M999.5,12327.5A6,6,0,1,1,987.5,12327.5A6,6,0,1,1,999.5,12327.5"></path><path id="kity_path_25212" fill="none" stroke="gray" d="M989,12327.5L998,12327.5"></path></g><path id="node_outline1564" fill="none" stroke="none" d="M1004.5,12183.5h1507a5,5,0,0,1,5,5v278a5,5,0,0,1,-5,5h-1507a5,5,0,0,1,-5,-5v-278a5,5,0,0,1,5,-5z"></path><g id="node_text1564" fill="black"><text id="kity_text_11567" text-rendering="inherit" font-size="12" dy=".8em" y="12184.700000047684" x="1004.5">1.newFixedThreadPool (固定数目线程的线程池)</text><text id="kity_text_11568" text-rendering="inherit" font-size="12" dy=".8em" y="12202.700000047684" x="1004.5">特点：核心线程数和最大线程数大小一样。没有所谓的非空闲时间，即keepAliveTime为0。阻塞队列为无界队列LinkedBlockingQueue</text><text id="kity_text_11569" text-rendering="inherit" font-size="12" dy=".8em" y="12220.700000047684" x="1004.5">工作机制：提交任务。如果线程数少于核心线程，创建核心线程执行任务。如果线程数等于核心线程，把任务添加到LinkedBlockingQueue阻塞队列。如果线程执行完任务，去阻塞队列取任务，继续执行。</text><text id="kity_text_11570" text-rendering="inherit" font-size="12" dy=".8em" y="12238.700000047684" x="1004.5">场景：FixedThreadPool 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。</text><text id="kity_text_11571" text-rendering="inherit" font-size="12" dy=".8em" y="12256.700000047684" x="1004.5">2.newCachedThreadPool(可缓存线程的线程池)</text><text id="kity_text_11572" text-rendering="inherit" font-size="12" dy=".8em" y="12274.700000047684" x="1004.5">特点：核心线程数为0。最大线程数为Integer.MAX_VALUE。非核心线程空闲存活时间为60秒。阻塞队列是SynchronousQueue。由于空闲 60 秒的线程会被终止，长时间保持空闲的 CachedThreadPool 不会占用任何资源。</text><text id="kity_text_11573" text-rendering="inherit" font-size="12" dy=".8em" y="12292.700000047684" x="1004.5">工作机制：提交任务。因为没有核心线程，所以任务直接加到SynchronousQueue队列。判断是否有空闲线程，如果有，就去取出任务执行。如果没有空闲线程，就新建一个线程执行。执行完任务的线程，还可以存活60秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁。</text><text id="kity_text_11574" text-rendering="inherit" font-size="12" dy=".8em" y="12310.700000047684" x="1004.5">场景：用于并发执行大量短期的小任务。</text><text id="kity_text_11575" text-rendering="inherit" font-size="12" dy=".8em" y="12328.700000047684" x="1004.5">3.newSingleThreadExecutor(单线程的线程池)</text><text id="kity_text_11576" text-rendering="inherit" font-size="12" dy=".8em" y="12346.700000047684" x="1004.5">特点：核心线程数为1。最大线程数也为1。阻塞队列是LinkedBlockingQueue。keepAliveTime为0</text><text id="kity_text_11577" text-rendering="inherit" font-size="12" dy=".8em" y="12364.700000047684" x="1004.5">工作机制：提交任务。线程池是否有一条线程在，如果没有，新建线程执行任务，如果有，把任务加到阻塞队列。当前的唯一线程，从队列取任务，执行完一个，再继续取，一个人（一条线程）夜以继日地干活。</text><text id="kity_text_11578" text-rendering="inherit" font-size="12" dy=".8em" y="12382.700000047684" x="1004.5">场景：适用于串行执行任务的场景，一个任务一个任务地执行。</text><text id="kity_text_11579" text-rendering="inherit" font-size="12" dy=".8em" y="12400.700000047684" x="1004.5">4.newScheduledThreadPool(定时及周期执行的线程池)</text><text id="kity_text_11580" text-rendering="inherit" font-size="12" dy=".8em" y="12418.700000047684" x="1004.5">特点：最大线程数为Integer.MAX_VALUE。阻塞队列是DelayedWorkQueue。keepAliveTime为0。scheduleAtFixedRate() ：按某种速率周期执行。scheduleWithFixedDelay()：在某个延迟后执行</text><text id="kity_text_11581" text-rendering="inherit" font-size="12" dy=".8em" y="12436.700000047684" x="1004.5">工作机制：添加一个任务。线程池中的线程从 DelayQueue 中取任务。线程从 DelayQueue 中获取 time 大于等于当前时间的task。执行完后修改这个 task 的 time 为下次被执行的时间。这个 task 放回DelayQueue队列中</text><text id="kity_text_11582" text-rendering="inherit" font-size="12" dy=".8em" y="12454.700000047684" x="1004.5">场景：周期性执行任务的场景，需要限制线程数量的场景</text></g></g><g id="minder_node1569"><g id="node_expander1562" style="cursor: pointer;" display="none"><path id="kity_path_25208" fill="white" stroke="gray" d="M2532.5,12327.5A6,6,0,1,1,2520.5,12327.5A6,6,0,1,1,2532.5,12327.5"></path><path id="kity_path_25209" fill="none" stroke="gray"></path></g><path id="node_outline1563" fill="none" stroke="none" d="M2537.5,12318.5h333a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1563" fill="black"><text id="kity_text_11565" text-rendering="inherit" font-size="12" dy=".8em" y="12319.700000047684" x="2537.5">https://juejin.cn/post/6844903889678893063#heading-22</text></g></g><g id="minder_node1570"><g id="node_expander1566" style="cursor: pointer;"><path id="kity_path_25220" fill="white" stroke="gray" d="M659.5,12524.5A6,6,0,1,1,647.5,12524.5A6,6,0,1,1,659.5,12524.5"></path><path id="kity_path_25221" fill="none" stroke="gray" d="M649,12524.5L658,12524.5"></path></g><path id="node_outline1567" fill="none" stroke="none" d="M664.5,12515.5h168a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-168a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1567" fill="black"><text id="kity_text_11592" text-rendering="inherit" font-size="12" dy=".8em" y="12516.700000047684" x="664.5">缓存线程池和固定线程池区别？</text></g></g><g id="minder_node1571"><g id="node_expander1565" style="cursor: pointer;" display="none"><path id="kity_path_25217" fill="white" stroke="gray" d="M853.5,12524.5A6,6,0,1,1,841.5,12524.5A6,6,0,1,1,853.5,12524.5"></path><path id="kity_path_25218" fill="none" stroke="gray"></path></g><path id="node_outline1566" fill="none" stroke="none" d="M858.5,12479.5h1471a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1471a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1566" fill="black"><text id="kity_text_11586" text-rendering="inherit" font-size="12" dy=".8em" y="12480.700000047684" x="858.5">1.</text><text id="kity_text_11587" text-rendering="inherit" font-size="12" dy=".8em" y="12498.700000047684" x="858.5">因为 corePoolSize == maximumPoolSize ，所以FixedThreadPool只会创建核 ⼼线程。 ⽽CachedThreadPool因为corePoolSize=0，所以只会创建⾮核⼼线 程。</text><text id="kity_text_11588" text-rendering="inherit" font-size="12" dy=".8em" y="12516.700000047684" x="858.5">在 getTask() ⽅法，如果队列⾥没有任务可取，线程会⼀直阻塞在LinkedBlockingQueue.take() ，线程不会被回收。 CachedThreadPool会在60s后收回（默认一分钟）</text><text id="kity_text_11589" text-rendering="inherit" font-size="12" dy=".8em" y="12534.700000047684" x="858.5">由于线程不会被回收，会⼀直卡在阻塞，所以没有任务的情况下，**FixedThreadPool**占⽤资源更多。&#xa0;</text><text id="kity_text_11590" text-rendering="inherit" font-size="12" dy=".8em" y="12552.700000047684" x="858.5">都⼏乎不会触发拒绝策略，但是原理不同。FixedThreadPool是因为阻塞队列 可以很⼤（最⼤为Integer最⼤值），故⼏乎不会触发拒绝策略；CachedThreadPool是因为线程池很⼤（最⼤为Integer最⼤值），⼏乎不会导 致线程数量⼤于最⼤线程数，故⼏乎不会触发拒绝策略。</text></g></g><g id="minder_node1572"><g id="node_expander1568" style="cursor: pointer;"><path id="kity_path_25226" fill="white" stroke="gray" d="M659.5,12640.5A6,6,0,1,1,647.5,12640.5A6,6,0,1,1,659.5,12640.5"></path><path id="kity_path_25227" fill="none" stroke="gray" d="M649,12640.5L658,12640.5"></path></g><path id="node_outline1569" fill="none" stroke="none" d="M664.5,12631.5h110a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-110a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1569" fill="black"><text id="kity_text_11602" text-rendering="inherit" font-size="12" dy=".8em" y="12632.700000047684" x="664.5">线程池的参数有哪些</text></g></g><g id="minder_node1573"><g id="node_expander1567" style="cursor: pointer;" display="none"><path id="kity_path_25223" fill="white" stroke="gray" d="M795.5,12640.5A6,6,0,1,1,783.5,12640.5A6,6,0,1,1,795.5,12640.5"></path><path id="kity_path_25224" fill="none" stroke="gray"></path></g><path id="node_outline1568" fill="none" stroke="none" d="M800.5,12577.5h882a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-882a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text1568" fill="black"><text id="kity_text_11594" text-rendering="inherit" font-size="12" dy=".8em" y="12578.700000047684" x="800.5">1.corePoolSize:[5] 核心线程数[一直存在除非（allowCoreThreadTimeOut）]; 线程池，创建好以后就准备就绪的线程数量，就等待来接受异步任务去执行。</text><text id="kity_text_11595" text-rendering="inherit" font-size="12" dy=".8em" y="12596.700000047684" x="800.5">2.maximumPoolSize:[200] 最大线程数量;  控制资源</text><text id="kity_text_11596" text-rendering="inherit" font-size="12" dy=".8em" y="12614.700000047684" x="800.5">3.keepAliveTime:存活时间。如果当前的线程数量大于core数量。释放空闲的线程（maximumPoolSize-corePoolSize）。只要线程空闲大于指定的keepAliveTime；</text><text id="kity_text_11597" text-rendering="inherit" font-size="12" dy=".8em" y="12632.700000047684" x="800.5">4.unit:时间单位</text><text id="kity_text_11598" text-rendering="inherit" font-size="12" dy=".8em" y="12650.700000047684" x="800.5">5. BlockingQueue&lt;Runnable&gt; workQueue:阻塞队列。如果任务有很多，就会将目前多的任务放在队列里面。</text><text id="kity_text_11599" text-rendering="inherit" font-size="12" dy=".8em" y="12668.700000047684" x="800.5">6.threadFactory:线程的创建工厂。</text><text id="kity_text_11600" text-rendering="inherit" font-size="12" dy=".8em" y="12686.700000047684" x="800.5">7. RejectedExecutionHandler handler:如果队列满了，按照我们指定的拒绝策略拒绝执行任务</text></g></g><g id="minder_node1574"><g id="node_expander1570" style="cursor: pointer;"><path id="kity_path_25232" fill="white" stroke="gray" d="M659.5,12756.5A6,6,0,1,1,647.5,12756.5A6,6,0,1,1,659.5,12756.5"></path><path id="kity_path_25233" fill="none" stroke="gray" d="M649,12756.5L658,12756.5"></path></g><path id="node_outline1571" fill="none" stroke="none" d="M664.5,12747.5h122a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-122a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1571" fill="black"><text id="kity_text_11610" text-rendering="inherit" font-size="12" dy=".8em" y="12748.700000047684" x="664.5">说说线程池的拒绝策略</text></g></g><g id="minder_node1575"><g id="node_expander1569" style="cursor: pointer;" display="none"><path id="kity_path_25229" fill="white" stroke="gray" d="M807.5,12756.5A6,6,0,1,1,795.5,12756.5A6,6,0,1,1,807.5,12756.5"></path><path id="kity_path_25230" fill="none" stroke="gray"></path></g><path id="node_outline1570" fill="none" stroke="none" d="M812.5,12711.5h623a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-623a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1570" fill="black"><text id="kity_text_11604" text-rendering="inherit" font-size="12" dy=".8em" y="12712.700000047684" x="812.5">一共有四种拒绝策略</text><text id="kity_text_11605" text-rendering="inherit" font-size="12" dy=".8em" y="12730.700000047684" x="812.5">1.ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。注：默认策略！！！！！！</text><text id="kity_text_11606" text-rendering="inherit" font-size="12" dy=".8em" y="12748.700000047684" x="812.5">2.ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</text><text id="kity_text_11607" text-rendering="inherit" font-size="12" dy=".8em" y="12766.700000047684" x="812.5">3.ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</text><text id="kity_text_11608" text-rendering="inherit" font-size="12" dy=".8em" y="12784.700000047684" x="812.5">4.ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</text></g></g><g id="minder_node1576"><g id="node_expander1572" style="cursor: pointer;"><path id="kity_path_25238" fill="white" stroke="gray" d="M659.5,12845.5A6,6,0,1,1,647.5,12845.5A6,6,0,1,1,659.5,12845.5"></path><path id="kity_path_25239" fill="none" stroke="gray" d="M649,12845.5L658,12845.5"></path></g><path id="node_outline1573" fill="none" stroke="none" d="M664.5,12836.5h146a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-146a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1573" fill="black"><text id="kity_text_11617" text-rendering="inherit" font-size="12" dy=".8em" y="12837.700000047684" x="664.5">说说任务进入线程池的流程</text></g></g><g id="minder_node1577"><g id="node_expander1571" style="cursor: pointer;" display="none"><path id="kity_path_25235" fill="white" stroke="gray" d="M831.5,12845.5A6,6,0,1,1,819.5,12845.5A6,6,0,1,1,831.5,12845.5"></path><path id="kity_path_25236" fill="none" stroke="gray"></path></g><path id="node_outline1572" fill="none" stroke="none" d="M836.5,12809.5h508a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-508a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1572" fill="black"><text id="kity_text_11612" text-rendering="inherit" font-size="12" dy=".8em" y="12810.700000047684" x="836.5">1. core满了，就将再进来的任务放入阻塞队列中。空闲的core就会自己去阻塞队列获取任务执行</text><text id="kity_text_11613" text-rendering="inherit" font-size="12" dy=".8em" y="12828.700000047684" x="836.5">2.阻塞队列满了，就直接开新线程执行，最大只能开到max指定的数量</text><text id="kity_text_11614" text-rendering="inherit" font-size="12" dy=".8em" y="12846.700000047684" x="836.5">3.max满了就用RejectedExecutionHandler拒绝任务</text><text id="kity_text_11615" text-rendering="inherit" font-size="12" dy=".8em" y="12864.700000047684" x="836.5">4.max都执行完成，有很多空闲.在指定的时间keepAliveTime以后，释放max-core这些线程</text></g></g><g id="minder_node1578"><g id="node_expander1575" style="cursor: pointer;"><path id="kity_path_25247" fill="white" stroke="gray" d="M659.5,12988.5A6,6,0,1,1,647.5,12988.5A6,6,0,1,1,659.5,12988.5"></path><path id="kity_path_25248" fill="none" stroke="gray" d="M649,12988.5L658,12988.5"></path></g><path id="node_outline1576" fill="none" stroke="none" d="M664.5,12979.5h146a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-146a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1576" fill="black"><text id="kity_text_11634" text-rendering="inherit" font-size="12" dy=".8em" y="12980.700000047684" x="664.5">说一下线程池的状态和流程</text></g></g><g id="minder_node1579"><g id="node_expander1574" style="cursor: pointer;"><path id="kity_path_25244" fill="white" stroke="gray" d="M831.5,12988.5A6,6,0,1,1,819.5,12988.5A6,6,0,1,1,831.5,12988.5"></path><path id="kity_path_25245" fill="none" stroke="gray" d="M821,12988.5L830,12988.5M825.5,12984L825.5,12993"></path></g><path id="node_outline1575" fill="none" stroke="none" d="M836.5,12889.5h1789a5,5,0,0,1,5,5v188a5,5,0,0,1,-5,5h-1789a5,5,0,0,1,-5,-5v-188a5,5,0,0,1,5,-5z"></path><g id="node_text1575" fill="black"><text id="kity_text_11622" text-rendering="inherit" font-size="12" dy=".8em" y="12890.700000047684" x="836.5">1.</text><text id="kity_text_11623" text-rendering="inherit" font-size="12" dy=".8em" y="12908.700000047684" x="836.5">(1)运行状态，线程池可以接受新任务，也可以处理阻塞队列中的任务。执行 shutdown 方法可进入 SHUTDOWN 待关闭 状态,执行 shutdownNow 方法可进入 STOP 停止状态</text><text id="kity_text_11624" text-rendering="inherit" font-size="12" dy=".8em" y="12926.700000047684" x="836.5">(2) SHUTDOWN 待关闭状态 不能创建新的线程，不再接受新的任务，继续处理阻塞队列中的任务 当阻塞队列中的任务为空，并且工作线程数为0时，进入 TIDYING 状态</text><text id="kity_text_11625" text-rendering="inherit" font-size="12" dy=".8em" y="12944.700000047684" x="836.5">(3) STOP	停止状态 不能创建新的线程，不接收新任务，也不处理阻塞队列中的任务，并且会尝试结束执行中的任务 当工作线程数为0时，进入 TIDYING 状态</text><text id="kity_text_11626" text-rendering="inherit" font-size="12" dy=".8em" y="12962.700000047684" x="836.5">(4)TIDYING	整理状态，此时任务都已经执行完毕，并且也没有工作线程 执行 terminated 方法后进入 TERMINATED 状态</text><text id="kity_text_11627" text-rendering="inherit" font-size="12" dy=".8em" y="12980.700000047684" x="836.5">(5) TERMINATED	终止状态，此时线程池完全终止了，并完成了所有资源的释放</text><text id="kity_text_11628" text-rendering="inherit" font-size="12" dy=".8em" y="12998.700000047684" x="836.5">2.</text><text id="kity_text_11629" text-rendering="inherit" font-size="12" dy=".8em" y="13016.700000047684" x="836.5">(1)当工作线程数小于核心线程数时，直接创建新的核心工作线程 (2)当工作线程数不小于核心线程数时，就需要尝试将任务添加到阻塞队列中去 (3)如果能够加入成功，说明队列还没有满，那么需要做以下的二次验证来保证添加进去的任务能够成功被执行&#xa0;</text><text id="kity_text_11630" text-rendering="inherit" font-size="12" dy=".8em" y="13034.700000047684" x="836.5">(4)验证当前线程池的运行状态，如果是非RUNNING状态，则需要将任务从阻塞队列中移除，然后拒绝该任务</text><text id="kity_text_11631" text-rendering="inherit" font-size="12" dy=".8em" y="13052.700000047684" x="836.5">(5)验证当前线程池中的工作线程的个数，如果为0，则需要主动添加一个空工作线程来执行刚刚添加到阻塞队列中的任务 (6)如果加入失败，则说明队列已经满了，那么这时就需要创建新的“临时”工作线程来执行任务&#xa0; &#xa0;(7)如果创建成功，则直接执行该任务 (8)如果创建失败，则说明工作线程数已经等于最大线程数了，则只能拒绝该任务了</text><text id="kity_text_11632" text-rendering="inherit" font-size="12" dy=".8em" y="13070.700000047684" x="836.5"> </text></g></g><g id="minder_node1580" display="none"><g id="node_expander1573" style="cursor: pointer;" display="none"><path id="kity_path_25241" fill="white" stroke="gray" d="M2646.5,12988.5A6,6,0,1,1,2634.5,12988.5A6,6,0,1,1,2646.5,12988.5"></path><path id="kity_path_25242" fill="none" stroke="gray"></path></g><path id="node_outline1574" fill="none" stroke="none" d="M2646.5,12970.5h333a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1574" fill="black"><text id="kity_text_11619" text-rendering="inherit" font-size="12" dy=".8em" y="12971.700000047684" x="2646.5">https://juejin.cn/post/6844903810091974669#heading-12</text><text id="kity_text_11620" text-rendering="inherit" font-size="12" dy=".8em" y="12989.700000047684" x="2646.5">http://concurrent.redspider.group/article/03/12.html</text></g></g><g id="minder_node1581"><g id="node_expander1577" style="cursor: pointer;"><path id="kity_path_25253" fill="white" stroke="gray" d="M659.5,13122.5A6,6,0,1,1,647.5,13122.5A6,6,0,1,1,659.5,13122.5"></path><path id="kity_path_25254" fill="none" stroke="gray" d="M649,13122.5L658,13122.5"></path></g><path id="node_outline1578" fill="none" stroke="none" d="M664.5,13113.5h205a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-205a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1578" fill="black"><text id="kity_text_11640" text-rendering="inherit" font-size="12" dy=".8em" y="13114.700000047684" x="664.5">线程池的execute和submit有什么区别</text></g></g><g id="minder_node1582"><g id="node_expander1576" style="cursor: pointer;" display="none"><path id="kity_path_25250" fill="white" stroke="gray" d="M890.5,13122.5A6,6,0,1,1,878.5,13122.5A6,6,0,1,1,890.5,13122.5"></path><path id="kity_path_25251" fill="none" stroke="gray"></path></g><path id="node_outline1577" fill="none" stroke="none" d="M895.5,13095.5h645a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-645a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1577" fill="black"><text id="kity_text_11636" text-rendering="inherit" font-size="12" dy=".8em" y="13096.700000047684" x="895.5">1.相同点就是都可以开启线程执行池中的任务。</text><text id="kity_text_11637" text-rendering="inherit" font-size="12" dy=".8em" y="13114.700000047684" x="895.5">2.接收参数：execute()只能执行 Runnable 类型的任务。submit()可以执行 Runnable 和 Callable 类型的任务。</text><text id="kity_text_11638" text-rendering="inherit" font-size="12" dy=".8em" y="13132.700000047684" x="895.5">返回值：submit()方法可以返回持有计算结果的 Future 对象，而execute()没有。异常处理：submit()方便Exception处理</text></g></g><g id="minder_node1583"><g id="node_expander1579" style="cursor: pointer;"><path id="kity_path_25259" fill="white" stroke="gray" d="M659.5,13175.5A6,6,0,1,1,647.5,13175.5A6,6,0,1,1,659.5,13175.5"></path><path id="kity_path_25260" fill="none" stroke="gray" d="M649,13175.5L658,13175.5"></path></g><path id="node_outline1580" fill="none" stroke="none" d="M664.5,13166.5h263a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-263a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1580" fill="black"><text id="kity_text_11645" text-rendering="inherit" font-size="12" dy=".8em" y="13167.700000047684" x="664.5">线程池中的shutdown()和shutdownnew()区别？</text></g></g><g id="minder_node1584"><g id="node_expander1578" style="cursor: pointer;" display="none"><path id="kity_path_25256" fill="white" stroke="gray" d="M948.5,13175.5A6,6,0,1,1,936.5,13175.5A6,6,0,1,1,948.5,13175.5"></path><path id="kity_path_25257" fill="none" stroke="gray"></path></g><path id="node_outline1579" fill="none" stroke="none" d="M953.5,13157.5h1474a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1474a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1579" fill="black"><text id="kity_text_11642" text-rendering="inherit" font-size="12" dy=".8em" y="13158.700000047684" x="953.5">1.shutdown()方法是一个很保守的关闭线程池的方法，线程池执行shutdown()后，就会拒绝接受新的任务，但是会等待线程池中正在执行的任务和已经进入阻塞队列的任务都执行完毕之后才会最终关闭线程池。</text><text id="kity_text_11643" text-rendering="inherit" font-size="12" dy=".8em" y="13176.700000047684" x="953.5">2.而shutdownNow()方法，相对就激进一些了，线程池执行shutdownNow()后，会拒绝接受新的任务，同时还会中断线程池中正在进行执行的任务，已经进入阻塞队列的任务也会被剥夺执行的机会，不过这些被剥夺执行的机会的任务会作为shutdownNow()方法的返回值返回。</text></g></g><g id="minder_node1585"><g id="node_expander1583" style="cursor: pointer;"><path id="kity_path_25271" fill="white" stroke="gray" d="M608.5,13228.5A6,6,0,1,1,596.5,13228.5A6,6,0,1,1,608.5,13228.5"></path><path id="kity_path_25272" fill="none" stroke="gray" d="M598,13228.5L607,13228.5"></path></g><path id="node_outline1584" fill="none" stroke="none" d="M613.5,13219.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1584" fill="black"><text id="kity_text_11655" text-rendering="inherit" font-size="12" dy=".8em" y="13220.700000047684" x="613.5">进阶</text></g></g><g id="minder_node1586"><g id="node_expander1582" style="cursor: pointer;"><path id="kity_path_25268" fill="white" stroke="gray" d="M660.5,13228.5A6,6,0,1,1,648.5,13228.5A6,6,0,1,1,660.5,13228.5"></path><path id="kity_path_25269" fill="none" stroke="gray" d="M650,13228.5L659,13228.5"></path></g><path id="node_outline1583" fill="none" stroke="none" d="M665.5,13219.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1583" fill="black"><text id="kity_text_11653" text-rendering="inherit" font-size="12" dy=".8em" y="13220.700000047684" x="665.5">核心线程会被销毁吗</text></g></g><g id="minder_node1587"><g id="node_expander1581" style="cursor: pointer;" display="none"><path id="kity_path_25265" fill="white" stroke="gray" d="M795.5,13228.5A6,6,0,1,1,783.5,13228.5A6,6,0,1,1,795.5,13228.5"></path><path id="kity_path_25266" fill="none" stroke="gray"></path></g><path id="node_outline1582" fill="none" stroke="none" d="M800.5,13201.5h382a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-382a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1582" fill="black"><text id="kity_text_11649" text-rendering="inherit" font-size="12" dy=".8em" y="13202.700000047684" x="800.5">1.我看了下，代码里面没有写什么线程是核心线程，什么不是核心线程。</text><text id="kity_text_11650" text-rendering="inherit" font-size="12" dy=".8em" y="13220.700000047684" x="800.5">线程池只是销毁了超出核心线程数目的空闲线程而已</text><text id="kity_text_11651" text-rendering="inherit" font-size="12" dy=".8em" y="13238.700000047684" x="800.5">2.并没有核心线程一定不会销毁。</text></g></g><g id="minder_node1588"><g id="node_expander1594" style="cursor: pointer;"><path id="kity_path_25304" fill="white" stroke="gray" d="M608.5,13391.5A6,6,0,1,1,596.5,13391.5A6,6,0,1,1,608.5,13391.5"></path><path id="kity_path_25305" fill="none" stroke="gray" d="M598,13391.5L607,13391.5"></path></g><path id="node_outline1595" fill="none" stroke="none" d="M613.5,13382.5h108a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-108a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1595" fill="black"><text id="kity_text_11687" text-rendering="inherit" font-size="12" dy=".8em" y="13383.700000047684" x="613.5">场景&amp;问题优化排查</text></g></g><g id="minder_node1589"><g id="node_expander1585" style="cursor: pointer;"><path id="kity_path_25277" fill="white" stroke="gray" d="M742.5,13272.5A6,6,0,1,1,730.5,13272.5A6,6,0,1,1,742.5,13272.5"></path><path id="kity_path_25278" fill="none" stroke="gray" d="M732,13272.5L741,13272.5"></path></g><path id="node_outline1586" fill="none" stroke="none" d="M747.5,13263.5h241a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-241a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1586" fill="black"><text id="kity_text_11659" text-rendering="inherit" font-size="12" dy=".8em" y="13264.700000047684" x="747.5">当你提交任务，你线程队列已满，会发生什么</text></g></g><g id="minder_node1590"><g id="node_expander1584" style="cursor: pointer;" display="none"><path id="kity_path_25274" fill="white" stroke="gray" d="M1009.5,13272.5A6,6,0,1,1,997.5,13272.5A6,6,0,1,1,1009.5,13272.5"></path><path id="kity_path_25275" fill="none" stroke="gray"></path></g><path id="node_outline1585" fill="none" stroke="none" d="M1014.5,13263.5h275a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-275a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1585" fill="black"><text id="kity_text_11657" text-rendering="inherit" font-size="12" dy=".8em" y="13264.700000047684" x="1014.5">1.看你的拒绝策略，默认情况是会抛异常，抛弃任务</text></g></g><g id="minder_node1591"><g id="node_expander1587" style="cursor: pointer;"><path id="kity_path_25283" fill="white" stroke="gray" d="M742.5,13307.5A6,6,0,1,1,730.5,13307.5A6,6,0,1,1,742.5,13307.5"></path><path id="kity_path_25284" fill="none" stroke="gray" d="M732,13307.5L741,13307.5"></path></g><path id="node_outline1588" fill="none" stroke="none" d="M747.5,13298.5h381a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-381a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1588" fill="black"><text id="kity_text_11664" text-rendering="inherit" font-size="12" dy=".8em" y="13299.700000047684" x="747.5">如果达到核心线程数但是没达到最大线程数然后队列已满&#xa0; 这时候怎么办</text></g></g><g id="minder_node1592"><g id="node_expander1586" style="cursor: pointer;" display="none"><path id="kity_path_25280" fill="white" stroke="gray" d="M1149.5,13307.5A6,6,0,1,1,1137.5,13307.5A6,6,0,1,1,1149.5,13307.5"></path><path id="kity_path_25281" fill="none" stroke="gray"></path></g><path id="node_outline1587" fill="none" stroke="none" d="M1154.5,13289.5h877a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-877a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1587" fill="black"><text id="kity_text_11661" text-rendering="inherit" font-size="12" dy=".8em" y="13290.700000047684" x="1154.5">1.</text><text id="kity_text_11662" text-rendering="inherit" font-size="12" dy=".8em" y="13308.700000047684" x="1154.5">首先会验证一下工作线程数，为了保证这个任务会执行，会通过addWorker()创建一个临时工作线程，创建失败就拒绝，因为创建失败说明工作线程数等于最大线程数</text></g></g><g id="minder_node1593"><g id="node_expander1589" style="cursor: pointer;"><path id="kity_path_25289" fill="white" stroke="gray" d="M742.5,13342.5A6,6,0,1,1,730.5,13342.5A6,6,0,1,1,742.5,13342.5"></path><path id="kity_path_25290" fill="none" stroke="gray" d="M732,13342.5L741,13342.5"></path></g><path id="node_outline1590" fill="none" stroke="none" d="M747.5,13333.5h241a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-241a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1590" fill="black"><text id="kity_text_11668" text-rendering="inherit" font-size="12" dy=".8em" y="13334.700000047684" x="747.5">核心线程在创建后维持，线程池是怎么维持的</text></g></g><g id="minder_node1594"><g id="node_expander1588" style="cursor: pointer;" display="none"><path id="kity_path_25286" fill="white" stroke="gray" d="M1009.5,13342.5A6,6,0,1,1,997.5,13342.5A6,6,0,1,1,1009.5,13342.5"></path><path id="kity_path_25287" fill="none" stroke="gray"></path></g><path id="node_outline1589" fill="none" stroke="none" d="M1014.5,13333.5h584a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-584a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1589" fill="black"><text id="kity_text_11666" text-rendering="inherit" font-size="12" dy=".8em" y="13334.700000047684" x="1014.5">1.阻塞，将线程封装成工作线程worker,并放入工作线程组中，然后这个worker反复从阻塞队列中拿任务去执行</text></g></g><g id="minder_node1595"><g id="node_expander1591" style="cursor: pointer;"><path id="kity_path_25295" fill="white" stroke="gray" d="M742.5,13404.5A6,6,0,1,1,730.5,13404.5A6,6,0,1,1,742.5,13404.5"></path><path id="kity_path_25296" fill="none" stroke="gray" d="M732,13404.5L741,13404.5"></path></g><path id="node_outline1592" fill="none" stroke="none" d="M747.5,13395.5h218a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-218a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1592" fill="black"><text id="kity_text_11676" text-rendering="inherit" font-size="12" dy=".8em" y="13396.700000047684" x="747.5">Executors创建线程池出现OOM的情况？</text></g></g><g id="minder_node1596"><g id="node_expander1590" style="cursor: pointer;" display="none"><path id="kity_path_25292" fill="white" stroke="gray" d="M986.5,13404.5A6,6,0,1,1,974.5,13404.5A6,6,0,1,1,986.5,13404.5"></path><path id="kity_path_25293" fill="none" stroke="gray"></path></g><path id="node_outline1591" fill="none" stroke="none" d="M991.5,13359.5h890a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-890a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1591" fill="black"><text id="kity_text_11670" text-rendering="inherit" font-size="12" dy=".8em" y="13360.700000047684" x="991.5">1.FixedThreadPool和SingleThreadExecutor =&gt;因为LinkedBlockingQueue是长度为Integer.MAX_VALUE的队列，可以认为是无界队列&#xa0;</text><text id="kity_text_11671" text-rendering="inherit" font-size="12" dy=".8em" y="13378.700000047684" x="991.5">允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而引起OOM异常</text><text id="kity_text_11672" text-rendering="inherit" font-size="12" dy=".8em" y="13396.700000047684" x="991.5">2.CachedThreadPool =&gt; 允许创建的线程数为Integer.MAX_VALUE，可能会创建大量的线程，从而引起OOM异常</text><text id="kity_text_11673" text-rendering="inherit" font-size="12" dy=".8em" y="13414.700000047684" x="991.5">3.newFixedThreadPool中创建的LinkedBlockingQueue，是无界队列。不断向队列添加任务就会导致内存溢出</text><text id="kity_text_11674" text-rendering="inherit" font-size="12" dy=".8em" y="13432.700000047684" x="991.5">4.OOM的提示消息为执行垃圾收集的时间比例太大, 有效的运算量太小. 默认情况下, 如果GC花费的时间超过 98%, 并且GC回收的内存少于 2%, JVM就会抛出这个错误。</text></g></g><g id="minder_node1597"><g id="node_expander1593" style="cursor: pointer;"><path id="kity_path_25301" fill="white" stroke="gray" d="M742.5,13511.5A6,6,0,1,1,730.5,13511.5A6,6,0,1,1,742.5,13511.5"></path><path id="kity_path_25302" fill="none" stroke="gray" d="M732,13511.5L741,13511.5"></path></g><path id="node_outline1594" fill="none" stroke="none" d="M747.5,13502.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1594" fill="black"><text id="kity_text_11685" text-rendering="inherit" font-size="12" dy=".8em" y="13503.700000047684" x="747.5">这么配置线程池参数？</text></g></g><g id="minder_node1598"><g id="node_expander1592" style="cursor: pointer;" display="none"><path id="kity_path_25298" fill="white" stroke="gray" d="M889.5,13511.5A6,6,0,1,1,877.5,13511.5A6,6,0,1,1,889.5,13511.5"></path><path id="kity_path_25299" fill="none" stroke="gray"></path></g><path id="node_outline1593" fill="none" stroke="none" d="M894.5,13457.5h1200a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1200a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1593" fill="black"><text id="kity_text_11678" text-rendering="inherit" font-size="12" dy=".8em" y="13458.700000047684" x="894.5">1.首先分析线程池的任务特性</text><text id="kity_text_11679" text-rendering="inherit" font-size="12" dy=".8em" y="13476.700000047684" x="894.5">任务的性质：CPU密集型任务配置尽可能少的线程数量，如配置Ncpu+1个线程的线程池。IO密集型任务，IO密集型任务则由于需要等待IO操作，线程并不是一直在执行任务，则配置尽可能多的线程，如2xNcpu。混合型任务。</text><text id="kity_text_11680" text-rendering="inherit" font-size="12" dy=".8em" y="13494.700000047684" x="894.5">任务的优先级：使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行</text><text id="kity_text_11681" text-rendering="inherit" font-size="12" dy=".8em" y="13512.700000047684" x="894.5">任务的执行时间：可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。</text><text id="kity_text_11682" text-rendering="inherit" font-size="12" dy=".8em" y="13530.700000047684" x="894.5">任务的依赖性：是否依赖其他系统资源，如数据库连接。如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。</text><text id="kity_text_11683" text-rendering="inherit" font-size="12" dy=".8em" y="13548.700000047684" x="894.5">通过 ThreadPoolExecutor创建线程池 阻塞队列最好是使用有界队列，如果采用无界队列的话，一旦任务积压在阻塞队列中的话就会占用过多的内存资源，甚至会使得系统崩溃。</text></g></g><g id="minder_node1599"><g id="node_expander1608" style="cursor: pointer;"><path id="kity_path_25346" fill="white" stroke="gray" d="M608.5,13792.5A6,6,0,1,1,596.5,13792.5A6,6,0,1,1,608.5,13792.5"></path><path id="kity_path_25347" fill="none" stroke="gray" d="M598,13792.5L607,13792.5"></path></g><path id="node_outline1609" fill="none" stroke="none" d="M613.5,13783.5h111a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-111a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1609" fill="black"><text id="kity_text_11730" text-rendering="inherit" font-size="12" dy=".8em" y="13784.700000047684" x="613.5">Future&amp;FutureTask</text></g></g><g id="minder_node1600"><g id="node_expander1596" style="cursor: pointer;"><path id="kity_path_25310" fill="white" stroke="gray" d="M745.5,13618.5A6,6,0,1,1,733.5,13618.5A6,6,0,1,1,745.5,13618.5"></path><path id="kity_path_25311" fill="none" stroke="gray" d="M735,13618.5L744,13618.5"></path></g><path id="node_outline1597" fill="none" stroke="none" d="M750.5,13609.5h166a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-166a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1597" fill="black"><text id="kity_text_11695" text-rendering="inherit" font-size="12" dy=".8em" y="13610.700000047684" x="750.5">说说Future?FutureTask了解？</text></g></g><g id="minder_node1601"><g id="node_expander1595" style="cursor: pointer;" display="none"><path id="kity_path_25307" fill="white" stroke="gray" d="M937.5,13618.5A6,6,0,1,1,925.5,13618.5A6,6,0,1,1,937.5,13618.5"></path><path id="kity_path_25308" fill="none" stroke="gray"></path></g><path id="node_outline1596" fill="none" stroke="none" d="M942.5,13573.5h1079a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1079a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1596" fill="black"><text id="kity_text_11689" text-rendering="inherit" font-size="12" dy=".8em" y="13574.700000047684" x="942.5">1.future</text><text id="kity_text_11690" text-rendering="inherit" font-size="12" dy=".8em" y="13592.700000047684" x="942.5">&#xa0;就是说使用类似于runable的Callable，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值。Callable用于产生结果，Future 用于获取结果。</text><text id="kity_text_11691" text-rendering="inherit" font-size="12" dy=".8em" y="13610.700000047684" x="942.5">2.futuretask</text><text id="kity_text_11692" text-rendering="inherit" font-size="12" dy=".8em" y="13628.700000047684" x="942.5">FutureTask实现了Future接口，FutureTask提供了启动和取消异步任务，查询异步任务是否计算结束以及获取最终的异步任务的结果.</text><text id="kity_text_11693" text-rendering="inherit" font-size="12" dy=".8em" y="13646.700000047684" x="942.5">FutureTask实现了RunnableFuture接口，同时具有Runnable、Future的能力，即既可以作为Future得到Callable的返回值，又可以作为一个Runnable。</text></g></g><g id="minder_node1602"><g id="node_expander1599" style="cursor: pointer;"><path id="kity_path_25319" fill="white" stroke="gray" d="M745.5,13698.5A6,6,0,1,1,733.5,13698.5A6,6,0,1,1,745.5,13698.5"></path><path id="kity_path_25320" fill="none" stroke="gray" d="M735,13698.5L744,13698.5"></path></g><path id="node_outline1600" fill="none" stroke="none" d="M750.5,13689.5h103a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-103a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1600" fill="black"><text id="kity_text_11704" text-rendering="inherit" font-size="12" dy=".8em" y="13690.700000047684" x="750.5">Future.get()实现？</text></g></g><g id="minder_node1603"><g id="node_expander1598" style="cursor: pointer;"><path id="kity_path_25316" fill="white" stroke="gray" d="M874.5,13698.5A6,6,0,1,1,862.5,13698.5A6,6,0,1,1,874.5,13698.5"></path><path id="kity_path_25317" fill="none" stroke="gray" d="M864,13698.5L873,13698.5"></path></g><path id="node_outline1599" fill="none" stroke="none" d="M879.5,13671.5h1042a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1042a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1599" fill="black"><text id="kity_text_11700" text-rendering="inherit" font-size="12" dy=".8em" y="13672.700000047684" x="879.5">1.get有最多等待时间模式，和无线等待时间模式</text><text id="kity_text_11701" text-rendering="inherit" font-size="12" dy=".8em" y="13690.700000047684" x="879.5">通过get()方法来获取异步任务的结果，但是会阻塞当前线程直至异步任务执行结束。一旦任务执行结束，任务不能重新启动或取消，除非调用runAndReset()方法。</text><text id="kity_text_11702" text-rendering="inherit" font-size="12" dy=".8em" y="13708.700000047684" x="879.5">当FutureTask处于未启动或已启动状态时，执行FutureTask.get()方法将导致调用线程阻塞。如果FutureTask处于已完成状态，调用FutureTask.get()方法将导致调用线程立即返回结果或者抛出异常</text></g></g><g id="minder_node1604"><g id="node_expander1597" style="cursor: pointer;" display="none"><path id="kity_path_25313" fill="white" stroke="gray" d="M1942.5,13698.5A6,6,0,1,1,1930.5,13698.5A6,6,0,1,1,1942.5,13698.5"></path><path id="kity_path_25314" fill="none" stroke="gray"></path></g><path id="node_outline1598" fill="none" stroke="none" d="M1947.5,13680.5h333a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1598" fill="black"><text id="kity_text_11697" text-rendering="inherit" font-size="12" dy=".8em" y="13681.700000047684" x="1947.5">https://juejin.cn/post/6844903710133321736#heading-6</text><text id="kity_text_11698" text-rendering="inherit" font-size="12" dy=".8em" y="13699.700000047684" x="1947.5">https://juejin.cn/post/6844904177039212557#heading-11</text></g></g><g id="minder_node1605"><g id="node_expander1602" style="cursor: pointer;"><path id="kity_path_25328" fill="white" stroke="gray" d="M745.5,13760.5A6,6,0,1,1,733.5,13760.5A6,6,0,1,1,745.5,13760.5"></path><path id="kity_path_25329" fill="none" stroke="gray" d="M735,13760.5L744,13760.5"></path></g><path id="node_outline1603" fill="none" stroke="none" d="M750.5,13751.5h149a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-149a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1603" fill="black"><text id="kity_text_11712" text-rendering="inherit" font-size="12" dy=".8em" y="13752.700000047684" x="750.5">说说FutureTask有哪些状态</text></g></g><g id="minder_node1606"><g id="node_expander1601" style="cursor: pointer;"><path id="kity_path_25325" fill="white" stroke="gray" d="M920.5,13760.5A6,6,0,1,1,908.5,13760.5A6,6,0,1,1,920.5,13760.5"></path><path id="kity_path_25326" fill="none" stroke="gray" d="M910,13760.5L919,13760.5M914.5,13756L914.5,13765"></path></g><path id="node_outline1602" fill="none" stroke="none" d="M925.5,13733.5h503a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-503a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1602" fill="black"><text id="kity_text_11708" text-rendering="inherit" font-size="12" dy=".8em" y="13734.700000047684" x="925.5">1.未启动。FutureTask.run()方法还没有被执行之前，FutureTask处于未启动状态。</text><text id="kity_text_11709" text-rendering="inherit" font-size="12" dy=".8em" y="13752.700000047684" x="925.5">2.已启动。FutureTask.run()方法被执行的过程中，FutureTask处于已启动状态。</text><text id="kity_text_11710" text-rendering="inherit" font-size="12" dy=".8em" y="13770.700000047684" x="925.5">3.已完成。FutureTask.run()方法执行结束。已完成又分为 正常结束，取消而结束，异常而结束</text></g></g><g id="minder_node1607" display="none"><g id="node_expander1600" style="cursor: pointer;" display="none"><path id="kity_path_25322" fill="white" stroke="gray" d="M1449.5,13760.5A6,6,0,1,1,1437.5,13760.5A6,6,0,1,1,1449.5,13760.5"></path><path id="kity_path_25323" fill="none" stroke="gray"></path></g><path id="node_outline1601" fill="none" stroke="none" d="M1391.5,13659.5h200a5,5,0,0,1,5,5v100a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-100a5,5,0,0,1,5,-5z"></path><g id="node_text1601" fill="black"><text id="kity_text_11706" text-rendering="inherit" font-size="12" dy=".8em" y="13752.700000047684" x="1449.5">futuretask状态</text></g><image id="kity_image_17069" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210330150800.png" x="1391.5" y="13662.5" width="200" height="87"></image></g><g id="minder_node1608"><g id="node_expander1605" style="cursor: pointer;"><path id="kity_path_25337" fill="white" stroke="gray" d="M745.5,13863.5A6,6,0,1,1,733.5,13863.5A6,6,0,1,1,745.5,13863.5"></path><path id="kity_path_25338" fill="none" stroke="gray" d="M735,13863.5L744,13863.5"></path></g><path id="node_outline1606" fill="none" stroke="none" d="M750.5,13854.5h172a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-172a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1606" fill="black"><text id="kity_text_11722" text-rendering="inherit" font-size="12" dy=".8em" y="13855.700000047684" x="750.5">知道FutureTask的cancel方法吗</text></g></g><g id="minder_node1609"><g id="node_expander1604" style="cursor: pointer;"><path id="kity_path_25334" fill="white" stroke="gray" d="M943.5,13863.5A6,6,0,1,1,931.5,13863.5A6,6,0,1,1,943.5,13863.5"></path><path id="kity_path_25335" fill="none" stroke="gray" d="M933,13863.5L942,13863.5"></path></g><path id="node_outline1605" fill="none" stroke="none" d="M948.5,13818.5h730a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-730a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1605" fill="black"><text id="kity_text_11716" text-rendering="inherit" font-size="12" dy=".8em" y="13819.700000047684" x="948.5">1.cancel方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。</text><text id="kity_text_11717" text-rendering="inherit" font-size="12" dy=".8em" y="13837.700000047684" x="948.5">参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。</text><text id="kity_text_11718" text-rendering="inherit" font-size="12" dy=".8em" y="13855.700000047684" x="948.5">如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；</text><text id="kity_text_11719" text-rendering="inherit" font-size="12" dy=".8em" y="13873.700000047684" x="948.5">如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；</text><text id="kity_text_11720" text-rendering="inherit" font-size="12" dy=".8em" y="13891.700000047684" x="948.5">如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</text></g></g><g id="minder_node1610"><g id="node_expander1603" style="cursor: pointer;" display="none"><path id="kity_path_25331" fill="white" stroke="gray" d="M1699.5,13864A6,6,0,1,1,1687.5,13864A6,6,0,1,1,1699.5,13864"></path><path id="kity_path_25332" fill="none" stroke="gray"></path></g><path id="node_outline1604" fill="none" stroke="none" d="M1704.5,13795.5h200a5,5,0,0,1,5,5v127a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-127a5,5,0,0,1,5,-5z"></path><g id="node_text1604" fill="black"><text id="kity_text_11714" text-rendering="inherit" font-size="12" dy=".8em" y="13915.700000047684" x="1779.5">分支主题</text></g><image id="kity_image_17070" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210330150945.png" x="1704.5" y="13798.5" width="200" height="114"></image></g><g id="minder_node1611"><g id="node_expander1607" style="cursor: pointer;"><path id="kity_path_25343" fill="white" stroke="gray" d="M745.5,13967.5A6,6,0,1,1,733.5,13967.5A6,6,0,1,1,745.5,13967.5"></path><path id="kity_path_25344" fill="none" stroke="gray" d="M735,13967.5L744,13967.5"></path></g><path id="node_outline1608" fill="none" stroke="none" d="M750.5,13958.5h124a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-124a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1608" fill="black"><text id="kity_text_11728" text-rendering="inherit" font-size="12" dy=".8em" y="13959.700000047684" x="750.5">说说FutureTask的场景</text></g></g><g id="minder_node1612"><g id="node_expander1606" style="cursor: pointer;" display="none"><path id="kity_path_25340" fill="white" stroke="gray" d="M895.5,13967.5A6,6,0,1,1,883.5,13967.5A6,6,0,1,1,895.5,13967.5"></path><path id="kity_path_25341" fill="none" stroke="gray"></path></g><path id="node_outline1607" fill="none" stroke="none" d="M900.5,13940.5h612a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-612a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1607" fill="black"><text id="kity_text_11724" text-rendering="inherit" font-size="12" dy=".8em" y="13941.700000047684" x="900.5">1.当一个线程需要等待另一个线程把某个任务执行完后它才能继续执行，此时可以使用FutureTask。</text><text id="kity_text_11725" text-rendering="inherit" font-size="12" dy=".8em" y="13959.700000047684" x="900.5">假设有多个线程执行若干任务，每个任务最多只能被执行一次。</text><text id="kity_text_11726" text-rendering="inherit" font-size="12" dy=".8em" y="13977.700000047684" x="900.5">当多个线程试图执行同一个任务时，只允许一个线程执行任务，其他线程需要等待这个任务执行完后才能继续执行。</text></g></g><g id="minder_node1613"><g id="node_expander1616" style="cursor: pointer;"><path id="kity_path_25370" fill="white" stroke="gray" d="M608.5,14149.5A6,6,0,1,1,596.5,14149.5A6,6,0,1,1,608.5,14149.5"></path><path id="kity_path_25371" fill="none" stroke="gray" d="M598,14149.5L607,14149.5"></path></g><path id="node_outline1617" fill="none" stroke="none" d="M613.5,14140.5h53a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-53a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1617" fill="black"><text id="kity_text_11757" text-rendering="inherit" font-size="12" dy=".8em" y="14141.700000047684" x="613.5">Fork/Join</text></g></g><g id="minder_node1614"><g id="node_expander1611" style="cursor: pointer;"><path id="kity_path_25355" fill="white" stroke="gray" d="M687.5,14056.5A6,6,0,1,1,675.5,14056.5A6,6,0,1,1,687.5,14056.5"></path><path id="kity_path_25356" fill="none" stroke="gray" d="M677,14056.5L686,14056.5"></path></g><path id="node_outline1612" fill="none" stroke="none" d="M692.5,14047.5h309a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-309a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1612" fill="black"><text id="kity_text_11742" text-rendering="inherit" font-size="12" dy=".8em" y="14048.700000047684" x="692.5">知道ForkJoinPool?做什么的？和一般线程池有什么区别？</text></g></g><g id="minder_node1615"><g id="node_expander1610" style="cursor: pointer;"><path id="kity_path_25352" fill="white" stroke="gray" d="M1022.5,14056.5A6,6,0,1,1,1010.5,14056.5A6,6,0,1,1,1022.5,14056.5"></path><path id="kity_path_25353" fill="none" stroke="gray" d="M1012,14056.5L1021,14056.5M1016.5,14052L1016.5,14061"></path></g><path id="node_outline1611" fill="none" stroke="none" d="M1027.5,14002.5h921a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-921a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1611" fill="black"><text id="kity_text_11735" text-rendering="inherit" font-size="12" dy=".8em" y="14003.700000047684" x="1027.5">1.ForkJoinPool是用于执行ForkJoinTask任务的执行（线程）池。</text><text id="kity_text_11736" text-rendering="inherit" font-size="12" dy=".8em" y="14021.700000047684" x="1027.5">一般每个任务都是交由线程池每个线程来处理的，当一个非常耗时的任务交由一个线程来完成，而其他线程处于空闲状态时就显得不太合理。</text><text id="kity_text_11737" text-rendering="inherit" font-size="12" dy=".8em" y="14039.700000047684" x="1027.5">ForkJoinPool又叫分而治之，通俗来讲就是帮我们把一个任务分成许多小任务给不同的线程执行，然后通过join将多个线程处理的结果进行汇总返回。</text><text id="kity_text_11738" text-rendering="inherit" font-size="12" dy=".8em" y="14057.700000047684" x="1027.5">2.</text><text id="kity_text_11739" text-rendering="inherit" font-size="12" dy=".8em" y="14075.700000047684" x="1027.5">ForkJoinPool与传统线程池最显著的区别就是它维护了一个工作队列数组（volatile WorkQueue[] workQueues，ForkJoinPool中的每个工作线程都维护着一个工作队列）。</text><text id="kity_text_11740" text-rendering="inherit" font-size="12" dy=".8em" y="14093.700000047684" x="1027.5">每个线程有自己的工作队列，它是一个双端队列，自己从队列头存取任务，其它线程从尾部窃取任务；</text></g></g><g id="minder_node1616" display="none"><g id="node_expander1609" style="cursor: pointer;" display="none"><path id="kity_path_25349" fill="white" stroke="gray" d="M1969.5,14056.5A6,6,0,1,1,1957.5,14056.5A6,6,0,1,1,1969.5,14056.5"></path><path id="kity_path_25350" fill="none" stroke="gray"></path></g><path id="node_outline1610" fill="none" stroke="none" d="M1969.5,14038.5h346a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-346a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1610" fill="black"><text id="kity_text_11732" text-rendering="inherit" font-size="12" dy=".8em" y="14039.700000047684" x="1969.5">https://blog.csdn.net/qq_25224749/article/details/81146556</text><text id="kity_text_11733" text-rendering="inherit" font-size="12" dy=".8em" y="14057.700000047684" x="1969.5">https://juejin.cn/post/6844903870896799751#heading-2</text></g></g><g id="minder_node1617"><g id="node_expander1613" style="cursor: pointer;"><path id="kity_path_25361" fill="white" stroke="gray" d="M687.5,14172.5A6,6,0,1,1,675.5,14172.5A6,6,0,1,1,687.5,14172.5"></path><path id="kity_path_25362" fill="none" stroke="gray" d="M677,14172.5L686,14172.5"></path></g><path id="node_outline1614" fill="none" stroke="none" d="M692.5,14163.5h72a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-72a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1614" fill="black"><text id="kity_text_11751" text-rendering="inherit" font-size="12" dy=".8em" y="14164.700000047684" x="692.5">了解原理吗？</text></g></g><g id="minder_node1618"><g id="node_expander1612" style="cursor: pointer;" display="none"><path id="kity_path_25358" fill="white" stroke="gray" d="M785.5,14172.5A6,6,0,1,1,773.5,14172.5A6,6,0,1,1,785.5,14172.5"></path><path id="kity_path_25359" fill="none" stroke="gray"></path></g><path id="node_outline1613" fill="none" stroke="none" d="M790.5,14118.5h1653a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1653a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1613" fill="black"><text id="kity_text_11744" text-rendering="inherit" font-size="12" dy=".8em" y="14119.700000047684" x="790.5">1.</text><text id="kity_text_11745" text-rendering="inherit" font-size="12" dy=".8em" y="14137.700000047684" x="790.5">(1).任务分割：首先Fork/Join框架需要把大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割</text><text id="kity_text_11746" text-rendering="inherit" font-size="12" dy=".8em" y="14155.700000047684" x="790.5">(2).执行任务并合并结果：分割的子任务分别放到双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，启动一个线程从队列里取数据，然后合并这些数据。</text><text id="kity_text_11747" text-rendering="inherit" font-size="12" dy=".8em" y="14173.700000047684" x="790.5">这个双端队列就是工作队列WorkQueue&#xa0; ForkJoinTask存放在这里。当工作线程在处理自己的工作队列时，会从队列首取任务来执行（FIFO）；如果是窃取其他队列的任务时，窃取的任务位于所属任务队列的队尾（LIFO）。</text><text id="kity_text_11748" text-rendering="inherit" font-size="12" dy=".8em" y="14191.700000047684" x="790.5">2.</text><text id="kity_text_11749" text-rendering="inherit" font-size="12" dy=".8em" y="14209.700000047684" x="790.5">ForkJoinTask有两个核心方法——fork(),把任务推入当前工作线程的工作队列里。和join(),等待处理任务的线程处理完毕，获得返回值，并且它不会组塞。，有三个重要子类——RecursiveAction[无返回值的ForkJoinTask的子类]、RecursiveTask[有返回值的ForkJoinTask子类]和CountedCompleter[异步编排]；</text></g></g><g id="minder_node1619"><g id="node_expander1615" style="cursor: pointer;"><path id="kity_path_25367" fill="white" stroke="gray" d="M687.5,14243.5A6,6,0,1,1,675.5,14243.5A6,6,0,1,1,687.5,14243.5"></path><path id="kity_path_25368" fill="none" stroke="gray" d="M677,14243.5L686,14243.5"></path></g><path id="node_outline1616" fill="none" stroke="none" d="M692.5,14234.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1616" fill="black"><text id="kity_text_11755" text-rendering="inherit" font-size="12" dy=".8em" y="14235.700000047684" x="692.5">使用场景呢？真实用过吗？</text></g></g><g id="minder_node1620"><g id="node_expander1614" style="cursor: pointer;" display="none"><path id="kity_path_25364" fill="white" stroke="gray" d="M858.5,14243.5A6,6,0,1,1,846.5,14243.5A6,6,0,1,1,858.5,14243.5"></path><path id="kity_path_25365" fill="none" stroke="gray"></path></g><path id="node_outline1615" fill="none" stroke="none" d="M863.5,14234.5h1066a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1066a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1615" fill="black"><text id="kity_text_11753" text-rendering="inherit" font-size="12" dy=".8em" y="14235.700000047684" x="863.5">1.就是一个大问题可以拆成一个个子问题，并且不互相影响，就可以使用，比如前端需要一个业务订单，涉及到后端很多组件查询，就可以拆开方便来查询，而不是之前一样，一个查询完成再查询一个，</text></g></g><g id="minder_node1621"><g id="node_expander1644" style="cursor: pointer;"><path id="kity_path_25454" fill="white" stroke="gray" d="M544.5,14465.5A6,6,0,1,1,532.5,14465.5A6,6,0,1,1,544.5,14465.5"></path><path id="kity_path_25455" fill="none" stroke="gray" d="M534,14465.5L543,14465.5"></path></g><path id="node_outline1645" fill="none" stroke="none" d="M549.5,14456.5h39a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-39a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1645" fill="black"><text id="kity_text_11835" text-rendering="inherit" font-size="12" dy=".8em" y="14457.700000047684" x="549.5">atomic</text></g></g><g id="minder_node1622"><g id="node_expander1622" style="cursor: pointer;"><path id="kity_path_25388" fill="white" stroke="gray" d="M609.5,14290.5A6,6,0,1,1,597.5,14290.5A6,6,0,1,1,609.5,14290.5"></path><path id="kity_path_25389" fill="none" stroke="gray" d="M599,14290.5L608,14290.5"></path></g><path id="node_outline1623" fill="none" stroke="none" d="M614.5,14281.5h38a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-38a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1623" fill="black"><text id="kity_text_11771" text-rendering="inherit" font-size="12" dy=".8em" y="14282.700000047684" x="614.5">原子类</text></g></g><g id="minder_node1623"><g id="node_expander1619" style="cursor: pointer;"><path id="kity_path_25379" fill="white" stroke="gray" d="M673.5,14268.5A6,6,0,1,1,661.5,14268.5A6,6,0,1,1,673.5,14268.5"></path><path id="kity_path_25380" fill="none" stroke="gray" d="M663,14268.5L672,14268.5"></path></g><path id="node_outline1620" fill="none" stroke="none" d="M678.5,14259.5h134a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-134a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1620" fill="black"><text id="kity_text_11763" text-rendering="inherit" font-size="12" dy=".8em" y="14260.700000047684" x="678.5">你知道有哪些原子操作类</text></g></g><g id="minder_node1624"><g id="node_expander1618" style="cursor: pointer;" display="none"><path id="kity_path_25376" fill="white" stroke="gray" d="M833.5,14268.5A6,6,0,1,1,821.5,14268.5A6,6,0,1,1,833.5,14268.5"></path><path id="kity_path_25377" fill="none" stroke="gray"></path></g><path id="node_outline1619" fill="none" stroke="none" d="M838.5,14259.5h509a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-509a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1619" fill="black"><text id="kity_text_11761" text-rendering="inherit" font-size="12" dy=".8em" y="14260.700000047684" x="838.5">1.AtomicInteger，AtomicBoolean，AtomicLong，AtomicIntegerArray，AtomicReference</text></g></g><g id="minder_node1625"><g id="node_expander1621" style="cursor: pointer;"><path id="kity_path_25385" fill="white" stroke="gray" d="M673.5,14312.5A6,6,0,1,1,661.5,14312.5A6,6,0,1,1,673.5,14312.5"></path><path id="kity_path_25386" fill="none" stroke="gray" d="M663,14312.5L672,14312.5"></path></g><path id="node_outline1622" fill="none" stroke="none" d="M678.5,14303.5h181a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-181a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1622" fill="black"><text id="kity_text_11769" text-rendering="inherit" font-size="12" dy=".8em" y="14304.700000047684" x="678.5">知道这些原子操作类可以做什么吗</text></g></g><g id="minder_node1626"><g id="node_expander1620" style="cursor: pointer;" display="none"><path id="kity_path_25382" fill="white" stroke="gray" d="M880.5,14312.5A6,6,0,1,1,868.5,14312.5A6,6,0,1,1,880.5,14312.5"></path><path id="kity_path_25383" fill="none" stroke="gray"></path></g><path id="node_outline1621" fill="none" stroke="none" d="M885.5,14285.5h678a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-678a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1621" fill="black"><text id="kity_text_11765" text-rendering="inherit" font-size="12" dy=".8em" y="14286.700000047684" x="885.5">1.在J.U.C下的atomic包的原子操作类能保证线程安全的类去更新基本类型变量，数组元素，引用类型以及更新对象中的字段类型</text><text id="kity_text_11766" text-rendering="inherit" font-size="12" dy=".8em" y="14304.700000047684" x="885.5">atomic包下的这些类都是采用的是乐观锁策略去原子更新数据，底层使用unsafe类的cas操作</text><text id="kity_text_11767" text-rendering="inherit" font-size="12" dy=".8em" y="14322.700000047684" x="885.5">2.比如i++，并发出现线程安全问题，而原子操作类atomicInteger就可以实现高效安全自增</text></g></g><g id="minder_node1627"><g id="node_expander1628" style="cursor: pointer;"><path id="kity_path_25406" fill="white" stroke="gray" d="M609.5,14383.5A6,6,0,1,1,597.5,14383.5A6,6,0,1,1,609.5,14383.5"></path><path id="kity_path_25407" fill="none" stroke="gray" d="M599,14383.5L608,14383.5"></path></g><path id="node_outline1629" fill="none" stroke="none" d="M614.5,14374.5h84a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-84a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1629" fill="black"><text id="kity_text_11784" text-rendering="inherit" font-size="12" dy=".8em" y="14375.700000047684" x="614.5">AtomicInteger</text></g></g><g id="minder_node1628"><g id="node_expander1625" style="cursor: pointer;"><path id="kity_path_25397" fill="white" stroke="gray" d="M719.5,14366.5A6,6,0,1,1,707.5,14366.5A6,6,0,1,1,719.5,14366.5"></path><path id="kity_path_25398" fill="none" stroke="gray" d="M709,14366.5L718,14366.5"></path></g><path id="node_outline1626" fill="none" stroke="none" d="M724.5,14357.5h182a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-182a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1626" fill="black"><text id="kity_text_11778" text-rendering="inherit" font-size="12" dy=".8em" y="14358.700000047684" x="724.5">了解AtomicInteger 的底层实现吗</text></g></g><g id="minder_node1629"><g id="node_expander1624" style="cursor: pointer;"><path id="kity_path_25394" fill="white" stroke="gray" d="M927.5,14366.5A6,6,0,1,1,915.5,14366.5A6,6,0,1,1,927.5,14366.5"></path><path id="kity_path_25395" fill="none" stroke="gray" d="M917,14366.5L926,14366.5M921.5,14362L921.5,14371"></path></g><path id="node_outline1625" fill="none" stroke="none" d="M932.5,14348.5h802a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-802a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1625" fill="black"><text id="kity_text_11775" text-rendering="inherit" font-size="12" dy=".8em" y="14349.700000047684" x="932.5">1.AtomicInteger，他的值是存在一个volatile的int里面。volatile只能保证这个变量的可见性。原子性是通过Unsafe实例的CAS操作+自旋保证原子性。</text><text id="kity_text_11776" text-rendering="inherit" font-size="12" dy=".8em" y="14367.700000047684" x="932.5">在自旋中 通过CAS比较更新value值，如果更新失败，重新获取旧值，然后更新。</text></g></g><g id="minder_node1630" display="none"><g id="node_expander1623" style="cursor: pointer;" display="none"><path id="kity_path_25391" fill="white" stroke="gray" d="M1755.5,14366.5A6,6,0,1,1,1743.5,14366.5A6,6,0,1,1,1755.5,14366.5"></path><path id="kity_path_25392" fill="none" stroke="gray"></path></g><path id="node_outline1624" fill="none" stroke="none" d="M1755.5,14357.5h326a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1624" fill="black"><text id="kity_text_11773" text-rendering="inherit" font-size="12" dy=".8em" y="14358.700000047684" x="1755.5">https://juejin.cn/post/6844903680303431688#heading-0</text></g></g><g id="minder_node1631"><g id="node_expander1627" style="cursor: pointer;"><path id="kity_path_25403" fill="white" stroke="gray" d="M719.5,14401.5A6,6,0,1,1,707.5,14401.5A6,6,0,1,1,719.5,14401.5"></path><path id="kity_path_25404" fill="none" stroke="gray" d="M709,14401.5L718,14401.5"></path></g><path id="node_outline1628" fill="none" stroke="none" d="M724.5,14392.5h155a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-155a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1628" fill="black"><text id="kity_text_11782" text-rendering="inherit" font-size="12" dy=".8em" y="14393.700000047684" x="724.5">AtomicInteger的使用场景？</text></g></g><g id="minder_node1632"><g id="node_expander1626" style="cursor: pointer;" display="none"><path id="kity_path_25400" fill="white" stroke="gray" d="M900.5,14401.5A6,6,0,1,1,888.5,14401.5A6,6,0,1,1,900.5,14401.5"></path><path id="kity_path_25401" fill="none" stroke="gray"></path></g><path id="node_outline1627" fill="none" stroke="none" d="M905.5,14392.5h370a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-370a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1627" fill="black"><text id="kity_text_11780" text-rendering="inherit" font-size="12" dy=".8em" y="14393.700000047684" x="905.5">1.线程安全的对基本变量的操作比如自增，自减，相加，更新等操作，</text></g></g><g id="minder_node1633"><g id="node_expander1643" style="cursor: pointer;"><path id="kity_path_25451" fill="white" stroke="gray" d="M609.5,14640.5A6,6,0,1,1,597.5,14640.5A6,6,0,1,1,609.5,14640.5"></path><path id="kity_path_25452" fill="none" stroke="gray" d="M599,14640.5L608,14640.5"></path></g><path id="node_outline1644" fill="none" stroke="none" d="M614.5,14631.5h64a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-64a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1644" fill="black"><text id="kity_text_11833" text-rendering="inherit" font-size="12" dy=".8em" y="14632.700000047684" x="614.5">LongAdder</text></g></g><g id="minder_node1634"><g id="node_expander1630" style="cursor: pointer;"><path id="kity_path_25412" fill="white" stroke="gray" d="M699.5,14436.5A6,6,0,1,1,687.5,14436.5A6,6,0,1,1,699.5,14436.5"></path><path id="kity_path_25413" fill="none" stroke="gray" d="M689,14436.5L698,14436.5"></path></g><path id="node_outline1631" fill="none" stroke="none" d="M704.5,14427.5h236a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-236a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1631" fill="black"><text id="kity_text_11789" text-rendering="inherit" font-size="12" dy=".8em" y="14428.700000047684" x="704.5">了解LongAdder?和AtomicInteger的区别？</text></g></g><g id="minder_node1635"><g id="node_expander1629" style="cursor: pointer;" display="none"><path id="kity_path_25409" fill="white" stroke="gray" d="M961.5,14436.5A6,6,0,1,1,949.5,14436.5A6,6,0,1,1,961.5,14436.5"></path><path id="kity_path_25410" fill="none" stroke="gray"></path></g><path id="node_outline1630" fill="none" stroke="none" d="M966.5,14418.5h906a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-906a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1630" fill="black"><text id="kity_text_11786" text-rendering="inherit" font-size="12" dy=".8em" y="14419.700000047684" x="966.5">1.AtomicInteger 保证线程安全的是 CAS+自旋适合使用在低并发有同步数据的应用场景。</text><text id="kity_text_11787" text-rendering="inherit" font-size="12" dy=".8em" y="14437.700000047684" x="966.5">LongAddr在这基础上引入了分段锁的概念。当竞争激烈的时候，会将根据当前线程哈希到对于Cell数组上进行修改（多段锁）。通过降低锁粒度（多段锁）增加并发性能。</text></g></g><g id="minder_node1636"><g id="node_expander1632" style="cursor: pointer;"><path id="kity_path_25418" fill="white" stroke="gray" d="M699.5,14489.5A6,6,0,1,1,687.5,14489.5A6,6,0,1,1,699.5,14489.5"></path><path id="kity_path_25419" fill="none" stroke="gray" d="M689,14489.5L698,14489.5"></path></g><path id="node_outline1633" fill="none" stroke="none" d="M704.5,14480.5h112a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-112a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1633" fill="black"><text id="kity_text_11795" text-rendering="inherit" font-size="12" dy=".8em" y="14481.700000047684" x="704.5">LongAdder的结构？</text></g></g><g id="minder_node1637"><g id="node_expander1631" style="cursor: pointer;" display="none"><path id="kity_path_25415" fill="white" stroke="gray" d="M837.5,14489.5A6,6,0,1,1,825.5,14489.5A6,6,0,1,1,837.5,14489.5"></path><path id="kity_path_25416" fill="none" stroke="gray"></path></g><path id="node_outline1632" fill="none" stroke="none" d="M842.5,14462.5h706a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-706a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1632" fill="black"><text id="kity_text_11791" text-rendering="inherit" font-size="12" dy=".8em" y="14463.700000047684" x="842.5">1.两个成员变量来管理value，分别是base和cells，cells是一个数组，其元素是父类的内部类Cell的实现，Cell只记录一个value。</text><text id="kity_text_11792" text-rendering="inherit" font-size="12" dy=".8em" y="14481.700000047684" x="842.5">当LongAdder低并发访问的时候，会直接通过cas的方式更新base的值，存在高并发访问时，会定位到某一个cell，修改cell的value。</text><text id="kity_text_11793" text-rendering="inherit" font-size="12" dy=".8em" y="14499.700000047684" x="842.5">最终，value = base + sum(cells)。</text></g></g><g id="minder_node1638"><g id="node_expander1635" style="cursor: pointer;"><path id="kity_path_25427" fill="white" stroke="gray" d="M699.5,14632.5A6,6,0,1,1,687.5,14632.5A6,6,0,1,1,699.5,14632.5"></path><path id="kity_path_25428" fill="none" stroke="gray" d="M689,14632.5L698,14632.5"></path></g><path id="node_outline1636" fill="none" stroke="none" d="M704.5,14623.5h348a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-348a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1636" fill="black"><text id="kity_text_11815" text-rendering="inherit" font-size="12" dy=".8em" y="14624.700000047684" x="704.5">如何扩容？如何初始化？如何解决线程访问分配cell冲突时处理？&#xa0;</text></g></g><g id="minder_node1639"><g id="node_expander1634" style="cursor: pointer;"><path id="kity_path_25424" fill="white" stroke="gray" d="M1073.5,14632.5A6,6,0,1,1,1061.5,14632.5A6,6,0,1,1,1073.5,14632.5"></path><path id="kity_path_25425" fill="none" stroke="gray" d="M1063,14632.5L1072,14632.5"></path></g><path id="node_outline1635" fill="none" stroke="none" d="M1078.5,14524.5h1828a5,5,0,0,1,5,5v206a5,5,0,0,1,-5,5h-1828a5,5,0,0,1,-5,-5v-206a5,5,0,0,1,5,-5z"></path><g id="node_text1635" fill="black"><text id="kity_text_11802" text-rendering="inherit" font-size="12" dy=".8em" y="14525.700000047684" x="1078.5">1.扩容</text><text id="kity_text_11803" text-rendering="inherit" font-size="12" dy=".8em" y="14543.700000047684" x="1078.5">当前cells元素个数小于当前机器的CPU个数并且当前多个线程访问cells中的同一个元素，从而导致冲突使其中一个线程CAS失败时才会进行扩容操作。然后先 通过CAS设置cellsBusy为1，然后才能进行扩容。cellbusy标志位是因为扩容数组等行为需要只能有一个线程同时执行，因此需要一个锁，这里通过CAS更新cellsBusy来实现一个简单的锁。</text><text id="kity_text_11804" text-rendering="inherit" font-size="12" dy=".8em" y="14561.700000047684" x="1078.5">cellsBusy为0说明cells数组没用被初始化或者扩容，也没有在新建Cell元素，为1则说明cells数组在被初始化或者扩容，或者当前在创建新的Cell元素。最后casCellsBusy()将cellsBusy的值从0更新为1,成功就将容量扩充为之前的两倍，并复制Cell元素到新扩容的数组。</text><text id="kity_text_11805" text-rendering="inherit" font-size="12" dy=".8em" y="14579.700000047684" x="1078.5">每次扩容(当线程竞争异常激烈时，发生扩容)为上次长度的2倍，因此数组长度一直是2的次幂，但是当数组长度≥CPU的核心数时，就不再进行扩容</text><text id="kity_text_11806" text-rendering="inherit" font-size="12" dy=".8em" y="14597.700000047684" x="1078.5">为什么小于等于cpu ：一般有CPU核心数个线程能够并行，因此同时也就这么多个线程操作Cell数组，每个线程更新一个位置上的元素，且又因为数组中每个元素cell十分的占据内存。考虑到这两个因素，Cell数组在长度≥CPU核心数时，停止扩容。</text><text id="kity_text_11807" text-rendering="inherit" font-size="12" dy=".8em" y="14615.700000047684" x="1078.5">2.初始化</text><text id="kity_text_11808" text-rendering="inherit" font-size="12" dy=".8em" y="14633.700000047684" x="1078.5">当出现冲突时，就需要使用cell数组，Cell数组初始值为2。然后使用 h&amp;1 计算当前线程应该访问cell数组的那一个位置。最后重置了cellsBusy标记。</text><text id="kity_text_11809" text-rendering="inherit" font-size="12" dy=".8em" y="14651.700000047684" x="1078.5">多线程并发初始化table数组时，必须要保证table数组只被初始化一次，因此只有一个线程能够竞争成功，这种情况下竞争失败的线程会尝试在base上进行一次累积操作。</text><text id="kity_text_11810" text-rendering="inherit" font-size="12" dy=".8em" y="14669.700000047684" x="1078.5">使用cellsBusy是用来控制并发修改cells的变量，初始值为0，通过casCellsBusy将cellsBusy的值从0更新为1。然后，new了一个初始大小为2的Cell数组，new了一个Cell并将add的值作为初始值，然后计算一个cells的index，将这个Cell赋值进去。最后，更新实例变量cells，并将cellsBusy重置为0。</text><text id="kity_text_11811" text-rendering="inherit" font-size="12" dy=".8em" y="14687.700000047684" x="1078.5">3.冲突</text><text id="kity_text_11812" text-rendering="inherit" font-size="12" dy=".8em" y="14705.700000047684" x="1078.5">当前线程调用add方法并根据当前线程的随机数threadLocalRandomProbe和cells元素个数计算要访问的Cell元素下标，然后如果发现对应下标的值为null，则新增一个Cell元素到cells数组，并且将其添加到cells数组之前要竞争设置cellsBusy为1.</text><text id="kity_text_11813" text-rendering="inherit" font-size="12" dy=".8em" y="14723.700000047684" x="1078.5">对CAS失败的线程重新计算当前线程的随机值threadLocalReadomProbe，以减少下次访问cells元素时的冲突机会。</text></g></g><g id="minder_node1640"><g id="node_expander1633" style="cursor: pointer;" display="none"><path id="kity_path_25421" fill="white" stroke="gray" d="M2927.5,14632.5A6,6,0,1,1,2915.5,14632.5A6,6,0,1,1,2927.5,14632.5"></path><path id="kity_path_25422" fill="none" stroke="gray"></path></g><path id="node_outline1634" fill="none" stroke="none" d="M2932.5,14596.5h347a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-347a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1634" fill="black"><text id="kity_text_11797" text-rendering="inherit" font-size="12" dy=".8em" y="14597.700000047684" x="2932.5">https://blog.csdn.net/u011392897/article/details/60480108</text><text id="kity_text_11798" text-rendering="inherit" font-size="12" dy=".8em" y="14615.700000047684" x="2932.5">https://github.com/aCoder2013/blog/issues/22</text><text id="kity_text_11799" text-rendering="inherit" font-size="12" dy=".8em" y="14633.700000047684" x="2932.5">https://juejin.cn/post/6844903891310477325</text><text id="kity_text_11800" text-rendering="inherit" font-size="12" dy=".8em" y="14651.700000047684" x="2932.5">https://blog.csdn.net/jiangtianjiao/article/details/103844801</text></g></g><g id="minder_node1641"><g id="node_expander1637" style="cursor: pointer;"><path id="kity_path_25433" fill="white" stroke="gray" d="M699.5,14766.5A6,6,0,1,1,687.5,14766.5A6,6,0,1,1,699.5,14766.5"></path><path id="kity_path_25434" fill="none" stroke="gray" d="M689,14766.5L698,14766.5"></path></g><path id="node_outline1638" fill="none" stroke="none" d="M704.5,14757.5h212a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-212a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1638" fill="black"><text id="kity_text_11820" text-rendering="inherit" font-size="12" dy=".8em" y="14758.700000047684" x="704.5">如何保证线程操作操作的cell的原子性？</text></g></g><g id="minder_node1642"><g id="node_expander1636" style="cursor: pointer;" display="none"><path id="kity_path_25430" fill="white" stroke="gray" d="M937.5,14766.5A6,6,0,1,1,925.5,14766.5A6,6,0,1,1,937.5,14766.5"></path><path id="kity_path_25431" fill="none" stroke="gray"></path></g><path id="node_outline1637" fill="none" stroke="none" d="M942.5,14748.5h1074a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1074a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1637" fill="black"><text id="kity_text_11817" text-rendering="inherit" font-size="12" dy=".8em" y="14749.700000047684" x="942.5">1.</text><text id="kity_text_11818" text-rendering="inherit" font-size="12" dy=".8em" y="14767.700000047684" x="942.5">LongAdder先尝试一次cas更新，如果失败会转而通过Cell[]的方式更新值，也是CAS更新数组元素，如果计算index的方式足够散列，那么在并发量大的情况下，多个线程定位到同一个cell的概率也就越低</text></g></g><g id="minder_node1643"><g id="node_expander1640" style="cursor: pointer;"><path id="kity_path_25442" fill="white" stroke="gray" d="M699.5,14810.5A6,6,0,1,1,687.5,14810.5A6,6,0,1,1,699.5,14810.5"></path><path id="kity_path_25443" fill="none" stroke="gray" d="M689,14810.5L698,14810.5"></path></g><path id="node_outline1641" fill="none" stroke="none" d="M704.5,14801.5h225a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-225a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1641" fill="black"><text id="kity_text_11827" text-rendering="inherit" font-size="12" dy=".8em" y="14802.700000047684" x="704.5">如何知道当前线程访问的是哪一个cell元素</text></g></g><g id="minder_node1644"><g id="node_expander1639" style="cursor: pointer;"><path id="kity_path_25439" fill="white" stroke="gray" d="M950.5,14810.5A6,6,0,1,1,938.5,14810.5A6,6,0,1,1,950.5,14810.5"></path><path id="kity_path_25440" fill="none" stroke="gray" d="M940,14810.5L949,14810.5"></path></g><path id="node_outline1640" fill="none" stroke="none" d="M955.5,14792.5h634a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-634a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1640" fill="black"><text id="kity_text_11824" text-rendering="inherit" font-size="12" dy=".8em" y="14793.700000047684" x="955.5">1.当前线程应该访问那个Cell元素是通过&#xa0;&#xa0;Unsafe获取Thread中threadLocalRandomProbe的这个值 取模 进行计算的。</text><text id="kity_text_11825" text-rendering="inherit" font-size="12" dy=".8em" y="14811.700000047684" x="955.5">2.数组访问索引是通过Thread里的threadLocalRandomProbe域取模实现的，这个域是ThreadLocalRandom更新的，</text></g></g><g id="minder_node1645"><g id="node_expander1638" style="cursor: pointer;" display="none"><path id="kity_path_25436" fill="white" stroke="gray" d="M1610.5,14810.5A6,6,0,1,1,1598.5,14810.5A6,6,0,1,1,1610.5,14810.5"></path><path id="kity_path_25437" fill="none" stroke="gray"></path></g><path id="node_outline1639" fill="none" stroke="none" d="M1615.5,14796.5h79a5,5,0,0,1,5,5v18a5,5,0,0,1,-5,5h-79a5,5,0,0,1,-5,-5v-18a5,5,0,0,1,5,-5z"></path><g id="node_text1639" fill="black"><text id="kity_text_11822" text-rendering="inherit" font-size="12" dy=".8em" y="14802.700000047684" x="1615.5">分支主题</text></g><a id="kity_a_16943" xlink:href="https://blog.csdn.net/chuanyingcao2675/article/details/101048887?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-9.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-9.control" target="_blank" xlink:title="https://blog.csdn.net/chuanyingcao2675/article/details/101048887?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-9.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-9.control" style="cursor: pointer;"><path id="kity_path_16945" fill="rgba(255, 255, 255, 0)" stroke="none" d="M1674.5,14799.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16944" fill="#666" stroke="none" d="M1689.114,14815.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V14809.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C1684.766,14806.571,1686.168,14805.5,1687.836,14805.5h1.278c2.116,0,3.834,1.716,3.834,3.834V14811.89C1692.948,14814.008,1691.23,14815.724,1689.114,14815.724zM1677.612,14810.612c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S1687.265,14811.89,1686.558,14811.89H1678.89C1678.185,14811.89,1677.612,14811.319,1677.612,14810.612zM1675.056,14809.334V14811.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H1676.334C1674.216,14815.724,1672.5,14814.008,1672.5,14811.89V14809.334C1672.5,14807.216,1674.216,14805.5,1676.334,14805.5h1.278c1.667,0,3.071,1.071,3.599,2.556H1676.334C1675.629,14808.056,1675.056,14808.627,1675.056,14809.334z"></path></a></g><g id="minder_node1646"><g id="node_expander1642" style="cursor: pointer;"><path id="kity_path_25448" fill="white" stroke="gray" d="M699.5,14845.5A6,6,0,1,1,687.5,14845.5A6,6,0,1,1,699.5,14845.5"></path><path id="kity_path_25449" fill="none" stroke="gray" d="M689,14845.5L698,14845.5"></path></g><path id="node_outline1643" fill="none" stroke="none" d="M704.5,14836.5h136a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-136a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1643" fill="black"><text id="kity_text_11831" text-rendering="inherit" font-size="12" dy=".8em" y="14837.700000047684" x="704.5">LongAdder的使用场景？</text></g></g><g id="minder_node1647"><g id="node_expander1641" style="cursor: pointer;" display="none"><path id="kity_path_25445" fill="white" stroke="gray" d="M861.5,14845.5A6,6,0,1,1,849.5,14845.5A6,6,0,1,1,861.5,14845.5"></path><path id="kity_path_25446" fill="none" stroke="gray"></path></g><path id="node_outline1642" fill="none" stroke="none" d="M866.5,14836.5h1695a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1695a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1642" fill="black"><text id="kity_text_11829" text-rendering="inherit" font-size="12" dy=".8em" y="14837.700000047684" x="866.5">LongAdder从性能上来说要远远好于AtomicLong，一般情况下是可以直接替代AtomicLong使用的，Netty也通过一个接口封装了这两个类，在Java8下直接采用LongAdder，但是AtomicLong的一系列方法不仅仅可以自增，还可以获取更新后的值，如果是例如获取一个全局唯一的ID还是采用AtomicLong会方便一点。</text></g></g><g id="minder_node1648"><g id="node_expander1661" style="cursor: pointer;"><path id="kity_path_25505" fill="white" stroke="gray" d="M544.5,15202.5A6,6,0,1,1,532.5,15202.5A6,6,0,1,1,544.5,15202.5"></path><path id="kity_path_25506" fill="none" stroke="gray" d="M534,15202.5L543,15202.5"></path></g><path id="node_outline1662" fill="none" stroke="none" d="M549.5,15193.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1662" fill="black"><text id="kity_text_11895" text-rendering="inherit" font-size="12" dy=".8em" y="15194.700000047684" x="549.5">并发工具</text></g></g><g id="minder_node1649"><g id="node_expander1651" style="cursor: pointer;"><path id="kity_path_25475" fill="white" stroke="gray" d="M620.5,14972.5A6,6,0,1,1,608.5,14972.5A6,6,0,1,1,620.5,14972.5"></path><path id="kity_path_25476" fill="none" stroke="gray" d="M610,14972.5L619,14972.5"></path></g><path id="node_outline1652" fill="none" stroke="none" d="M625.5,14963.5h105a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-105a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1652" fill="black"><text id="kity_text_11857" text-rendering="inherit" font-size="12" dy=".8em" y="14964.700000047684" x="625.5">CountDownLatch?</text></g></g><g id="minder_node1650"><g id="node_expander1646" style="cursor: pointer;"><path id="kity_path_25460" fill="white" stroke="gray" d="M751.5,14906.5A6,6,0,1,1,739.5,14906.5A6,6,0,1,1,751.5,14906.5"></path><path id="kity_path_25461" fill="none" stroke="gray" d="M741,14906.5L750,14906.5"></path></g><path id="node_outline1647" fill="none" stroke="none" d="M756.5,14897.5h136a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-136a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1647" fill="black"><text id="kity_text_11843" text-rendering="inherit" font-size="12" dy=".8em" y="14898.700000047684" x="756.5">知道CountDownLatch吗</text></g></g><g id="minder_node1651"><g id="node_expander1645" style="cursor: pointer;" display="none"><path id="kity_path_25457" fill="white" stroke="gray" d="M913.5,14906.5A6,6,0,1,1,901.5,14906.5A6,6,0,1,1,913.5,14906.5"></path><path id="kity_path_25458" fill="none" stroke="gray"></path></g><path id="node_outline1646" fill="none" stroke="none" d="M918.5,14861.5h1166a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1166a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1646" fill="black"><text id="kity_text_11837" text-rendering="inherit" font-size="12" dy=".8em" y="14862.700000047684" x="918.5">1.</text><text id="kity_text_11838" text-rendering="inherit" font-size="12" dy=".8em" y="14880.700000047684" x="918.5">CountDownLatch递减计数栅栏。用于控制一个线程等待多个线程。</text><text id="kity_text_11839" text-rendering="inherit" font-size="12" dy=".8em" y="14898.700000047684" x="918.5">CountDownLatch 维护一个计数器 count，表示需要等待的事件数量。countDown 方法递减计数器，将统计值原子减1，表示有一个事件已经发生。直到计数器的值为0的时候，调用await方法的线程才能继续往下执行。</text><text id="kity_text_11840" text-rendering="inherit" font-size="12" dy=".8em" y="14916.700000047684" x="918.5">调用 await 方法的线程会一直阻塞直到计数器为零，或者等待中的线程中断，或者等待超时。</text><text id="kity_text_11841" text-rendering="inherit" font-size="12" dy=".8em" y="14934.700000047684" x="918.5">2.对于这个计数值不能初始化以后就不能重新设置，也就是不能重复使用</text></g></g><g id="minder_node1652"><g id="node_expander1648" style="cursor: pointer;"><path id="kity_path_25466" fill="white" stroke="gray" d="M751.5,14977.5A6,6,0,1,1,739.5,14977.5A6,6,0,1,1,751.5,14977.5"></path><path id="kity_path_25467" fill="none" stroke="gray" d="M741,14977.5L750,14977.5"></path></g><path id="node_outline1649" fill="none" stroke="none" d="M756.5,14968.5h195a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-195a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1649" fill="black"><text id="kity_text_11848" text-rendering="inherit" font-size="12" dy=".8em" y="14969.700000047684" x="756.5">CountDownLatch可以用到什么场景</text></g></g><g id="minder_node1653"><g id="node_expander1647" style="cursor: pointer;" display="none"><path id="kity_path_25463" fill="white" stroke="gray" d="M972.5,14977.5A6,6,0,1,1,960.5,14977.5A6,6,0,1,1,972.5,14977.5"></path><path id="kity_path_25464" fill="none" stroke="gray"></path></g><path id="node_outline1648" fill="none" stroke="none" d="M977.5,14959.5h781a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-781a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1648" fill="black"><text id="kity_text_11845" text-rendering="inherit" font-size="12" dy=".8em" y="14960.700000047684" x="977.5">1.</text><text id="kity_text_11846" text-rendering="inherit" font-size="12" dy=".8em" y="14978.700000047684" x="977.5">假设某个线程在执行任务之前，需要等待其它线程完成一些前置任务，必须等所有的前置任务都完成，才能开始执行本线程的任务。就可以使用CDL</text></g></g><g id="minder_node1654"><g id="node_expander1650" style="cursor: pointer;"><path id="kity_path_25472" fill="white" stroke="gray" d="M751.5,15039.5A6,6,0,1,1,739.5,15039.5A6,6,0,1,1,751.5,15039.5"></path><path id="kity_path_25473" fill="none" stroke="gray" d="M741,15039.5L750,15039.5"></path></g><path id="node_outline1651" fill="none" stroke="none" d="M756.5,15030.5h253a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-253a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1651" fill="black"><text id="kity_text_11855" text-rendering="inherit" font-size="12" dy=".8em" y="15031.700000047684" x="756.5">知道countDownLatch和CyclicBarrier的区别吗</text></g></g><g id="minder_node1655"><g id="node_expander1649" style="cursor: pointer;" display="none"><path id="kity_path_25469" fill="white" stroke="gray" d="M1030.5,15039.5A6,6,0,1,1,1018.5,15039.5A6,6,0,1,1,1030.5,15039.5"></path><path id="kity_path_25470" fill="none" stroke="gray"></path></g><path id="node_outline1650" fill="none" stroke="none" d="M1035.5,15003.5h1393a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1393a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1650" fill="black"><text id="kity_text_11850" text-rendering="inherit" font-size="12" dy=".8em" y="15004.700000047684" x="1035.5">1.</text><text id="kity_text_11851" text-rendering="inherit" font-size="12" dy=".8em" y="15022.700000047684" x="1035.5">CyclicBarrier 可以重复使用，而 CountdownLatch 不能重复使用，CountdownLatch计数减为0无法被重置，而可以使用reset()方法重置计数屏障。</text><text id="kity_text_11852" text-rendering="inherit" font-size="12" dy=".8em" y="15040.700000047684" x="1035.5">CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；CountDownLatch强调一个线程等多个线程完成某件事情。CyclicBarrier是多个线程互等</text><text id="kity_text_11853" text-rendering="inherit" font-size="12" dy=".8em" y="15058.700000047684" x="1035.5">调用CountDownLatch的countDown方法后，当前线程并不会阻塞，会继续往下执行，而调用CyclicBarrier的await方法，会阻塞当前线程，直到CyclicBarrier指定的线程全部都到达了指定点的时候，才能继续往下执行；</text></g></g><g id="minder_node1656"><g id="node_expander1654" style="cursor: pointer;"><path id="kity_path_25484" fill="white" stroke="gray" d="M620.5,15137.5A6,6,0,1,1,608.5,15137.5A6,6,0,1,1,620.5,15137.5"></path><path id="kity_path_25485" fill="none" stroke="gray" d="M610,15137.5L619,15137.5"></path></g><path id="node_outline1655" fill="none" stroke="none" d="M625.5,15128.5h71a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-71a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1655" fill="black"><text id="kity_text_11868" text-rendering="inherit" font-size="12" dy=".8em" y="15129.700000047684" x="625.5">CyclicBarrier</text></g></g><g id="minder_node1657"><g id="node_expander1653" style="cursor: pointer;"><path id="kity_path_25481" fill="white" stroke="gray" d="M717.5,15137.5A6,6,0,1,1,705.5,15137.5A6,6,0,1,1,717.5,15137.5"></path><path id="kity_path_25482" fill="none" stroke="gray" d="M707,15137.5L716,15137.5"></path></g><path id="node_outline1654" fill="none" stroke="none" d="M722.5,15128.5h168a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-168a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1654" fill="black"><text id="kity_text_11866" text-rendering="inherit" font-size="12" dy=".8em" y="15129.700000047684" x="722.5">知道循环珊栏吗CyclicBarrier吗</text></g></g><g id="minder_node1658"><g id="node_expander1652" style="cursor: pointer;" display="none"><path id="kity_path_25478" fill="white" stroke="gray" d="M911.5,15137.5A6,6,0,1,1,899.5,15137.5A6,6,0,1,1,911.5,15137.5"></path><path id="kity_path_25479" fill="none" stroke="gray"></path></g><path id="node_outline1653" fill="none" stroke="none" d="M916.5,15083.5h879a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-879a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1653" fill="black"><text id="kity_text_11859" text-rendering="inherit" font-size="12" dy=".8em" y="15084.700000047684" x="916.5">1.</text><text id="kity_text_11860" text-rendering="inherit" font-size="12" dy=".8em" y="15102.700000047684" x="916.5">CyclicBarrier让多个线程都等待完成后才会继续下一步行动。</text><text id="kity_text_11861" text-rendering="inherit" font-size="12" dy=".8em" y="15120.700000047684" x="916.5">和CountDownLatch一样具有等待计数的功能，但是相比于CountDownLatch功能更加强大。并且可以循环使用，</text><text id="kity_text_11862" text-rendering="inherit" font-size="12" dy=".8em" y="15138.700000047684" x="916.5">CyclicBarrier内部使用的是Lock + Condition实现的等待/通知模式。</text><text id="kity_text_11863" text-rendering="inherit" font-size="12" dy=".8em" y="15156.700000047684" x="916.5">CyclicBarrier初始化时规定一个数目，然后计算调用了CyclicBarrier.await()进入等待的线程数。当线程数达到了这个数目时，所有进入等待状态的线程被唤醒并继续。</text><text id="kity_text_11864" text-rendering="inherit" font-size="12" dy=".8em" y="15174.700000047684" x="916.5">CyclicBarrier初始时还可带一个Runnable的参数， 此Runnable任务在CyclicBarrier的数目达到后，所有其它线程被唤醒前被执行。</text></g></g><g id="minder_node1659"><g id="node_expander1657" style="cursor: pointer;"><path id="kity_path_25493" fill="white" stroke="gray" d="M620.5,15289.5A6,6,0,1,1,608.5,15289.5A6,6,0,1,1,620.5,15289.5"></path><path id="kity_path_25494" fill="none" stroke="gray" d="M610,15289.5L619,15289.5"></path></g><path id="node_outline1658" fill="none" stroke="none" d="M625.5,15280.5h66a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-66a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1658" fill="black"><text id="kity_text_11883" text-rendering="inherit" font-size="12" dy=".8em" y="15281.700000047684" x="625.5">Semaphore</text></g></g><g id="minder_node1660"><g id="node_expander1656" style="cursor: pointer;"><path id="kity_path_25490" fill="white" stroke="gray" d="M712.5,15289.5A6,6,0,1,1,700.5,15289.5A6,6,0,1,1,712.5,15289.5"></path><path id="kity_path_25491" fill="none" stroke="gray" d="M702,15289.5L711,15289.5"></path></g><path id="node_outline1657" fill="none" stroke="none" d="M717.5,15280.5h139a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-139a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1657" fill="black"><text id="kity_text_11881" text-rendering="inherit" font-size="12" dy=".8em" y="15281.700000047684" x="717.5">知道信号量Semaphore吗</text></g></g><g id="minder_node1661"><g id="node_expander1655" style="cursor: pointer;" display="none"><path id="kity_path_25487" fill="white" stroke="gray" d="M877.5,15289.5A6,6,0,1,1,865.5,15289.5A6,6,0,1,1,877.5,15289.5"></path><path id="kity_path_25488" fill="none" stroke="gray"></path></g><path id="node_outline1656" fill="none" stroke="none" d="M882.5,15199.5h810a5,5,0,0,1,5,5v170a5,5,0,0,1,-5,5h-810a5,5,0,0,1,-5,-5v-170a5,5,0,0,1,5,-5z"></path><g id="node_text1656" fill="black"><text id="kity_text_11870" text-rendering="inherit" font-size="12" dy=".8em" y="15200.700000047684" x="882.5">1.信号量</text><text id="kity_text_11871" text-rendering="inherit" font-size="12" dy=".8em" y="15218.700000047684" x="882.5">Semaphore信号量，用于控制资源能够被并发访问的线程数量，以保证多个线程能够合理的使用特定资源。默认情况下，是非公平的。保证系统吞吐量。</text><text id="kity_text_11872" text-rendering="inherit" font-size="12" dy=".8em" y="15236.700000047684" x="882.5">Semaphore就相当于一个许可证，线程需要先通过acquire方法获取该许可证，该线程才能继续往下执行，否则只能在该方法出阻塞等待。</text><text id="kity_text_11873" text-rendering="inherit" font-size="12" dy=".8em" y="15254.700000047684" x="882.5">当执行完业务功能后，需要通过release()方法将许可证归还，以便其他线程能够获得许可证继续执行。</text><text id="kity_text_11874" text-rendering="inherit" font-size="12" dy=".8em" y="15272.700000047684" x="882.5">2.场景</text><text id="kity_text_11875" text-rendering="inherit" font-size="12" dy=".8em" y="15290.700000047684" x="882.5">Semaphore往往用于资源有限的场景中，去限制线程的数量。如数据库连接数量</text><text id="kity_text_11876" text-rendering="inherit" font-size="12" dy=".8em" y="15308.700000047684" x="882.5">Semaphore用来做特殊资源的并发访问控制是相当合适的，如果有业务场景需要进行流量控制，可以优先考虑Semaphore。</text><text id="kity_text_11877" text-rendering="inherit" font-size="12" dy=".8em" y="15326.700000047684" x="882.5">3.原理</text><text id="kity_text_11878" text-rendering="inherit" font-size="12" dy=".8em" y="15344.700000047684" x="882.5">Semaphore内部有一个继承了AQS的同步器Sync，重写了tryAcquireShared方法。在这个方法里，会去尝试获取资源。</text><text id="kity_text_11879" text-rendering="inherit" font-size="12" dy=".8em" y="15362.700000047684" x="882.5">如果获取失败（想要的资源数量小于目前已有的资源数量），就会返回一个负数（代表尝试获取资源失败）。然后当前线程就会进入AQS的等待队列。</text></g></g><g id="minder_node1662"><g id="node_expander1660" style="cursor: pointer;"><path id="kity_path_25502" fill="white" stroke="gray" d="M620.5,15432.5A6,6,0,1,1,608.5,15432.5A6,6,0,1,1,620.5,15432.5"></path><path id="kity_path_25503" fill="none" stroke="gray" d="M610,15432.5L619,15432.5"></path></g><path id="node_outline1661" fill="none" stroke="none" d="M625.5,15423.5h60a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-60a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1661" fill="black"><text id="kity_text_11893" text-rendering="inherit" font-size="12" dy=".8em" y="15424.700000047684" x="625.5">Exchanger</text></g></g><g id="minder_node1663"><g id="node_expander1659" style="cursor: pointer;"><path id="kity_path_25499" fill="white" stroke="gray" d="M706.5,15432.5A6,6,0,1,1,694.5,15432.5A6,6,0,1,1,706.5,15432.5"></path><path id="kity_path_25500" fill="none" stroke="gray" d="M696,15432.5L705,15432.5"></path></g><path id="node_outline1660" fill="none" stroke="none" d="M711.5,15423.5h144a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-144a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1660" fill="black"><text id="kity_text_11891" text-rendering="inherit" font-size="12" dy=".8em" y="15424.700000047684" x="711.5">知道Exchanger数据交换吗</text></g></g><g id="minder_node1664"><g id="node_expander1658" style="cursor: pointer;" display="none"><path id="kity_path_25496" fill="white" stroke="gray" d="M876.5,15432.5A6,6,0,1,1,864.5,15432.5A6,6,0,1,1,876.5,15432.5"></path><path id="kity_path_25497" fill="none" stroke="gray"></path></g><path id="node_outline1659" fill="none" stroke="none" d="M881.5,15387.5h1357a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1357a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1659" fill="black"><text id="kity_text_11885" text-rendering="inherit" font-size="12" dy=".8em" y="15388.700000047684" x="881.5">1.</text><text id="kity_text_11886" text-rendering="inherit" font-size="12" dy=".8em" y="15406.700000047684" x="881.5">Exchanger类用于两个线程交换数据。它支持泛型，也就是说你可以在两个线程之间传送任何数据。如果一个线程先执行exchange方法，那么它会同步等待另一个线程也执行exchange方法，这个时候两个线程就都达到了同步点，两个线程就可以交换数据。</text><text id="kity_text_11887" text-rendering="inherit" font-size="12" dy=".8em" y="15424.700000047684" x="881.5">exchange是可以重复使用的，两个线程可以使用Exchanger在内存中不断地再交换数据。此类提供对外的操作是同步的；用于成对出现的线程之间交换数据；提供超时构造。</text><text id="kity_text_11888" text-rendering="inherit" font-size="12" dy=".8em" y="15442.700000047684" x="881.5">2.</text><text id="kity_text_11889" text-rendering="inherit" font-size="12" dy=".8em" y="15460.700000047684" x="881.5">三个调用同一个实例的exchange方法会发生什么呢？答案是只有前两个线程会交换数据，第三个线程会进入阻塞状态。</text></g></g><g id="minder_node1665"><g id="node_expander1676" style="cursor: pointer;"><path id="kity_path_25550" fill="white" stroke="gray" d="M544.5,15664.5A6,6,0,1,1,532.5,15664.5A6,6,0,1,1,544.5,15664.5"></path><path id="kity_path_25551" fill="none" stroke="gray" d="M534,15664.5L543,15664.5"></path></g><path id="node_outline1677" fill="none" stroke="none" d="M549.5,15655.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1677" fill="black"><text id="kity_text_11932" text-rendering="inherit" font-size="12" dy=".8em" y="15656.700000047684" x="549.5">异步编排</text></g></g><g id="minder_node1666"><g id="node_expander1675" style="cursor: pointer;"><path id="kity_path_25547" fill="white" stroke="gray" d="M619.5,15664.5A6,6,0,1,1,607.5,15664.5A6,6,0,1,1,619.5,15664.5"></path><path id="kity_path_25548" fill="none" stroke="gray" d="M609,15664.5L618,15664.5"></path></g><path id="node_outline1676" fill="none" stroke="none" d="M624.5,15655.5h111a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-111a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1676" fill="black"><text id="kity_text_11930" text-rendering="inherit" font-size="12" dy=".8em" y="15656.700000047684" x="624.5">CompletableFuture</text></g></g><g id="minder_node1667"><g id="node_expander1669" style="cursor: pointer;"><path id="kity_path_25529" fill="white" stroke="gray" d="M756.5,15578.5A6,6,0,1,1,744.5,15578.5A6,6,0,1,1,756.5,15578.5"></path><path id="kity_path_25530" fill="none" stroke="gray" d="M746,15578.5L755,15578.5"></path></g><path id="node_outline1670" fill="none" stroke="none" d="M761.5,15569.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1670" fill="black"><text id="kity_text_11918" text-rendering="inherit" font-size="12" dy=".8em" y="15570.700000047684" x="761.5">基础</text></g></g><g id="minder_node1668"><g id="node_expander1663" style="cursor: pointer;"><path id="kity_path_25511" fill="white" stroke="gray" d="M807.5,15512.5A6,6,0,1,1,795.5,15512.5A6,6,0,1,1,807.5,15512.5"></path><path id="kity_path_25512" fill="none" stroke="gray" d="M797,15512.5L806,15512.5"></path></g><path id="node_outline1664" fill="none" stroke="none" d="M812.5,15503.5h158a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-158a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1664" fill="black"><text id="kity_text_11901" text-rendering="inherit" font-size="12" dy=".8em" y="15504.700000047684" x="812.5">CompletableFuture是什么？</text></g></g><g id="minder_node1669"><g id="node_expander1662" style="cursor: pointer;" display="none"><path id="kity_path_25508" fill="white" stroke="gray" d="M991.5,15512.5A6,6,0,1,1,979.5,15512.5A6,6,0,1,1,991.5,15512.5"></path><path id="kity_path_25509" fill="none" stroke="gray"></path></g><path id="node_outline1663" fill="none" stroke="none" d="M996.5,15485.5h1013a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1013a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1663" fill="black"><text id="kity_text_11897" text-rendering="inherit" font-size="12" dy=".8em" y="15486.700000047684" x="996.5">1.CompletableFuture是java8新增的实现future接口的扩展类，用于异步编程编写非阻塞的代码，运行的任务在一个单独的线程，与主线程隔离，并且会通知主线程它的进度，成功或者失败。</text><text id="kity_text_11898" text-rendering="inherit" font-size="12" dy=".8em" y="15504.700000047684" x="996.5">在这种方式中，主线程不会被阻塞，不需要一直等到子线程完成。主线程可以并行的执行其他任务。</text><text id="kity_text_11899" text-rendering="inherit" font-size="12" dy=".8em" y="15522.700000047684" x="996.5">使用这种并行方式，可以极大的提高程序的性能。可以各种处理组合任务，处理任务结果，对任务结果再封装，对任务异常的处理，对顺序任务的处理</text></g></g><g id="minder_node1670"><g id="node_expander1665" style="cursor: pointer;"><path id="kity_path_25517" fill="white" stroke="gray" d="M807.5,15574.5A6,6,0,1,1,795.5,15574.5A6,6,0,1,1,807.5,15574.5"></path><path id="kity_path_25518" fill="none" stroke="gray" d="M797,15574.5L806,15574.5"></path></g><path id="node_outline1666" fill="none" stroke="none" d="M812.5,15565.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1666" fill="black"><text id="kity_text_11907" text-rendering="inherit" font-size="12" dy=".8em" y="15566.700000047684" x="812.5">你在项目中怎么使用的？</text></g></g><g id="minder_node1671"><g id="node_expander1664" style="cursor: pointer;" display="none"><path id="kity_path_25514" fill="white" stroke="gray" d="M966.5,15574.5A6,6,0,1,1,954.5,15574.5A6,6,0,1,1,966.5,15574.5"></path><path id="kity_path_25515" fill="none" stroke="gray"></path></g><path id="node_outline1665" fill="none" stroke="none" d="M971.5,15547.5h842a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-842a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1665" fill="black"><text id="kity_text_11903" text-rendering="inherit" font-size="12" dy=".8em" y="15548.700000047684" x="971.5">1.如开头这样吹 在项目中的某一个模块中，我们需要对客户的某一项数据进行数据申报和审核，数据处理比较大并且复杂，然后是每一个月的月末最后一天下午</text><text id="kity_text_11904" text-rendering="inherit" font-size="12" dy=".8em" y="15566.700000047684" x="971.5">三点之前申报上去，中午12点截止办理业务，也就是说只有三个小时用来处理数据，并且这些数据有些业务员还要去核查和修改，用之前的业务流水号来查询</text><text id="kity_text_11905" text-rendering="inherit" font-size="12" dy=".8em" y="15584.700000047684" x="971.5">一个组件数据查询完再下一个效率比较慢，用异步编排多任务组合ABC结束组合数据返回，再处理就比较快</text></g></g><g id="minder_node1672"><g id="node_expander1668" style="cursor: pointer;"><path id="kity_path_25526" fill="white" stroke="gray" d="M807.5,15645.5A6,6,0,1,1,795.5,15645.5A6,6,0,1,1,807.5,15645.5"></path><path id="kity_path_25527" fill="none" stroke="gray" d="M797,15645.5L806,15645.5"></path></g><path id="node_outline1669" fill="none" stroke="none" d="M812.5,15636.5h203a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-203a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1669" fill="black"><text id="kity_text_11916" text-rendering="inherit" font-size="12" dy=".8em" y="15637.700000047684" x="812.5">future和completableFuture的区别？</text></g></g><g id="minder_node1673"><g id="node_expander1667" style="cursor: pointer;"><path id="kity_path_25523" fill="white" stroke="gray" d="M1036.5,15645.5A6,6,0,1,1,1024.5,15645.5A6,6,0,1,1,1036.5,15645.5"></path><path id="kity_path_25524" fill="none" stroke="gray" d="M1026,15645.5L1035,15645.5"></path></g><path id="node_outline1668" fill="none" stroke="none" d="M1041.5,15609.5h1339a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1339a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1668" fill="black"><text id="kity_text_11911" text-rendering="inherit" font-size="12" dy=".8em" y="15610.700000047684" x="1041.5">1，</text><text id="kity_text_11912" text-rendering="inherit" font-size="12" dy=".8em" y="15628.700000047684" x="1041.5">Future 的结果在非阻塞的情况下，不能执行更进一步的操作 也就是说不会通知你它已经完成了，它提供了一个阻塞的 get() 方法通知你结果。而且无法给 Future 植入一个回调函数，当 Future 结果可用的时候，用该回调函数自动的调用 Future 的结果。</text><text id="kity_text_11913" text-rendering="inherit" font-size="12" dy=".8em" y="15646.700000047684" x="1041.5">不能组合多个 Future 的结果 假设你有10个不同的Future，你无法并行的运行获取结果</text><text id="kity_text_11914" text-rendering="inherit" font-size="12" dy=".8em" y="15664.700000047684" x="1041.5">2.而CompletableFuture实现多任务组合，并且可以使用allOf等待他们都完成，然后获取他们的结果 并组合成我们想要的，也可以在其中一个任务完成就修改结果，也可以完成其中一个任务就返回，比较灵活，互相不阻塞</text></g></g><g id="minder_node1674"><g id="node_expander1666" style="cursor: pointer;" display="none"><path id="kity_path_25520" fill="white" stroke="gray" d="M2401.5,15645.5A6,6,0,1,1,2389.5,15645.5A6,6,0,1,1,2401.5,15645.5"></path><path id="kity_path_25521" fill="none" stroke="gray"></path></g><path id="node_outline1667" fill="none" stroke="none" d="M2406.5,15636.5h598a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-598a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1667" fill="black"><text id="kity_text_11909" text-rendering="inherit" font-size="12" dy=".8em" y="15637.700000047684" x="2406.5">https://gitee.com/xiaobo97/viwmall#7%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BB%84%E5%90%88</text></g></g><g id="minder_node1675"><g id="node_expander1670" style="cursor: pointer;" display="none"><path id="kity_path_25532" fill="white" stroke="gray" d="M756.5,15698.5A6,6,0,1,1,744.5,15698.5A6,6,0,1,1,756.5,15698.5"></path><path id="kity_path_25533" fill="none" stroke="gray"></path></g><path id="node_outline1671" fill="none" stroke="none" d="M761.5,15689.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1671" fill="black"><text id="kity_text_11920" text-rendering="inherit" font-size="12" dy=".8em" y="15690.700000047684" x="761.5">进阶</text></g></g><g id="minder_node1676"><g id="node_expander1673" style="cursor: pointer;"><path id="kity_path_25541" fill="white" stroke="gray" d="M756.5,15724.5A6,6,0,1,1,744.5,15724.5A6,6,0,1,1,756.5,15724.5"></path><path id="kity_path_25542" fill="none" stroke="gray" d="M746,15724.5L755,15724.5"></path></g><path id="node_outline1674" fill="none" stroke="none" d="M761.5,15715.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1674" fill="black"><text id="kity_text_11926" text-rendering="inherit" font-size="12" dy=".8em" y="15716.700000047684" x="761.5">场景</text></g></g><g id="minder_node1677"><g id="node_expander1672" style="cursor: pointer;"><path id="kity_path_25538" fill="white" stroke="gray" d="M807.5,15724.5A6,6,0,1,1,795.5,15724.5A6,6,0,1,1,807.5,15724.5"></path><path id="kity_path_25539" fill="none" stroke="gray" d="M797,15724.5L806,15724.5"></path></g><path id="node_outline1673" fill="none" stroke="none" d="M812.5,15715.5h97a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-97a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1673" fill="black"><text id="kity_text_11924" text-rendering="inherit" font-size="12" dy=".8em" y="15716.700000047684" x="812.5">什么场景用这个？</text></g></g><g id="minder_node1678"><g id="node_expander1671" style="cursor: pointer;" display="none"><path id="kity_path_25535" fill="white" stroke="gray" d="M930.5,15724.5A6,6,0,1,1,918.5,15724.5A6,6,0,1,1,930.5,15724.5"></path><path id="kity_path_25536" fill="none" stroke="gray"></path></g><path id="node_outline1672" fill="none" stroke="none" d="M935.5,15715.5h71a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-71a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1672" fill="black"><text id="kity_text_11922" text-rendering="inherit" font-size="12" dy=".8em" y="15716.700000047684" x="935.5">1.结合项目吹</text></g></g><g id="minder_node1679"><g id="node_expander1674" style="cursor: pointer;" display="none"><path id="kity_path_25544" fill="white" stroke="gray" d="M756.5,15750.5A6,6,0,1,1,744.5,15750.5A6,6,0,1,1,756.5,15750.5"></path><path id="kity_path_25545" fill="none" stroke="gray"></path></g><path id="node_outline1675" fill="none" stroke="none" d="M761.5,15741.5h86a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-86a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1675" fill="black"><text id="kity_text_11928" text-rendering="inherit" font-size="12" dy=".8em" y="15742.700000047684" x="761.5">优化和问题分析</text></g></g><g id="minder_node1680"><g id="node_expander1696" style="cursor: pointer;"><path id="kity_path_25610" fill="white" stroke="gray" d="M544.5,16089.5A6,6,0,1,1,532.5,16089.5A6,6,0,1,1,544.5,16089.5"></path><path id="kity_path_25611" fill="none" stroke="gray" d="M534,16089.5L543,16089.5"></path></g><path id="node_outline1697" fill="none" stroke="none" d="M549.5,16080.5h134a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-134a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1697" fill="black"><text id="kity_text_12017" text-rendering="inherit" font-size="12" dy=".8em" y="16081.700000047684" x="549.5">性能排查和场景优化实操</text></g></g><g id="minder_node1681"><g id="node_expander1678" style="cursor: pointer;"><path id="kity_path_25556" fill="white" stroke="gray" d="M704.5,15858.5A6,6,0,1,1,692.5,15858.5A6,6,0,1,1,704.5,15858.5"></path><path id="kity_path_25557" fill="none" stroke="gray" d="M694,15858.5L703,15858.5"></path></g><path id="node_outline1679" fill="none" stroke="none" d="M709.5,15849.5h289a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-289a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1679" fill="black"><text id="kity_text_11945" text-rendering="inherit" font-size="12" dy=".8em" y="15850.700000047684" x="709.5">说说为什么发生死锁，怎么排查解决呢，那怎么避免呢</text></g></g><g id="minder_node1682"><g id="node_expander1677" style="cursor: pointer;" display="none"><path id="kity_path_25553" fill="white" stroke="gray" d="M1019.5,15858.5A6,6,0,1,1,1007.5,15858.5A6,6,0,1,1,1019.5,15858.5"></path><path id="kity_path_25554" fill="none" stroke="gray"></path></g><path id="node_outline1678" fill="none" stroke="none" d="M1024.5,15768.5h1359a5,5,0,0,1,5,5v170a5,5,0,0,1,-5,5h-1359a5,5,0,0,1,-5,-5v-170a5,5,0,0,1,5,-5z"></path><g id="node_text1678" fill="black"><text id="kity_text_11934" text-rendering="inherit" font-size="12" dy=".8em" y="15769.700000047684" x="1024.5">1.</text><text id="kity_text_11935" text-rendering="inherit" font-size="12" dy=".8em" y="15787.700000047684" x="1024.5">两个任务以不合理的顺序互相争夺资源”造成</text><text id="kity_text_11936" text-rendering="inherit" font-size="12" dy=".8em" y="15805.700000047684" x="1024.5">多个的线程互相持有对方所需要的资源，由于某些锁的特性，比如syn使用下，一个线程持有一个资源，或者说获得一个锁，在该线程释放这个锁之前，其它线程是获取不到这个锁的，而且会一直死等下去，因此这便造成了死锁。</text><text id="kity_text_11937" text-rendering="inherit" font-size="12" dy=".8em" y="15823.700000047684" x="1024.5">2.</text><text id="kity_text_11938" text-rendering="inherit" font-size="12" dy=".8em" y="15841.700000047684" x="1024.5">jps -l 定位正在运行java进程号 jstack [进程号] 线程堆栈信息，进程号找到死锁问题，可以知道在哪一块代码出问题</text><text id="kity_text_11939" text-rendering="inherit" font-size="12" dy=".8em" y="15859.700000047684" x="1024.5">也可以通过jVisual来查看 线程堆栈信息，然后会有提示，查看dump文件就可以分析出来死锁</text><text id="kity_text_11940" text-rendering="inherit" font-size="12" dy=".8em" y="15877.700000047684" x="1024.5">3.</text><text id="kity_text_11941" text-rendering="inherit" font-size="12" dy=".8em" y="15895.700000047684" x="1024.5">在通常情况下，都是应用在生产环境运行了一段时间后，才开始慢慢显现出来，在实际测试过程中，由于死锁的隐蔽性，很难在测试过程中及时发现死锁的存在，而且在生产环境中，应用出现了死锁，往往都是在应用状况最糟糕的时候——在高负载情况下。</text><text id="kity_text_11942" text-rendering="inherit" font-size="12" dy=".8em" y="15913.700000047684" x="1024.5">加锁顺序：线程按照相同的顺序加锁。最后一个是支持可重入，因为</text><text id="kity_text_11943" text-rendering="inherit" font-size="12" dy=".8em" y="15931.700000047684" x="1024.5">限时加锁：线程获取锁的过程中限制一定的时间，如果给定时间内获取不到，就算了，这需要用到Lock的一些API。</text></g></g><g id="minder_node1683"><g id="node_expander1680" style="cursor: pointer;"><path id="kity_path_25562" fill="white" stroke="gray" d="M704.5,15967.5A6,6,0,1,1,692.5,15967.5A6,6,0,1,1,704.5,15967.5"></path><path id="kity_path_25563" fill="none" stroke="gray" d="M694,15967.5L703,15967.5"></path></g><path id="node_outline1681" fill="none" stroke="none" d="M709.5,15958.5h72a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-72a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1681" fill="black"><text id="kity_text_11949" text-rendering="inherit" font-size="12" dy=".8em" y="15959.700000047684" x="709.5">死锁的代码？</text></g></g><g id="minder_node1684"><g id="node_expander1679" style="cursor: pointer;" display="none"><path id="kity_path_25559" fill="white" stroke="gray" d="M802.5,15968A6,6,0,1,1,790.5,15968A6,6,0,1,1,802.5,15968"></path><path id="kity_path_25560" fill="none" stroke="gray"></path></g><path id="node_outline1680" fill="none" stroke="none" d="M807.5,15956.5h235a5,5,0,0,1,5,5v13a5,5,0,0,1,-5,5h-235a5,5,0,0,1,-5,-5v-13a5,5,0,0,1,5,-5z"></path><g id="node_text1680" fill="black"><text id="kity_text_11947" text-rendering="inherit" font-size="12" dy=".8em" y="15959.700000047684" x="807.5">A线程等待B释放锁，B线程等待A释放锁</text></g><g id="kity_g_16997" style="cursor: pointer;"><path id="kity_path_16998" fill="none" stroke="none" d="M1029,15959h12a2,2,0,0,1,2,2v13a2,2,0,0,1,-2,2h-12a2,2,0,0,1,-2,-2v-13a2,2,0,0,1,2,-2z"></path><path id="kity_path_16999" fill="black" stroke="none" d="M1038,15970H1032V15969h6L1038,15970L1038,15970zM1038,15968H1032V15967h6V15968zM1038,15966H1032V15965h6V15966zM1037.5,15972H1031V15963h8v7.5M1038,15973l2,-2V15962H1030v11"></path></g></g><g id="minder_node1685"><g id="node_expander1682" style="cursor: pointer;"><path id="kity_path_25568" fill="white" stroke="gray" d="M704.5,15996.5A6,6,0,1,1,692.5,15996.5A6,6,0,1,1,704.5,15996.5"></path><path id="kity_path_25569" fill="none" stroke="gray" d="M694,15996.5L703,15996.5M698.5,15992L698.5,16001"></path></g><path id="node_outline1683" fill="none" stroke="none" d="M709.5,15987.5h119a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-119a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1683" fill="black"><text id="kity_text_11976" text-rendering="inherit" font-size="12" dy=".8em" y="15988.700000047684" x="709.5">多线程顺序打印 A B C</text></g></g><g id="minder_node1686" display="none"><g id="node_expander1681" style="cursor: pointer;" display="none"><path id="kity_path_25565" fill="white" stroke="gray" d="M849.5,15996.5A6,6,0,1,1,837.5,15996.5A6,6,0,1,1,849.5,15996.5"></path><path id="kity_path_25566" fill="none" stroke="gray"></path></g><path id="node_outline1682" fill="none" stroke="none" d="M849.5,15780.5h216a5,5,0,0,1,5,5v422a5,5,0,0,1,-5,5h-216a5,5,0,0,1,-5,-5v-422a5,5,0,0,1,5,-5z"></path><g id="node_text1682" fill="black"><text id="kity_text_11951" text-rendering="inherit" font-size="12" dy=".8em" y="15781.700000047684" x="849.5">volatile int&#xa0; i = 0;</text><text id="kity_text_11952" text-rendering="inherit" font-size="12" dy=".8em" y="15799.700000047684" x="849.5">volatile int flag = 0;</text><text id="kity_text_11953" text-rendering="inherit" font-size="12" dy=".8em" y="15817.700000047684" x="849.5">public class ThreadA extends Thread{</text><text id="kity_text_11954" text-rendering="inherit" font-size="12" dy=".8em" y="15835.700000047684" x="849.5">@Override</text><text id="kity_text_11955" text-rendering="inherit" font-size="12" dy=".8em" y="15853.700000047684" x="849.5">public void run(){</text><text id="kity_text_11956" text-rendering="inherit" font-size="12" dy=".8em" y="15871.700000047684" x="849.5">if(flag == 0){</text><text id="kity_text_11957" text-rendering="inherit" font-size="12" dy=".8em" y="15889.700000047684" x="849.5">&#xa0; // do something</text><text id="kity_text_11958" text-rendering="inherit" font-size="12" dy=".8em" y="15907.700000047684" x="849.5">&#xa0; flag = 1;</text><text id="kity_text_11959" text-rendering="inherit" font-size="12" dy=".8em" y="15925.700000047684" x="849.5">}}}</text><text id="kity_text_11960" text-rendering="inherit" font-size="12" dy=".8em" y="15943.700000047684" x="849.5">public class ThreadB&#xa0; extends Thread{</text><text id="kity_text_11961" text-rendering="inherit" font-size="12" dy=".8em" y="15961.700000047684" x="849.5">@Override</text><text id="kity_text_11962" text-rendering="inherit" font-size="12" dy=".8em" y="15979.700000047684" x="849.5">public void run(){</text><text id="kity_text_11963" text-rendering="inherit" font-size="12" dy=".8em" y="15997.700000047684" x="849.5">	if(flag == 1){</text><text id="kity_text_11964" text-rendering="inherit" font-size="12" dy=".8em" y="16015.700000047684" x="849.5">	 // do something</text><text id="kity_text_11965" text-rendering="inherit" font-size="12" dy=".8em" y="16033.700000047684" x="849.5">	 flag = 2;</text><text id="kity_text_11966" text-rendering="inherit" font-size="12" dy=".8em" y="16051.700000047684" x="849.5">	}}}</text><text id="kity_text_11967" text-rendering="inherit" font-size="12" dy=".8em" y="16069.700000047684" x="849.5">public class Thread extends Thread{</text><text id="kity_text_11968" text-rendering="inherit" font-size="12" dy=".8em" y="16087.700000047684" x="849.5">@Override</text><text id="kity_text_11969" text-rendering="inherit" font-size="12" dy=".8em" y="16105.700000047684" x="849.5">public void run(){</text><text id="kity_text_11970" text-rendering="inherit" font-size="12" dy=".8em" y="16123.700000047684" x="849.5">&#xa0;if(flag == 2){</text><text id="kity_text_11971" text-rendering="inherit" font-size="12" dy=".8em" y="16141.700000047684" x="849.5">&#xa0;// do something&#xa0;</text><text id="kity_text_11972" text-rendering="inherit" font-size="12" dy=".8em" y="16159.700000047684" x="849.5">&#xa0;flag = 0;</text><text id="kity_text_11973" text-rendering="inherit" font-size="12" dy=".8em" y="16177.700000047684" x="849.5">&#xa0;}}}}</text><text id="kity_text_11974" text-rendering="inherit" font-size="12" dy=".8em" y="16195.700000047684" x="849.5"> </text></g></g><g id="minder_node1687"><g id="node_expander1684" style="cursor: pointer;"><path id="kity_path_25574" fill="white" stroke="gray" d="M704.5,16022.5A6,6,0,1,1,692.5,16022.5A6,6,0,1,1,704.5,16022.5"></path><path id="kity_path_25575" fill="none" stroke="gray" d="M694,16022.5L703,16022.5"></path></g><path id="node_outline1685" fill="none" stroke="none" d="M709.5,16013.5h122a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-122a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1685" fill="black"><text id="kity_text_11980" text-rendering="inherit" font-size="12" dy=".8em" y="16014.700000047684" x="709.5">怎么检测线程获取了锁</text></g></g><g id="minder_node1688"><g id="node_expander1683" style="cursor: pointer;" display="none"><path id="kity_path_25571" fill="white" stroke="gray" d="M852.5,16022.5A6,6,0,1,1,840.5,16022.5A6,6,0,1,1,852.5,16022.5"></path><path id="kity_path_25572" fill="none" stroke="gray"></path></g><path id="node_outline1684" fill="none" stroke="none" d="M857.5,16013.5h576a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-576a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1684" fill="black"><text id="kity_text_11978" text-rendering="inherit" font-size="12" dy=".8em" y="16014.700000047684" x="857.5">1.java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。</text></g></g><g id="minder_node1689"><g id="node_expander1685" style="cursor: pointer;" display="none"><path id="kity_path_25577" fill="white" stroke="gray" d="M704.5,16048.5A6,6,0,1,1,692.5,16048.5A6,6,0,1,1,704.5,16048.5"></path><path id="kity_path_25578" fill="none" stroke="gray"></path></g><path id="node_outline1686" fill="none" stroke="none" d="M709.5,16039.5h138a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-138a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1686" fill="black"><text id="kity_text_11982" text-rendering="inherit" font-size="12" dy=".8em" y="16040.700000047684" x="709.5">来&#xa0;写个生产者消费者模型</text></g></g><g id="minder_node1690"><g id="node_expander1686" style="cursor: pointer;" display="none"><path id="kity_path_25580" fill="white" stroke="gray" d="M704.5,16074.5A6,6,0,1,1,692.5,16074.5A6,6,0,1,1,704.5,16074.5"></path><path id="kity_path_25581" fill="none" stroke="gray"></path></g><path id="node_outline1687" fill="none" stroke="none" d="M709.5,16065.5h169a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-169a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1687" fill="black"><text id="kity_text_11984" text-rendering="inherit" font-size="12" dy=".8em" y="16066.700000047684" x="709.5">写个简单的线程池实现线程复用</text></g></g><g id="minder_node1691"><g id="node_expander1687" style="cursor: pointer;" display="none"><path id="kity_path_25583" fill="white" stroke="gray" d="M704.5,16100.5A6,6,0,1,1,692.5,16100.5A6,6,0,1,1,704.5,16100.5"></path><path id="kity_path_25584" fill="none" stroke="gray"></path></g><path id="node_outline1688" fill="none" stroke="none" d="M709.5,16091.5h134a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-134a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1688" fill="black"><text id="kity_text_11986" text-rendering="inherit" font-size="12" dy=".8em" y="16092.700000047684" x="709.5">锁优化关注的因素有哪些</text></g></g><g id="minder_node1692"><g id="node_expander1689" style="cursor: pointer;"><path id="kity_path_25589" fill="white" stroke="gray" d="M704.5,16126.5A6,6,0,1,1,692.5,16126.5A6,6,0,1,1,704.5,16126.5"></path><path id="kity_path_25590" fill="none" stroke="gray" d="M694,16126.5L703,16126.5"></path></g><path id="node_outline1690" fill="none" stroke="none" d="M709.5,16117.5h391a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-391a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1690" fill="black"><text id="kity_text_11990" text-rendering="inherit" font-size="12" dy=".8em" y="16118.700000047684" x="709.5">阿里巴巴禁止使用Executors创建线程池，而是使用原生线程池指定参数？</text></g></g><g id="minder_node1693"><g id="node_expander1688" style="cursor: pointer;" display="none"><path id="kity_path_25586" fill="white" stroke="gray" d="M1121.5,16126.5A6,6,0,1,1,1109.5,16126.5A6,6,0,1,1,1121.5,16126.5"></path><path id="kity_path_25587" fill="none" stroke="gray"></path></g><path id="node_outline1689" fill="none" stroke="none" d="M1126.5,16117.5h287a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-287a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1689" fill="black"><text id="kity_text_11988" text-rendering="inherit" font-size="12" dy=".8em" y="16118.700000047684" x="1126.5">1.可以指定参数，方便排查死锁，利于控制线程池资源</text></g></g><g id="minder_node1694"><g id="node_expander1691" style="cursor: pointer;"><path id="kity_path_25595" fill="white" stroke="gray" d="M704.5,16152.5A6,6,0,1,1,692.5,16152.5A6,6,0,1,1,704.5,16152.5"></path><path id="kity_path_25596" fill="none" stroke="gray" d="M694,16152.5L703,16152.5"></path></g><path id="node_outline1692" fill="none" stroke="none" d="M709.5,16143.5h169a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-169a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1692" fill="black"><text id="kity_text_11994" text-rendering="inherit" font-size="12" dy=".8em" y="16144.700000047684" x="709.5">线程池一般设置多少比较合适？</text></g></g><g id="minder_node1695"><g id="node_expander1690" style="cursor: pointer;" display="none"><path id="kity_path_25592" fill="white" stroke="gray" d="M899.5,16152.5A6,6,0,1,1,887.5,16152.5A6,6,0,1,1,899.5,16152.5"></path><path id="kity_path_25593" fill="none" stroke="gray"></path></g><path id="node_outline1691" fill="none" stroke="none" d="M904.5,16143.5h233a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-233a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1691" fill="black"><text id="kity_text_11992" text-rendering="inherit" font-size="12" dy=".8em" y="16144.700000047684" x="904.5">https://club.perfma.com/article/2386187</text></g></g><g id="minder_node1696"><g id="node_expander1693" style="cursor: pointer;"><path id="kity_path_25601" fill="white" stroke="gray" d="M704.5,16178.5A6,6,0,1,1,692.5,16178.5A6,6,0,1,1,704.5,16178.5"></path><path id="kity_path_25602" fill="none" stroke="gray" d="M694,16178.5L703,16178.5"></path></g><path id="node_outline1694" fill="none" stroke="none" d="M709.5,16169.5h493a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-493a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1694" fill="black"><text id="kity_text_11998" text-rendering="inherit" font-size="12" dy=".8em" y="16170.700000047684" x="709.5">在同步的过程中，一个线程占有了共享资源，但是在占有的过程中，突然挂了，如何做处理？</text></g></g><g id="minder_node1697"><g id="node_expander1692" style="cursor: pointer;" display="none"><path id="kity_path_25598" fill="white" stroke="gray" d="M1223.5,16178.5A6,6,0,1,1,1211.5,16178.5A6,6,0,1,1,1223.5,16178.5"></path><path id="kity_path_25599" fill="none" stroke="gray"></path></g><path id="node_outline1693" fill="none" stroke="none" d="M1228.5,16169.5h478a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-478a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1693" fill="black"><text id="kity_text_11996" text-rendering="inherit" font-size="12" dy=".8em" y="16170.700000047684" x="1228.5">1.设置自旋的次数；对共享资源的占有时间做一个上限限制，超过时间自动将该线程移除。</text></g></g><g id="minder_node1698"><g id="node_expander1695" style="cursor: pointer;"><path id="kity_path_25607" fill="white" stroke="gray" d="M704.5,16321.5A6,6,0,1,1,692.5,16321.5A6,6,0,1,1,704.5,16321.5"></path><path id="kity_path_25608" fill="none" stroke="gray" d="M694,16321.5L703,16321.5"></path></g><path id="node_outline1696" fill="none" stroke="none" d="M709.5,16312.5h74a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-74a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1696" fill="black"><text id="kity_text_12015" text-rendering="inherit" font-size="12" dy=".8em" y="16313.700000047684" x="709.5">并发参考文章</text></g></g><g id="minder_node1699"><g id="node_expander1694" style="cursor: pointer;" display="none"><path id="kity_path_25604" fill="white" stroke="gray" d="M804.5,16321.5A6,6,0,1,1,792.5,16321.5A6,6,0,1,1,804.5,16321.5"></path><path id="kity_path_25605" fill="none" stroke="gray"></path></g><path id="node_outline1695" fill="none" stroke="none" d="M809.5,16195.5h1356a5,5,0,0,1,5,5v242a5,5,0,0,1,-5,5h-1356a5,5,0,0,1,-5,-5v-242a5,5,0,0,1,5,-5z"></path><g id="node_text1695" fill="black"><text id="kity_text_12000" text-rendering="inherit" font-size="12" dy=".8em" y="16196.700000047684" x="809.5">1.https://juejin.cn/post/6844903889678893063#heading-34</text><text id="kity_text_12001" text-rendering="inherit" font-size="12" dy=".8em" y="16214.700000047684" x="809.5">2.https://juejin.cn/post/6844903941830869006#heading-23</text><text id="kity_text_12002" text-rendering="inherit" font-size="12" dy=".8em" y="16232.700000047684" x="809.5">3.https://juejin.cn/post/6844903703430823944#heading-2</text><text id="kity_text_12003" text-rendering="inherit" font-size="12" dy=".8em" y="16250.700000047684" x="809.5">4.https://juejin.cn/post/6844903503333179405#heading-17</text><text id="kity_text_12004" text-rendering="inherit" font-size="12" dy=".8em" y="16268.700000047684" x="809.5">5.https://juejin.cn/post/6844903991696965640#heading-18</text><text id="kity_text_12005" text-rendering="inherit" font-size="12" dy=".8em" y="16286.700000047684" x="809.5">6.https://juejin.cn/post/6844904125755293710#heading-16</text><text id="kity_text_12006" text-rendering="inherit" font-size="12" dy=".8em" y="16304.700000047684" x="809.5">7.https://juejin.cn/post/6911156752033677325#heading-10</text><text id="kity_text_12007" text-rendering="inherit" font-size="12" dy=".8em" y="16322.700000047684" x="809.5">8.https://juejin.cn/post/6844903993144147981#heading-5</text><text id="kity_text_12008" text-rendering="inherit" font-size="12" dy=".8em" y="16340.700000047684" x="809.5">9.https://juejin.cn/post/6844904063687983111#heading-13</text><text id="kity_text_12009" text-rendering="inherit" font-size="12" dy=".8em" y="16358.700000047684" x="809.5">10.https://github.com/dunwu/javacore/blob/master/docs/concurrent/Java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB.md</text><text id="kity_text_12010" text-rendering="inherit" font-size="12" dy=".8em" y="16376.700000047684" x="809.5">11.https://www.codercc.com/backend/basic/juc/</text><text id="kity_text_12011" text-rendering="inherit" font-size="12" dy=".8em" y="16394.700000047684" x="809.5">12.https://github.com/h2pl/Java-Tutorial/blob/master/docs/java/currency/Java%E5%B9%B6%E5%8F%91%E6%8C%87%E5%8D%977%EF%BC%9AJUC%E7%9A%84%E6%A0%B8%E5%BF%83%E7%B1%BBAQS%E8%AF%A6%E8%A7%A3.md</text><text id="kity_text_12012" text-rendering="inherit" font-size="12" dy=".8em" y="16412.700000047684" x="809.5">13.https://www.javadoop.com/</text><text id="kity_text_12013" text-rendering="inherit" font-size="12" dy=".8em" y="16430.700000047684" x="809.5">14.http://concurrent.redspider.group/article/03/19.html</text></g></g><g id="minder_node1700"><g id="node_expander1957" style="cursor: pointer;"><path id="kity_path_26393" fill="white" stroke="gray" d="M492.5,21047.5A6,6,0,1,1,480.5,21047.5A6,6,0,1,1,492.5,21047.5"></path><path id="kity_path_26394" fill="none" stroke="gray" d="M482,21047.5L491,21047.5"></path></g><path id="node_outline1958" fill="none" stroke="none" d="M497.5,21038.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z" stroke-width="3"></path><g id="node_text1958" fill="black"><text id="kity_text_12930" text-rendering="inherit" font-size="12" dy=".8em" y="21039.700000047684" x="497.5">JVM</text></g></g><g id="minder_node1701"><g id="node_expander1706" style="cursor: pointer;"><path id="kity_path_25640" fill="white" stroke="gray" d="M544.5,16597.5A6,6,0,1,1,532.5,16597.5A6,6,0,1,1,544.5,16597.5"></path><path id="kity_path_25641" fill="none" stroke="gray" d="M534,16597.5L543,16597.5"></path></g><path id="node_outline1707" fill="none" stroke="none" d="M549.5,16588.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1707" fill="black"><text id="kity_text_12045" text-rendering="inherit" font-size="12" dy=".8em" y="16589.700000047684" x="549.5">基础</text></g></g><g id="minder_node1702"><g id="node_expander1699" style="cursor: pointer;"><path id="kity_path_25619" fill="white" stroke="gray" d="M595.5,16509.5A6,6,0,1,1,583.5,16509.5A6,6,0,1,1,595.5,16509.5"></path><path id="kity_path_25620" fill="none" stroke="gray" d="M585,16509.5L594,16509.5"></path></g><path id="node_outline1700" fill="none" stroke="none" d="M600.5,16500.5h206a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-206a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1700" fill="black"><text id="kity_text_12028" text-rendering="inherit" font-size="12" dy=".8em" y="16501.700000047684" x="600.5">你说一下new一个对象发生了什么过程</text></g></g><g id="minder_node1703"><g id="node_expander1698" style="cursor: pointer;" display="none"><path id="kity_path_25616" fill="white" stroke="gray" d="M827.5,16509.5A6,6,0,1,1,815.5,16509.5A6,6,0,1,1,827.5,16509.5"></path><path id="kity_path_25617" fill="none" stroke="gray"></path></g><path id="node_outline1699" fill="none" stroke="none" d="M832.5,16455.5h946a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-946a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1699" fill="black"><text id="kity_text_12021" text-rendering="inherit" font-size="12" dy=".8em" y="16456.700000047684" x="832.5">1.所有的类都是在第一次使用时，被动态加载到jvm内存中，即首次创建对象时，或者类中的静态方法首次被调用时，或者静态属性被访问时，类加载器定位找到对应的class文件；</text><text id="kity_text_12022" text-rendering="inherit" font-size="12" dy=".8em" y="16474.700000047684" x="832.5">2.类加载器把class文件载入内存，并生成class对象，把对象中所有的静态资源都执行一遍，并把这些静态资源存放到jvm的方法区中，有且只在class对象首次生成时执行一次；</text><text id="kity_text_12023" text-rendering="inherit" font-size="12" dy=".8em" y="16492.700000047684" x="832.5">3.new创建对象时，首先检查该类的class文件是否已加载到jvm内存中并生成class对象，若有，则会在jvm堆内存中为该类分配足够的空间；</text><text id="kity_text_12024" text-rendering="inherit" font-size="12" dy=".8em" y="16510.700000047684" x="832.5">4.把存储的空间清空，并把该类的所有的基本数据类型设置成默认值，对象引用设置null；</text><text id="kity_text_12025" text-rendering="inherit" font-size="12" dy=".8em" y="16528.700000047684" x="832.5">继续执行字段中被自定义的值的一些初始化操作；</text><text id="kity_text_12026" text-rendering="inherit" font-size="12" dy=".8em" y="16546.700000047684" x="832.5">5.调用构造方法，便创建了一个对象。</text></g></g><g id="minder_node1704"><g id="node_expander1701" style="cursor: pointer;"><path id="kity_path_25625" fill="white" stroke="gray" d="M595.5,16589.5A6,6,0,1,1,583.5,16589.5A6,6,0,1,1,595.5,16589.5"></path><path id="kity_path_25626" fill="none" stroke="gray" d="M585,16589.5L594,16589.5"></path></g><path id="node_outline1702" fill="none" stroke="none" d="M600.5,16580.5h120a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-120a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1702" fill="black"><text id="kity_text_12033" text-rendering="inherit" font-size="12" dy=".8em" y="16581.700000047684" x="600.5">jdk8对jvm有哪些改变</text></g></g><g id="minder_node1705"><g id="node_expander1700" style="cursor: pointer;" display="none"><path id="kity_path_25622" fill="white" stroke="gray" d="M741.5,16589.5A6,6,0,1,1,729.5,16589.5A6,6,0,1,1,741.5,16589.5"></path><path id="kity_path_25623" fill="none" stroke="gray"></path></g><path id="node_outline1701" fill="none" stroke="none" d="M746.5,16571.5h641a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-641a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1701" fill="black"><text id="kity_text_12030" text-rendering="inherit" font-size="12" dy=".8em" y="16572.700000047684" x="746.5">1.主流VM的HotSpots取消了永久代，使用元空间来存方法区，并且元空间不再与堆连续，而且是存在于本地内存</text><text id="kity_text_12031" text-rendering="inherit" font-size="12" dy=".8em" y="16590.700000047684" x="746.5">方法区主要是存 已经被加载的类信息（包含：类版本、字段、方法、接口），常量，静态变量，即时编译器编译后的代码</text></g></g><g id="minder_node1706"><g id="node_expander1703" style="cursor: pointer;"><path id="kity_path_25631" fill="white" stroke="gray" d="M595.5,16642.5A6,6,0,1,1,583.5,16642.5A6,6,0,1,1,595.5,16642.5"></path><path id="kity_path_25632" fill="none" stroke="gray" d="M585,16642.5L594,16642.5"></path></g><path id="node_outline1704" fill="none" stroke="none" d="M600.5,16633.5h93a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-93a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1704" fill="black"><text id="kity_text_12039" text-rendering="inherit" font-size="12" dy=".8em" y="16634.700000047684" x="600.5">i++是原子操作吗</text></g></g><g id="minder_node1707"><g id="node_expander1702" style="cursor: pointer;" display="none"><path id="kity_path_25628" fill="white" stroke="gray" d="M714.5,16642.5A6,6,0,1,1,702.5,16642.5A6,6,0,1,1,714.5,16642.5"></path><path id="kity_path_25629" fill="none" stroke="gray"></path></g><path id="node_outline1703" fill="none" stroke="none" d="M719.5,16615.5h1003a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1003a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1703" fill="black"><text id="kity_text_12035" text-rendering="inherit" font-size="12" dy=".8em" y="16616.700000047684" x="719.5">1.不是。++i和 i++分为三个阶段：I++做了三次指令操作，两次内存访问，第一次，从内存中读取i变量的值到CPU的寄存器，第二次在寄存器中的i自增1，第三次将寄存器中的值写入内存。</text><text id="kity_text_12036" text-rendering="inherit" font-size="12" dy=".8em" y="16634.700000047684" x="719.5">这三个阶段中间都可以被中断分离开.</text><text id="kity_text_12037" text-rendering="inherit" font-size="12" dy=".8em" y="16652.700000047684" x="719.5">在单线程下结果是我们想要的，因为单线程下指令执行结果不能被改变，在并发情况下可能就不是我们想要的结果了。要想安全的i++和++i 就需要保证原子性加锁，或者使用原子操作类，</text></g></g><g id="minder_node1708"><g id="node_expander1705" style="cursor: pointer;"><path id="kity_path_25637" fill="white" stroke="gray" d="M595.5,16686.5A6,6,0,1,1,583.5,16686.5A6,6,0,1,1,595.5,16686.5"></path><path id="kity_path_25638" fill="none" stroke="gray" d="M585,16686.5L594,16686.5"></path></g><path id="node_outline1706" fill="none" stroke="none" d="M600.5,16677.5h226a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-226a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1706" fill="black"><text id="kity_text_12043" text-rendering="inherit" font-size="12" dy=".8em" y="16678.700000047684" x="600.5">java两种启动模式 server和client的区别？</text></g></g><g id="minder_node1709"><g id="node_expander1704" style="cursor: pointer;" display="none"><path id="kity_path_25634" fill="white" stroke="gray" d="M847.5,16686.5A6,6,0,1,1,835.5,16686.5A6,6,0,1,1,847.5,16686.5"></path><path id="kity_path_25635" fill="none" stroke="gray"></path></g><path id="node_outline1705" fill="none" stroke="none" d="M852.5,16677.5h777a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-777a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1705" fill="black"><text id="kity_text_12041" text-rendering="inherit" font-size="12" dy=".8em" y="16678.700000047684" x="852.5">1.Client模式启动速度较快。Server模式启动较慢，但稳定后速度比Client远远要快。用的JVM不一样，一个重量级，对程序优化更多。 一个轻量级</text></g></g><g id="minder_node1710"><g id="node_expander1769" style="cursor: pointer;"><path id="kity_path_25829" fill="white" stroke="gray" d="M544.5,18017.5A6,6,0,1,1,532.5,18017.5A6,6,0,1,1,544.5,18017.5"></path><path id="kity_path_25830" fill="none" stroke="gray" d="M534,18017.5L543,18017.5"></path></g><path id="node_outline1770" fill="none" stroke="none" d="M549.5,18008.5h29a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-29a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1770" fill="black"><text id="kity_text_12264" text-rendering="inherit" font-size="12" dy=".8em" y="18009.700000047684" x="549.5">JMM</text></g></g><g id="minder_node1711"><g id="node_expander1709" style="cursor: pointer;"><path id="kity_path_25649" fill="white" stroke="gray" d="M599.5,16837.5A6,6,0,1,1,587.5,16837.5A6,6,0,1,1,599.5,16837.5"></path><path id="kity_path_25650" fill="none" stroke="gray" d="M589,16837.5L598,16837.5"></path></g><path id="node_outline1710" fill="none" stroke="none" d="M604.5,16828.5h99a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-99a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1710" fill="black"><text id="kity_text_12065" text-rendering="inherit" font-size="12" dy=".8em" y="16829.700000047684" x="604.5">说说JVM内存模型</text></g></g><g id="minder_node1712"><g id="node_expander1708" style="cursor: pointer;"><path id="kity_path_25646" fill="white" stroke="gray" d="M724.5,16837.5A6,6,0,1,1,712.5,16837.5A6,6,0,1,1,724.5,16837.5"></path><path id="kity_path_25647" fill="none" stroke="gray" d="M714,16837.5L723,16837.5"></path></g><path id="node_outline1709" fill="none" stroke="none" d="M729.5,16702.5h2598a5,5,0,0,1,5,5v260a5,5,0,0,1,-5,5h-2598a5,5,0,0,1,-5,-5v-260a5,5,0,0,1,5,-5z"></path><g id="node_text1709" fill="black"><text id="kity_text_12049" text-rendering="inherit" font-size="12" dy=".8em" y="16703.700000047684" x="729.5">运行时数据区域分为</text><text id="kity_text_12050" text-rendering="inherit" font-size="12" dy=".8em" y="16721.700000047684" x="729.5">1.线程私有</text><text id="kity_text_12051" text-rendering="inherit" font-size="12" dy=".8em" y="16739.700000047684" x="729.5">(1)程序计数器：相当于是当前线程所执行的字节码的行号指示器。每一个线程都有自己的程序计数器。主要作用是实现代码流程的控制，比如让字节码解释器改变程序计数器来有序的读取命令，还有就是在多线程的情况下，时间片切换时 程序计数器就是保存当前线程执行到这里了，下一次切换回来的时侯就知道执行到哪里了。相当于一个标记的功能</text><text id="kity_text_12052" text-rendering="inherit" font-size="12" dy=".8em" y="16757.700000047684" x="729.5">特点：线程私有的。他的生命周期和线程一致，唯一一个不会OOM的内存区域</text><text id="kity_text_12053" text-rendering="inherit" font-size="12" dy=".8em" y="16775.700000047684" x="729.5">(2)Java虚拟机栈：描述java方法运行过程的内存模型。虚拟机会为每一个要执行的方法创建一块叫 栈帧 的区域，这里面保存着方法运行时的一些信息，比如，局部变量，操作数栈，方法出口的信息，常量池的引用等 。而每一个方法从执行到结束，就相当于一次入栈和出栈的过程。栈顶是当前正在执行的栈帧，而每一个栈帧又相当于一个正在执行的方法，那么程序计数器也是指向这里的地址。</text><text id="kity_text_12054" text-rendering="inherit" font-size="12" dy=".8em" y="16793.700000047684" x="729.5">特点：线程私有，不需要考虑变量安全问题。可以通过-Xss来指定运行大小。这里可能抛出StackOverFlowError（如果Java 虚拟机栈的大小不允许动态扩展 当线程方法请求栈的深度超过当前 Java 虚拟机栈的最大深度时，抛出 StackOverFlowError 异常。而此时可能内存空间还有。） 和OutOfMemoryError（若允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展时，抛出 OutOfMemoryError 异常。）</text><text id="kity_text_12055" text-rendering="inherit" font-size="12" dy=".8em" y="16811.700000047684" x="729.5">(3)本地方法栈：虚拟机栈是为虚拟机服务，本地方法栈为JVM为了运行本地方法而准备的空间。方法执行结束后，相应的栈帧也会出栈，并释放内存空间。也会抛出 StackOverFlowError 和 OutOfMemoryError 异常。</text><text id="kity_text_12056" text-rendering="inherit" font-size="12" dy=".8em" y="16829.700000047684" x="729.5">2.线程共享</text><text id="kity_text_12057" text-rendering="inherit" font-size="12" dy=".8em" y="16847.700000047684" x="729.5">(1)堆：堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中。也是GC的主要区域。一个JVM只有一个堆。所有线程都访问同一个堆。在虚拟机启动时创建。现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同的区域存放不同生命周期的对象采取不同的垃圾回收算法。堆可以分为：新生代(Eden 区 From Survior To Survivor)、老年代。堆是可以扩展大小的。如果扩展失败就会抛出OutOfMemoryError (当线程请求分配内存，但堆已满，且内存已无法再扩展时)</text><text id="kity_text_12058" text-rendering="inherit" font-size="12" dy=".8em" y="16865.700000047684" x="729.5">可以通过Xms 和Xmx 来 设置初始大小和最大大小。</text><text id="kity_text_12059" text-rendering="inherit" font-size="12" dy=".8em" y="16883.700000047684" x="729.5">(2)方法区(1.8已删除永久代)：整个虚拟机中只有一个方法区。方法区中的信息一般需要长期存在，把方法区称为“永久代”。可以动态扩展，动态扩展失败一样会抛出OutOfMemoryError异常。</text><text id="kity_text_12060" text-rendering="inherit" font-size="12" dy=".8em" y="16901.700000047684" x="729.5">(3)运行时常量池：是方法区的一部分，JDK1.7 及之后版本的 JVM 已经将运行时常量池从永久代中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</text><text id="kity_text_12061" text-rendering="inherit" font-size="12" dy=".8em" y="16919.700000047684" x="729.5">方法区中存放：类信息、常量、静态变量、即时编译器编译后的代码(1.8元空间存储类的元信息，静态变量和常量池等并入堆中。)。常量就存放在运行时常量池中。当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。 当类被 Java 虚拟机加载后， .class 文件中的常量就存放在方法区的运行时常量池中。除了在编译期生成的常量， 而且在运行期间，可以向常量池中添加新的常量。如 String 类的 intern() 方法就能在运行期间向常量池中添加字符串常量。</text><text id="kity_text_12062" text-rendering="inherit" font-size="12" dy=".8em" y="16937.700000047684" x="729.5">3.元空间，1.8用元空间替换了永久代</text><text id="kity_text_12063" text-rendering="inherit" font-size="12" dy=".8em" y="16955.700000047684" x="729.5">直接内存：直接内存是除 Java 虚拟机之外的内存，不属于虚拟机运行时数据区的一部分。直接内存的大小不受 Java 虚拟机控制。可以使用native函数库直接存储堆外内存。它可以指定大小，也可以动态扩展，和GC，</text></g></g><g id="minder_node1713"><g id="node_expander1707" style="cursor: pointer;" display="none"><path id="kity_path_25643" fill="white" stroke="gray" d="M3348.5,16837.5A6,6,0,1,1,3336.5,16837.5A6,6,0,1,1,3348.5,16837.5"></path><path id="kity_path_25644" fill="none" stroke="gray"></path></g><path id="node_outline1708" fill="none" stroke="none" d="M3353.5,16753.5h200a5,5,0,0,1,5,5v158a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-158a5,5,0,0,1,5,-5z"></path><g id="node_text1708" fill="black"><text id="kity_text_12047" text-rendering="inherit" font-size="12" dy=".8em" y="16904.700000047684" x="3428.5">分支主题</text></g><image id="kity_image_17071" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20201122234131321.png" x="3353.5" y="16756.5" width="200" height="145"></image></g><g id="minder_node1714"><g id="node_expander1712" style="cursor: pointer;"><path id="kity_path_25658" fill="white" stroke="gray" d="M599.5,17052.5A6,6,0,1,1,587.5,17052.5A6,6,0,1,1,599.5,17052.5"></path><path id="kity_path_25659" fill="none" stroke="gray" d="M589,17052.5L598,17052.5"></path></g><path id="node_outline1713" fill="none" stroke="none" d="M604.5,17043.5h156a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-156a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1713" fill="black"><text id="kity_text_12078" text-rendering="inherit" font-size="12" dy=".8em" y="17044.700000047684" x="604.5">为什么把永久代改为元空间？</text></g></g><g id="minder_node1715"><g id="node_expander1711" style="cursor: pointer;"><path id="kity_path_25655" fill="white" stroke="gray" d="M781.5,17052.5A6,6,0,1,1,769.5,17052.5A6,6,0,1,1,781.5,17052.5"></path><path id="kity_path_25656" fill="none" stroke="gray" d="M771,17052.5L780,17052.5"></path></g><path id="node_outline1712" fill="none" stroke="none" d="M786.5,16980.5h1350a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-1350a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text1712" fill="black"><text id="kity_text_12069" text-rendering="inherit" font-size="12" dy=".8em" y="16981.700000047684" x="786.5">1.</text><text id="kity_text_12070" text-rendering="inherit" font-size="12" dy=".8em" y="16999.700000047684" x="786.5">java8把永久代（方法区的实现）: PermGen-----&gt;替换为Metaspace(本地内存中)，官方说主要是为了合并VM代码，因为hotspotVM有永久代，但是其他VM没有，</text><text id="kity_text_12071" text-rendering="inherit" font-size="12" dy=".8em" y="17017.700000047684" x="786.5">而且由于永久代内存经常不够用或发生内存泄露，爆出异常java.lang.OutOfMemoryError: PermGen。而默认情况下元空间是可以无限使用本地内存的 可以通过 -XX:MetaspaceSize，初始空间 达到该值就会GC进行类型卸载，同时GC会对该值进行调整：</text><text id="kity_text_12072" text-rendering="inherit" font-size="12" dy=".8em" y="17035.700000047684" x="786.5">如果释放了大量的空间，就适当的降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize（如果设置了的话），适当的提高该值。直接内存在不指定时默认和堆一样大小</text><text id="kity_text_12073" text-rendering="inherit" font-size="12" dy=".8em" y="17053.700000047684" x="786.5">2.</text><text id="kity_text_12074" text-rendering="inherit" font-size="12" dy=".8em" y="17071.700000047684" x="786.5">HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。</text><text id="kity_text_12075" text-rendering="inherit" font-size="12" dy=".8em" y="17089.700000047684" x="786.5">为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间(永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中)，它位于本地内存中，而不是虚拟机内存中。</text><text id="kity_text_12076" text-rendering="inherit" font-size="12" dy=".8em" y="17107.700000047684" x="786.5"> </text></g></g><g id="minder_node1716"><g id="node_expander1710" style="cursor: pointer;" display="none"><path id="kity_path_25652" fill="white" stroke="gray" d="M2157.5,17052.5A6,6,0,1,1,2145.5,17052.5A6,6,0,1,1,2157.5,17052.5"></path><path id="kity_path_25653" fill="none" stroke="gray"></path></g><path id="node_outline1711" fill="none" stroke="none" d="M2162.5,17043.5h353a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-353a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1711" fill="black"><text id="kity_text_12067" text-rendering="inherit" font-size="12" dy=".8em" y="17044.700000047684" x="2162.5">https://blog.csdn.net/u011665991/article/details/107141348/</text></g></g><g id="minder_node1717"><g id="node_expander1715" style="cursor: pointer;"><path id="kity_path_25667" fill="white" stroke="gray" d="M599.5,17195.5A6,6,0,1,1,587.5,17195.5A6,6,0,1,1,599.5,17195.5"></path><path id="kity_path_25668" fill="none" stroke="gray" d="M589,17195.5L598,17195.5"></path></g><path id="node_outline1716" fill="none" stroke="none" d="M604.5,17186.5h88a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-88a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1716" fill="black"><text id="kity_text_12091" text-rendering="inherit" font-size="12" dy=".8em" y="17187.700000047684" x="604.5">为什么有JMM？</text></g></g><g id="minder_node1718"><g id="node_expander1714" style="cursor: pointer;"><path id="kity_path_25664" fill="white" stroke="gray" d="M713.5,17195.5A6,6,0,1,1,701.5,17195.5A6,6,0,1,1,713.5,17195.5"></path><path id="kity_path_25665" fill="none" stroke="gray" d="M703,17195.5L712,17195.5"></path></g><path id="node_outline1715" fill="none" stroke="none" d="M718.5,17132.5h1576a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-1576a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text1715" fill="black"><text id="kity_text_12083" text-rendering="inherit" font-size="12" dy=".8em" y="17133.700000047684" x="718.5">1.</text><text id="kity_text_12084" text-rendering="inherit" font-size="12" dy=".8em" y="17151.700000047684" x="718.5">Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。</text><text id="kity_text_12085" text-rendering="inherit" font-size="12" dy=".8em" y="17169.700000047684" x="718.5">不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</text><text id="kity_text_12086" text-rendering="inherit" font-size="12" dy=".8em" y="17187.700000047684" x="718.5">JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。</text><text id="kity_text_12087" text-rendering="inherit" font-size="12" dy=".8em" y="17205.700000047684" x="718.5">比如说volatile是提供给我们开发者直接调用的，而底层是怎么保证原子有序一致。都是已经在底层指令实现好了，通过这样一个内存模型来保证我们可以编写需要的安全代码</text><text id="kity_text_12088" text-rendering="inherit" font-size="12" dy=".8em" y="17223.700000047684" x="718.5">2.回答2</text><text id="kity_text_12089" text-rendering="inherit" font-size="12" dy=".8em" y="17241.700000047684" x="718.5">为了保证共享内存的正确性(可见性、有序性、原子性)，内存模型定义了共享内存模式下多线程程序读写操作行为的规范，既JMM模型，注意JMM只是一个约定概念，是用来保证效果一致的机制跟规范。它作用于工作内存和主存之间数据同步过程，规定了如何做数据同步以及什么时候做数据同步。</text></g></g><g id="minder_node1719"><g id="node_expander1713" style="cursor: pointer;" display="none"><path id="kity_path_25661" fill="white" stroke="gray" d="M2315.5,17195.5A6,6,0,1,1,2303.5,17195.5A6,6,0,1,1,2315.5,17195.5"></path><path id="kity_path_25662" fill="none" stroke="gray"></path></g><path id="node_outline1714" fill="none" stroke="none" d="M2320.5,17177.5h363a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-363a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1714" fill="black"><text id="kity_text_12080" text-rendering="inherit" font-size="12" dy=".8em" y="17178.700000047684" x="2320.5">https://blog.csdn.net/javazejian/article/details/72772461</text><text id="kity_text_12081" text-rendering="inherit" font-size="12" dy=".8em" y="17196.700000047684" x="2320.5">https://juejin.cn/post/6911156752033677325#heading-14</text></g><a id="kity_a_16946" xlink:href="https://blog.csdn.net/javazejian/article/details/72772461" target="_blank" xlink:title="https://blog.csdn.net/javazejian/article/details/72772461" style="cursor: pointer;"><path id="kity_path_16948" fill="rgba(255, 255, 255, 0)" stroke="none" d="M2663.5,17184.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16947" fill="#666" stroke="none" d="M2678.114,17200.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V17194.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C2673.766,17191.571,2675.168,17190.5,2676.836,17190.5h1.278c2.116,0,3.834,1.716,3.834,3.834V17196.89C2681.948,17199.008,2680.23,17200.724,2678.114,17200.724zM2666.612,17195.612c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S2676.265,17196.89,2675.558,17196.89H2667.89C2667.185,17196.89,2666.612,17196.319,2666.612,17195.612zM2664.056,17194.334V17196.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H2665.334C2663.216,17200.724,2661.5,17199.008,2661.5,17196.89V17194.334C2661.5,17192.216,2663.216,17190.5,2665.334,17190.5h1.278c1.667,0,3.071,1.071,3.599,2.556H2665.334C2664.629,17193.056,2664.056,17193.627,2664.056,17194.334z"></path></a></g><g id="minder_node1720"><g id="node_expander1717" style="cursor: pointer;"><path id="kity_path_25673" fill="white" stroke="gray" d="M599.5,17275.5A6,6,0,1,1,587.5,17275.5A6,6,0,1,1,599.5,17275.5"></path><path id="kity_path_25674" fill="none" stroke="gray" d="M589,17275.5L598,17275.5"></path></g><path id="node_outline1718" fill="none" stroke="none" d="M604.5,17266.5h122a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-122a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1718" fill="black"><text id="kity_text_12095" text-rendering="inherit" font-size="12" dy=".8em" y="17267.700000047684" x="604.5">pc计数器什么时侯为空</text></g></g><g id="minder_node1721"><g id="node_expander1716" style="cursor: pointer;" display="none"><path id="kity_path_25670" fill="white" stroke="gray" d="M747.5,17275.5A6,6,0,1,1,735.5,17275.5A6,6,0,1,1,747.5,17275.5"></path><path id="kity_path_25671" fill="none" stroke="gray"></path></g><path id="node_outline1717" fill="none" stroke="none" d="M752.5,17266.5h190a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-190a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1717" fill="black"><text id="kity_text_12093" text-rendering="inherit" font-size="12" dy=".8em" y="17267.700000047684" x="752.5">1.如果正在执行的是本地方法则为空</text></g></g><g id="minder_node1722"><g id="node_expander1722" style="cursor: pointer;"><path id="kity_path_25688" fill="white" stroke="gray" d="M599.5,17377.5A6,6,0,1,1,587.5,17377.5A6,6,0,1,1,599.5,17377.5"></path><path id="kity_path_25689" fill="none" stroke="gray" d="M589,17377.5L598,17377.5"></path></g><path id="node_outline1723" fill="none" stroke="none" d="M604.5,17368.5h262a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-262a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1723" fill="black"><text id="kity_text_12111" text-rendering="inherit" font-size="12" dy=".8em" y="17369.700000047684" x="604.5">JMM中 栈空间里面放的是什么，等等一系列问题</text></g></g><g id="minder_node1723"><g id="node_expander1719" style="cursor: pointer;"><path id="kity_path_25679" fill="white" stroke="gray" d="M887.5,17337.5A6,6,0,1,1,875.5,17337.5A6,6,0,1,1,887.5,17337.5"></path><path id="kity_path_25680" fill="none" stroke="gray" d="M877,17337.5L886,17337.5"></path></g><path id="node_outline1720" fill="none" stroke="none" d="M892.5,17328.5h183a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-183a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1720" fill="black"><text id="kity_text_12103" text-rendering="inherit" font-size="12" dy=".8em" y="17329.700000047684" x="892.5">栈里面存放什么？JVM有多少个栈</text></g></g><g id="minder_node1724"><g id="node_expander1718" style="cursor: pointer;" display="none"><path id="kity_path_25676" fill="white" stroke="gray" d="M1096.5,17337.5A6,6,0,1,1,1084.5,17337.5A6,6,0,1,1,1096.5,17337.5"></path><path id="kity_path_25677" fill="none" stroke="gray"></path></g><path id="node_outline1719" fill="none" stroke="none" d="M1101.5,17292.5h891a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-891a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1719" fill="black"><text id="kity_text_12097" text-rendering="inherit" font-size="12" dy=".8em" y="17293.700000047684" x="1101.5">1.</text><text id="kity_text_12098" text-rendering="inherit" font-size="12" dy=".8em" y="17311.700000047684" x="1101.5">局部变量表(存储我们临时8个基本数据类型、对象引用地址、方法return后要返回执行的字节码的指令地址)、操作数栈(保存着Java虚拟机执行过程中数据)、常量池引用&#xa0;</text><text id="kity_text_12099" text-rendering="inherit" font-size="12" dy=".8em" y="17329.700000047684" x="1101.5">动态链接：要链接到别的方法中去的地址 等信息</text><text id="kity_text_12100" text-rendering="inherit" font-size="12" dy=".8em" y="17347.700000047684" x="1101.5">2.一个虚拟机栈，一个本地方法栈</text><text id="kity_text_12101" text-rendering="inherit" font-size="12" dy=".8em" y="17365.700000047684" x="1101.5">虚拟机会为每一个调用执行的方法打包创建一块 栈桢，</text></g></g><g id="minder_node1725"><g id="node_expander1721" style="cursor: pointer;"><path id="kity_path_25685" fill="white" stroke="gray" d="M887.5,17417.5A6,6,0,1,1,875.5,17417.5A6,6,0,1,1,887.5,17417.5"></path><path id="kity_path_25686" fill="none" stroke="gray" d="M877,17417.5L886,17417.5"></path></g><path id="node_outline1722" fill="none" stroke="none" d="M892.5,17408.5h265a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-265a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1722" fill="black"><text id="kity_text_12109" text-rendering="inherit" font-size="12" dy=".8em" y="17409.700000047684" x="892.5">什么时候入栈？什么时候出栈？异常情况会出栈？</text></g></g><g id="minder_node1726"><g id="node_expander1720" style="cursor: pointer;" display="none"><path id="kity_path_25682" fill="white" stroke="gray" d="M1178.5,17417.5A6,6,0,1,1,1166.5,17417.5A6,6,0,1,1,1178.5,17417.5"></path><path id="kity_path_25683" fill="none" stroke="gray"></path></g><path id="node_outline1721" fill="none" stroke="none" d="M1183.5,17390.5h992a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-992a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1721" fill="black"><text id="kity_text_12105" text-rendering="inherit" font-size="12" dy=".8em" y="17391.700000047684" x="1183.5">1.方法执行开始入栈。方法执行结束出栈。还有异常情况下也会出栈</text><text id="kity_text_12106" text-rendering="inherit" font-size="12" dy=".8em" y="17409.700000047684" x="1183.5">2.JVM内部产生的异常和代码中使用了throw字节码指令产生的异常，只要本方法的异常表中，没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式成为异常完成出口。</text><text id="kity_text_12107" text-rendering="inherit" font-size="12" dy=".8em" y="17427.700000047684" x="1183.5">一个方法使用异常完成出口的方式退出，是不会给他的上层调用者产生任何返回值。</text></g></g><g id="minder_node1727"><g id="node_expander1724" style="cursor: pointer;"><path id="kity_path_25694" fill="white" stroke="gray" d="M599.5,17488.5A6,6,0,1,1,587.5,17488.5A6,6,0,1,1,599.5,17488.5"></path><path id="kity_path_25695" fill="none" stroke="gray" d="M589,17488.5L598,17488.5"></path></g><path id="node_outline1725" fill="none" stroke="none" d="M604.5,17479.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1725" fill="black"><text id="kity_text_12118" text-rendering="inherit" font-size="12" dy=".8em" y="17480.700000047684" x="604.5">堆和栈对象怎么建立关联的？</text></g></g><g id="minder_node1728"><g id="node_expander1723" style="cursor: pointer;" display="none"><path id="kity_path_25691" fill="white" stroke="gray" d="M782.5,17488.5A6,6,0,1,1,770.5,17488.5A6,6,0,1,1,782.5,17488.5"></path><path id="kity_path_25692" fill="none" stroke="gray"></path></g><path id="node_outline1724" fill="none" stroke="none" d="M787.5,17452.5h1111a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1111a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1724" fill="black"><text id="kity_text_12113" text-rendering="inherit" font-size="12" dy=".8em" y="17453.700000047684" x="787.5">1.对象存储在堆中分配，但对象的引用在堆栈中分配。建对象时两个地方都分配内存，在堆中内存实际建立这个对象，栈中内存只是一个指向这个堆对象的指针(引用变量)而已</text><text id="kity_text_12114" text-rendering="inherit" font-size="12" dy=".8em" y="17471.700000047684" x="787.5">2.引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。</text><text id="kity_text_12115" text-rendering="inherit" font-size="12" dy=".8em" y="17489.700000047684" x="787.5">而对象本身在堆中分配，即使程序运行到使用 new 产生数组或者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能在被使用，</text><text id="kity_text_12116" text-rendering="inherit" font-size="12" dy=".8em" y="17507.700000047684" x="787.5">但仍然占据内存空间不放，利用从GC Roots可达性分析算法，不可达的对象在随后的一个不确定的时间被垃圾回收器收走（释放掉）。</text></g></g><g id="minder_node1729"><g id="node_expander1746" style="cursor: pointer;"><path id="kity_path_25760" fill="white" stroke="gray" d="M599.5,17915.5A6,6,0,1,1,587.5,17915.5A6,6,0,1,1,599.5,17915.5"></path><path id="kity_path_25761" fill="none" stroke="gray" d="M589,17915.5L598,17915.5"></path></g><path id="node_outline1747" fill="none" stroke="none" d="M604.5,17897.5h170a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-170a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1747" fill="black"><text id="kity_text_12189" text-rendering="inherit" font-size="12" dy=".8em" y="17898.700000047684" x="604.5">java对象分配在哪？</text><text id="kity_text_12190" text-rendering="inherit" font-size="12" dy=".8em" y="17916.700000047684" x="604.5">堆，一定是存在堆吗？系列问题</text></g></g><g id="minder_node1730"><g id="node_expander1725" style="cursor: pointer;" display="none"><path id="kity_path_25697" fill="white" stroke="gray" d="M795.5,17550.5A6,6,0,1,1,783.5,17550.5A6,6,0,1,1,795.5,17550.5"></path><path id="kity_path_25698" fill="none" stroke="gray"></path></g><path id="node_outline1726" fill="none" stroke="none" d="M800.5,17532.5h767a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-767a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1726" fill="black"><text id="kity_text_12120" text-rendering="inherit" font-size="12" dy=".8em" y="17533.700000047684" x="800.5">1.堆，不一定是在堆，还有堆外内存，特殊情况栈也会有分配</text><text id="kity_text_12121" text-rendering="inherit" font-size="12" dy=".8em" y="17551.700000047684" x="800.5">2.Java中的对象不一定是在堆上分配的，因为JVM通过逃逸分析，能够分析出一个新对象的使用范围，并以此确定是否要将这个对象分配到堆上。</text></g></g><g id="minder_node1731"><g id="node_expander1728" style="cursor: pointer;"><path id="kity_path_25706" fill="white" stroke="gray" d="M795.5,17603.5A6,6,0,1,1,783.5,17603.5A6,6,0,1,1,795.5,17603.5"></path><path id="kity_path_25707" fill="none" stroke="gray" d="M785,17603.5L794,17603.5"></path></g><path id="node_outline1729" fill="none" stroke="none" d="M800.5,17594.5h228a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-228a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1729" fill="black"><text id="kity_text_12129" text-rendering="inherit" font-size="12" dy=".8em" y="17595.700000047684" x="800.5">那为什么不直接在堆上分配对象？了解过吗</text></g></g><g id="minder_node1732"><g id="node_expander1727" style="cursor: pointer;"><path id="kity_path_25703" fill="white" stroke="gray" d="M1049.5,17603.5A6,6,0,1,1,1037.5,17603.5A6,6,0,1,1,1049.5,17603.5"></path><path id="kity_path_25704" fill="none" stroke="gray" d="M1039,17603.5L1048,17603.5M1043.5,17599L1043.5,17608"></path></g><path id="node_outline1728" fill="none" stroke="none" d="M1054.5,17576.5h694a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-694a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1728" fill="black"><text id="kity_text_12125" text-rendering="inherit" font-size="12" dy=".8em" y="17577.700000047684" x="1054.5">1.堆是线程共享，会竞争资源的发生，对于竞争资源，须采取必要的同步，所以当使用new关键字在堆上分配对象时，是需要锁的。</text><text id="kity_text_12126" text-rendering="inherit" font-size="12" dy=".8em" y="17595.700000047684" x="1054.5">有锁，就必定存在锁带来的开销，而且由于是对整个堆加锁，相对而言锁的粒度还是比较大的，影响效率。</text><text id="kity_text_12127" text-rendering="inherit" font-size="12" dy=".8em" y="17613.700000047684" x="1054.5">而栈是线程私有的，私有即避免了竞争。</text></g></g><g id="minder_node1733" display="none"><g id="node_expander1726" style="cursor: pointer;" display="none"><path id="kity_path_25700" fill="white" stroke="gray" d="M1769.5,17603.5A6,6,0,1,1,1757.5,17603.5A6,6,0,1,1,1769.5,17603.5"></path><path id="kity_path_25701" fill="none" stroke="gray"></path></g><path id="node_outline1727" fill="none" stroke="none" d="M1769.5,17594.5h333a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1727" fill="black"><text id="kity_text_12123" text-rendering="inherit" font-size="12" dy=".8em" y="17595.700000047684" x="1769.5">https://juejin.cn/post/6933080274594955271#heading-53</text></g></g><g id="minder_node1734"><g id="node_expander1730" style="cursor: pointer;"><path id="kity_path_25712" fill="white" stroke="gray" d="M795.5,17665.5A6,6,0,1,1,783.5,17665.5A6,6,0,1,1,795.5,17665.5"></path><path id="kity_path_25713" fill="none" stroke="gray" d="M785,17665.5L794,17665.5"></path></g><path id="node_outline1731" fill="none" stroke="none" d="M800.5,17656.5h313a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-313a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1731" fill="black"><text id="kity_text_12135" text-rendering="inherit" font-size="12" dy=".8em" y="17657.700000047684" x="800.5">你说栈上也会分配对象？那你说说栈上分配，和有什么优点</text></g></g><g id="minder_node1735"><g id="node_expander1729" style="cursor: pointer;" display="none"><path id="kity_path_25709" fill="white" stroke="gray" d="M1134.5,17665.5A6,6,0,1,1,1122.5,17665.5A6,6,0,1,1,1134.5,17665.5"></path><path id="kity_path_25710" fill="none" stroke="gray"></path></g><path id="node_outline1730" fill="none" stroke="none" d="M1139.5,17638.5h653a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-653a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1730" fill="black"><text id="kity_text_12131" text-rendering="inherit" font-size="12" dy=".8em" y="17639.700000047684" x="1139.5">1.栈上分配是 Java 虚拟机提供的一种优化技术，该技术的基本思想是可以将线程私有的对象打散，分配到栈上，而非堆上。</text><text id="kity_text_12132" text-rendering="inherit" font-size="12" dy=".8em" y="17657.700000047684" x="1139.5">栈中的变量会在方法调用结束后自动销毁，就省掉了 jvm 进行垃圾回收，进而可以提高系统的性能</text><text id="kity_text_12133" text-rendering="inherit" font-size="12" dy=".8em" y="17675.700000047684" x="1139.5">2.栈上分配是基于逃逸分析和标量替换</text></g></g><g id="minder_node1736"><g id="node_expander1732" style="cursor: pointer;"><path id="kity_path_25718" fill="white" stroke="gray" d="M795.5,17718.5A6,6,0,1,1,783.5,17718.5A6,6,0,1,1,795.5,17718.5"></path><path id="kity_path_25719" fill="none" stroke="gray" d="M785,17718.5L794,17718.5"></path></g><path id="node_outline1733" fill="none" stroke="none" d="M800.5,17709.5h98a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-98a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1733" fill="black"><text id="kity_text_12140" text-rendering="inherit" font-size="12" dy=".8em" y="17710.700000047684" x="800.5">逃逸分析？你说说</text></g></g><g id="minder_node1737"><g id="node_expander1731" style="cursor: pointer;" display="none"><path id="kity_path_25715" fill="white" stroke="gray" d="M919.5,17718.5A6,6,0,1,1,907.5,17718.5A6,6,0,1,1,919.5,17718.5"></path><path id="kity_path_25716" fill="none" stroke="gray"></path></g><path id="node_outline1732" fill="none" stroke="none" d="M924.5,17700.5h1186a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1186a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1732" fill="black"><text id="kity_text_12137" text-rendering="inherit" font-size="12" dy=".8em" y="17701.700000047684" x="924.5">1.逃逸分析可以分析出某个对象是否永远只在某个方法、线程的范围内，并没有“逃逸”出这个范围，逃逸分析的一个结果就是对于某些未逃逸对象可以直接在栈上分配，由于该对象一定是局部的，所以栈上分配不会有问题。</text><text id="kity_text_12138" text-rendering="inherit" font-size="12" dy=".8em" y="17719.700000047684" x="924.5">2.逃逸分析的目的是判断对象的作用域是否有可能逃出方法体</text></g></g><g id="minder_node1738"><g id="node_expander1734" style="cursor: pointer;"><path id="kity_path_25724" fill="white" stroke="gray" d="M795.5,17771.5A6,6,0,1,1,783.5,17771.5A6,6,0,1,1,795.5,17771.5"></path><path id="kity_path_25725" fill="none" stroke="gray" d="M785,17771.5L794,17771.5"></path></g><path id="node_outline1735" fill="none" stroke="none" d="M800.5,17762.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1735" fill="black"><text id="kity_text_12146" text-rendering="inherit" font-size="12" dy=".8em" y="17763.700000047684" x="800.5">逃逸分析的判断依据呢，有吗</text></g></g><g id="minder_node1739"><g id="node_expander1733" style="cursor: pointer;" display="none"><path id="kity_path_25721" fill="white" stroke="gray" d="M978.5,17771.5A6,6,0,1,1,966.5,17771.5A6,6,0,1,1,978.5,17771.5"></path><path id="kity_path_25722" fill="none" stroke="gray"></path></g><path id="node_outline1734" fill="none" stroke="none" d="M983.5,17744.5h754a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-754a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1734" fill="black"><text id="kity_text_12142" text-rendering="inherit" font-size="12" dy=".8em" y="17745.700000047684" x="983.5">1.对象是否被存入堆中（静态字段或堆中对象的实例字段）。堆内存是线程共享的，一旦对象被分配在堆中，那所有线程都可以访问到该对象，</text><text id="kity_text_12143" text-rendering="inherit" font-size="12" dy=".8em" y="17763.700000047684" x="983.5">这样即时编译器就追踪不到所有使用到该对象的地方了，这样的对象就属于逃逸对象</text><text id="kity_text_12144" text-rendering="inherit" font-size="12" dy=".8em" y="17781.700000047684" x="983.5">2.对象是否被传入未知代码中（方法的调用者和参数）</text></g></g><g id="minder_node1740"><g id="node_expander1736" style="cursor: pointer;"><path id="kity_path_25730" fill="white" stroke="gray" d="M795.5,17860.5A6,6,0,1,1,783.5,17860.5A6,6,0,1,1,795.5,17860.5"></path><path id="kity_path_25731" fill="none" stroke="gray" d="M785,17860.5L794,17860.5"></path></g><path id="node_outline1737" fill="none" stroke="none" d="M800.5,17851.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1737" fill="black"><text id="kity_text_12155" text-rendering="inherit" font-size="12" dy=".8em" y="17852.700000047684" x="800.5">逃逸分析有什么优点</text></g></g><g id="minder_node1741"><g id="node_expander1735" style="cursor: pointer;" display="none"><path id="kity_path_25727" fill="white" stroke="gray" d="M930.5,17860.5A6,6,0,1,1,918.5,17860.5A6,6,0,1,1,930.5,17860.5"></path><path id="kity_path_25728" fill="none" stroke="gray"></path></g><path id="node_outline1736" fill="none" stroke="none" d="M935.5,17806.5h1233a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1233a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1736" fill="black"><text id="kity_text_12148" text-rendering="inherit" font-size="12" dy=".8em" y="17807.700000047684" x="935.5">1.优点可以分为三个：对象可能分配在栈上、分离对象或标量替换、消除同步锁。</text><text id="kity_text_12149" text-rendering="inherit" font-size="12" dy=".8em" y="17825.700000047684" x="935.5">2.JVM通过逃逸分析，分析出新对象的使用范围，就可能将对象在栈上进行分配。</text><text id="kity_text_12150" text-rendering="inherit" font-size="12" dy=".8em" y="17843.700000047684" x="935.5">栈分配可以快速地在栈帧上创建和销毁对象，不用再将对象分配到堆空间，可以有效地减少 JVM 垃圾回收的压力。</text><text id="kity_text_12151" text-rendering="inherit" font-size="12" dy=".8em" y="17861.700000047684" x="935.5">3.当确定要将对象分配到栈上时，即时编译可以将对象打散，将对象替换为一个个很小的局部变量，这叫标量替换。</text><text id="kity_text_12152" text-rendering="inherit" font-size="12" dy=".8em" y="17879.700000047684" x="935.5">将对象替换为一个个局部变量后，就可以非常方便的在栈上进行分配了。</text><text id="kity_text_12153" text-rendering="inherit" font-size="12" dy=".8em" y="17897.700000047684" x="935.5">4.JVM通过逃逸分析，如果发现一个对象只能从一个线程被访问到，则访问这个对象时，可以不加同步锁。如果程序中使用了synchronized锁，则JVM会将synchronized锁消除。需要通过指定参数开启同步消除 -XX:+EliminateLocks </text></g></g><g id="minder_node1742"><g id="node_expander1738" style="cursor: pointer;"><path id="kity_path_25736" fill="white" stroke="gray" d="M795.5,17931.5A6,6,0,1,1,783.5,17931.5A6,6,0,1,1,795.5,17931.5"></path><path id="kity_path_25737" fill="none" stroke="gray" d="M785,17931.5L794,17931.5"></path></g><path id="node_outline1739" fill="none" stroke="none" d="M800.5,17922.5h98a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-98a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1739" fill="black"><text id="kity_text_12159" text-rendering="inherit" font-size="12" dy=".8em" y="17923.700000047684" x="800.5">怎么开启逃逸分析</text></g></g><g id="minder_node1743"><g id="node_expander1737" style="cursor: pointer;" display="none"><path id="kity_path_25733" fill="white" stroke="gray" d="M919.5,17931.5A6,6,0,1,1,907.5,17931.5A6,6,0,1,1,919.5,17931.5"></path><path id="kity_path_25734" fill="none" stroke="gray"></path></g><path id="node_outline1738" fill="none" stroke="none" d="M924.5,17922.5h317a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-317a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1738" fill="black"><text id="kity_text_12157" text-rendering="inherit" font-size="12" dy=".8em" y="17923.700000047684" x="924.5">1.通过指定命令参数-XX:+DoEscapeAnalysis 开启逃逸分析</text></g></g><g id="minder_node1744"><g id="node_expander1740" style="cursor: pointer;"><path id="kity_path_25742" fill="white" stroke="gray" d="M795.5,18002.5A6,6,0,1,1,783.5,18002.5A6,6,0,1,1,795.5,18002.5"></path><path id="kity_path_25743" fill="none" stroke="gray" d="M785,18002.5L794,18002.5"></path></g><path id="node_outline1741" fill="none" stroke="none" d="M800.5,17993.5h278a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-278a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1741" fill="black"><text id="kity_text_12168" text-rendering="inherit" font-size="12" dy=".8em" y="17994.700000047684" x="800.5">你说函数调用，那你知道JVM函数调用大概过程吗，</text></g></g><g id="minder_node1745"><g id="node_expander1739" style="cursor: pointer;" display="none"><path id="kity_path_25739" fill="white" stroke="gray" d="M1099.5,18002.5A6,6,0,1,1,1087.5,18002.5A6,6,0,1,1,1099.5,18002.5"></path><path id="kity_path_25740" fill="none" stroke="gray"></path></g><path id="node_outline1740" fill="none" stroke="none" d="M1104.5,17948.5h624a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-624a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1740" fill="black"><text id="kity_text_12161" text-rendering="inherit" font-size="12" dy=".8em" y="17949.700000047684" x="1104.5">函数调用过程，就是压栈和出栈过程，函数调用需要有一定的时间开销和空间开销，我们需要优化热点代码，提升性能</text><text id="kity_text_12162" text-rendering="inherit" font-size="12" dy=".8em" y="17967.700000047684" x="1104.5">1、首先会有个执行栈，存储它们的局部变量、方法名、动态连接</text><text id="kity_text_12163" text-rendering="inherit" font-size="12" dy=".8em" y="17985.700000047684" x="1104.5">2、当一个方法被调用，一个新的栈帧会被加到栈顶，分配的本地变量和参数会存储在这个栈帧</text><text id="kity_text_12164" text-rendering="inherit" font-size="12" dy=".8em" y="18003.700000047684" x="1104.5">3、跳转到目标方法代码执行</text><text id="kity_text_12165" text-rendering="inherit" font-size="12" dy=".8em" y="18021.700000047684" x="1104.5">4、方法返回的时候，本地方法和参数被销毁，栈顶被移除</text><text id="kity_text_12166" text-rendering="inherit" font-size="12" dy=".8em" y="18039.700000047684" x="1104.5">5、返回原来的地址执行</text></g></g><g id="minder_node1746"><g id="node_expander1745" style="cursor: pointer;"><path id="kity_path_25757" fill="white" stroke="gray" d="M795.5,18289.5A6,6,0,1,1,783.5,18289.5A6,6,0,1,1,795.5,18289.5"></path><path id="kity_path_25758" fill="none" stroke="gray" d="M785,18289.5L794,18289.5"></path></g><path id="node_outline1746" fill="none" stroke="none" d="M800.5,18280.5h263a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-263a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1746" fill="black"><text id="kity_text_12187" text-rendering="inherit" font-size="12" dy=".8em" y="18281.700000047684" x="800.5">TLAB在哪分配，为什么有TLAB？解决什么问题？</text></g></g><g id="minder_node1747"><g id="node_expander1744" style="cursor: pointer;"><path id="kity_path_25754" fill="white" stroke="gray" d="M1084.5,18289.5A6,6,0,1,1,1072.5,18289.5A6,6,0,1,1,1084.5,18289.5"></path><path id="kity_path_25755" fill="none" stroke="gray" d="M1074,18289.5L1083,18289.5"></path></g><path id="node_outline1745" fill="none" stroke="none" d="M1089.5,18226.5h1363a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-1363a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text1745" fill="black"><text id="kity_text_12179" text-rendering="inherit" font-size="12" dy=".8em" y="18227.700000047684" x="1089.5">1.TLAB是每一个线程自己内部的本地缓存区域。他是在伊甸区 非常小，默认是开启的。</text><text id="kity_text_12180" text-rendering="inherit" font-size="12" dy=".8em" y="18245.700000047684" x="1089.5">JVM为每一个线程分配一块TLAB，在多线程情况下 jvm为每一个线程分配内存，然后会被这一块内存保存下来，就可以不用从主内存上去取再分配了，如果能估算每轮 GC 内每个线程使用的内存大小，可以提前分配好内存给线程，这样就更能提高分配效率。</text><text id="kity_text_12181" text-rendering="inherit" font-size="12" dy=".8em" y="18263.700000047684" x="1089.5">如果开启TLAB，大概堆内分配流程是&#xa0;</text><text id="kity_text_12182" text-rendering="inherit" font-size="12" dy=".8em" y="18281.700000047684" x="1089.5">1).开启TALB 然后从线程当前的TLAB分配(如果在开启栈内分配在TLAB分配前还会有判断栈内是否可分配)，如果分配成功 就在这一块区域分配。如果分配失败就看是否存在浪费空间，这个最大浪费空间是JVM内部维护的一个值。</text><text id="kity_text_12183" text-rendering="inherit" font-size="12" dy=".8em" y="18299.700000047684" x="1089.5">2).如果大于最大浪费空间就在TLAB外分配，然后不同GC是否不同分配模式。如果小于那么 TLAB退回伊甸园。重新为线程申请一个新的TLAB</text><text id="kity_text_12184" text-rendering="inherit" font-size="12" dy=".8em" y="18317.700000047684" x="1089.5">2.可以加速内存的分配。堆是实际中频繁操作的区域。可以提高对象分配的效率。</text><text id="kity_text_12185" text-rendering="inherit" font-size="12" dy=".8em" y="18335.700000047684" x="1089.5">3.主要解决的是 尽量避免从堆上直接分配内存从而避免频繁的锁争用。因为堆是共享区域，会有竞争的情况 就会有锁的空闲。</text></g></g><g id="minder_node1748"><g id="node_expander1741" style="cursor: pointer;" display="none"><path id="kity_path_25745" fill="white" stroke="gray" d="M2473.5,18104A6,6,0,1,1,2461.5,18104A6,6,0,1,1,2473.5,18104"></path><path id="kity_path_25746" fill="none" stroke="gray"></path></g><path id="node_outline1742" fill="none" stroke="none" d="M2478.5,18065.5h374a5,5,0,0,1,5,5v67a5,5,0,0,1,-5,5h-374a5,5,0,0,1,-5,-5v-67a5,5,0,0,1,5,-5z"></path><g id="node_text1742" fill="black"><text id="kity_text_12170" text-rendering="inherit" font-size="12" dy=".8em" y="18071.700000047684" x="2478.5">https://juejin.cn/post/6925217498723778568#heading-47</text><text id="kity_text_12171" text-rendering="inherit" font-size="12" dy=".8em" y="18089.700000047684" x="2478.5">https://www.cnblogs.com/mutong1228/p/10294706.html</text><text id="kity_text_12172" text-rendering="inherit" font-size="12" dy=".8em" y="18107.700000047684" x="2478.5">https://blog.csdn.net/xiaomingdetianxia/article/details/77688945</text><text id="kity_text_12173" text-rendering="inherit" font-size="12" dy=".8em" y="18125.700000047684" x="2478.5">https://www.cnblogs.com/BlueStarWei/p/9358757.html</text></g><image id="kity_image_17072" xlink:href="https://img-blog.csdn.net/20170829215419709?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhb21pbmdkZXRpYW54aWE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" x="2665.5" y="18068.5" width="0" height="0" xlink:title="这里写图片描述"></image></g><g id="minder_node1749"><g id="node_expander1742" style="cursor: pointer;" display="none"><path id="kity_path_25748" fill="white" stroke="gray" d="M2473.5,18217A6,6,0,1,1,2461.5,18217A6,6,0,1,1,2473.5,18217"></path><path id="kity_path_25749" fill="none" stroke="gray"></path></g><path id="node_outline1743" fill="none" stroke="none" d="M2478.5,18150.5h200a5,5,0,0,1,5,5v123a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-123a5,5,0,0,1,5,-5z"></path><g id="node_text1743" fill="black"><text id="kity_text_12175" text-rendering="inherit" font-size="12" dy=".8em" y="18266.700000047684" x="2553.5">总体流程</text></g><image id="kity_image_17073" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210424170012.png" x="2478.5" y="18153.5" width="200" height="110"></image></g><g id="minder_node1750"><g id="node_expander1743" style="cursor: pointer;" display="none"><path id="kity_path_25751" fill="white" stroke="gray" d="M2473.5,18403A6,6,0,1,1,2461.5,18403A6,6,0,1,1,2473.5,18403"></path><path id="kity_path_25752" fill="none" stroke="gray"></path></g><path id="node_outline1744" fill="none" stroke="none" d="M2478.5,18291.5h151a5,5,0,0,1,5,5v213a5,5,0,0,1,-5,5h-151a5,5,0,0,1,-5,-5v-213a5,5,0,0,1,5,-5z"></path><g id="node_text1744" fill="black"><text id="kity_text_12177" text-rendering="inherit" font-size="12" dy=".8em" y="18497.700000047684" x="2528.5">分支主题</text></g><image id="kity_image_17074" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210505181727.png" x="2478.5" y="18294.5" width="151" height="200"></image></g><g id="minder_node1751"><g id="node_expander1749" style="cursor: pointer;"><path id="kity_path_25769" fill="white" stroke="gray" d="M599.5,18575.5A6,6,0,1,1,587.5,18575.5A6,6,0,1,1,599.5,18575.5"></path><path id="kity_path_25770" fill="none" stroke="gray" d="M589,18575.5L598,18575.5"></path></g><path id="node_outline1750" fill="none" stroke="none" d="M604.5,18566.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1750" fill="black"><text id="kity_text_12201" text-rendering="inherit" font-size="12" dy=".8em" y="18567.700000047684" x="604.5">什么情况栈会内存溢出</text></g></g><g id="minder_node1752"><g id="node_expander1748" style="cursor: pointer;"><path id="kity_path_25766" fill="white" stroke="gray" d="M746.5,18575.5A6,6,0,1,1,734.5,18575.5A6,6,0,1,1,746.5,18575.5"></path><path id="kity_path_25767" fill="none" stroke="gray" d="M736,18575.5L745,18575.5"></path></g><path id="node_outline1749" fill="none" stroke="none" d="M751.5,18521.5h1249a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1249a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1749" fill="black"><text id="kity_text_12194" text-rendering="inherit" font-size="12" dy=".8em" y="18522.700000047684" x="751.5">1.</text><text id="kity_text_12195" text-rendering="inherit" font-size="12" dy=".8em" y="18540.700000047684" x="751.5">栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。局部变量表又包含基本数据类型，对象引用类型</text><text id="kity_text_12196" text-rendering="inherit" font-size="12" dy=".8em" y="18558.700000047684" x="751.5">如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常，方法递归调用产生这种结果。</text><text id="kity_text_12197" text-rendering="inherit" font-size="12" dy=".8em" y="18576.700000047684" x="751.5">如果Java虚拟机栈可以动态扩展，并且扩展的动作已经尝试过，但是无法申请到足够的内存去完成扩展，或者在新建立线程的时候没有足够的内存去创建对应的虚拟机栈，那么Java虚拟机将抛出一个OutOfMemory 异常。(线程启动过多)</text><text id="kity_text_12198" text-rendering="inherit" font-size="12" dy=".8em" y="18594.700000047684" x="751.5">参数 -Xss 去调整JVM栈的大小</text><text id="kity_text_12199" text-rendering="inherit" font-size="12" dy=".8em" y="18612.700000047684" x="751.5">2.写一个死递归，再调整栈大小就可以触发了</text></g></g><g id="minder_node1753"><g id="node_expander1747" style="cursor: pointer;" display="none"><path id="kity_path_25763" fill="white" stroke="gray" d="M2021.5,18575.5A6,6,0,1,1,2009.5,18575.5A6,6,0,1,1,2021.5,18575.5"></path><path id="kity_path_25764" fill="none" stroke="gray"></path></g><path id="node_outline1748" fill="none" stroke="none" d="M2026.5,18561.5h79a5,5,0,0,1,5,5v18a5,5,0,0,1,-5,5h-79a5,5,0,0,1,-5,-5v-18a5,5,0,0,1,5,-5z"></path><g id="node_text1748" fill="black"><text id="kity_text_12192" text-rendering="inherit" font-size="12" dy=".8em" y="18567.700000047684" x="2026.5">分支主题</text></g><a id="kity_a_16949" xlink:href="https://www.cnblogs.com/myseries/p/12079757.html" target="_blank" xlink:title="https://www.cnblogs.com/myseries/p/12079757.html" style="cursor: pointer;"><path id="kity_path_16951" fill="rgba(255, 255, 255, 0)" stroke="none" d="M2085.5,18564.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16950" fill="#666" stroke="none" d="M2100.114,18580.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V18574.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C2095.766,18571.571,2097.168,18570.5,2098.836,18570.5h1.278c2.116,0,3.834,1.716,3.834,3.834V18576.89C2103.948,18579.008,2102.23,18580.724,2100.114,18580.724zM2088.612,18575.612c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S2098.265,18576.89,2097.558,18576.89H2089.89C2089.185,18576.89,2088.612,18576.319,2088.612,18575.612zM2086.056,18574.334V18576.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H2087.334C2085.216,18580.724,2083.5,18579.008,2083.5,18576.89V18574.334C2083.5,18572.216,2085.216,18570.5,2087.334,18570.5h1.278c1.667,0,3.071,1.071,3.599,2.556H2087.334C2086.629,18573.056,2086.056,18573.627,2086.056,18574.334z"></path></a></g><g id="minder_node1754"><g id="node_expander1752" style="cursor: pointer;"><path id="kity_path_25778" fill="white" stroke="gray" d="M599.5,18682.5A6,6,0,1,1,587.5,18682.5A6,6,0,1,1,599.5,18682.5"></path><path id="kity_path_25779" fill="none" stroke="gray" d="M589,18682.5L598,18682.5"></path></g><path id="node_outline1753" fill="none" stroke="none" d="M604.5,18673.5h180a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-180a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1753" fill="black"><text id="kity_text_12212" text-rendering="inherit" font-size="12" dy=".8em" y="18674.700000047684" x="604.5">为什么新生代分三块，两块可以吗</text></g></g><g id="minder_node1755"><g id="node_expander1751" style="cursor: pointer;"><path id="kity_path_25775" fill="white" stroke="gray" d="M805.5,18682.5A6,6,0,1,1,793.5,18682.5A6,6,0,1,1,805.5,18682.5"></path><path id="kity_path_25776" fill="none" stroke="gray" d="M795,18682.5L804,18682.5"></path></g><path id="node_outline1752" fill="none" stroke="none" d="M810.5,18637.5h1321a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1321a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1752" fill="black"><text id="kity_text_12206" text-rendering="inherit" font-size="12" dy=".8em" y="18638.700000047684" x="810.5">1.三片主要目的是为了减少被送到老年代的对象，进而减少Full GC的发生。</text><text id="kity_text_12207" text-rendering="inherit" font-size="12" dy=".8em" y="18656.700000047684" x="810.5">没有Survivor区，那么Eden每次满了清理垃圾，存活的对象被迁移到老年区，老年区满了，就会触发Full GC，Full GC是非常耗时的，</text><text id="kity_text_12208" text-rendering="inherit" font-size="12" dy=".8em" y="18674.700000047684" x="810.5">而为什么有两个幸存区 是为了 减少内存碎片</text><text id="kity_text_12209" text-rendering="inherit" font-size="12" dy=".8em" y="18692.700000047684" x="810.5">大多数新建的对象被放在Eden中，然后他们不可达后，经历一次young GC，Eden中的存活对象就会被移动到第一块survivor S0，Eden被清空；等Eden区再满了，就再触发一次young GC，Eden和S0中的存活对象又会被复制送入第二块survivor S1</text><text id="kity_text_12210" text-rendering="inherit" font-size="12" dy=".8em" y="18710.700000047684" x="810.5">这样保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生</text></g></g><g id="minder_node1756"><g id="node_expander1750" style="cursor: pointer;" display="none"><path id="kity_path_25772" fill="white" stroke="gray" d="M2152.5,18682.5A6,6,0,1,1,2140.5,18682.5A6,6,0,1,1,2152.5,18682.5"></path><path id="kity_path_25773" fill="none" stroke="gray"></path></g><path id="node_outline1751" fill="none" stroke="none" d="M2157.5,18664.5h375a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-375a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1751" fill="black"><text id="kity_text_12203" text-rendering="inherit" font-size="12" dy=".8em" y="18665.700000047684" x="2157.5">https://juejin.cn/post/6844904125696573448#heading-39</text><text id="kity_text_12204" text-rendering="inherit" font-size="12" dy=".8em" y="18683.700000047684" x="2157.5">https://blog.csdn.net/baihehaitangyijiu/article/details/105245065</text></g></g><g id="minder_node1757"><g id="node_expander1754" style="cursor: pointer;"><path id="kity_path_25784" fill="white" stroke="gray" d="M599.5,18780.5A6,6,0,1,1,587.5,18780.5A6,6,0,1,1,599.5,18780.5"></path><path id="kity_path_25785" fill="none" stroke="gray" d="M589,18780.5L598,18780.5"></path></g><path id="node_outline1755" fill="none" stroke="none" d="M604.5,18771.5h126a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-126a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1755" fill="black"><text id="kity_text_12220" text-rendering="inherit" font-size="12" dy=".8em" y="18772.700000047684" x="604.5">JMM的三大特性你说说</text></g></g><g id="minder_node1758"><g id="node_expander1753" style="cursor: pointer;" display="none"><path id="kity_path_25781" fill="white" stroke="gray" d="M751.5,18780.5A6,6,0,1,1,739.5,18780.5A6,6,0,1,1,751.5,18780.5"></path><path id="kity_path_25782" fill="none" stroke="gray"></path></g><path id="node_outline1754" fill="none" stroke="none" d="M756.5,18735.5h1862a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1862a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1754" fill="black"><text id="kity_text_12214" text-rendering="inherit" font-size="12" dy=".8em" y="18736.700000047684" x="756.5">1.可见性(指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。)、原子性(原子性就是指该操作是不可再分的。不论是多核还是单核，具有原子性的量，同一时刻只能有一个线程来对它进行操作。)、有序性(程序执行的顺序按照代码的先后顺序执行，)。对应的底层就是 缓存一致性、内存可见性、有序性。</text><text id="kity_text_12215" text-rendering="inherit" font-size="12" dy=".8em" y="18754.700000047684" x="756.5">实现三大特性就是</text><text id="kity_text_12216" text-rendering="inherit" font-size="12" dy=".8em" y="18772.700000047684" x="756.5">内存屏障、Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序，从而让程序按我们预想的流程去执行</text><text id="kity_text_12217" text-rendering="inherit" font-size="12" dy=".8em" y="18790.700000047684" x="756.5">happen-before、在JMM 中如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系&#xa0;</text><text id="kity_text_12218" text-rendering="inherit" font-size="12" dy=".8em" y="18808.700000047684" x="756.5">af-if-serial，不管怎么重排序(编译器和处理器为了提高并行度)，单线程环境下程序的执行结果不能被改变且必须正确。使单线程环境下程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</text></g></g><g id="minder_node1759"><g id="node_expander1756" style="cursor: pointer;"><path id="kity_path_25790" fill="white" stroke="gray" d="M599.5,18851.5A6,6,0,1,1,587.5,18851.5A6,6,0,1,1,599.5,18851.5"></path><path id="kity_path_25791" fill="none" stroke="gray" d="M589,18851.5L598,18851.5"></path></g><path id="node_outline1757" fill="none" stroke="none" d="M604.5,18842.5h170a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-170a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1757" fill="black"><text id="kity_text_12225" text-rendering="inherit" font-size="12" dy=".8em" y="18843.700000047684" x="604.5">你说了可见性，怎么保证可见性</text></g></g><g id="minder_node1760"><g id="node_expander1755" style="cursor: pointer;" display="none"><path id="kity_path_25787" fill="white" stroke="gray" d="M795.5,18851.5A6,6,0,1,1,783.5,18851.5A6,6,0,1,1,795.5,18851.5"></path><path id="kity_path_25788" fill="none" stroke="gray"></path></g><path id="node_outline1756" fill="none" stroke="none" d="M800.5,18833.5h701a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-701a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1756" fill="black"><text id="kity_text_12222" text-rendering="inherit" font-size="12" dy=".8em" y="18834.700000047684" x="800.5">1.在JMM 中如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系</text><text id="kity_text_12223" text-rendering="inherit" font-size="12" dy=".8em" y="18852.700000047684" x="800.5">比如 volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。这样其他线程都是读取最新的值</text></g></g><g id="minder_node1761"><g id="node_expander1758" style="cursor: pointer;"><path id="kity_path_25796" fill="white" stroke="gray" d="M599.5,18895.5A6,6,0,1,1,587.5,18895.5A6,6,0,1,1,599.5,18895.5"></path><path id="kity_path_25797" fill="none" stroke="gray" d="M589,18895.5L598,18895.5"></path></g><path id="node_outline1759" fill="none" stroke="none" d="M604.5,18886.5h86a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-86a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1759" fill="black"><text id="kity_text_12230" text-rendering="inherit" font-size="12" dy=".8em" y="18887.700000047684" x="604.5">怎么保证有序性</text></g></g><g id="minder_node1762"><g id="node_expander1757" style="cursor: pointer;" display="none"><path id="kity_path_25793" fill="white" stroke="gray" d="M711.5,18895.5A6,6,0,1,1,699.5,18895.5A6,6,0,1,1,711.5,18895.5"></path><path id="kity_path_25794" fill="none" stroke="gray"></path></g><path id="node_outline1758" fill="none" stroke="none" d="M716.5,18877.5h962a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-962a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1758" fill="black"><text id="kity_text_12227" text-rendering="inherit" font-size="12" dy=".8em" y="18878.700000047684" x="716.5">1.</text><text id="kity_text_12228" text-rendering="inherit" font-size="12" dy=".8em" y="18896.700000047684" x="716.5">Java编译器也会根据内存屏障的规则禁止重排序。Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序，从而让程序按我们预想的流程去执行。</text></g></g><g id="minder_node1763"><g id="node_expander1760" style="cursor: pointer;"><path id="kity_path_25802" fill="white" stroke="gray" d="M599.5,18948.5A6,6,0,1,1,587.5,18948.5A6,6,0,1,1,599.5,18948.5"></path><path id="kity_path_25803" fill="none" stroke="gray" d="M589,18948.5L598,18948.5"></path></g><path id="node_outline1761" fill="none" stroke="none" d="M604.5,18939.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1761" fill="black"><text id="kity_text_12236" text-rendering="inherit" font-size="12" dy=".8em" y="18940.700000047684" x="604.5">知道内存屏障吗</text></g></g><g id="minder_node1764"><g id="node_expander1759" style="cursor: pointer;" display="none"><path id="kity_path_25799" fill="white" stroke="gray" d="M710.5,18948.5A6,6,0,1,1,698.5,18948.5A6,6,0,1,1,710.5,18948.5"></path><path id="kity_path_25800" fill="none" stroke="gray"></path></g><path id="node_outline1760" fill="none" stroke="none" d="M715.5,18921.5h1474a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1474a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1760" fill="black"><text id="kity_text_12232" text-rendering="inherit" font-size="12" dy=".8em" y="18922.700000047684" x="715.5">1.</text><text id="kity_text_12233" text-rendering="inherit" font-size="12" dy=".8em" y="18940.700000047684" x="715.5">内存屏障 (Memory Barrier) 是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序，从而让程序按我们预想的流程去执行。</text><text id="kity_text_12234" text-rendering="inherit" font-size="12" dy=".8em" y="18958.700000047684" x="715.5">可以保证特定操作的执行顺序和影响某些数据的内存可见性。</text></g></g><g id="minder_node1765"><g id="node_expander1762" style="cursor: pointer;"><path id="kity_path_25808" fill="white" stroke="gray" d="M599.5,19028.5A6,6,0,1,1,587.5,19028.5A6,6,0,1,1,599.5,19028.5"></path><path id="kity_path_25809" fill="none" stroke="gray" d="M589,19028.5L598,19028.5"></path></g><path id="node_outline1763" fill="none" stroke="none" d="M604.5,19019.5h132a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-132a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1763" fill="black"><text id="kity_text_12244" text-rendering="inherit" font-size="12" dy=".8em" y="19020.700000047684" x="604.5">内存屏障分哪些，了解吗</text></g></g><g id="minder_node1766"><g id="node_expander1761" style="cursor: pointer;" display="none"><path id="kity_path_25805" fill="white" stroke="gray" d="M757.5,19028.5A6,6,0,1,1,745.5,19028.5A6,6,0,1,1,757.5,19028.5"></path><path id="kity_path_25806" fill="none" stroke="gray"></path></g><path id="node_outline1762" fill="none" stroke="none" d="M762.5,18983.5h1230a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1230a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1762" fill="black"><text id="kity_text_12238" text-rendering="inherit" font-size="12" dy=".8em" y="18984.700000047684" x="762.5">1.读屏障和写屏障</text><text id="kity_text_12239" text-rendering="inherit" font-size="12" dy=".8em" y="19002.700000047684" x="762.5">LoadLoad屏障：读读屏障 屏障之前读先行发生屏障后的所有读</text><text id="kity_text_12240" text-rendering="inherit" font-size="12" dy=".8em" y="19020.700000047684" x="762.5">StoreStore屏障： 写写屏障&#xa0; 屏障之前写先行发生屏障后续的所有写， 保证屏障之前的写入操作对其它处理器可见。</text><text id="kity_text_12241" text-rendering="inherit" font-size="12" dy=".8em" y="19038.700000047684" x="762.5">LoadStore屏障：读写屏障&#xa0; 屏障之前的读先行发生屏障之后所有的写</text><text id="kity_text_12242" text-rendering="inherit" font-size="12" dy=".8em" y="19056.700000047684" x="762.5">StoreLoad屏障：写读屏障 屏障之前的写先行发生屏障之后所有的读，保证屏障之前的写入对所有处理器可见。它的开销是四种屏障中最大的。&#xa0; &#xa0; &#xa0; &#xa0; 在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</text></g></g><g id="minder_node1767"><g id="node_expander1765" style="cursor: pointer;"><path id="kity_path_25817" fill="white" stroke="gray" d="M599.5,19126.5A6,6,0,1,1,587.5,19126.5A6,6,0,1,1,599.5,19126.5"></path><path id="kity_path_25818" fill="none" stroke="gray" d="M589,19126.5L598,19126.5"></path></g><path id="node_outline1766" fill="none" stroke="none" d="M604.5,19117.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1766" fill="black"><text id="kity_text_12254" text-rendering="inherit" font-size="12" dy=".8em" y="19118.700000047684" x="604.5">你知道先行发生原则吗</text></g></g><g id="minder_node1768"><g id="node_expander1764" style="cursor: pointer;"><path id="kity_path_25814" fill="white" stroke="gray" d="M746.5,19126.5A6,6,0,1,1,734.5,19126.5A6,6,0,1,1,746.5,19126.5"></path><path id="kity_path_25815" fill="none" stroke="gray" d="M736,19126.5L745,19126.5"></path></g><path id="node_outline1765" fill="none" stroke="none" d="M751.5,19081.5h1326a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1326a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1765" fill="black"><text id="kity_text_12248" text-rendering="inherit" font-size="12" dy=".8em" y="19082.700000047684" x="751.5">1.</text><text id="kity_text_12249" text-rendering="inherit" font-size="12" dy=".8em" y="19100.700000047684" x="751.5">happen-before先行发生是Java内存模型中定义的两项操作之间的偏序关系，比如说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。</text><text id="kity_text_12250" text-rendering="inherit" font-size="12" dy=".8em" y="19118.700000047684" x="751.5">(1)如果操作1 happens-before 操作2，那么第操作1的执行结果将对操作2可见，而且操作1的执行顺序排在第操作2之前。</text><text id="kity_text_12251" text-rendering="inherit" font-size="12" dy=".8em" y="19136.700000047684" x="751.5">(2)两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</text><text id="kity_text_12252" text-rendering="inherit" font-size="12" dy=".8em" y="19154.700000047684" x="751.5">单线程天然满足先行发生原则，前面的所有写对后面的操作可读。</text></g></g><g id="minder_node1769"><g id="node_expander1763" style="cursor: pointer;" display="none"><path id="kity_path_25811" fill="white" stroke="gray" d="M2098.5,19126.5A6,6,0,1,1,2086.5,19126.5A6,6,0,1,1,2098.5,19126.5"></path><path id="kity_path_25812" fill="none" stroke="gray"></path></g><path id="node_outline1764" fill="none" stroke="none" d="M2103.5,19117.5h247a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-247a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1764" fill="black"><text id="kity_text_12246" text-rendering="inherit" font-size="12" dy=".8em" y="19118.700000047684" x="2103.5">https://www.jianshu.com/p/b9186dbebe8e</text></g></g><g id="minder_node1770"><g id="node_expander1768" style="cursor: pointer;"><path id="kity_path_25826" fill="white" stroke="gray" d="M599.5,19197.5A6,6,0,1,1,587.5,19197.5A6,6,0,1,1,599.5,19197.5"></path><path id="kity_path_25827" fill="none" stroke="gray" d="M589,19197.5L598,19197.5"></path></g><path id="node_outline1769" fill="none" stroke="none" d="M604.5,19188.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1769" fill="black"><text id="kity_text_12262" text-rendering="inherit" font-size="12" dy=".8em" y="19189.700000047684" x="604.5">直接内存的使用场景知道吗</text></g></g><g id="minder_node1771"><g id="node_expander1767" style="cursor: pointer;"><path id="kity_path_25823" fill="white" stroke="gray" d="M770.5,19197.5A6,6,0,1,1,758.5,19197.5A6,6,0,1,1,770.5,19197.5"></path><path id="kity_path_25824" fill="none" stroke="gray" d="M760,19197.5L769,19197.5"></path></g><path id="node_outline1768" fill="none" stroke="none" d="M775.5,19179.5h418a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-418a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1768" fill="black"><text id="kity_text_12259" text-rendering="inherit" font-size="12" dy=".8em" y="19180.700000047684" x="775.5">1.nio文件拷贝操作直接内存</text><text id="kity_text_12260" text-rendering="inherit" font-size="12" dy=".8em" y="19198.700000047684" x="775.5">2.memcache就使用利用nio的DirectByteBuffers把长对象存储到直接内存上面</text></g></g><g id="minder_node1772"><g id="node_expander1766" style="cursor: pointer;" display="none"><path id="kity_path_25820" fill="white" stroke="gray" d="M1214.5,19197.5A6,6,0,1,1,1202.5,19197.5A6,6,0,1,1,1214.5,19197.5"></path><path id="kity_path_25821" fill="none" stroke="gray"></path></g><path id="node_outline1767" fill="none" stroke="none" d="M1219.5,19179.5h289a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-289a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1767" fill="black"><text id="kity_text_12256" text-rendering="inherit" font-size="12" dy=".8em" y="19180.700000047684" x="1219.5">https://www.cnblogs.com/duanxz/p/3141647.html</text><text id="kity_text_12257" text-rendering="inherit" font-size="12" dy=".8em" y="19198.700000047684" x="1219.5">https://zhuanlan.zhihu.com/p/161939673</text></g></g><g id="minder_node1773"><g id="node_expander1790" style="cursor: pointer;"><path id="kity_path_25892" fill="white" stroke="gray" d="M544.5,19570.5A6,6,0,1,1,532.5,19570.5A6,6,0,1,1,544.5,19570.5"></path><path id="kity_path_25893" fill="none" stroke="gray" d="M534,19570.5L543,19570.5"></path></g><path id="node_outline1791" fill="none" stroke="none" d="M549.5,19561.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1791" fill="black"><text id="kity_text_12331" text-rendering="inherit" font-size="12" dy=".8em" y="19562.700000047684" x="549.5">内存管理</text></g></g><g id="minder_node1774"><g id="node_expander1771" style="cursor: pointer;"><path id="kity_path_25835" fill="white" stroke="gray" d="M619.5,19268.5A6,6,0,1,1,607.5,19268.5A6,6,0,1,1,619.5,19268.5"></path><path id="kity_path_25836" fill="none" stroke="gray" d="M609,19268.5L618,19268.5"></path></g><path id="node_outline1772" fill="none" stroke="none" d="M624.5,19259.5h110a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-110a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1772" fill="black"><text id="kity_text_12272" text-rendering="inherit" font-size="12" dy=".8em" y="19260.700000047684" x="624.5">说一下内存分配策略</text></g></g><g id="minder_node1775"><g id="node_expander1770" style="cursor: pointer;" display="none"><path id="kity_path_25832" fill="white" stroke="gray" d="M755.5,19268.5A6,6,0,1,1,743.5,19268.5A6,6,0,1,1,755.5,19268.5"></path><path id="kity_path_25833" fill="none" stroke="gray"></path></g><path id="node_outline1771" fill="none" stroke="none" d="M760.5,19223.5h1734a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1734a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1771" fill="black"><text id="kity_text_12266" text-rendering="inherit" font-size="12" dy=".8em" y="19224.700000047684" x="760.5">1.对象优先在伊甸区分配，大多数情况下 对象是在 新生代中的伊甸分配，没有空间 触发 young gc</text><text id="kity_text_12267" text-rendering="inherit" font-size="12" dy=".8em" y="19242.700000047684" x="760.5">2.大对象直接进入老年代， 需要大量连续内存空间的对象，频繁出现大对象是致命的，会导致在内存还有不少空间的情况下提前触发 GC 以获取足够的连续空间来安置新对象。主要是避免了在 新生代和老年代中的频繁的 移动复制</text><text id="kity_text_12268" text-rendering="inherit" font-size="12" dy=".8em" y="19260.700000047684" x="760.5">3.长期存活的对象进入老年代。我们可以通过为对象设置年龄计数器，熬过多少次GC 就进入老年代，`-XX:MaxTenuringThreshold` 用来定义年龄的阈值。</text><text id="kity_text_12269" text-rendering="inherit" font-size="12" dy=".8em" y="19278.700000047684" x="760.5">4.动态对象判断 如果这个对象在幸存区中 的年龄超过了 这个幸存区所有对象年龄的平均值，直接进入老年代</text><text id="kity_text_12270" text-rendering="inherit" font-size="12" dy=".8em" y="19296.700000047684" x="760.5">5.空间分配担保 老年代给新生代空间在担保，检查保证老年代的连续内存空间是超过新生代所有对象的和，如果是超过的话，young gc 没问题，如果不超过的话 首先看是否允许担保失败，如果允许就会检查老年代连续内存是不是一直超过young 空间，如果是就会young gc，如果不是或者不允许担保失败，就可能就会&#xa0; full gc</text></g></g><g id="minder_node1776"><g id="node_expander1773" style="cursor: pointer;"><path id="kity_path_25841" fill="white" stroke="gray" d="M619.5,19366.5A6,6,0,1,1,607.5,19366.5A6,6,0,1,1,619.5,19366.5"></path><path id="kity_path_25842" fill="none" stroke="gray" d="M609,19366.5L618,19366.5"></path></g><path id="node_outline1774" fill="none" stroke="none" d="M624.5,19357.5h181a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-181a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1774" fill="black"><text id="kity_text_12280" text-rendering="inherit" font-size="12" dy=".8em" y="19358.700000047684" x="624.5">知道内存泄漏和内存溢出的区别吗</text></g></g><g id="minder_node1777"><g id="node_expander1772" style="cursor: pointer;" display="none"><path id="kity_path_25838" fill="white" stroke="gray" d="M826.5,19366.5A6,6,0,1,1,814.5,19366.5A6,6,0,1,1,826.5,19366.5"></path><path id="kity_path_25839" fill="none" stroke="gray"></path></g><path id="node_outline1773" fill="none" stroke="none" d="M831.5,19321.5h909a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-909a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1773" fill="black"><text id="kity_text_12274" text-rendering="inherit" font-size="12" dy=".8em" y="19322.700000047684" x="831.5">1.</text><text id="kity_text_12275" text-rendering="inherit" font-size="12" dy=".8em" y="19340.700000047684" x="831.5">内存泄漏： 就是申请了内存使用完不还回去 某一个对象应该被回收 但是因为GCRoot的存在 而没有被回收，比如说10M内存，5M长期不回收，可用的只有5M，泄露的5M</text><text id="kity_text_12276" text-rendering="inherit" font-size="12" dy=".8em" y="19358.700000047684" x="831.5">内存溢出：	在申请内存时，没有足够的内存空间供其使用，出现out of memory；</text><text id="kity_text_12277" text-rendering="inherit" font-size="12" dy=".8em" y="19376.700000047684" x="831.5">2.</text><text id="kity_text_12278" text-rendering="inherit" font-size="12" dy=".8em" y="19394.700000047684" x="831.5">内存泄漏增多最后的结果就是内存溢出，导致没有可用的内存创建新对象。但是内存溢出的原因不一定是内存泄漏</text></g></g><g id="minder_node1778"><g id="node_expander1776" style="cursor: pointer;"><path id="kity_path_25850" fill="white" stroke="gray" d="M619.5,19491.5A6,6,0,1,1,607.5,19491.5A6,6,0,1,1,619.5,19491.5"></path><path id="kity_path_25851" fill="none" stroke="gray" d="M609,19491.5L618,19491.5"></path></g><path id="node_outline1777" fill="none" stroke="none" d="M624.5,19482.5h217a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-217a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1777" fill="black"><text id="kity_text_12293" text-rendering="inherit" font-size="12" dy=".8em" y="19483.700000047684" x="624.5">什么原因会导致内存泄漏，和内存溢出呢</text></g></g><g id="minder_node1779"><g id="node_expander1775" style="cursor: pointer;"><path id="kity_path_25847" fill="white" stroke="gray" d="M862.5,19491.5A6,6,0,1,1,850.5,19491.5A6,6,0,1,1,862.5,19491.5"></path><path id="kity_path_25848" fill="none" stroke="gray" d="M852,19491.5L861,19491.5"></path></g><path id="node_outline1776" fill="none" stroke="none" d="M867.5,19419.5h937a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-937a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text1776" fill="black"><text id="kity_text_12284" text-rendering="inherit" font-size="12" dy=".8em" y="19420.700000047684" x="867.5">1.内存泄漏</text><text id="kity_text_12285" text-rendering="inherit" font-size="12" dy=".8em" y="19438.700000047684" x="867.5">循环过多或死循环，产生大量对象；</text><text id="kity_text_12286" text-rendering="inherit" font-size="12" dy=".8em" y="19456.700000047684" x="867.5">静态集合类引起内存泄漏，因为静态集合的生命周期和 JVM 一致，所以静态集合引用的对象不能被释放；</text><text id="kity_text_12287" text-rendering="inherit" font-size="12" dy=".8em" y="19474.700000047684" x="867.5">长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收。</text><text id="kity_text_12288" text-rendering="inherit" font-size="12" dy=".8em" y="19492.700000047684" x="867.5">网络连接（socket）和io连接 等 除非显示的调用了其close()方法（或类似方法）将其连接关闭，否则是不会自动被GC回收的。因为长生命周期对象持有短生命周期对象的引用。</text><text id="kity_text_12289" text-rendering="inherit" font-size="12" dy=".8em" y="19510.700000047684" x="867.5">如果单例对象持有外部对象的引用，那么这个外部对象将不能被JVM正常回收，导致内存泄漏。</text><text id="kity_text_12290" text-rendering="inherit" font-size="12" dy=".8em" y="19528.700000047684" x="867.5">2.内存溢出</text><text id="kity_text_12291" text-rendering="inherit" font-size="12" dy=".8em" y="19546.700000047684" x="867.5">比如说栈内存溢出。死递归。</text></g></g><g id="minder_node1780"><g id="node_expander1774" style="cursor: pointer;" display="none"><path id="kity_path_25844" fill="white" stroke="gray" d="M1825.5,19492A6,6,0,1,1,1813.5,19492A6,6,0,1,1,1825.5,19492"></path><path id="kity_path_25845" fill="none" stroke="gray"></path></g><path id="node_outline1775" fill="none" stroke="none" d="M1830.5,19480.5h117a5,5,0,0,1,5,5v13a5,5,0,0,1,-5,5h-117a5,5,0,0,1,-5,-5v-13a5,5,0,0,1,5,-5z"></path><g id="node_text1775" fill="black"><text id="kity_text_12282" text-rendering="inherit" font-size="12" dy=".8em" y="19483.700000047684" x="1830.5">内存泄漏参考代码</text></g><g id="kity_g_17000" style="cursor: pointer;"><path id="kity_path_17001" fill="none" stroke="none" d="M1934,19483h12a2,2,0,0,1,2,2v13a2,2,0,0,1,-2,2h-12a2,2,0,0,1,-2,-2v-13a2,2,0,0,1,2,-2z"></path><path id="kity_path_17002" fill="black" stroke="none" d="M1943,19494H1937V19493h6L1943,19494L1943,19494zM1943,19492H1937V19491h6V19492zM1943,19490H1937V19489h6V19490zM1942.5,19496H1936V19487h8v7.5M1943,19497l2,-2V19486H1935v11"></path></g></g><g id="minder_node1781"><g id="node_expander1778" style="cursor: pointer;"><path id="kity_path_25856" fill="white" stroke="gray" d="M619.5,19607.5A6,6,0,1,1,607.5,19607.5A6,6,0,1,1,619.5,19607.5"></path><path id="kity_path_25857" fill="none" stroke="gray" d="M609,19607.5L618,19607.5"></path></g><path id="node_outline1779" fill="none" stroke="none" d="M624.5,19598.5h158a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-158a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1779" fill="black"><text id="kity_text_12300" text-rendering="inherit" font-size="12" dy=".8em" y="19599.700000047684" x="624.5">对象的访问定位有哪几种方式</text></g></g><g id="minder_node1782"><g id="node_expander1777" style="cursor: pointer;" display="none"><path id="kity_path_25853" fill="white" stroke="gray" d="M803.5,19607.5A6,6,0,1,1,791.5,19607.5A6,6,0,1,1,803.5,19607.5"></path><path id="kity_path_25854" fill="none" stroke="gray"></path></g><path id="node_outline1778" fill="none" stroke="none" d="M808.5,19571.5h1293a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1293a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1778" fill="black"><text id="kity_text_12295" text-rendering="inherit" font-size="12" dy=".8em" y="19572.700000047684" x="808.5">1.句柄访问方式：</text><text id="kity_text_12296" text-rendering="inherit" font-size="12" dy=".8em" y="19590.700000047684" x="808.5">使用句柄来访问的最大好处就是引用中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。</text><text id="kity_text_12297" text-rendering="inherit" font-size="12" dy=".8em" y="19608.700000047684" x="808.5">2.直接指针访问方式</text><text id="kity_text_12298" text-rendering="inherit" font-size="12" dy=".8em" y="19626.700000047684" x="808.5">引用中存储的指针就是对象地址。最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。Sun HotSpot使用 直接指针访问方式 进行对象访问的。</text></g></g><g id="minder_node1783"><g id="node_expander1780" style="cursor: pointer;"><path id="kity_path_25862" fill="white" stroke="gray" d="M619.5,19687.5A6,6,0,1,1,607.5,19687.5A6,6,0,1,1,619.5,19687.5"></path><path id="kity_path_25863" fill="none" stroke="gray" d="M609,19687.5L618,19687.5"></path></g><path id="node_outline1781" fill="none" stroke="none" d="M624.5,19678.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1781" fill="black"><text id="kity_text_12307" text-rendering="inherit" font-size="12" dy=".8em" y="19679.700000047684" x="624.5">说说对象的内存布局</text></g></g><g id="minder_node1784"><g id="node_expander1779" style="cursor: pointer;" display="none"><path id="kity_path_25859" fill="white" stroke="gray" d="M754.5,19687.5A6,6,0,1,1,742.5,19687.5A6,6,0,1,1,754.5,19687.5"></path><path id="kity_path_25860" fill="none" stroke="gray"></path></g><path id="node_outline1780" fill="none" stroke="none" d="M759.5,19651.5h860a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-860a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1780" fill="black"><text id="kity_text_12302" text-rendering="inherit" font-size="12" dy=".8em" y="19652.700000047684" x="759.5">1.堆中创建的对象由三部分组成，</text><text id="kity_text_12303" text-rendering="inherit" font-size="12" dy=".8em" y="19670.700000047684" x="759.5">对象头：主要是两部分，(1)是指向它的类元数据的指针,表明是哪个类的实例 (2)哈希码，GC分代年龄，锁标志状态，锁指针。如果是数组对象，还会有数组的长度</text><text id="kity_text_12304" text-rendering="inherit" font-size="12" dy=".8em" y="19688.700000047684" x="759.5">实例变量：主要是保存对象的全局变量，包括父类的全局变量，和本类的全局变量</text><text id="kity_text_12305" text-rendering="inherit" font-size="12" dy=".8em" y="19706.700000047684" x="759.5">填充数据：主要是让对象的长度保持在8字节的整数倍</text></g></g><g id="minder_node1785"><g id="node_expander1782" style="cursor: pointer;"><path id="kity_path_25868" fill="white" stroke="gray" d="M619.5,19758.5A6,6,0,1,1,607.5,19758.5A6,6,0,1,1,619.5,19758.5"></path><path id="kity_path_25869" fill="none" stroke="gray" d="M609,19758.5L618,19758.5"></path></g><path id="node_outline1783" fill="none" stroke="none" d="M624.5,19749.5h194a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-194a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1783" fill="black"><text id="kity_text_12313" text-rendering="inherit" font-size="12" dy=".8em" y="19750.700000047684" x="624.5">你说了对象头，那对象头里面有什么</text></g></g><g id="minder_node1786"><g id="node_expander1781" style="cursor: pointer;" display="none"><path id="kity_path_25865" fill="white" stroke="gray" d="M839.5,19758.5A6,6,0,1,1,827.5,19758.5A6,6,0,1,1,839.5,19758.5"></path><path id="kity_path_25866" fill="none" stroke="gray"></path></g><path id="node_outline1782" fill="none" stroke="none" d="M844.5,19731.5h1363a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1363a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1782" fill="black"><text id="kity_text_12309" text-rendering="inherit" font-size="12" dy=".8em" y="19732.700000047684" x="844.5">1.</text><text id="kity_text_12310" text-rendering="inherit" font-size="12" dy=".8em" y="19750.700000047684" x="844.5">MarkWord（标记字段）：哈希码、分代年龄、锁标志位，轻量级锁指向锁记录指针地址，重量级锁指向监视器指针地址、偏向线程ID、偏向时间戳等信息。</text><text id="kity_text_12311" text-rendering="inherit" font-size="12" dy=".8em" y="19768.700000047684" x="844.5">Mark Word被设计成了一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。如果是数组的话，还需要有一块区域存放数组大小，因为没办法从元数据确认数组大小，所以要存储到对象头的MarkWord中。</text></g></g><g id="minder_node1787"><g id="node_expander1784" style="cursor: pointer;"><path id="kity_path_25874" fill="white" stroke="gray" d="M619.5,19802.5A6,6,0,1,1,607.5,19802.5A6,6,0,1,1,619.5,19802.5"></path><path id="kity_path_25875" fill="none" stroke="gray" d="M609,19802.5L618,19802.5"></path></g><path id="node_outline1785" fill="none" stroke="none" d="M624.5,19793.5h199a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-199a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1785" fill="black"><text id="kity_text_12317" text-rendering="inherit" font-size="12" dy=".8em" y="19794.700000047684" x="624.5">64位系统 对象头的锁标志位占多少位</text></g></g><g id="minder_node1788"><g id="node_expander1783" style="cursor: pointer;" display="none"><path id="kity_path_25871" fill="white" stroke="gray" d="M844.5,19802.5A6,6,0,1,1,832.5,19802.5A6,6,0,1,1,844.5,19802.5"></path><path id="kity_path_25872" fill="none" stroke="gray"></path></g><path id="node_outline1784" fill="none" stroke="none" d="M849.5,19793.5h35a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-35a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1784" fill="black"><text id="kity_text_12315" text-rendering="inherit" font-size="12" dy=".8em" y="19794.700000047684" x="849.5">1.两位</text></g></g><g id="minder_node1789"><g id="node_expander1786" style="cursor: pointer;"><path id="kity_path_25880" fill="white" stroke="gray" d="M619.5,19828.5A6,6,0,1,1,607.5,19828.5A6,6,0,1,1,619.5,19828.5"></path><path id="kity_path_25881" fill="none" stroke="gray" d="M609,19828.5L618,19828.5"></path></g><path id="node_outline1787" fill="none" stroke="none" d="M624.5,19819.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1787" fill="black"><text id="kity_text_12321" text-rendering="inherit" font-size="12" dy=".8em" y="19820.700000047684" x="624.5">你怎么查看的对象头</text></g></g><g id="minder_node1790"><g id="node_expander1785" style="cursor: pointer;" display="none"><path id="kity_path_25877" fill="white" stroke="gray" d="M754.5,19828.5A6,6,0,1,1,742.5,19828.5A6,6,0,1,1,754.5,19828.5"></path><path id="kity_path_25878" fill="none" stroke="gray"></path></g><path id="node_outline1786" fill="none" stroke="none" d="M759.5,19819.5h379a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-379a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1786" fill="black"><text id="kity_text_12319" text-rendering="inherit" font-size="12" dy=".8em" y="19820.700000047684" x="759.5">1.第三方工具JOL，就可以打印出对象头的信息，具体没有仔细研究过，</text></g></g><g id="minder_node1791"><g id="node_expander1789" style="cursor: pointer;"><path id="kity_path_25889" fill="white" stroke="gray" d="M619.5,19872.5A6,6,0,1,1,607.5,19872.5A6,6,0,1,1,619.5,19872.5"></path><path id="kity_path_25890" fill="none" stroke="gray" d="M609,19872.5L618,19872.5"></path></g><path id="node_outline1790" fill="none" stroke="none" d="M624.5,19863.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1790" fill="black"><text id="kity_text_12329" text-rendering="inherit" font-size="12" dy=".8em" y="19864.700000047684" x="624.5">对象头占多少字节知道吗</text></g></g><g id="minder_node1792"><g id="node_expander1788" style="cursor: pointer;"><path id="kity_path_25886" fill="white" stroke="gray" d="M778.5,19872.5A6,6,0,1,1,766.5,19872.5A6,6,0,1,1,778.5,19872.5"></path><path id="kity_path_25887" fill="none" stroke="gray" d="M768,19872.5L777,19872.5"></path></g><path id="node_outline1789" fill="none" stroke="none" d="M783.5,19845.5h460a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-460a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1789" fill="black"><text id="kity_text_12325" text-rendering="inherit" font-size="12" dy=".8em" y="19846.700000047684" x="783.5">1.开启指针压缩，是12位，错了？具体没有研究过，</text><text id="kity_text_12326" text-rendering="inherit" font-size="12" dy=".8em" y="19864.700000047684" x="783.5">2.应该是普通对象8位，数组12位。错了？那不知道了</text><text id="kity_text_12327" text-rendering="inherit" font-size="12" dy=".8em" y="19882.700000047684" x="783.5">3.32位是8位，64位16位，64位开启指针压缩是12位(class指针4+对象头8)数组是16位</text></g></g><g id="minder_node1793"><g id="node_expander1787" style="cursor: pointer;" display="none"><path id="kity_path_25883" fill="white" stroke="gray" d="M1264.5,19872.5A6,6,0,1,1,1252.5,19872.5A6,6,0,1,1,1264.5,19872.5"></path><path id="kity_path_25884" fill="none" stroke="gray"></path></g><path id="node_outline1788" fill="none" stroke="none" d="M1269.5,19863.5h284a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-284a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1788" fill="black"><text id="kity_text_12323" text-rendering="inherit" font-size="12" dy=".8em" y="19864.700000047684" x="1269.5">https://www.cnblogs.com/yewy/p/13584915.html</text></g></g><g id="minder_node1794"><g id="node_expander1848" style="cursor: pointer;"><path id="kity_path_26066" fill="white" stroke="gray" d="M544.5,21124.5A6,6,0,1,1,532.5,21124.5A6,6,0,1,1,544.5,21124.5"></path><path id="kity_path_26067" fill="none" stroke="gray" d="M534,21124.5L543,21124.5"></path></g><path id="node_outline1849" fill="none" stroke="none" d="M549.5,21115.5h17a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-17a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1849" fill="black"><text id="kity_text_12553" text-rendering="inherit" font-size="12" dy=".8em" y="21116.700000047684" x="549.5">GC</text></g></g><g id="minder_node1795"><g id="node_expander1792" style="cursor: pointer;"><path id="kity_path_25898" fill="white" stroke="gray" d="M587.5,19916.5A6,6,0,1,1,575.5,19916.5A6,6,0,1,1,587.5,19916.5"></path><path id="kity_path_25899" fill="none" stroke="gray" d="M577,19916.5L586,19916.5"></path></g><path id="node_outline1793" fill="none" stroke="none" d="M592.5,19907.5h88a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-88a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1793" fill="black"><text id="kity_text_12335" text-rendering="inherit" font-size="12" dy=".8em" y="19908.700000047684" x="592.5">说一下gc是什么</text></g></g><g id="minder_node1796"><g id="node_expander1791" style="cursor: pointer;" display="none"><path id="kity_path_25895" fill="white" stroke="gray" d="M701.5,19916.5A6,6,0,1,1,689.5,19916.5A6,6,0,1,1,701.5,19916.5"></path><path id="kity_path_25896" fill="none" stroke="gray"></path></g><path id="node_outline1792" fill="none" stroke="none" d="M706.5,19907.5h1445a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1445a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1792" fill="black"><text id="kity_text_12333" text-rendering="inherit" font-size="12" dy=".8em" y="19908.700000047684" x="706.5">1.GC 就是垃圾收集的意思,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。</text></g></g><g id="minder_node1797"><g id="node_expander1795" style="cursor: pointer;"><path id="kity_path_25907" fill="white" stroke="gray" d="M587.5,19978.5A6,6,0,1,1,575.5,19978.5A6,6,0,1,1,587.5,19978.5"></path><path id="kity_path_25908" fill="none" stroke="gray" d="M577,19978.5L586,19978.5"></path></g><path id="node_outline1796" fill="none" stroke="none" d="M592.5,19969.5h229a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-229a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1796" fill="black"><text id="kity_text_12345" text-rendering="inherit" font-size="12" dy=".8em" y="19970.700000047684" x="592.5">说说java的引用类型有哪些，分别表示什么</text></g></g><g id="minder_node1798"><g id="node_expander1794" style="cursor: pointer;"><path id="kity_path_25904" fill="white" stroke="gray" d="M842.5,19978.5A6,6,0,1,1,830.5,19978.5A6,6,0,1,1,842.5,19978.5"></path><path id="kity_path_25905" fill="none" stroke="gray" d="M832,19978.5L841,19978.5"></path></g><path id="node_outline1795" fill="none" stroke="none" d="M847.5,19933.5h966a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-966a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1795" fill="black"><text id="kity_text_12339" text-rendering="inherit" font-size="12" dy=".8em" y="19934.700000047684" x="847.5">1.</text><text id="kity_text_12340" text-rendering="inherit" font-size="12" dy=".8em" y="19952.700000047684" x="847.5">强引用：发生 gc 的时候不会被回收。垃圾回收器绝对不会回收它，内存不足时宁愿抛出OOM导致程序异常</text><text id="kity_text_12341" text-rendering="inherit" font-size="12" dy=".8em" y="19970.700000047684" x="847.5">软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</text><text id="kity_text_12342" text-rendering="inherit" font-size="12" dy=".8em" y="19988.700000047684" x="847.5">弱引用：扫描到该对象时无论内存是否充足都会回收该对象。ThreadLocal 的Key就是弱引用。</text><text id="kity_text_12343" text-rendering="inherit" font-size="12" dy=".8em" y="20006.700000047684" x="847.5">虚引用：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。任何适合都可以被回收。主要用跟踪对象跟垃圾回收器回收的活动。</text></g></g><g id="minder_node1799"><g id="node_expander1793" style="cursor: pointer;" display="none"><path id="kity_path_25901" fill="white" stroke="gray" d="M1834.5,19978.5A6,6,0,1,1,1822.5,19978.5A6,6,0,1,1,1834.5,19978.5"></path><path id="kity_path_25902" fill="none" stroke="gray"></path></g><path id="node_outline1794" fill="none" stroke="none" d="M1839.5,19969.5h327a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-327a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1794" fill="black"><text id="kity_text_12337" text-rendering="inherit" font-size="12" dy=".8em" y="19970.700000047684" x="1839.5">https://juejin.cn/post/6844904165563432974#heading-4</text></g></g><g id="minder_node1800"><g id="node_expander1798" style="cursor: pointer;"><path id="kity_path_25916" fill="white" stroke="gray" d="M587.5,20094.5A6,6,0,1,1,575.5,20094.5A6,6,0,1,1,587.5,20094.5"></path><path id="kity_path_25917" fill="none" stroke="gray" d="M577,20094.5L586,20094.5"></path></g><path id="node_outline1799" fill="none" stroke="none" d="M592.5,20085.5h265a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-265a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1799" fill="black"><text id="kity_text_12358" text-rendering="inherit" font-size="12" dy=".8em" y="20086.700000047684" x="592.5">软引用怎么实现的？使用场景？哪些地方用到它？</text></g></g><g id="minder_node1801"><g id="node_expander1797" style="cursor: pointer;"><path id="kity_path_25913" fill="white" stroke="gray" d="M878.5,20094.5A6,6,0,1,1,866.5,20094.5A6,6,0,1,1,878.5,20094.5"></path><path id="kity_path_25914" fill="none" stroke="gray" d="M868,20094.5L877,20094.5"></path></g><path id="node_outline1798" fill="none" stroke="none" d="M883.5,20031.5h1620a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-1620a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text1798" fill="black"><text id="kity_text_12350" text-rendering="inherit" font-size="12" dy=".8em" y="20032.700000047684" x="883.5">1.使用 WeakReference 类来实现弱引用。Object obj = new Object(); WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);</text><text id="kity_text_12351" text-rendering="inherit" font-size="12" dy=".8em" y="20050.700000047684" x="883.5">2.场景</text><text id="kity_text_12352" text-rendering="inherit" font-size="12" dy=".8em" y="20068.700000047684" x="883.5">正常来说 我们使用一个静态成员变量的HashMap，我们在其他方法调用add，但是我们希望在方法结束后里面数据并gc，而实际情况是，即使我们把这个map的k-v都设置成了null来告诉JVM回收，依然不会回收。也就是</text><text id="kity_text_12353" text-rendering="inherit" font-size="12" dy=".8em" y="20086.700000047684" x="883.5">这个map是一个生命周期长对象，然后我们在方法内部不remove 就会有大量的K-V短对象，这些最终就有可能消耗掉JVM中全部的内存。导致内存泄漏而内存溢出。这个时侯可以所有一个弱引用的hashmap( static Map&lt;WeakReference&lt;String&gt;, String&gt; map; ).那么就可以不remove 而被垃圾回收掉。</text><text id="kity_text_12354" text-rendering="inherit" font-size="12" dy=".8em" y="20104.700000047684" x="883.5">可以使用WeakHashMap, 内部有一个引用队列，在弱引用被回收的时候会把该对象放到引用队列中，也就意味着从引用队列中获取的对象都是被回收的对象，</text><text id="kity_text_12355" text-rendering="inherit" font-size="12" dy=".8em" y="20122.700000047684" x="883.5">3.threadlocal中的底层结构entry就继承了WeakReference，表明是一个弱引用。entry是threadlocalmap存储数据的map。目的是将ThreadLocal对象生命周期跟线程周期解绑</text><text id="kity_text_12356" text-rendering="inherit" font-size="12" dy=".8em" y="20140.700000047684" x="883.5">而为什么使用弱引用 主要是为了尽量减少threadlocal在我们没有remove时 Thread仍然运行的前提下 弱引用的 key为null ，那么value也会被设置为null 那么后面调用这个threadlocal时再操作set get就可以gc这些k-v都为null的entry 防止内存泄漏。</text></g></g><g id="minder_node1802"><g id="node_expander1796" style="cursor: pointer;" display="none"><path id="kity_path_25910" fill="white" stroke="gray" d="M2524.5,20094.5A6,6,0,1,1,2512.5,20094.5A6,6,0,1,1,2524.5,20094.5"></path><path id="kity_path_25911" fill="none" stroke="gray"></path></g><path id="node_outline1797" fill="none" stroke="none" d="M2529.5,20076.5h328a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-328a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1797" fill="black"><text id="kity_text_12347" text-rendering="inherit" font-size="12" dy=".8em" y="20077.700000047684" x="2529.5">https://www.jianshu.com/p/825cca41d962</text><text id="kity_text_12348" text-rendering="inherit" font-size="12" dy=".8em" y="20095.700000047684" x="2529.5">https://mp.weixin.qq.com/s/G9ISms47K6Kwz9_NPE0wXw</text></g></g><g id="minder_node1803"><g id="node_expander1800" style="cursor: pointer;"><path id="kity_path_25922" fill="white" stroke="gray" d="M587.5,20210.5A6,6,0,1,1,575.5,20210.5A6,6,0,1,1,587.5,20210.5"></path><path id="kity_path_25923" fill="none" stroke="gray" d="M577,20210.5L586,20210.5"></path></g><path id="node_outline1801" fill="none" stroke="none" d="M592.5,20201.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1801" fill="black"><text id="kity_text_12366" text-rendering="inherit" font-size="12" dy=".8em" y="20202.700000047684" x="592.5">怎么判断一个对象是否存活呢</text></g></g><g id="minder_node1804"><g id="node_expander1799" style="cursor: pointer;" display="none"><path id="kity_path_25919" fill="white" stroke="gray" d="M770.5,20210.5A6,6,0,1,1,758.5,20210.5A6,6,0,1,1,770.5,20210.5"></path><path id="kity_path_25920" fill="none" stroke="gray"></path></g><path id="node_outline1800" fill="none" stroke="none" d="M775.5,20165.5h790a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-790a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1800" fill="black"><text id="kity_text_12360" text-rendering="inherit" font-size="12" dy=".8em" y="20166.700000047684" x="775.5">1.引用计数法</text><text id="kity_text_12361" text-rendering="inherit" font-size="12" dy=".8em" y="20184.700000047684" x="775.5">就是在对象头维护了一个count计数器，然后只要对象被引用了一次，就+1，如引用失效就-1如果为0&#xa0; 什么对象就是无效对象。</text><text id="kity_text_12362" text-rendering="inherit" font-size="12" dy=".8em" y="20202.700000047684" x="775.5">引用计数法的效率比较高，但是不能解决循环引用的问题</text><text id="kity_text_12363" text-rendering="inherit" font-size="12" dy=".8em" y="20220.700000047684" x="775.5">2.可达性分析</text><text id="kity_text_12364" text-rendering="inherit" font-size="12" dy=".8em" y="20238.700000047684" x="775.5">以GCROOT为起点开始搜索，可达的对象都是活着的，不可达的对象都是无效对象。然后 gcroot不包括堆中的引用对象，这样避免了循环引用的问题</text></g></g><g id="minder_node1805"><g id="node_expander1802" style="cursor: pointer;"><path id="kity_path_25928" fill="white" stroke="gray" d="M587.5,20335.5A6,6,0,1,1,575.5,20335.5A6,6,0,1,1,587.5,20335.5"></path><path id="kity_path_25929" fill="none" stroke="gray" d="M577,20335.5L586,20335.5"></path></g><path id="node_outline1803" fill="none" stroke="none" d="M592.5,20326.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1803" fill="black"><text id="kity_text_12377" text-rendering="inherit" font-size="12" dy=".8em" y="20327.700000047684" x="592.5">说一下可达性分析的过程？</text></g></g><g id="minder_node1806"><g id="node_expander1801" style="cursor: pointer;" display="none"><path id="kity_path_25925" fill="white" stroke="gray" d="M758.5,20335.5A6,6,0,1,1,746.5,20335.5A6,6,0,1,1,758.5,20335.5"></path><path id="kity_path_25926" fill="none" stroke="gray"></path></g><path id="node_outline1802" fill="none" stroke="none" d="M763.5,20263.5h892a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-892a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text1802" fill="black"><text id="kity_text_12368" text-rendering="inherit" font-size="12" dy=".8em" y="20264.700000047684" x="763.5">1.</text><text id="kity_text_12369" text-rendering="inherit" font-size="12" dy=".8em" y="20282.700000047684" x="763.5">当一个对象到 GC Roots 没有任何引用链相连时，则判断该对象不可达。可达性分析仅仅只是判断对象是否可达，但还不足以判断对象是否存活 / 死亡。</text><text id="kity_text_12370" text-rendering="inherit" font-size="12" dy=".8em" y="20300.700000047684" x="763.5">2.第一次标记 &amp; 筛选</text><text id="kity_text_12371" text-rendering="inherit" font-size="12" dy=".8em" y="20318.700000047684" x="763.5">如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记</text><text id="kity_text_12372" text-rendering="inherit" font-size="12" dy=".8em" y="20336.700000047684" x="763.5">筛选的条件 对象是否有必要执行finalize() 如果没有重写finalize或者调用过finalize 则将该对象加入到F-Queue中，等待线程运行执行自救。但是不一定能够执行完成。</text><text id="kity_text_12373" text-rendering="inherit" font-size="12" dy=".8em" y="20354.700000047684" x="763.5">3.第二次标记 &amp; 筛选</text><text id="kity_text_12374" text-rendering="inherit" font-size="12" dy=".8em" y="20372.700000047684" x="763.5">第二次标记如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，那在第二次标记时它将被移出“即将回收”的集合，成功自救</text><text id="kity_text_12375" text-rendering="inherit" font-size="12" dy=".8em" y="20390.700000047684" x="763.5">否则经过F-Queue筛选后如果对象还没有跟GC Root建立引用关系则被回收。</text></g></g><g id="minder_node1807"><g id="node_expander1804" style="cursor: pointer;"><path id="kity_path_25934" fill="white" stroke="gray" d="M587.5,20469.5A6,6,0,1,1,575.5,20469.5A6,6,0,1,1,587.5,20469.5"></path><path id="kity_path_25935" fill="none" stroke="gray" d="M577,20469.5L586,20469.5"></path></g><path id="node_outline1805" fill="none" stroke="none" d="M592.5,20460.5h99a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-99a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1805" fill="black"><text id="kity_text_12386" text-rendering="inherit" font-size="12" dy=".8em" y="20461.700000047684" x="592.5">gcroot可达性流程</text></g></g><g id="minder_node1808"><g id="node_expander1803" style="cursor: pointer;" display="none"><path id="kity_path_25931" fill="white" stroke="gray" d="M712.5,20469.5A6,6,0,1,1,700.5,20469.5A6,6,0,1,1,712.5,20469.5"></path><path id="kity_path_25932" fill="none" stroke="gray"></path></g><path id="node_outline1804" fill="none" stroke="none" d="M717.5,20415.5h892a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-892a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1804" fill="black"><text id="kity_text_12379" text-rendering="inherit" font-size="12" dy=".8em" y="20416.700000047684" x="717.5">1.第一次标记 &amp; 筛选</text><text id="kity_text_12380" text-rendering="inherit" font-size="12" dy=".8em" y="20434.700000047684" x="717.5">如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记</text><text id="kity_text_12381" text-rendering="inherit" font-size="12" dy=".8em" y="20452.700000047684" x="717.5">筛选的条件 对象是否有必要执行finalize() 如果没有重写finalize或者调用过finalize 则将该对象加入到F-Queue中，等待线程运行执行自救。但是不一定能够执行完成。</text><text id="kity_text_12382" text-rendering="inherit" font-size="12" dy=".8em" y="20470.700000047684" x="717.5">2.第二次标记 &amp; 筛选</text><text id="kity_text_12383" text-rendering="inherit" font-size="12" dy=".8em" y="20488.700000047684" x="717.5">第二次标记如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，那在第二次标记时它将被移出“即将回收”的集合，成功自救</text><text id="kity_text_12384" text-rendering="inherit" font-size="12" dy=".8em" y="20506.700000047684" x="717.5">否则经过F-Queue筛选后如果对象还没有跟GC Root建立引用关系则被回收。</text></g></g><g id="minder_node1809"><g id="node_expander1806" style="cursor: pointer;"><path id="kity_path_25940" fill="white" stroke="gray" d="M587.5,20576.5A6,6,0,1,1,575.5,20576.5A6,6,0,1,1,587.5,20576.5"></path><path id="kity_path_25941" fill="none" stroke="gray" d="M577,20576.5L586,20576.5"></path></g><path id="node_outline1807" fill="none" stroke="none" d="M592.5,20567.5h170a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-170a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1807" fill="black"><text id="kity_text_12394" text-rendering="inherit" font-size="12" dy=".8em" y="20568.700000047684" x="592.5">那么哪些对象可以成为gcroot？</text></g></g><g id="minder_node1810"><g id="node_expander1805" style="cursor: pointer;" display="none"><path id="kity_path_25937" fill="white" stroke="gray" d="M783.5,20576.5A6,6,0,1,1,771.5,20576.5A6,6,0,1,1,783.5,20576.5"></path><path id="kity_path_25938" fill="none" stroke="gray"></path></g><path id="node_outline1806" fill="none" stroke="none" d="M788.5,20531.5h1306a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1306a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1806" fill="black"><text id="kity_text_12388" text-rendering="inherit" font-size="12" dy=".8em" y="20532.700000047684" x="788.5">1.虚拟机栈中引用的对象。创建一个对象，对象会在堆上开辟一块空间，同时会将这块空间的地址作为引用保存到虚拟机栈中，如果对象生命周期结束了，那么引用就会从虚拟机栈中出栈，因此如果在虚拟机栈中有引用，就说明这个对象还是有用的</text><text id="kity_text_12389" text-rendering="inherit" font-size="12" dy=".8em" y="20550.700000047684" x="788.5">2.方法区中类静态属性引用的对象，也就是使用了static关键字</text><text id="kity_text_12390" text-rendering="inherit" font-size="12" dy=".8em" y="20568.700000047684" x="788.5">3.方法区中常量引用的对象,使用了static final关键字，由于这种引用初始化之后不会修改，所以方法区常量池里的引用的对象也应该作为GC Roots。</text><text id="kity_text_12391" text-rendering="inherit" font-size="12" dy=".8em" y="20586.700000047684" x="788.5">4.本地方法栈中JNI引用的对象（使用Native方法）本地方法栈中引用的对象也会被作为GC Roots。</text><text id="kity_text_12392" text-rendering="inherit" font-size="12" dy=".8em" y="20604.700000047684" x="788.5">不包括堆中的引用对象</text></g></g><g id="minder_node1811"><g id="node_expander1808" style="cursor: pointer;"><path id="kity_path_25946" fill="white" stroke="gray" d="M587.5,20647.5A6,6,0,1,1,575.5,20647.5A6,6,0,1,1,587.5,20647.5"></path><path id="kity_path_25947" fill="none" stroke="gray" d="M577,20647.5L586,20647.5"></path></g><path id="node_outline1809" fill="none" stroke="none" d="M592.5,20638.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1809" fill="black"><text id="kity_text_12399" text-rendering="inherit" font-size="12" dy=".8em" y="20639.700000047684" x="592.5">不可达一定会被回收？</text></g></g><g id="minder_node1812"><g id="node_expander1807" style="cursor: pointer;" display="none"><path id="kity_path_25943" fill="white" stroke="gray" d="M734.5,20647.5A6,6,0,1,1,722.5,20647.5A6,6,0,1,1,734.5,20647.5"></path><path id="kity_path_25944" fill="none" stroke="gray"></path></g><path id="node_outline1808" fill="none" stroke="none" d="M739.5,20629.5h805a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-805a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1808" fill="black"><text id="kity_text_12396" text-rendering="inherit" font-size="12" dy=".8em" y="20630.700000047684" x="739.5">1.</text><text id="kity_text_12397" text-rendering="inherit" font-size="12" dy=".8em" y="20648.700000047684" x="739.5">当一个对象到 GC Roots 没有任何引用链相连时，则判断该对象不可达。可达性分析仅仅只是判断对象是否可达，但还不足以判断对象是否存活 / 死亡。</text></g></g><g id="minder_node1813"><g id="node_expander1813" style="cursor: pointer;"><path id="kity_path_25961" fill="white" stroke="gray" d="M587.5,20808.5A6,6,0,1,1,575.5,20808.5A6,6,0,1,1,587.5,20808.5"></path><path id="kity_path_25962" fill="none" stroke="gray" d="M577,20808.5L586,20808.5"></path></g><path id="node_outline1814" fill="none" stroke="none" d="M592.5,20799.5h63a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-63a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1814" fill="black"><text id="kity_text_12418" text-rendering="inherit" font-size="12" dy=".8em" y="20800.700000047684" x="592.5">gc算法相关</text></g></g><g id="minder_node1814"><g id="node_expander1810" style="cursor: pointer;"><path id="kity_path_25952" fill="white" stroke="gray" d="M676.5,20755.5A6,6,0,1,1,664.5,20755.5A6,6,0,1,1,676.5,20755.5"></path><path id="kity_path_25953" fill="none" stroke="gray" d="M666,20755.5L675,20755.5"></path></g><path id="node_outline1811" fill="none" stroke="none" d="M681.5,20746.5h112a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-112a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1811" fill="black"><text id="kity_text_12411" text-rendering="inherit" font-size="12" dy=".8em" y="20747.700000047684" x="681.5">说一下gc算法有哪些</text></g></g><g id="minder_node1815"><g id="node_expander1809" style="cursor: pointer;" display="none"><path id="kity_path_25949" fill="white" stroke="gray" d="M814.5,20755.5A6,6,0,1,1,802.5,20755.5A6,6,0,1,1,814.5,20755.5"></path><path id="kity_path_25950" fill="none" stroke="gray"></path></g><path id="node_outline1810" fill="none" stroke="none" d="M819.5,20674.5h977a5,5,0,0,1,5,5v152a5,5,0,0,1,-5,5h-977a5,5,0,0,1,-5,-5v-152a5,5,0,0,1,5,-5z"></path><g id="node_text1810" fill="black"><text id="kity_text_12401" text-rendering="inherit" font-size="12" dy=".8em" y="20675.700000047684" x="819.5">1.标记-清除算法</text><text id="kity_text_12402" text-rendering="inherit" font-size="12" dy=".8em" y="20693.700000047684" x="819.5">首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。标记和清除都需要遍历，影响性能，效率不高，标记清除之后会产生大量不连续的内存碎片，导致触发GC。</text><text id="kity_text_12403" text-rendering="inherit" font-size="12" dy=".8em" y="20711.700000047684" x="819.5">2.复制算法</text><text id="kity_text_12404" text-rendering="inherit" font-size="12" dy=".8em" y="20729.700000047684" x="819.5">可用内存分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</text><text id="kity_text_12405" text-rendering="inherit" font-size="12" dy=".8em" y="20747.700000047684" x="819.5">内存变小了，空间利用率太低了，还要来回移动数据。</text><text id="kity_text_12406" text-rendering="inherit" font-size="12" dy=".8em" y="20765.700000047684" x="819.5">3.标记-整理算法</text><text id="kity_text_12407" text-rendering="inherit" font-size="12" dy=".8em" y="20783.700000047684" x="819.5">首先标记出所有需要回收的对象，在标记完成后，后续步骤是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。涉及到移动大量对象，效率不高。</text><text id="kity_text_12408" text-rendering="inherit" font-size="12" dy=".8em" y="20801.700000047684" x="819.5">4.分代算法，主流VM算法</text><text id="kity_text_12409" text-rendering="inherit" font-size="12" dy=".8em" y="20819.700000047684" x="819.5">根据对象的存活周期将内存划分为几块。一般包括年轻代、老年代和 永久代(元空间)</text></g></g><g id="minder_node1816"><g id="node_expander1812" style="cursor: pointer;"><path id="kity_path_25958" fill="white" stroke="gray" d="M676.5,20862.5A6,6,0,1,1,664.5,20862.5A6,6,0,1,1,676.5,20862.5"></path><path id="kity_path_25959" fill="none" stroke="gray" d="M666,20862.5L675,20862.5"></path></g><path id="node_outline1813" fill="none" stroke="none" d="M681.5,20853.5h221a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-221a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1813" fill="black"><text id="kity_text_12416" text-rendering="inherit" font-size="12" dy=".8em" y="20854.700000047684" x="681.5">说一下标记整理 标记清除，复制，场景？</text></g></g><g id="minder_node1817"><g id="node_expander1811" style="cursor: pointer;" display="none"><path id="kity_path_25955" fill="white" stroke="gray" d="M923.5,20862.5A6,6,0,1,1,911.5,20862.5A6,6,0,1,1,923.5,20862.5"></path><path id="kity_path_25956" fill="none" stroke="gray"></path></g><path id="node_outline1812" fill="none" stroke="none" d="M928.5,20844.5h820a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-820a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1812" fill="black"><text id="kity_text_12413" text-rendering="inherit" font-size="12" dy=".8em" y="20845.700000047684" x="928.5">1.对于新生代，每次GC时都有大量的对象死亡，只有少量对象存活。考虑到复制成本低，适合采用复制算法。因此有了From Survivor和To Survivor区域。</text><text id="kity_text_12414" text-rendering="inherit" font-size="12" dy=".8em" y="20863.700000047684" x="928.5">2.对于老年代，因为对象存活率高，没有额外的内存空间对它进行担保。因而适合采用标记-清理算法和标记-整理算法进行回收。</text></g></g><g id="minder_node1818"><g id="node_expander1834" style="cursor: pointer;"><path id="kity_path_26024" fill="white" stroke="gray" d="M587.5,21423.5A6,6,0,1,1,575.5,21423.5A6,6,0,1,1,587.5,21423.5"></path><path id="kity_path_26025" fill="none" stroke="gray" d="M577,21423.5L586,21423.5"></path></g><path id="node_outline1835" fill="none" stroke="none" d="M592.5,21414.5h97a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-97a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1835" fill="black"><text id="kity_text_12503" text-rendering="inherit" font-size="12" dy=".8em" y="21415.700000047684" x="592.5">收集器引出的问题</text></g></g><g id="minder_node1819"><g id="node_expander1815" style="cursor: pointer;"><path id="kity_path_25967" fill="white" stroke="gray" d="M710.5,20977.5A6,6,0,1,1,698.5,20977.5A6,6,0,1,1,710.5,20977.5"></path><path id="kity_path_25968" fill="none" stroke="gray" d="M700,20977.5L709,20977.5"></path></g><path id="node_outline1816" fill="none" stroke="none" d="M715.5,20968.5h96a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-96a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1816" fill="black"><text id="kity_text_12431" text-rendering="inherit" font-size="12" dy=".8em" y="20969.700000047684" x="715.5">了解哪些收集器？</text></g></g><g id="minder_node1820"><g id="node_expander1814" style="cursor: pointer;" display="none"><path id="kity_path_25964" fill="white" stroke="gray" d="M832.5,20977.5A6,6,0,1,1,820.5,20977.5A6,6,0,1,1,832.5,20977.5"></path><path id="kity_path_25965" fill="none" stroke="gray"></path></g><path id="node_outline1815" fill="none" stroke="none" d="M837.5,20887.5h650a5,5,0,0,1,5,5v170a5,5,0,0,1,-5,5h-650a5,5,0,0,1,-5,-5v-170a5,5,0,0,1,5,-5z"></path><g id="node_text1815" fill="black"><text id="kity_text_12420" text-rendering="inherit" font-size="12" dy=".8em" y="20888.700000047684" x="837.5">JDK8 默认垃圾收集器 Parallel Scavenge（新生代）+ Parallel Old（老年代）。服务端比较常见的是使用ParNew + CMS</text><text id="kity_text_12421" text-rendering="inherit" font-size="12" dy=".8em" y="20906.700000047684" x="837.5">1.新生代</text><text id="kity_text_12422" text-rendering="inherit" font-size="12" dy=".8em" y="20924.700000047684" x="837.5">serial:串行。复制算法。单CPU，Client模式下虚拟机	。可以和cms搭配</text><text id="kity_text_12423" text-rendering="inherit" font-size="12" dy=".8em" y="20942.700000047684" x="837.5">ParNew：并行(Serial的并行版)。复制算法。多CPU，常在Server模式。可以和cms搭配</text><text id="kity_text_12424" text-rendering="inherit" font-size="12" dy=".8em" y="20960.700000047684" x="837.5">Parallel Scavenge:	并行。复制算法。	多CPU且关注吞吐量。	不可以和cms搭配</text><text id="kity_text_12425" text-rendering="inherit" font-size="12" dy=".8em" y="20978.700000047684" x="837.5">2.老年代</text><text id="kity_text_12426" text-rendering="inherit" font-size="12" dy=".8em" y="20996.700000047684" x="837.5">Serial Old：	串行	标记整理算法 。	单CPU</text><text id="kity_text_12427" text-rendering="inherit" font-size="12" dy=".8em" y="21014.700000047684" x="837.5">Parallel Old：	并行	标记整理算法。	多CPU</text><text id="kity_text_12428" text-rendering="inherit" font-size="12" dy=".8em" y="21032.700000047684" x="837.5">CMS	：并发。	标记清除算法	多CPU且关注吞吐量，常用Server端</text><text id="kity_text_12429" text-rendering="inherit" font-size="12" dy=".8em" y="21050.700000047684" x="837.5">3.g1&#xa0; jdk9所有的gc收集器</text></g></g><g id="minder_node1821"><g id="node_expander1817" style="cursor: pointer;"><path id="kity_path_25973" fill="white" stroke="gray" d="M710.5,21102.5A6,6,0,1,1,698.5,21102.5A6,6,0,1,1,710.5,21102.5"></path><path id="kity_path_25974" fill="none" stroke="gray" d="M700,21102.5L709,21102.5"></path></g><path id="node_outline1818" fill="none" stroke="none" d="M715.5,21093.5h77a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-77a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1818" fill="black"><text id="kity_text_12437" text-rendering="inherit" font-size="12" dy=".8em" y="21094.700000047684" x="715.5">说说g1收集器</text></g></g><g id="minder_node1822"><g id="node_expander1816" style="cursor: pointer;" display="none"><path id="kity_path_25970" fill="white" stroke="gray" d="M813.5,21102.5A6,6,0,1,1,801.5,21102.5A6,6,0,1,1,813.5,21102.5"></path><path id="kity_path_25971" fill="none" stroke="gray"></path></g><path id="node_outline1817" fill="none" stroke="none" d="M818.5,21075.5h1715a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1715a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1817" fill="black"><text id="kity_text_12433" text-rendering="inherit" font-size="12" dy=".8em" y="21076.700000047684" x="818.5">1.</text><text id="kity_text_12434" text-rendering="inherit" font-size="12" dy=".8em" y="21094.700000047684" x="818.5">G1 主要是 面向服务端的的收集器，将堆划分为一块块独立的 区域Region，每一个区域可以是新生代也可以是老年代,区域根据不同的策略去处理来达到最大的效果。当要进行垃圾收集时，首先估计每个 Region 中垃圾的数量，每次都从垃圾回收价值最大的 区域开始回收，因此可以获得最大的回收效率，这也是mixgc模式。</text><text id="kity_text_12435" text-rendering="inherit" font-size="12" dy=".8em" y="21112.700000047684" x="818.5">优点是 平衡了吞吐量和STW，效率高，并且G1是 标记-整理算法 + 复制算法 实现的。运行期间不会产生内存碎片，并行和并发 充分运用cpu。缺点是 内存占的多，并且 用到的记忆set 也是占内存。</text></g></g><g id="minder_node1823"><g id="node_expander1820" style="cursor: pointer;"><path id="kity_path_25982" fill="white" stroke="gray" d="M710.5,21173.5A6,6,0,1,1,698.5,21173.5A6,6,0,1,1,710.5,21173.5"></path><path id="kity_path_25983" fill="none" stroke="gray" d="M700,21173.5L709,21173.5"></path></g><path id="node_outline1821" fill="none" stroke="none" d="M715.5,21164.5h125a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-125a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1821" fill="black"><text id="kity_text_12446" text-rendering="inherit" font-size="12" dy=".8em" y="21165.700000047684" x="715.5">说说G1垃圾回收过程？</text></g></g><g id="minder_node1824"><g id="node_expander1819" style="cursor: pointer;"><path id="kity_path_25979" fill="white" stroke="gray" d="M861.5,21173.5A6,6,0,1,1,849.5,21173.5A6,6,0,1,1,861.5,21173.5"></path><path id="kity_path_25980" fill="none" stroke="gray" d="M851,21173.5L860,21173.5"></path></g><path id="node_outline1820" fill="none" stroke="none" d="M866.5,21137.5h1355a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1355a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1820" fill="black"><text id="kity_text_12441" text-rendering="inherit" font-size="12" dy=".8em" y="21138.700000047684" x="866.5">1.初始标记。仅仅是标记 GC Roots 内 直接关联 的对象。这个阶段 速度很快，需要 STP。</text><text id="kity_text_12442" text-rendering="inherit" font-size="12" dy=".8em" y="21156.700000047684" x="866.5">2.并发标记。从 GC Roots 开始对堆进行 可达性分析，找出 存活对象。不是STW</text><text id="kity_text_12443" text-rendering="inherit" font-size="12" dy=".8em" y="21174.700000047684" x="866.5">3.重新标记。修正 并发期间由于 用户进行运作 导致的 标记变动 的那一部分对象的 标记记录。这个阶段的 停顿时间 一般会比 初始标记阶段 稍长一些，但远比 并发标记 的时间短，也需要 Stop The World。</text><text id="kity_text_12444" text-rendering="inherit" font-size="12" dy=".8em" y="21192.700000047684" x="866.5">4.筛选回收。首先对各个 Region 的 回收价值 和 成本 进行排序，根据用户所期望的 GC 停顿时间 来制定回收计划。这个阶段可以与用户程序一起 并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿 用户线程 将大幅提高回收效率。</text></g></g><g id="minder_node1825"><g id="node_expander1818" style="cursor: pointer;" display="none"><path id="kity_path_25976" fill="white" stroke="gray" d="M2242.5,21173.5A6,6,0,1,1,2230.5,21173.5A6,6,0,1,1,2242.5,21173.5"></path><path id="kity_path_25977" fill="none" stroke="gray"></path></g><path id="node_outline1819" fill="none" stroke="none" d="M2247.5,21164.5h231a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-231a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1819" fill="black"><text id="kity_text_12439" text-rendering="inherit" font-size="12" dy=".8em" y="21165.700000047684" x="2247.5">https://zhuanlan.zhihu.com/p/59861022</text></g></g><g id="minder_node1826"><g id="node_expander1822" style="cursor: pointer;"><path id="kity_path_25988" fill="white" stroke="gray" d="M710.5,21280.5A6,6,0,1,1,698.5,21280.5A6,6,0,1,1,710.5,21280.5"></path><path id="kity_path_25989" fill="none" stroke="gray" d="M700,21280.5L709,21280.5"></path></g><path id="node_outline1823" fill="none" stroke="none" d="M715.5,21271.5h97a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-97a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1823" fill="black"><text id="kity_text_12456" text-rendering="inherit" font-size="12" dy=".8em" y="21272.700000047684" x="715.5">说一下cms收集器</text></g></g><g id="minder_node1827"><g id="node_expander1821" style="cursor: pointer;" display="none"><path id="kity_path_25985" fill="white" stroke="gray" d="M833.5,21280.5A6,6,0,1,1,821.5,21280.5A6,6,0,1,1,833.5,21280.5"></path><path id="kity_path_25986" fill="none" stroke="gray"></path></g><path id="node_outline1822" fill="none" stroke="none" d="M838.5,21217.5h1257a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-1257a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text1822" fill="black"><text id="kity_text_12448" text-rendering="inherit" font-size="12" dy=".8em" y="21218.700000047684" x="838.5">1.CMS，回收器是在 最短回收停顿时间 为前提的回收器，初衷也是以获取最短回收停顿时间为目标，属于 多线程回收器，采用 标记-清除算法。</text><text id="kity_text_12449" text-rendering="inherit" font-size="12" dy=".8em" y="21236.700000047684" x="838.5">使用场景：如果你的应用需要更快的响应，不希望有长时间的停顿，同时你的CPU资源也比较丰富，就适合适用CMS收集器。比如常见的Server端任务。</text><text id="kity_text_12450" text-rendering="inherit" font-size="12" dy=".8em" y="21254.700000047684" x="838.5">优点就是并发收集、低停顿。</text><text id="kity_text_12451" text-rendering="inherit" font-size="12" dy=".8em" y="21272.700000047684" x="838.5">缺点就是&#xa0;</text><text id="kity_text_12452" text-rendering="inherit" font-size="12" dy=".8em" y="21290.700000047684" x="838.5">(1)CMS收集器对CPU资源非常敏感：在并发阶段，虽然不会导致用户线程停顿，但是会占用CPU资源而导致引用程序变慢，总吞吐量下降。</text><text id="kity_text_12453" text-rendering="inherit" font-size="12" dy=".8em" y="21308.700000047684" x="838.5">(2)无法处理浮动垃圾：由于CMS并发清理阶段用户线程还在运行，伴随程序的运行自热会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理它们，只好留待下一次GC时将其清理掉。可以使用Serial Old</text><text id="kity_text_12454" text-rendering="inherit" font-size="12" dy=".8em" y="21326.700000047684" x="838.5">(3)空间碎片：CMS是基于标记-清除算法实现的收集器，使用标记-清除算法收集后，会产生大量碎片。</text></g></g><g id="minder_node1828"><g id="node_expander1824" style="cursor: pointer;"><path id="kity_path_25994" fill="white" stroke="gray" d="M710.5,21396.5A6,6,0,1,1,698.5,21396.5A6,6,0,1,1,710.5,21396.5"></path><path id="kity_path_25995" fill="none" stroke="gray" d="M700,21396.5L709,21396.5"></path></g><path id="node_outline1825" fill="none" stroke="none" d="M715.5,21387.5h136a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-136a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1825" fill="black"><text id="kity_text_12464" text-rendering="inherit" font-size="12" dy=".8em" y="21388.700000047684" x="715.5">说说CMS垃圾回收过程？</text></g></g><g id="minder_node1829"><g id="node_expander1823" style="cursor: pointer;" display="none"><path id="kity_path_25991" fill="white" stroke="gray" d="M872.5,21396.5A6,6,0,1,1,860.5,21396.5A6,6,0,1,1,872.5,21396.5"></path><path id="kity_path_25992" fill="none" stroke="gray"></path></g><path id="node_outline1824" fill="none" stroke="none" d="M877.5,21351.5h1062a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1062a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1824" fill="black"><text id="kity_text_12458" text-rendering="inherit" font-size="12" dy=".8em" y="21352.700000047684" x="877.5">1.初始标记 标记 GC Roots 内 直接关联 的对象，并且不可达的对象看是否有继承 finalize 方法，是否是第一次执行，是第一次执行把其标记为 alive，否则标记为 dead。这个阶段 速度很快，需要STW</text><text id="kity_text_12459" text-rendering="inherit" font-size="12" dy=".8em" y="21370.700000047684" x="877.5">2.并发标记 从 GC Roots 开始对堆进行 可达性分析，找出 存活对象，一边标记一边用户线程继续运行。 不SWT</text><text id="kity_text_12460" text-rendering="inherit" font-size="12" dy=".8em" y="21388.700000047684" x="877.5">3.重新标记 为了 修正 并发期间由于 用户进行运作 导致的 标记变动 的那一部分对象的 标记记录。这个阶段的 停顿时间 一般会比 初始标记阶段 稍长一些，但远比 并发标记 的时间短，也需要 STW</text><text id="kity_text_12461" text-rendering="inherit" font-size="12" dy=".8em" y="21406.700000047684" x="877.5">4.并发清除 多线程清除垃圾对象。</text><text id="kity_text_12462" text-rendering="inherit" font-size="12" dy=".8em" y="21424.700000047684" x="877.5">并发标记和并发清除的耗时最长但是不需要停止用户线程。初始标记和重新标记的耗时较短，但是需要停止用户线程，所以整个GC过程造成的停顿时间较短，大部分时候是可以和用户线程一起工作的。</text></g></g><g id="minder_node1830"><g id="node_expander1826" style="cursor: pointer;"><path id="kity_path_26000" fill="white" stroke="gray" d="M710.5,21467.5A6,6,0,1,1,698.5,21467.5A6,6,0,1,1,710.5,21467.5"></path><path id="kity_path_26001" fill="none" stroke="gray" d="M700,21467.5L709,21467.5"></path></g><path id="node_outline1827" fill="none" stroke="none" d="M715.5,21458.5h148a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-148a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1827" fill="black"><text id="kity_text_12469" text-rendering="inherit" font-size="12" dy=".8em" y="21459.700000047684" x="715.5">说说CMS会不会产生碎片？</text></g></g><g id="minder_node1831"><g id="node_expander1825" style="cursor: pointer;" display="none"><path id="kity_path_25997" fill="white" stroke="gray" d="M884.5,21467.5A6,6,0,1,1,872.5,21467.5A6,6,0,1,1,884.5,21467.5"></path><path id="kity_path_25998" fill="none" stroke="gray"></path></g><path id="node_outline1826" fill="none" stroke="none" d="M889.5,21449.5h530a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-530a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1826" fill="black"><text id="kity_text_12466" text-rendering="inherit" font-size="12" dy=".8em" y="21450.700000047684" x="889.5">1.会，这也是他的其中一个缺点</text><text id="kity_text_12467" text-rendering="inherit" font-size="12" dy=".8em" y="21468.700000047684" x="889.5">空间碎片：CMS是基于标记-清除算法实现的收集器，使用标记-清除算法收集后，会产生大量碎片。</text></g></g><g id="minder_node1832"><g id="node_expander1828" style="cursor: pointer;"><path id="kity_path_26006" fill="white" stroke="gray" d="M710.5,21610.5A6,6,0,1,1,698.5,21610.5A6,6,0,1,1,710.5,21610.5"></path><path id="kity_path_26007" fill="none" stroke="gray" d="M700,21610.5L709,21610.5"></path></g><path id="node_outline1829" fill="none" stroke="none" d="M715.5,21601.5h189a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-189a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1829" fill="black"><text id="kity_text_12485" text-rendering="inherit" font-size="12" dy=".8em" y="21602.700000047684" x="715.5">CMS的G1的区别比较？g1的优点？</text></g></g><g id="minder_node1833"><g id="node_expander1827" style="cursor: pointer;" display="none"><path id="kity_path_26003" fill="white" stroke="gray" d="M925.5,21610.5A6,6,0,1,1,913.5,21610.5A6,6,0,1,1,925.5,21610.5"></path><path id="kity_path_26004" fill="none" stroke="gray"></path></g><path id="node_outline1828" fill="none" stroke="none" d="M930.5,21493.5h1373a5,5,0,0,1,5,5v224a5,5,0,0,1,-5,5h-1373a5,5,0,0,1,-5,-5v-224a5,5,0,0,1,5,-5z"></path><g id="node_text1828" fill="black"><text id="kity_text_12471" text-rendering="inherit" font-size="12" dy=".8em" y="21494.700000047684" x="930.5">1.</text><text id="kity_text_12472" text-rendering="inherit" font-size="12" dy=".8em" y="21512.700000047684" x="930.5">CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用；</text><text id="kity_text_12473" text-rendering="inherit" font-size="12" dy=".8em" y="21530.700000047684" x="930.5">G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用；</text><text id="kity_text_12474" text-rendering="inherit" font-size="12" dy=".8em" y="21548.700000047684" x="930.5">CMS收集器以最小的停顿时间为目标的收集器；</text><text id="kity_text_12475" text-rendering="inherit" font-size="12" dy=".8em" y="21566.700000047684" x="930.5">G1收集器可预测垃圾回收的停顿时间</text><text id="kity_text_12476" text-rendering="inherit" font-size="12" dy=".8em" y="21584.700000047684" x="930.5">CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片</text><text id="kity_text_12477" text-rendering="inherit" font-size="12" dy=".8em" y="21602.700000047684" x="930.5">G1收集器使用的是“标记-整理”+复制 算法，进行了空间整合，降低了内存空间碎片。</text><text id="kity_text_12478" text-rendering="inherit" font-size="12" dy=".8em" y="21620.700000047684" x="930.5">2.优点</text><text id="kity_text_12479" text-rendering="inherit" font-size="12" dy=".8em" y="21638.700000047684" x="930.5">并行与并发：使用多个 CPU 来缩短 Stop-the-World 的 停顿时间，部分其他回收器需要停顿 Java 线程执行的 GC 动作，G1 回收器仍然可以通过 并发的方式 让 Java 程序继续执行。</text><text id="kity_text_12480" text-rendering="inherit" font-size="12" dy=".8em" y="21656.700000047684" x="930.5">分代回收：采用 不同的策略 去处理 新创建的对象 和 已经存活 一段时间、熬过多次 GC 的旧对象，以获取更好的回收效果。</text><text id="kity_text_12481" text-rendering="inherit" font-size="12" dy=".8em" y="21674.700000047684" x="930.5">空间整合：G1从整体上看是基于标记-整理算法实现的，从局部(两个Region之间)上看是基于复制算法实现的，G1运行期间不会产生内存空间碎片。</text><text id="kity_text_12482" text-rendering="inherit" font-size="12" dy=".8em" y="21692.700000047684" x="930.5">可预测停顿：G1 相对于 CMS 的另一大优势，降低停顿时间 是 G1 和 CMS 共同的关注点。G1 除了追求 低停顿 外，还能建立 可预测 的 停顿时间模型，能让使用者明确指定在一个 长度 为 M 毫秒的 时间片段 内，消耗在 垃圾回收 上的时间不得超过 N 毫秒。</text><text id="kity_text_12483" text-rendering="inherit" font-size="12" dy=".8em" y="21710.700000047684" x="930.5">（后台维护的 优先列表，优先回收 价值大 的 Region）。</text></g></g><g id="minder_node1834"><g id="node_expander1830" style="cursor: pointer;"><path id="kity_path_26012" fill="white" stroke="gray" d="M710.5,21789.5A6,6,0,1,1,698.5,21789.5A6,6,0,1,1,710.5,21789.5"></path><path id="kity_path_26013" fill="none" stroke="gray" d="M700,21789.5L709,21789.5"></path></g><path id="node_outline1831" fill="none" stroke="none" d="M715.5,21780.5h170a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-170a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1831" fill="black"><text id="kity_text_12494" text-rendering="inherit" font-size="12" dy=".8em" y="21781.700000047684" x="715.5">怎么选择一个合适的垃圾收集器</text></g></g><g id="minder_node1835"><g id="node_expander1829" style="cursor: pointer;" display="none"><path id="kity_path_26009" fill="white" stroke="gray" d="M906.5,21789.5A6,6,0,1,1,894.5,21789.5A6,6,0,1,1,906.5,21789.5"></path><path id="kity_path_26010" fill="none" stroke="gray"></path></g><path id="node_outline1830" fill="none" stroke="none" d="M911.5,21735.5h423a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-423a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1830" fill="black"><text id="kity_text_12487" text-rendering="inherit" font-size="12" dy=".8em" y="21736.700000047684" x="911.5">1.是看吞吐量优先还是响应速度</text><text id="kity_text_12488" text-rendering="inherit" font-size="12" dy=".8em" y="21754.700000047684" x="911.5">一般就是ParNew+CMS作为服务器使用,以后的GC收集器可能采用g1,jdk 9以后</text><text id="kity_text_12489" text-rendering="inherit" font-size="12" dy=".8em" y="21772.700000047684" x="911.5">2.</text><text id="kity_text_12490" text-rendering="inherit" font-size="12" dy=".8em" y="21790.700000047684" x="911.5">如果你想要最大化应用程序的吞吐量，请选Parallel GC；</text><text id="kity_text_12491" text-rendering="inherit" font-size="12" dy=".8em" y="21808.700000047684" x="911.5">如果你想要最小化GC的中断或停顿时间，请选CMS GC。</text><text id="kity_text_12492" text-rendering="inherit" font-size="12" dy=".8em" y="21826.700000047684" x="911.5">如果你想要最小化地使用内存和并行开销，请选Serial GC；</text></g></g><g id="minder_node1836"><g id="node_expander1833" style="cursor: pointer;"><path id="kity_path_26021" fill="white" stroke="gray" d="M710.5,21869.5A6,6,0,1,1,698.5,21869.5A6,6,0,1,1,710.5,21869.5"></path><path id="kity_path_26022" fill="none" stroke="gray" d="M700,21869.5L709,21869.5"></path></g><path id="node_outline1834" fill="none" stroke="none" d="M715.5,21860.5h165a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-165a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1834" fill="black"><text id="kity_text_12501" text-rendering="inherit" font-size="12" dy=".8em" y="21861.700000047684" x="715.5">GC中STW描述下。为什么SWT</text></g></g><g id="minder_node1837"><g id="node_expander1832" style="cursor: pointer;"><path id="kity_path_26018" fill="white" stroke="gray" d="M901.5,21869.5A6,6,0,1,1,889.5,21869.5A6,6,0,1,1,901.5,21869.5"></path><path id="kity_path_26019" fill="none" stroke="gray" d="M891,21869.5L900,21869.5"></path></g><path id="node_outline1833" fill="none" stroke="none" d="M906.5,21851.5h1516a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1516a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1833" fill="black"><text id="kity_text_12498" text-rendering="inherit" font-size="12" dy=".8em" y="21852.700000047684" x="906.5">1.java中Stop-The-World机制简称STW，是指执行垃圾收集算法时Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。是Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码虽然可以执行但不能与JVM交互，如果发生了STW 现象多半是由于gc引起。</text><text id="kity_text_12499" text-rendering="inherit" font-size="12" dy=".8em" y="21870.700000047684" x="906.5">2.因为gc 可达性分析在确认root的时候又 需要保证 当时整个gc root引用链路 树结果 是不变的&#xa0; 也就是形成当时的一个引用链快照，分析过程对象引用链时 树结构需要一致，所以才会停顿&#xa0;</text></g></g><g id="minder_node1838"><g id="node_expander1831" style="cursor: pointer;" display="none"><path id="kity_path_26015" fill="white" stroke="gray" d="M2443.5,21869.5A6,6,0,1,1,2431.5,21869.5A6,6,0,1,1,2443.5,21869.5"></path><path id="kity_path_26016" fill="none" stroke="gray"></path></g><path id="node_outline1832" fill="none" stroke="none" d="M2448.5,21860.5h376a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-376a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1832" fill="black"><text id="kity_text_12496" text-rendering="inherit" font-size="12" dy=".8em" y="21861.700000047684" x="2448.5">https://blog.csdn.net/luqiang81191293/article/details/108985952</text></g></g><g id="minder_node1839"><g id="node_expander1836" style="cursor: pointer;"><path id="kity_path_26030" fill="white" stroke="gray" d="M587.5,21985.5A6,6,0,1,1,575.5,21985.5A6,6,0,1,1,587.5,21985.5"></path><path id="kity_path_26031" fill="none" stroke="gray" d="M577,21985.5L586,21985.5"></path></g><path id="node_outline1837" fill="none" stroke="none" d="M592.5,21976.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1837" fill="black"><text id="kity_text_12516" text-rendering="inherit" font-size="12" dy=".8em" y="21977.700000047684" x="592.5">gc流程？</text></g></g><g id="minder_node1840"><g id="node_expander1835" style="cursor: pointer;" display="none"><path id="kity_path_26027" fill="white" stroke="gray" d="M663.5,21985.5A6,6,0,1,1,651.5,21985.5A6,6,0,1,1,663.5,21985.5"></path><path id="kity_path_26028" fill="none" stroke="gray"></path></g><path id="node_outline1836" fill="none" stroke="none" d="M668.5,21895.5h1022a5,5,0,0,1,5,5v170a5,5,0,0,1,-5,5h-1022a5,5,0,0,1,-5,-5v-170a5,5,0,0,1,5,-5z"></path><g id="node_text1836" fill="black"><text id="kity_text_12505" text-rendering="inherit" font-size="12" dy=".8em" y="21896.700000047684" x="668.5">1新创建的对象申请空间先去先去看伊甸园有没有足够的空间。</text><text id="kity_text_12506" text-rendering="inherit" font-size="12" dy=".8em" y="21914.700000047684" x="668.5">(1)如果有 不进行垃圾回收 ,对象直接在伊甸园存储.</text><text id="kity_text_12507" text-rendering="inherit" font-size="12" dy=".8em" y="21932.700000047684" x="668.5">(2)如果伊甸园内存已满,会进行一次young gc</text><text id="kity_text_12508" text-rendering="inherit" font-size="12" dy=".8em" y="21950.700000047684" x="668.5">2.然后再进行判断伊甸园中的内存是否足够.</text><text id="kity_text_12509" text-rendering="inherit" font-size="12" dy=".8em" y="21968.700000047684" x="668.5">(1)如果内存足够,把伊甸园部分活跃对象保存在存活区，然后把新建对象保存在伊甸园.</text><text id="kity_text_12510" text-rendering="inherit" font-size="12" dy=".8em" y="21986.700000047684" x="668.5">(2)如果不足 则去看幸存区的内存是否足够.</text><text id="kity_text_12511" text-rendering="inherit" font-size="12" dy=".8em" y="22004.700000047684" x="668.5">(2.1)如果内存不足,向老年代发送请求,查询老年代的内存是否足够</text><text id="kity_text_12512" text-rendering="inherit" font-size="12" dy=".8em" y="22022.700000047684" x="668.5">(2.1.1)如果老年代内存足够,将部分存活区的活跃对象存入老年代.然后把伊甸园的活跃对象放入存活区,对象依旧保存在伊甸园.</text><text id="kity_text_12513" text-rendering="inherit" font-size="12" dy=".8em" y="22040.700000047684" x="668.5">(2.1.2).如果老年代内存不足,会进行一次full gc,之后老年代会再进行判断 内存是否足够,如果足够 将部分存活区的活跃对象存入老年代.然后把伊甸园的活跃对象放入存活区,对象依旧保存在伊甸园.</text><text id="kity_text_12514" text-rendering="inherit" font-size="12" dy=".8em" y="22058.700000047684" x="668.5">3.如果不足 会抛出OutOfMemoryError.</text></g></g><g id="minder_node1841"><g id="node_expander1839" style="cursor: pointer;"><path id="kity_path_26039" fill="white" stroke="gray" d="M587.5,22110.5A6,6,0,1,1,575.5,22110.5A6,6,0,1,1,587.5,22110.5"></path><path id="kity_path_26040" fill="none" stroke="gray" d="M577,22110.5L586,22110.5"></path></g><path id="node_outline1840" fill="none" stroke="none" d="M592.5,22101.5h343a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-343a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1840" fill="black"><text id="kity_text_12525" text-rendering="inherit" font-size="12" dy=".8em" y="22102.700000047684" x="592.5">年轻代对象gc次数超过默认值15以后就放到老年代？15怎么来的</text></g></g><g id="minder_node1842"><g id="node_expander1838" style="cursor: pointer;"><path id="kity_path_26036" fill="white" stroke="gray" d="M956.5,22110.5A6,6,0,1,1,944.5,22110.5A6,6,0,1,1,956.5,22110.5"></path><path id="kity_path_26037" fill="none" stroke="gray" d="M946,22110.5L955,22110.5"></path></g><path id="node_outline1839" fill="none" stroke="none" d="M961.5,22083.5h628a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-628a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1839" fill="black"><text id="kity_text_12521" text-rendering="inherit" font-size="12" dy=".8em" y="22084.700000047684" x="961.5">1.经验值来的。太大 对象在幸存区 来回复制，增加没必要开销。太小 进入老年代就死亡，</text><text id="kity_text_12522" text-rendering="inherit" font-size="12" dy=".8em" y="22102.700000047684" x="961.5">2.64位对象头markwork的分代年龄是4bit，也就是4位 也就是15。&#xa0;</text><text id="kity_text_12523" text-rendering="inherit" font-size="12" dy=".8em" y="22120.700000047684" x="961.5">3.CMS默认是6，G1默认是15。其次 如果你指定了CMS 没有指定次数 那么是6，如果不指定垃圾回收器 就是默认的15</text></g></g><g id="minder_node1843"><g id="node_expander1837" style="cursor: pointer;" display="none"><path id="kity_path_26033" fill="white" stroke="gray" d="M1610.5,22110.5A6,6,0,1,1,1598.5,22110.5A6,6,0,1,1,1610.5,22110.5"></path><path id="kity_path_26034" fill="none" stroke="gray"></path></g><path id="node_outline1838" fill="none" stroke="none" d="M1615.5,22092.5h284a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-284a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1838" fill="black"><text id="kity_text_12518" text-rendering="inherit" font-size="12" dy=".8em" y="22093.700000047684" x="1615.5">https://www.cnblogs.com/yewy/p/13584915.html</text><text id="kity_text_12519" text-rendering="inherit" font-size="12" dy=".8em" y="22111.700000047684" x="1615.5">https://club.perfma.com/question/1662008</text></g></g><g id="minder_node1844"><g id="node_expander1844" style="cursor: pointer;"><path id="kity_path_26054" fill="white" stroke="gray" d="M587.5,22212.5A6,6,0,1,1,575.5,22212.5A6,6,0,1,1,587.5,22212.5"></path><path id="kity_path_26055" fill="none" stroke="gray" d="M577,22212.5L586,22212.5"></path></g><path id="node_outline1845" fill="none" stroke="none" d="M592.5,22203.5h73a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-73a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1845" fill="black"><text id="kity_text_12539" text-rendering="inherit" font-size="12" dy=".8em" y="22204.700000047684" x="592.5">三色标记算法</text></g></g><g id="minder_node1845"><g id="node_expander1841" style="cursor: pointer;"><path id="kity_path_26045" fill="white" stroke="gray" d="M686.5,22181.5A6,6,0,1,1,674.5,22181.5A6,6,0,1,1,686.5,22181.5"></path><path id="kity_path_26046" fill="none" stroke="gray" d="M676,22181.5L685,22181.5"></path></g><path id="node_outline1842" fill="none" stroke="none" d="M691.5,22172.5h120a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-120a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1842" fill="black"><text id="kity_text_12532" text-rendering="inherit" font-size="12" dy=".8em" y="22173.700000047684" x="691.5">三色标记算法是什么？</text></g></g><g id="minder_node1846"><g id="node_expander1840" style="cursor: pointer;" display="none"><path id="kity_path_26042" fill="white" stroke="gray" d="M832.5,22181.5A6,6,0,1,1,820.5,22181.5A6,6,0,1,1,832.5,22181.5"></path><path id="kity_path_26043" fill="none" stroke="gray"></path></g><path id="node_outline1841" fill="none" stroke="none" d="M837.5,22145.5h754a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-754a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1841" fill="black"><text id="kity_text_12527" text-rendering="inherit" font-size="12" dy=".8em" y="22146.700000047684" x="837.5">可达性分析进一步延伸出三色标记法。通常，GC 算法会维持一套对象图，图上节点表示对象，节点之间的连线表示对象间的引用关系，其中：</text><text id="kity_text_12528" text-rendering="inherit" font-size="12" dy=".8em" y="22164.700000047684" x="837.5">白色节点：尚未被标记的对象；</text><text id="kity_text_12529" text-rendering="inherit" font-size="12" dy=".8em" y="22182.700000047684" x="837.5">黑色节点：已经被标记，且其引用关系已经被处理；</text><text id="kity_text_12530" text-rendering="inherit" font-size="12" dy=".8em" y="22200.700000047684" x="837.5">灰色节点：已经被标记，但引用关系尚未被处理；</text></g></g><g id="minder_node1847"><g id="node_expander1843" style="cursor: pointer;"><path id="kity_path_26051" fill="white" stroke="gray" d="M686.5,22243.5A6,6,0,1,1,674.5,22243.5A6,6,0,1,1,686.5,22243.5"></path><path id="kity_path_26052" fill="none" stroke="gray" d="M676,22243.5L685,22243.5"></path></g><path id="node_outline1844" fill="none" stroke="none" d="M691.5,22234.5h151a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-151a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1844" fill="black"><text id="kity_text_12537" text-rendering="inherit" font-size="12" dy=".8em" y="22235.700000047684" x="691.5">CMS和G1的三色标记区别？</text></g></g><g id="minder_node1848"><g id="node_expander1842" style="cursor: pointer;" display="none"><path id="kity_path_26048" fill="white" stroke="gray" d="M863.5,22243.5A6,6,0,1,1,851.5,22243.5A6,6,0,1,1,863.5,22243.5"></path><path id="kity_path_26049" fill="none" stroke="gray"></path></g><path id="node_outline1843" fill="none" stroke="none" d="M868.5,22225.5h347a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-347a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1843" fill="black"><text id="kity_text_12534" text-rendering="inherit" font-size="12" dy=".8em" y="22226.700000047684" x="868.5">CMS使用的是三色标记+Incremental Update算法</text><text id="kity_text_12535" text-rendering="inherit" font-size="12" dy=".8em" y="22244.700000047684" x="868.5">G1使用的是三色标记+snapshot at the begining （SATB）算法</text></g></g><g id="minder_node1849"><g id="node_expander1847" style="cursor: pointer;"><path id="kity_path_26063" fill="white" stroke="gray" d="M587.5,22332.5A6,6,0,1,1,575.5,22332.5A6,6,0,1,1,587.5,22332.5"></path><path id="kity_path_26064" fill="none" stroke="gray" d="M577,22332.5L586,22332.5"></path></g><path id="node_outline1848" fill="none" stroke="none" d="M592.5,22323.5h193a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-193a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1848" fill="black"><text id="kity_text_12551" text-rendering="inherit" font-size="12" dy=".8em" y="22324.700000047684" x="592.5">什么时侯full gc 什么时侯young&#xa0; gc</text></g></g><g id="minder_node1850"><g id="node_expander1846" style="cursor: pointer;"><path id="kity_path_26060" fill="white" stroke="gray" d="M806.5,22332.5A6,6,0,1,1,794.5,22332.5A6,6,0,1,1,806.5,22332.5"></path><path id="kity_path_26061" fill="none" stroke="gray" d="M796,22332.5L805,22332.5"></path></g><path id="node_outline1847" fill="none" stroke="none" d="M811.5,22269.5h513a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-513a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text1847" fill="black"><text id="kity_text_12543" text-rendering="inherit" font-size="12" dy=".8em" y="22270.700000047684" x="811.5">1.young gc</text><text id="kity_text_12544" text-rendering="inherit" font-size="12" dy=".8em" y="22288.700000047684" x="811.5">eden区满时，触发young gc。即申请一个对象时，发现eden区不够用，则触发一次young gc。</text><text id="kity_text_12545" text-rendering="inherit" font-size="12" dy=".8em" y="22306.700000047684" x="811.5">新创建的对象大小 &gt; Eden所剩空间时触发young GC</text><text id="kity_text_12546" text-rendering="inherit" font-size="12" dy=".8em" y="22324.700000047684" x="811.5">2.full gc</text><text id="kity_text_12547" text-rendering="inherit" font-size="12" dy=".8em" y="22342.700000047684" x="811.5">每次晋升到老年代的对象平均大小&gt;老年代剩余空间</text><text id="kity_text_12548" text-rendering="inherit" font-size="12" dy=".8em" y="22360.700000047684" x="811.5">young GC后存活的对象超过了老年代剩余空间</text><text id="kity_text_12549" text-rendering="inherit" font-size="12" dy=".8em" y="22378.700000047684" x="811.5">执行System.gc()。堆内存分配很大的对象</text></g></g><g id="minder_node1851"><g id="node_expander1845" style="cursor: pointer;" display="none"><path id="kity_path_26057" fill="white" stroke="gray" d="M1345.5,22332.5A6,6,0,1,1,1333.5,22332.5A6,6,0,1,1,1345.5,22332.5"></path><path id="kity_path_26058" fill="none" stroke="gray"></path></g><path id="node_outline1846" fill="none" stroke="none" d="M1350.5,22323.5h326a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1846" fill="black"><text id="kity_text_12541" text-rendering="inherit" font-size="12" dy=".8em" y="22324.700000047684" x="1350.5">https://juejin.cn/post/6844903669251440653#heading-1</text></g></g><g id="minder_node1852"><g id="node_expander1859" style="cursor: pointer;"><path id="kity_path_26099" fill="white" stroke="gray" d="M544.5,22609.5A6,6,0,1,1,532.5,22609.5A6,6,0,1,1,544.5,22609.5"></path><path id="kity_path_26100" fill="none" stroke="gray" d="M534,22609.5L543,22609.5"></path></g><path id="node_outline1860" fill="none" stroke="none" d="M549.5,22600.5h51a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-51a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1860" fill="black"><text id="kity_text_12592" text-rendering="inherit" font-size="12" dy=".8em" y="22601.700000047684" x="549.5">JVM参数</text></g></g><g id="minder_node1853"><g id="node_expander1852" style="cursor: pointer;"><path id="kity_path_26078" fill="white" stroke="gray" d="M621.5,22484.5A6,6,0,1,1,609.5,22484.5A6,6,0,1,1,621.5,22484.5"></path><path id="kity_path_26079" fill="none" stroke="gray" d="M611,22484.5L620,22484.5"></path></g><path id="node_outline1853" fill="none" stroke="none" d="M626.5,22475.5h72a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-72a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1853" fill="black"><text id="kity_text_12569" text-rendering="inherit" font-size="12" dy=".8em" y="22476.700000047684" x="626.5">jvm调优参数</text></g></g><g id="minder_node1854"><g id="node_expander1851" style="cursor: pointer;"><path id="kity_path_26075" fill="white" stroke="gray" d="M719.5,22484.5A6,6,0,1,1,707.5,22484.5A6,6,0,1,1,719.5,22484.5"></path><path id="kity_path_26076" fill="none" stroke="gray" d="M709,22484.5L718,22484.5"></path></g><path id="node_outline1852" fill="none" stroke="none" d="M724.5,22475.5h119a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-119a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1852" fill="black"><text id="kity_text_12567" text-rendering="inherit" font-size="12" dy=".8em" y="22476.700000047684" x="724.5">说说jvm调优常见参数</text></g></g><g id="minder_node1855"><g id="node_expander1850" style="cursor: pointer;"><path id="kity_path_26072" fill="white" stroke="gray" d="M864.5,22484.5A6,6,0,1,1,852.5,22484.5A6,6,0,1,1,864.5,22484.5"></path><path id="kity_path_26073" fill="none" stroke="gray" d="M854,22484.5L863,22484.5M858.5,22480L858.5,22489"></path></g><path id="node_outline1851" fill="none" stroke="none" d="M869.5,22403.5h1303a5,5,0,0,1,5,5v152a5,5,0,0,1,-5,5h-1303a5,5,0,0,1,-5,-5v-152a5,5,0,0,1,5,-5z"></path><g id="node_text1851" fill="black"><text id="kity_text_12557" text-rendering="inherit" font-size="12" dy=".8em" y="22404.700000047684" x="869.5">1.堆</text><text id="kity_text_12558" text-rendering="inherit" font-size="12" dy=".8em" y="22422.700000047684" x="869.5">(1).-Xms：初始堆大小，JVM 启动的时候，给定堆空间大小。 (2).-Xmx：最大堆大小，JVM 运行过程中，如果初始堆空间不足的时候，最大可以扩展到多少。 (3).-Xmn：设置堆中年轻代大小。整个堆大小=年轻代大小+年老代大小+持久代大小。</text><text id="kity_text_12559" text-rendering="inherit" font-size="12" dy=".8em" y="22440.700000047684" x="869.5">2.年轻代</text><text id="kity_text_12560" text-rendering="inherit" font-size="12" dy=".8em" y="22458.700000047684" x="869.5">(1).-XX:NewSize=n 设置年轻代初始化大小(2).-XX:MaxNewSize=n 设置年轻代最大值</text><text id="kity_text_12561" text-rendering="inherit" font-size="12" dy=".8em" y="22476.700000047684" x="869.5">(3).-XX:NewRatio=n 设置年轻代和年老代的比值。如: -XX:NewRatio=3，表示年轻代与年老代比值为 1：3，(4)-XX:SurvivorRatio=n 年轻代中 Eden 区与两个 Survivor 区的比值。8表示两个Survivor :eden=2:8&#xa0;</text><text id="kity_text_12562" text-rendering="inherit" font-size="12" dy=".8em" y="22494.700000047684" x="869.5">3.线程</text><text id="kity_text_12563" text-rendering="inherit" font-size="12" dy=".8em" y="22512.700000047684" x="869.5">1）-Xss：设置每个线程的堆栈大小。</text><text id="kity_text_12564" text-rendering="inherit" font-size="12" dy=".8em" y="22530.700000047684" x="869.5">4.持久代</text><text id="kity_text_12565" text-rendering="inherit" font-size="12" dy=".8em" y="22548.700000047684" x="869.5">-XX:PermSize=n 设置持久代初始值 -XX:MaxPermSize=n 设置持久代大小 -XX:MaxTenuringThreshold=n 设置年轻代垃圾对象最大年龄。</text></g></g><g id="minder_node1856" display="none"><g id="node_expander1849" style="cursor: pointer;" display="none"><path id="kity_path_26069" fill="white" stroke="gray" d="M2193.5,22484.5A6,6,0,1,1,2181.5,22484.5A6,6,0,1,1,2193.5,22484.5"></path><path id="kity_path_26070" fill="none" stroke="gray"></path></g><path id="node_outline1850" fill="none" stroke="none" d="M2193.5,22475.5h333a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1850" fill="black"><text id="kity_text_12555" text-rendering="inherit" font-size="12" dy=".8em" y="22476.700000047684" x="2193.5">https://juejin.cn/post/6844904125696573448#heading-63</text></g></g><g id="minder_node1857"><g id="node_expander1855" style="cursor: pointer;"><path id="kity_path_26087" fill="white" stroke="gray" d="M621.5,22627.5A6,6,0,1,1,609.5,22627.5A6,6,0,1,1,621.5,22627.5"></path><path id="kity_path_26088" fill="none" stroke="gray" d="M611,22627.5L620,22627.5"></path></g><path id="node_outline1856" fill="none" stroke="none" d="M626.5,22618.5h39a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-39a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1856" fill="black"><text id="kity_text_12580" text-rendering="inherit" font-size="12" dy=".8em" y="22619.700000047684" x="626.5">gc参数</text></g></g><g id="minder_node1858"><g id="node_expander1854" style="cursor: pointer;"><path id="kity_path_26084" fill="white" stroke="gray" d="M686.5,22627.5A6,6,0,1,1,674.5,22627.5A6,6,0,1,1,686.5,22627.5"></path><path id="kity_path_26085" fill="none" stroke="gray" d="M676,22627.5L685,22627.5"></path></g><path id="node_outline1855" fill="none" stroke="none" d="M691.5,22618.5h120a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-120a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1855" fill="black"><text id="kity_text_12578" text-rendering="inherit" font-size="12" dy=".8em" y="22619.700000047684" x="691.5">说说jvm的gc常见参数</text></g></g><g id="minder_node1859"><g id="node_expander1853" style="cursor: pointer;" display="none"><path id="kity_path_26081" fill="white" stroke="gray" d="M832.5,22627.5A6,6,0,1,1,820.5,22627.5A6,6,0,1,1,832.5,22627.5"></path><path id="kity_path_26082" fill="none" stroke="gray"></path></g><path id="node_outline1854" fill="none" stroke="none" d="M837.5,22573.5h762a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-762a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1854" fill="black"><text id="kity_text_12571" text-rendering="inherit" font-size="12" dy=".8em" y="22574.700000047684" x="837.5">-XX:+UseSerialGC:设置串行收集器，年轻带收集器&#xa0;</text><text id="kity_text_12572" text-rendering="inherit" font-size="12" dy=".8em" y="22592.700000047684" x="837.5">-XX:+UseParNewGC:设置年轻代为并行收集。可与 CMS 收集同时使用。JDK5.0 以上，JVM 会根据系统配置自行设置，所以无需再设置此值。</text><text id="kity_text_12573" text-rendering="inherit" font-size="12" dy=".8em" y="22610.700000047684" x="837.5">-XX:+UseParallelGC:设置并行收集器，目标是目标是达到可控制的吞吐量</text><text id="kity_text_12574" text-rendering="inherit" font-size="12" dy=".8em" y="22628.700000047684" x="837.5">-XX:+UseParallelOldGC:设置并行年老代收集器，JDK6.0 支持对年老代并行收集。&#xa0;</text><text id="kity_text_12575" text-rendering="inherit" font-size="12" dy=".8em" y="22646.700000047684" x="837.5">-XX:+UseConcMarkSweepGC:设置年老代并发收集器</text><text id="kity_text_12576" text-rendering="inherit" font-size="12" dy=".8em" y="22664.700000047684" x="837.5">-XX:+UseG1GC:设置 G1 收集器，JDK1.9默认垃圾收集器</text></g></g><g id="minder_node1860"><g id="node_expander1858" style="cursor: pointer;"><path id="kity_path_26096" fill="white" stroke="gray" d="M621.5,22734.5A6,6,0,1,1,609.5,22734.5A6,6,0,1,1,621.5,22734.5"></path><path id="kity_path_26097" fill="none" stroke="gray" d="M611,22734.5L620,22734.5"></path></g><path id="node_outline1859" fill="none" stroke="none" d="M626.5,22725.5h72a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-72a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1859" fill="black"><text id="kity_text_12590" text-rendering="inherit" font-size="12" dy=".8em" y="22726.700000047684" x="626.5">jvm监控参数</text></g></g><g id="minder_node1861"><g id="node_expander1857" style="cursor: pointer;"><path id="kity_path_26093" fill="white" stroke="gray" d="M719.5,22734.5A6,6,0,1,1,707.5,22734.5A6,6,0,1,1,719.5,22734.5"></path><path id="kity_path_26094" fill="none" stroke="gray" d="M709,22734.5L718,22734.5"></path></g><path id="node_outline1858" fill="none" stroke="none" d="M724.5,22725.5h142a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-142a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1858" fill="black"><text id="kity_text_12588" text-rendering="inherit" font-size="12" dy=".8em" y="22726.700000047684" x="724.5">使用过那些jvm监控参数？</text></g></g><g id="minder_node1862"><g id="node_expander1856" style="cursor: pointer;" display="none"><path id="kity_path_26090" fill="white" stroke="gray" d="M887.5,22734.5A6,6,0,1,1,875.5,22734.5A6,6,0,1,1,887.5,22734.5"></path><path id="kity_path_26091" fill="none" stroke="gray"></path></g><path id="node_outline1857" fill="none" stroke="none" d="M892.5,22689.5h918a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-918a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1857" fill="black"><text id="kity_text_12582" text-rendering="inherit" font-size="12" dy=".8em" y="22690.700000047684" x="892.5">1.jps -lv查看所有java进程&#xa0; jstat查看虚拟机运行状态&#xa0; &#xa0;jinfo可以查看和调整虚拟机参数</text><text id="kity_text_12583" text-rendering="inherit" font-size="12" dy=".8em" y="22708.700000047684" x="892.5">jmap生成堆快照，也可以查看堆的使用率信息&#xa0;</text><text id="kity_text_12584" text-rendering="inherit" font-size="12" dy=".8em" y="22726.700000047684" x="892.5">jstat 可以查看虚拟机当前时刻的线程快照，定位线程出现长时间停顿的原因，入线程间死锁、死循环、请求外部资源导致的长时间等待都是导致线程长时间停顿的常见原因。</text><text id="kity_text_12585" text-rendering="inherit" font-size="12" dy=".8em" y="22744.700000047684" x="892.5">线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情。</text><text id="kity_text_12586" text-rendering="inherit" font-size="12" dy=".8em" y="22762.700000047684" x="892.5">2.jconsole和jvisualvm</text></g></g><g id="minder_node1863"><g id="node_expander1903" style="cursor: pointer;"><path id="kity_path_26231" fill="white" stroke="gray" d="M544.5,23615.5A6,6,0,1,1,532.5,23615.5A6,6,0,1,1,544.5,23615.5"></path><path id="kity_path_26232" fill="none" stroke="gray" d="M534,23615.5L543,23615.5"></path></g><path id="node_outline1904" fill="none" stroke="none" d="M549.5,23606.5h38a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-38a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1904" fill="black"><text id="kity_text_12748" text-rendering="inherit" font-size="12" dy=".8em" y="23607.700000047684" x="549.5">类加载</text></g></g><g id="minder_node1864"><g id="node_expander1861" style="cursor: pointer;"><path id="kity_path_26105" fill="white" stroke="gray" d="M608.5,22805.5A6,6,0,1,1,596.5,22805.5A6,6,0,1,1,608.5,22805.5"></path><path id="kity_path_26106" fill="none" stroke="gray" d="M598,22805.5L607,22805.5"></path></g><path id="node_outline1862" fill="none" stroke="none" d="M613.5,22796.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1862" fill="black"><text id="kity_text_12597" text-rendering="inherit" font-size="12" dy=".8em" y="22797.700000047684" x="613.5">类加载机制怎么理解？</text></g></g><g id="minder_node1865"><g id="node_expander1860" style="cursor: pointer;" display="none"><path id="kity_path_26102" fill="white" stroke="gray" d="M755.5,22805.5A6,6,0,1,1,743.5,22805.5A6,6,0,1,1,755.5,22805.5"></path><path id="kity_path_26103" fill="none" stroke="gray"></path></g><path id="node_outline1861" fill="none" stroke="none" d="M760.5,22787.5h772a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-772a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1861" fill="black"><text id="kity_text_12594" text-rendering="inherit" font-size="12" dy=".8em" y="22788.700000047684" x="760.5">jvm虚拟机把类信息从class文件（二进制流）读取到内存中，然后包括准备，解析，赋初值等 ，然后最后一个转换成虚拟机直接使用的java类型，</text><text id="kity_text_12595" text-rendering="inherit" font-size="12" dy=".8em" y="22806.700000047684" x="760.5">注意的是 类是在运行时第一次使用动态加载的，要不然的话 那么多信息是很占内存的，</text></g></g><g id="minder_node1866"><g id="node_expander1863" style="cursor: pointer;"><path id="kity_path_26111" fill="white" stroke="gray" d="M608.5,22885.5A6,6,0,1,1,596.5,22885.5A6,6,0,1,1,608.5,22885.5"></path><path id="kity_path_26112" fill="none" stroke="gray" d="M598,22885.5L607,22885.5"></path></g><path id="node_outline1864" fill="none" stroke="none" d="M613.5,22876.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1864" fill="black"><text id="kity_text_12606" text-rendering="inherit" font-size="12" dy=".8em" y="22877.700000047684" x="613.5">类的几种加载方式？</text></g></g><g id="minder_node1867"><g id="node_expander1862" style="cursor: pointer;" display="none"><path id="kity_path_26108" fill="white" stroke="gray" d="M743.5,22885.5A6,6,0,1,1,731.5,22885.5A6,6,0,1,1,743.5,22885.5"></path><path id="kity_path_26109" fill="none" stroke="gray"></path></g><path id="node_outline1863" fill="none" stroke="none" d="M748.5,22831.5h674a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-674a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1863" fill="black"><text id="kity_text_12599" text-rendering="inherit" font-size="12" dy=".8em" y="22832.700000047684" x="748.5">1.通过命令行启动时由JVM初始化加载；</text><text id="kity_text_12600" text-rendering="inherit" font-size="12" dy=".8em" y="22850.700000047684" x="748.5">通过Class.forName()方法动态加载；</text><text id="kity_text_12601" text-rendering="inherit" font-size="12" dy=".8em" y="22868.700000047684" x="748.5">通过ClassLoader.loadClass()方法动态加载</text><text id="kity_text_12602" text-rendering="inherit" font-size="12" dy=".8em" y="22886.700000047684" x="748.5">2.</text><text id="kity_text_12603" text-rendering="inherit" font-size="12" dy=".8em" y="22904.700000047684" x="748.5">Class.forName()：把类的.class文件加载到JVM中，对类进行解释的同时执行类中的static静态代码块；</text><text id="kity_text_12604" text-rendering="inherit" font-size="12" dy=".8em" y="22922.700000047684" x="748.5">ClassLoader.loadClass()：只是把.class文件加载到JVM中，不会执行static代码块中的内容，只有在newInstance才会去执行。</text></g></g><g id="minder_node1868"><g id="node_expander1866" style="cursor: pointer;"><path id="kity_path_26120" fill="white" stroke="gray" d="M608.5,23010.5A6,6,0,1,1,596.5,23010.5A6,6,0,1,1,608.5,23010.5"></path><path id="kity_path_26121" fill="none" stroke="gray" d="M598,23010.5L607,23010.5"></path></g><path id="node_outline1867" fill="none" stroke="none" d="M613.5,23001.5h97a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-97a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1867" fill="black"><text id="kity_text_12618" text-rendering="inherit" font-size="12" dy=".8em" y="23002.700000047684" x="613.5">能不能修改字节码</text></g></g><g id="minder_node1869"><g id="node_expander1865" style="cursor: pointer;"><path id="kity_path_26117" fill="white" stroke="gray" d="M731.5,23010.5A6,6,0,1,1,719.5,23010.5A6,6,0,1,1,731.5,23010.5"></path><path id="kity_path_26118" fill="none" stroke="gray" d="M721,23010.5L730,23010.5"></path></g><path id="node_outline1866" fill="none" stroke="none" d="M736.5,22947.5h907a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-907a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text1866" fill="black"><text id="kity_text_12610" text-rendering="inherit" font-size="12" dy=".8em" y="22948.700000047684" x="736.5">1.能动态修改字节码</text><text id="kity_text_12611" text-rendering="inherit" font-size="12" dy=".8em" y="22966.700000047684" x="736.5">2.怎么修改？ 可以用开源的ASM来修改字节码和生成类，</text><text id="kity_text_12612" text-rendering="inherit" font-size="12" dy=".8em" y="22984.700000047684" x="736.5">ClassReader: 读取类文件 ClassWriter: 继承ClassVisitor 主要用来生成修改类之后的字节</text><text id="kity_text_12613" text-rendering="inherit" font-size="12" dy=".8em" y="23002.700000047684" x="736.5">ClassVisitor: 用于访问修改类 MethodVisitor: 用于访问修改类的方法</text><text id="kity_text_12614" text-rendering="inherit" font-size="12" dy=".8em" y="23020.700000047684" x="736.5">(1)先利用ClassReader读取待修改的类文件，然后基于Reader创建了对应的ClassWriter，</text><text id="kity_text_12615" text-rendering="inherit" font-size="12" dy=".8em" y="23038.700000047684" x="736.5">(2)再基于ClassWriter创建了对应的ClassVisitor, 再接着ClassReader委托ClassVisitor去读取修改类，</text><text id="kity_text_12616" text-rendering="inherit" font-size="12" dy=".8em" y="23056.700000047684" x="736.5">(3)最后，创建文件输出流，利用ClassWriter生成的字节，将重新生成的字节码写回build目录生成的class文件，替换编译生成的class文件，这样就可以达到修改类的目的。</text></g></g><g id="minder_node1870"><g id="node_expander1864" style="cursor: pointer;" display="none"><path id="kity_path_26114" fill="white" stroke="gray" d="M1664.5,23010.5A6,6,0,1,1,1652.5,23010.5A6,6,0,1,1,1664.5,23010.5"></path><path id="kity_path_26115" fill="none" stroke="gray"></path></g><path id="node_outline1865" fill="none" stroke="none" d="M1669.5,22996.5h53a5,5,0,0,1,5,5v18a5,5,0,0,1,-5,5h-53a5,5,0,0,1,-5,-5v-18a5,5,0,0,1,5,-5z"></path><g id="node_text1865" fill="black"><text id="kity_text_12608" text-rendering="inherit" font-size="12" dy=".8em" y="23002.700000047684" x="1669.5">参考</text></g><a id="kity_a_16952" xlink:href="https://blog.csdn.net/taoszu/article/details/82466117" target="_blank" xlink:title="https://blog.csdn.net/taoszu/article/details/82466117" style="cursor: pointer;"><path id="kity_path_16954" fill="rgba(255, 255, 255, 0)" stroke="none" d="M1702.5,22999.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16953" fill="#666" stroke="none" d="M1717.114,23015.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V23009.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C1712.766,23006.571,1714.168,23005.5,1715.836,23005.5h1.278c2.116,0,3.834,1.716,3.834,3.834V23011.89C1720.948,23014.008,1719.23,23015.724,1717.114,23015.724zM1705.612,23010.612c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S1715.265,23011.89,1714.558,23011.89H1706.89C1706.185,23011.89,1705.612,23011.319,1705.612,23010.612zM1703.056,23009.334V23011.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H1704.334C1702.216,23015.724,1700.5,23014.008,1700.5,23011.89V23009.334C1700.5,23007.216,1702.216,23005.5,1704.334,23005.5h1.278c1.667,0,3.071,1.071,3.599,2.556H1704.334C1703.629,23008.056,1703.056,23008.627,1703.056,23009.334z"></path></a></g><g id="minder_node1871"><g id="node_expander1868" style="cursor: pointer;"><path id="kity_path_26126" fill="white" stroke="gray" d="M608.5,23144.5A6,6,0,1,1,596.5,23144.5A6,6,0,1,1,608.5,23144.5"></path><path id="kity_path_26127" fill="none" stroke="gray" d="M598,23144.5L607,23144.5"></path></g><path id="node_outline1869" fill="none" stroke="none" d="M613.5,23135.5h97a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-97a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1869" fill="black"><text id="kity_text_12628" text-rendering="inherit" font-size="12" dy=".8em" y="23136.700000047684" x="613.5">类的初始化顺序？</text></g></g><g id="minder_node1872"><g id="node_expander1867" style="cursor: pointer;" display="none"><path id="kity_path_26123" fill="white" stroke="gray" d="M731.5,23144.5A6,6,0,1,1,719.5,23144.5A6,6,0,1,1,731.5,23144.5"></path><path id="kity_path_26124" fill="none" stroke="gray"></path></g><path id="node_outline1868" fill="none" stroke="none" d="M736.5,23081.5h289a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-289a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text1868" fill="black"><text id="kity_text_12620" text-rendering="inherit" font-size="12" dy=".8em" y="23082.700000047684" x="736.5">1.</text><text id="kity_text_12621" text-rendering="inherit" font-size="12" dy=".8em" y="23100.700000047684" x="736.5">父类静态变量和静态代码块（先声明的先执行）；</text><text id="kity_text_12622" text-rendering="inherit" font-size="12" dy=".8em" y="23118.700000047684" x="736.5">子类静态变量和静态代码块（先声明的先执行）；</text><text id="kity_text_12623" text-rendering="inherit" font-size="12" dy=".8em" y="23136.700000047684" x="736.5">父类普通成员变量和普通代码块（先声明的先执行）；</text><text id="kity_text_12624" text-rendering="inherit" font-size="12" dy=".8em" y="23154.700000047684" x="736.5">父类的构造函数；</text><text id="kity_text_12625" text-rendering="inherit" font-size="12" dy=".8em" y="23172.700000047684" x="736.5">子类普通成员变量和普通代码块（先声明的先执行）；</text><text id="kity_text_12626" text-rendering="inherit" font-size="12" dy=".8em" y="23190.700000047684" x="736.5">子类的构造函数</text></g></g><g id="minder_node1873"><g id="node_expander1870" style="cursor: pointer;"><path id="kity_path_26132" fill="white" stroke="gray" d="M608.5,23260.5A6,6,0,1,1,596.5,23260.5A6,6,0,1,1,608.5,23260.5"></path><path id="kity_path_26133" fill="none" stroke="gray" d="M598,23260.5L607,23260.5"></path></g><path id="node_outline1871" fill="none" stroke="none" d="M613.5,23251.5h146a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-146a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1871" fill="black"><text id="kity_text_12636" text-rendering="inherit" font-size="12" dy=".8em" y="23252.700000047684" x="613.5">说一下类加载的初始化时机</text></g></g><g id="minder_node1874"><g id="node_expander1869" style="cursor: pointer;" display="none"><path id="kity_path_26129" fill="white" stroke="gray" d="M780.5,23260.5A6,6,0,1,1,768.5,23260.5A6,6,0,1,1,780.5,23260.5"></path><path id="kity_path_26130" fill="none" stroke="gray"></path></g><path id="node_outline1870" fill="none" stroke="none" d="M785.5,23215.5h607a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-607a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1870" fill="black"><text id="kity_text_12630" text-rendering="inherit" font-size="12" dy=".8em" y="23216.700000047684" x="785.5">1.以下立即初始化</text><text id="kity_text_12631" text-rendering="inherit" font-size="12" dy=".8em" y="23234.700000047684" x="785.5">1）.new 实例化类时，也就是new关键字</text><text id="kity_text_12632" text-rendering="inherit" font-size="12" dy=".8em" y="23252.700000047684" x="785.5">2）.用到了反射包方法时，reflect包下，也就是 class.forName(xxx);时，因为反射调用类时，类是要初始化的</text><text id="kity_text_12633" text-rendering="inherit" font-size="12" dy=".8em" y="23270.700000047684" x="785.5">3）.初始化子类时，如果父类没初始化，需要先初始化父类</text><text id="kity_text_12634" text-rendering="inherit" font-size="12" dy=".8em" y="23288.700000047684" x="785.5">4）.程序入口包含main方法时的主类(springboot启动类) 5）.调用类的静态方法时 6）.对静态变量进行访问和赋值</text></g></g><g id="minder_node1875"><g id="node_expander1872" style="cursor: pointer;"><path id="kity_path_26138" fill="white" stroke="gray" d="M608.5,23340.5A6,6,0,1,1,596.5,23340.5A6,6,0,1,1,608.5,23340.5"></path><path id="kity_path_26139" fill="none" stroke="gray" d="M598,23340.5L607,23340.5"></path></g><path id="node_outline1873" fill="none" stroke="none" d="M613.5,23331.5h217a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-217a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1873" fill="black"><text id="kity_text_12642" text-rendering="inherit" font-size="12" dy=".8em" y="23332.700000047684" x="613.5">继续上面那个问题说一下初始化，解释下</text></g></g><g id="minder_node1876"><g id="node_expander1871" style="cursor: pointer;" display="none"><path id="kity_path_26135" fill="white" stroke="gray" d="M851.5,23340.5A6,6,0,1,1,839.5,23340.5A6,6,0,1,1,851.5,23340.5"></path><path id="kity_path_26136" fill="none" stroke="gray"></path></g><path id="node_outline1872" fill="none" stroke="none" d="M856.5,23313.5h812a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-812a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1872" fill="black"><text id="kity_text_12638" text-rendering="inherit" font-size="12" dy=".8em" y="23314.700000047684" x="856.5">1.这一步也是Java虚拟机才真正开始执行类中编写的Java程序代码的时侯，在准备阶段，基本数据类型和string已经被赋了默认值，而这一步是赋正确的值</text><text id="kity_text_12639" text-rendering="inherit" font-size="12" dy=".8em" y="23332.700000047684" x="856.5">2.作用:对静态变量声明的初始值初始化，对静态代码块设置的初始值初始化</text><text id="kity_text_12640" text-rendering="inherit" font-size="12" dy=".8em" y="23350.700000047684" x="856.5">3.这是类加载过程的最后一步，是执行类构造器 &lt;clinit&gt;() 方法的过程。</text></g></g><g id="minder_node1877"><g id="node_expander1874" style="cursor: pointer;"><path id="kity_path_26144" fill="white" stroke="gray" d="M608.5,23384.5A6,6,0,1,1,596.5,23384.5A6,6,0,1,1,608.5,23384.5"></path><path id="kity_path_26145" fill="none" stroke="gray" d="M598,23384.5L607,23384.5"></path></g><path id="node_outline1875" fill="none" stroke="none" d="M613.5,23375.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1875" fill="black"><text id="kity_text_12646" text-rendering="inherit" font-size="12" dy=".8em" y="23376.700000047684" x="613.5">类的生命周期？</text></g></g><g id="minder_node1878"><g id="node_expander1873" style="cursor: pointer;" display="none"><path id="kity_path_26141" fill="white" stroke="gray" d="M719.5,23384.5A6,6,0,1,1,707.5,23384.5A6,6,0,1,1,719.5,23384.5"></path><path id="kity_path_26142" fill="none" stroke="gray"></path></g><path id="node_outline1874" fill="none" stroke="none" d="M724.5,23375.5h356a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-356a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1874" fill="black"><text id="kity_text_12644" text-rendering="inherit" font-size="12" dy=".8em" y="23376.700000047684" x="724.5">1.加载&#xa0; 2.连接分三个，验证-&gt;准备-&gt;解析&#xa0; 3.初始化 4.使用&#xa0; 5.卸载</text></g></g><g id="minder_node1879"><g id="node_expander1877" style="cursor: pointer;"><path id="kity_path_26153" fill="white" stroke="gray" d="M608.5,23500.5A6,6,0,1,1,596.5,23500.5A6,6,0,1,1,608.5,23500.5"></path><path id="kity_path_26154" fill="none" stroke="gray" d="M598,23500.5L607,23500.5"></path></g><path id="node_outline1878" fill="none" stroke="none" d="M613.5,23491.5h134a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-134a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1878" fill="black"><text id="kity_text_12664" text-rendering="inherit" font-size="12" dy=".8em" y="23492.700000047684" x="613.5">说一下类加载加载的过程</text></g></g><g id="minder_node1880"><g id="node_expander1876" style="cursor: pointer;"><path id="kity_path_26150" fill="white" stroke="gray" d="M768.5,23500.5A6,6,0,1,1,756.5,23500.5A6,6,0,1,1,768.5,23500.5"></path><path id="kity_path_26151" fill="none" stroke="gray" d="M758,23500.5L767,23500.5"></path></g><path id="node_outline1877" fill="none" stroke="none" d="M773.5,23401.5h888a5,5,0,0,1,5,5v188a5,5,0,0,1,-5,5h-888a5,5,0,0,1,-5,-5v-188a5,5,0,0,1,5,-5z"></path><g id="node_text1877" fill="black"><text id="kity_text_12652" text-rendering="inherit" font-size="12" dy=".8em" y="23402.700000047684" x="773.5">1.加载：主要是通过类的全限定类名把 类的class二进制流文件通过类加载器装载入内存，并将这些静态数据转换成方法区中的运行时数据结构。</text><text id="kity_text_12653" text-rendering="inherit" font-size="12" dy=".8em" y="23420.700000047684" x="773.5">2.验证：主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。文件格式验证、元数据验证、字节码验证、符号引用验证。</text><text id="kity_text_12654" text-rendering="inherit" font-size="12" dy=".8em" y="23438.700000047684" x="773.5">3.准备：给类静态变量分配内存空间，分配内存并设置类变量初</text><text id="kity_text_12655" text-rendering="inherit" font-size="12" dy=".8em" y="23456.700000047684" x="773.5">始值的阶段，比如 public static int age = 14，在准备后age = 0 还是int的初值，在初始化阶段 age = 14，如果添加了final则在这个阶段直接赋值为14，</text><text id="kity_text_12656" text-rendering="inherit" font-size="12" dy=".8em" y="23474.700000047684" x="773.5">被 static final 一起修饰，那么他在编译时 是会被生成constantValue属性修饰，而这个修饰可以让a在准备这一步&#xa0; 就把 14 赋给a 那么就相当于把a直接放入常量池了。</text><text id="kity_text_12657" text-rendering="inherit" font-size="12" dy=".8em" y="23492.700000047684" x="773.5">4.解析 ，主要是针对 类和接口，字段，类方法，接口方法，方法类型 将常量池内的符号引用替换为直接引用。</text><text id="kity_text_12658" text-rendering="inherit" font-size="12" dy=".8em" y="23510.700000047684" x="773.5">5.初始化 是Java虚拟机才真正开始执行类中编写的Java程序代码的时侯，在准备阶段，基本数据类型和string已经被赋了默认值，而这一步是赋正确的值</text><text id="kity_text_12659" text-rendering="inherit" font-size="12" dy=".8em" y="23528.700000047684" x="773.5">当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</text><text id="kity_text_12660" text-rendering="inherit" font-size="12" dy=".8em" y="23546.700000047684" x="773.5">对静态变量声明的初始值初始化，对静态代码块设置的初始值初始化</text><text id="kity_text_12661" text-rendering="inherit" font-size="12" dy=".8em" y="23564.700000047684" x="773.5">6.使用 为对象分配内存空间和初始化了</text><text id="kity_text_12662" text-rendering="inherit" font-size="12" dy=".8em" y="23582.700000047684" x="773.5">7.卸载 过GC算法回收对象了。</text></g></g><g id="minder_node1881"><g id="node_expander1875" style="cursor: pointer;" display="none"><path id="kity_path_26147" fill="white" stroke="gray" d="M1682.5,23500.5A6,6,0,1,1,1670.5,23500.5A6,6,0,1,1,1682.5,23500.5"></path><path id="kity_path_26148" fill="none" stroke="gray"></path></g><path id="node_outline1876" fill="none" stroke="none" d="M1687.5,23473.5h461a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-461a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1876" fill="black"><text id="kity_text_12648" text-rendering="inherit" font-size="12" dy=".8em" y="23474.700000047684" x="1687.5">https://blog.csdn.net/itcodexy/article/details/112793206</text><text id="kity_text_12649" text-rendering="inherit" font-size="12" dy=".8em" y="23492.700000047684" x="1687.5">https://github.com/dunwu/javacore/blob/master/docs/jvm/jvm-class-loader.md</text><text id="kity_text_12650" text-rendering="inherit" font-size="12" dy=".8em" y="23510.700000047684" x="1687.5">https://juejin.cn/post/6844903517388275726#heading-3</text></g></g><g id="minder_node1882"><g id="node_expander1879" style="cursor: pointer;"><path id="kity_path_26159" fill="white" stroke="gray" d="M608.5,23616.5A6,6,0,1,1,596.5,23616.5A6,6,0,1,1,608.5,23616.5"></path><path id="kity_path_26160" fill="none" stroke="gray" d="M598,23616.5L607,23616.5"></path></g><path id="node_outline1880" fill="none" stroke="none" d="M613.5,23607.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1880" fill="black"><text id="kity_text_12668" text-rendering="inherit" font-size="12" dy=".8em" y="23608.700000047684" x="613.5">类加载的区域知道吗</text></g></g><g id="minder_node1883"><g id="node_expander1878" style="cursor: pointer;" display="none"><path id="kity_path_26156" fill="white" stroke="gray" d="M743.5,23616.5A6,6,0,1,1,731.5,23616.5A6,6,0,1,1,743.5,23616.5"></path><path id="kity_path_26157" fill="none" stroke="gray"></path></g><path id="node_outline1879" fill="none" stroke="none" d="M748.5,23607.5h962a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-962a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1879" fill="black"><text id="kity_text_12666" text-rendering="inherit" font-size="12" dy=".8em" y="23608.700000047684" x="748.5">1.类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。</text></g></g><g id="minder_node1884"><g id="node_expander1897" style="cursor: pointer;"><path id="kity_path_26213" fill="white" stroke="gray" d="M608.5,23931.5A6,6,0,1,1,596.5,23931.5A6,6,0,1,1,608.5,23931.5"></path><path id="kity_path_26214" fill="none" stroke="gray" d="M598,23931.5L607,23931.5"></path></g><path id="node_outline1898" fill="none" stroke="none" d="M613.5,23922.5h122a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-122a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1898" fill="black"><text id="kity_text_12736" text-rendering="inherit" font-size="12" dy=".8em" y="23923.700000047684" x="613.5">双亲委派机制相关问题</text></g></g><g id="minder_node1885"><g id="node_expander1881" style="cursor: pointer;"><path id="kity_path_26165" fill="white" stroke="gray" d="M756.5,23651.5A6,6,0,1,1,744.5,23651.5A6,6,0,1,1,756.5,23651.5"></path><path id="kity_path_26166" fill="none" stroke="gray" d="M746,23651.5L755,23651.5"></path></g><path id="node_outline1882" fill="none" stroke="none" d="M761.5,23642.5h146a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-146a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1882" fill="black"><text id="kity_text_12673" text-rendering="inherit" font-size="12" dy=".8em" y="23643.700000047684" x="761.5">说一下双亲委派机制是什么</text></g></g><g id="minder_node1886"><g id="node_expander1880" style="cursor: pointer;" display="none"><path id="kity_path_26162" fill="white" stroke="gray" d="M928.5,23651.5A6,6,0,1,1,916.5,23651.5A6,6,0,1,1,928.5,23651.5"></path><path id="kity_path_26163" fill="none" stroke="gray"></path></g><path id="node_outline1881" fill="none" stroke="none" d="M933.5,23633.5h856a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-856a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1881" fill="black"><text id="kity_text_12670" text-rendering="inherit" font-size="12" dy=".8em" y="23634.700000047684" x="933.5">1.当某个类加载器需要加载某个.class文件时，首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。</text><text id="kity_text_12671" text-rendering="inherit" font-size="12" dy=".8em" y="23652.700000047684" x="933.5">相当于就是 向上判断是否有加载器，向下加载器动态加载类，</text></g></g><g id="minder_node1887"><g id="node_expander1883" style="cursor: pointer;"><path id="kity_path_26171" fill="white" stroke="gray" d="M756.5,23713.5A6,6,0,1,1,744.5,23713.5A6,6,0,1,1,756.5,23713.5"></path><path id="kity_path_26172" fill="none" stroke="gray" d="M746,23713.5L755,23713.5"></path></g><path id="node_outline1884" fill="none" stroke="none" d="M761.5,23704.5h146a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-146a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1884" fill="black"><text id="kity_text_12680" text-rendering="inherit" font-size="12" dy=".8em" y="23705.700000047684" x="761.5">说一下双亲委派机制的好处</text></g></g><g id="minder_node1888"><g id="node_expander1882" style="cursor: pointer;" display="none"><path id="kity_path_26168" fill="white" stroke="gray" d="M928.5,23713.5A6,6,0,1,1,916.5,23713.5A6,6,0,1,1,928.5,23713.5"></path><path id="kity_path_26169" fill="none" stroke="gray"></path></g><path id="node_outline1883" fill="none" stroke="none" d="M933.5,23677.5h1268a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1268a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1883" fill="black"><text id="kity_text_12675" text-rendering="inherit" font-size="12" dy=".8em" y="23678.700000047684" x="933.5">1.可以防止重复加载同一个.class。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。保证被加载类的唯一性。</text><text id="kity_text_12676" text-rendering="inherit" font-size="12" dy=".8em" y="23696.700000047684" x="933.5">2.防止核心API库被随意篡改。自己写的java.lang.String.class类不会被加载 会报错</text><text id="kity_text_12677" text-rendering="inherit" font-size="12" dy=".8em" y="23714.700000047684" x="933.5">首先 Object类是顶级父类，而双亲委派模型可以让不管你使用哪个类加载器加载Object，最后一个都是委派给最顶端的启动类加载器加载，这样就保持了加载器是同一个了，这样对象也就是同一个，因为比较一个对象前提是同一个类加载器</text><text id="kity_text_12678" text-rendering="inherit" font-size="12" dy=".8em" y="23732.700000047684" x="933.5">如果不一致，那么多个不同的Object使用不同的类加载器，java最基础的行为也就无法保证，应用程序也将会变得一片混乱。</text></g></g><g id="minder_node1889"><g id="node_expander1886" style="cursor: pointer;"><path id="kity_path_26180" fill="white" stroke="gray" d="M756.5,23811.5A6,6,0,1,1,744.5,23811.5A6,6,0,1,1,756.5,23811.5"></path><path id="kity_path_26181" fill="none" stroke="gray" d="M746,23811.5L755,23811.5"></path></g><path id="node_outline1887" fill="none" stroke="none" d="M761.5,23802.5h172a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-172a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1887" fill="black"><text id="kity_text_12692" text-rendering="inherit" font-size="12" dy=".8em" y="23803.700000047684" x="761.5">为什么tomcat破坏双亲委派机制</text></g></g><g id="minder_node1890"><g id="node_expander1885" style="cursor: pointer;"><path id="kity_path_26177" fill="white" stroke="gray" d="M954.5,23811.5A6,6,0,1,1,942.5,23811.5A6,6,0,1,1,954.5,23811.5"></path><path id="kity_path_26178" fill="none" stroke="gray" d="M944,23811.5L953,23811.5"></path></g><path id="node_outline1886" fill="none" stroke="none" d="M959.5,23757.5h1092a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1092a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1886" fill="black"><text id="kity_text_12685" text-rendering="inherit" font-size="12" dy=".8em" y="23758.700000047684" x="959.5">1. 假设APP1 使用的是 Spring4 ， APP2 使用的是Spring5 , 毫无疑问 Spring4 和 Spring 5 肯定有 类的全路径一样的类吧，如果使用双亲委派 ，父加载器加载谁？</text><text id="kity_text_12686" text-rendering="inherit" font-size="12" dy=".8em" y="23776.700000047684" x="959.5">Tomcat可以部署多个应用，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离 .</text><text id="kity_text_12687" text-rendering="inherit" font-size="12" dy=".8em" y="23794.700000047684" x="959.5">如果使用默认的类加载器机制，肯定是无法加载两个相同类库的不同版本的，如果使用双亲委派，让父加载器去加载 ，不管你是什么版本的，只要你的全限定类名一样，那肯定只有一份，APP 隔离 无法满足</text><text id="kity_text_12688" text-rendering="inherit" font-size="12" dy=".8em" y="23812.700000047684" x="959.5">2.web容器 自己依赖的类库 (tomcat lib目录下)，不能与应用程序的类库混淆。基于安全考虑，应该让容器的类库和程序的类库隔离开来。</text><text id="kity_text_12689" text-rendering="inherit" font-size="12" dy=".8em" y="23830.700000047684" x="959.5">3.web容器要支持jsp的修改， jsp 文件最终也是要编译成class文件才能在虚拟机中运行， web容器需要支持 jsp 修改后不用重启</text><text id="kity_text_12690" text-rendering="inherit" font-size="12" dy=".8em" y="23848.700000047684" x="959.5">&#xa0;jsp 文件其实也就是class文件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp是不会重新加载的。所有需要打破</text></g></g><g id="minder_node1891"><g id="node_expander1884" style="cursor: pointer;" display="none"><path id="kity_path_26174" fill="white" stroke="gray" d="M2072.5,23811.5A6,6,0,1,1,2060.5,23811.5A6,6,0,1,1,2072.5,23811.5"></path><path id="kity_path_26175" fill="none" stroke="gray"></path></g><path id="node_outline1885" fill="none" stroke="none" d="M2077.5,23793.5h466a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-466a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1885" fill="black"><text id="kity_text_12682" text-rendering="inherit" font-size="12" dy=".8em" y="23794.700000047684" x="2077.5">https://blog.csdn.net/yangshangwei/article/details/106536300</text><text id="kity_text_12683" text-rendering="inherit" font-size="12" dy=".8em" y="23812.700000047684" x="2077.5">https://github.com/qiurunze123/memoryoptimization/blob/master/docs/jvm.md</text></g></g><g id="minder_node1892"><g id="node_expander1888" style="cursor: pointer;"><path id="kity_path_26186" fill="white" stroke="gray" d="M756.5,23882.5A6,6,0,1,1,744.5,23882.5A6,6,0,1,1,756.5,23882.5"></path><path id="kity_path_26187" fill="none" stroke="gray" d="M746,23882.5L755,23882.5"></path></g><path id="node_outline1889" fill="none" stroke="none" d="M761.5,23873.5h125a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-125a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1889" fill="black"><text id="kity_text_12696" text-rendering="inherit" font-size="12" dy=".8em" y="23874.700000047684" x="761.5">tomcat是怎么打破的？</text></g></g><g id="minder_node1893"><g id="node_expander1887" style="cursor: pointer;" display="none"><path id="kity_path_26183" fill="white" stroke="gray" d="M907.5,23882.5A6,6,0,1,1,895.5,23882.5A6,6,0,1,1,907.5,23882.5"></path><path id="kity_path_26184" fill="none" stroke="gray"></path></g><path id="node_outline1888" fill="none" stroke="none" d="M912.5,23873.5h1525a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1525a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1888" fill="black"><text id="kity_text_12694" text-rendering="inherit" font-size="12" dy=".8em" y="23874.700000047684" x="912.5">双亲委派机制要求除了顶层的启动类加载器之外，其余的类加载器都应当由自己的父类加载器加载。 很显然，tomcat 不是这样实现，tomcat 为了实现隔离性，没有遵守这个约定，每个 webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器，打破了双 亲委派机制。</text></g></g><g id="minder_node1894"><g id="node_expander1891" style="cursor: pointer;"><path id="kity_path_26195" fill="white" stroke="gray" d="M756.5,23953.5A6,6,0,1,1,744.5,23953.5A6,6,0,1,1,756.5,23953.5"></path><path id="kity_path_26196" fill="none" stroke="gray" d="M746,23953.5L755,23953.5"></path></g><path id="node_outline1892" fill="none" stroke="none" d="M761.5,23944.5h134a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-134a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1892" fill="black"><text id="kity_text_12711" text-rendering="inherit" font-size="12" dy=".8em" y="23945.700000047684" x="761.5">如何才能不走双亲委模型</text></g></g><g id="minder_node1895"><g id="node_expander1890" style="cursor: pointer;"><path id="kity_path_26192" fill="white" stroke="gray" d="M916.5,23953.5A6,6,0,1,1,904.5,23953.5A6,6,0,1,1,916.5,23953.5"></path><path id="kity_path_26193" fill="none" stroke="gray" d="M906,23953.5L915,23953.5"></path></g><path id="node_outline1891" fill="none" stroke="none" d="M921.5,23899.5h901a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-901a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1891" fill="black"><text id="kity_text_12704" text-rendering="inherit" font-size="12" dy=".8em" y="23900.700000047684" x="921.5">1.自定义类加载器，重写loadclass方法，</text><text id="kity_text_12705" text-rendering="inherit" font-size="12" dy=".8em" y="23918.700000047684" x="921.5">2.使用线程上下文加载器</text><text id="kity_text_12706" text-rendering="inherit" font-size="12" dy=".8em" y="23936.700000047684" x="921.5">2.1.线程上下文加载器(默认系统上下文加载器)可以越过根加载器 加载一些SPI(服务提供接口，如JDBC，只要mysql的jar包在类路径中，就可以注册mysql驱动)的实现类，</text><text id="kity_text_12707" text-rendering="inherit" font-size="12" dy=".8em" y="23954.700000047684" x="921.5">因为SPI的实现类&#xa0; 引导类加载器(bootstrap)是无法找到的。在JVM中会把当前线程的类加载器加载不到的类交给线程上下文类加载器来加载</text><text id="kity_text_12708" text-rendering="inherit" font-size="12" dy=".8em" y="23972.700000047684" x="921.5">2.2.使用线程上下文加载器，需要通信的线程的类 需要是同一个加载器，防止类转换错误</text><text id="kity_text_12709" text-rendering="inherit" font-size="12" dy=".8em" y="23990.700000047684" x="921.5">2.3.打破了双亲委托机制 是因为启动类加载器反倒需要委托系统类加载器去加载厂商提供的SPI具体实现</text></g></g><g id="minder_node1896"><g id="node_expander1889" style="cursor: pointer;" display="none"><path id="kity_path_26189" fill="white" stroke="gray" d="M1843.5,23953.5A6,6,0,1,1,1831.5,23953.5A6,6,0,1,1,1843.5,23953.5"></path><path id="kity_path_26190" fill="none" stroke="gray"></path></g><path id="node_outline1890" fill="none" stroke="none" d="M1848.5,23908.5h352a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-352a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1890" fill="black"><text id="kity_text_12698" text-rendering="inherit" font-size="12" dy=".8em" y="23909.700000047684" x="1848.5">https://blog.csdn.net/cy973071263/article/details/104129163</text><text id="kity_text_12699" text-rendering="inherit" font-size="12" dy=".8em" y="23927.700000047684" x="1848.5">https://blog.csdn.net/u013905744/article/details/114140495</text><text id="kity_text_12700" text-rendering="inherit" font-size="12" dy=".8em" y="23945.700000047684" x="1848.5">https://blog.csdn.net/yangcheng33/article/details/52631940</text><text id="kity_text_12701" text-rendering="inherit" font-size="12" dy=".8em" y="23963.700000047684" x="1848.5">https://cloud.tencent.com/developer/article/1147297</text><text id="kity_text_12702" text-rendering="inherit" font-size="12" dy=".8em" y="23981.700000047684" x="1848.5">https://blog.csdn.net/zhoudaxia/article/details/35897057</text></g></g><g id="minder_node1897"><g id="node_expander1893" style="cursor: pointer;"><path id="kity_path_26201" fill="white" stroke="gray" d="M756.5,24069.5A6,6,0,1,1,744.5,24069.5A6,6,0,1,1,756.5,24069.5"></path><path id="kity_path_26202" fill="none" stroke="gray" d="M746,24069.5L755,24069.5"></path></g><path id="node_outline1894" fill="none" stroke="none" d="M761.5,24060.5h218a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-218a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1894" fill="black"><text id="kity_text_12720" text-rendering="inherit" font-size="12" dy=".8em" y="24061.700000047684" x="761.5">有哪些JVM类加载器？类加载器的作用？</text></g></g><g id="minder_node1898"><g id="node_expander1892" style="cursor: pointer;" display="none"><path id="kity_path_26198" fill="white" stroke="gray" d="M1000.5,24069.5A6,6,0,1,1,988.5,24069.5A6,6,0,1,1,1000.5,24069.5"></path><path id="kity_path_26199" fill="none" stroke="gray"></path></g><path id="node_outline1893" fill="none" stroke="none" d="M1005.5,24015.5h1081a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1081a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1893" fill="black"><text id="kity_text_12713" text-rendering="inherit" font-size="12" dy=".8em" y="24016.700000047684" x="1005.5">1</text><text id="kity_text_12714" text-rendering="inherit" font-size="12" dy=".8em" y="24034.700000047684" x="1005.5">1).启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，Bootstrap类装载器是所有装载器的父亲。</text><text id="kity_text_12715" text-rendering="inherit" font-size="12" dy=".8em" y="24052.700000047684" x="1005.5">2).扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</text><text id="kity_text_12716" text-rendering="inherit" font-size="12" dy=".8em" y="24070.700000047684" x="1005.5">3).应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</text><text id="kity_text_12717" text-rendering="inherit" font-size="12" dy=".8em" y="24088.700000047684" x="1005.5">2.</text><text id="kity_text_12718" text-rendering="inherit" font-size="12" dy=".8em" y="24106.700000047684" x="1005.5">类加载器负责加载程序中的类型（类和接口），并赋予唯一的名字予以标识。</text></g></g><g id="minder_node1899"><g id="node_expander1896" style="cursor: pointer;"><path id="kity_path_26210" fill="white" stroke="gray" d="M756.5,24212.5A6,6,0,1,1,744.5,24212.5A6,6,0,1,1,756.5,24212.5"></path><path id="kity_path_26211" fill="none" stroke="gray" d="M746,24212.5L755,24212.5"></path></g><path id="node_outline1897" fill="none" stroke="none" d="M761.5,24203.5h241a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-241a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1897" fill="black"><text id="kity_text_12734" text-rendering="inherit" font-size="12" dy=".8em" y="24204.700000047684" x="761.5">怎么实现自定义类加载器？为什么要自定义？</text></g></g><g id="minder_node1900"><g id="node_expander1895" style="cursor: pointer;"><path id="kity_path_26207" fill="white" stroke="gray" d="M1023.5,24212.5A6,6,0,1,1,1011.5,24212.5A6,6,0,1,1,1023.5,24212.5"></path><path id="kity_path_26208" fill="none" stroke="gray" d="M1013,24212.5L1022,24212.5M1017.5,24208L1017.5,24217"></path></g><path id="node_outline1896" fill="none" stroke="none" d="M1028.5,24131.5h977a5,5,0,0,1,5,5v152a5,5,0,0,1,-5,5h-977a5,5,0,0,1,-5,-5v-152a5,5,0,0,1,5,-5z"></path><g id="node_text1896" fill="black"><text id="kity_text_12724" text-rendering="inherit" font-size="12" dy=".8em" y="24132.700000047684" x="1028.5">1.</text><text id="kity_text_12725" text-rendering="inherit" font-size="12" dy=".8em" y="24150.700000047684" x="1028.5">首先继承ClassLoader,重写 findClass方法&#xa0; findClass主要是来寻找类的，通过全限定类名&#xa0; 实例化class对象</text><text id="kity_text_12726" text-rendering="inherit" font-size="12" dy=".8em" y="24168.700000047684" x="1028.5">自定义需要的主要方法如下</text><text id="kity_text_12727" text-rendering="inherit" font-size="12" dy=".8em" y="24186.700000047684" x="1028.5">1)、loadClass() ： 加载目标类的入口，它首先会通过指定类的全限定名称查找当前 ClassLoader 以及它的双亲里面是否已经加载了目标类，找到直接返回该类的java.lang.Class对象。</text><text id="kity_text_12728" text-rendering="inherit" font-size="12" dy=".8em" y="24204.700000047684" x="1028.5">2)、findClass() ： 查找当前类加载器的缓存中是否已经加载目标类。 如果没有找到就会让双亲尝试加载，如果双亲都加载不了，就会调用 findClass() 让自定义加载器自己来加载目标类</text><text id="kity_text_12729" text-rendering="inherit" font-size="12" dy=".8em" y="24222.700000047684" x="1028.5">3)、defineClass() ： 拿到这个字节码之后再调用 defineClass() 方法将字节码转换成 Class 对象。</text><text id="kity_text_12730" text-rendering="inherit" font-size="12" dy=".8em" y="24240.700000047684" x="1028.5">2.</text><text id="kity_text_12731" text-rendering="inherit" font-size="12" dy=".8em" y="24258.700000047684" x="1028.5">高度的灵活性 通过自定义类加载器可以实现热部署 代码加密</text><text id="kity_text_12732" text-rendering="inherit" font-size="12" dy=".8em" y="24276.700000047684" x="1028.5">可以实现版本隔离，比如说 项目用了两套代码 一套开源的框架，一套在这个开源的框架修改的，那么如果要使用我们自己的就所有自定义类加载器加载我们自己版本的代码</text></g></g><g id="minder_node1901" display="none"><g id="node_expander1894" style="cursor: pointer;" display="none"><path id="kity_path_26204" fill="white" stroke="gray" d="M2026.5,24212.5A6,6,0,1,1,2014.5,24212.5A6,6,0,1,1,2026.5,24212.5"></path><path id="kity_path_26205" fill="none" stroke="gray"></path></g><path id="node_outline1895" fill="none" stroke="none" d="M2026.5,24203.5h333a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1895" fill="black"><text id="kity_text_12722" text-rendering="inherit" font-size="12" dy=".8em" y="24204.700000047684" x="2026.5">https://juejin.cn/post/6844903639794860040#heading-43</text></g></g><g id="minder_node1902"><g id="node_expander1902" style="cursor: pointer;"><path id="kity_path_26228" fill="white" stroke="gray" d="M608.5,24425.5A6,6,0,1,1,596.5,24425.5A6,6,0,1,1,608.5,24425.5"></path><path id="kity_path_26229" fill="none" stroke="gray" d="M598,24425.5L607,24425.5"></path></g><path id="node_outline1903" fill="none" stroke="none" d="M613.5,24416.5h65a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-65a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1903" fill="black"><text id="kity_text_12746" text-rendering="inherit" font-size="12" dy=".8em" y="24417.700000047684" x="613.5">JIT相关问题</text></g></g><g id="minder_node1903"><g id="node_expander1901" style="cursor: pointer;"><path id="kity_path_26225" fill="white" stroke="gray" d="M699.5,24425.5A6,6,0,1,1,687.5,24425.5A6,6,0,1,1,699.5,24425.5"></path><path id="kity_path_26226" fill="none" stroke="gray" d="M689,24425.5L698,24425.5"></path></g><path id="node_outline1902" fill="none" stroke="none" d="M704.5,24416.5h28a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-28a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1902" fill="black"><text id="kity_text_12744" text-rendering="inherit" font-size="12" dy=".8em" y="24417.700000047684" x="704.5">JIT？</text></g></g><g id="minder_node1904"><g id="node_expander1900" style="cursor: pointer;"><path id="kity_path_26222" fill="white" stroke="gray" d="M753.5,24425.5A6,6,0,1,1,741.5,24425.5A6,6,0,1,1,753.5,24425.5"></path><path id="kity_path_26223" fill="none" stroke="gray" d="M743,24425.5L752,24425.5"></path></g><path id="node_outline1901" fill="none" stroke="none" d="M758.5,24416.5h912a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-912a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1901" fill="black"><text id="kity_text_12742" text-rendering="inherit" font-size="12" dy=".8em" y="24417.700000047684" x="758.5">JIT是为了提高JVM编译速度的机制，通过判断是否是热点代码(多次调用的代码) 优化通过编译速度。如果走JIT就是走机器码(硬件层面)，否则走正常编译解释执行(效率不高)</text></g></g><g id="minder_node1905"><g id="node_expander1898" style="cursor: pointer;" display="none"><path id="kity_path_26216" fill="white" stroke="gray" d="M1691.5,24310.5A6,6,0,1,1,1679.5,24310.5A6,6,0,1,1,1691.5,24310.5"></path><path id="kity_path_26217" fill="none" stroke="gray"></path></g><path id="node_outline1899" fill="none" stroke="none" d="M1696.5,24301.5h298a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-298a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1899" fill="black"><text id="kity_text_12738" text-rendering="inherit" font-size="12" dy=".8em" y="24302.700000047684" x="1696.5">https://www.cnblogs.com/lyhero11/p/5080306.html</text></g></g><g id="minder_node1906"><g id="node_expander1899" style="cursor: pointer;" display="none"><path id="kity_path_26219" fill="white" stroke="gray" d="M1691.5,24439A6,6,0,1,1,1679.5,24439A6,6,0,1,1,1691.5,24439"></path><path id="kity_path_26220" fill="none" stroke="gray"></path></g><path id="node_outline1900" fill="none" stroke="none" d="M1696.5,24327.5h122a5,5,0,0,1,5,5v213a5,5,0,0,1,-5,5h-122a5,5,0,0,1,-5,-5v-213a5,5,0,0,1,5,-5z"></path><g id="node_text1900" fill="black"><text id="kity_text_12740" text-rendering="inherit" font-size="12" dy=".8em" y="24533.700000047684" x="1732.5">分支主题</text></g><image id="kity_image_17075" xlink:href="https://images2015.cnblogs.com/blog/588096/201512/588096-20151227155420406-1125753351.gif" x="1696.5" y="24330.5" width="122" height="200"></image></g><g id="minder_node1907"><g id="node_expander1956" style="cursor: pointer;"><path id="kity_path_26390" fill="white" stroke="gray" d="M544.5,25497.5A6,6,0,1,1,532.5,25497.5A6,6,0,1,1,544.5,25497.5"></path><path id="kity_path_26391" fill="none" stroke="gray" d="M534,25497.5L543,25497.5"></path></g><path id="node_outline1957" fill="none" stroke="none" d="M549.5,25488.5h110a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-110a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1957" fill="black"><text id="kity_text_12928" text-rendering="inherit" font-size="12" dy=".8em" y="25489.700000047684" x="549.5">性能调优和问题排查</text></g></g><g id="minder_node1908"><g id="node_expander1910" style="cursor: pointer;"><path id="kity_path_26252" fill="white" stroke="gray" d="M680.5,24624.5A6,6,0,1,1,668.5,24624.5A6,6,0,1,1,680.5,24624.5"></path><path id="kity_path_26253" fill="none" stroke="gray" d="M670,24624.5L679,24624.5"></path></g><path id="node_outline1911" fill="none" stroke="none" d="M685.5,24615.5h47a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-47a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1911" fill="black"><text id="kity_text_12765" text-rendering="inherit" font-size="12" dy=".8em" y="24616.700000047684" x="685.5">yong gc</text></g></g><g id="minder_node1909"><g id="node_expander1905" style="cursor: pointer;"><path id="kity_path_26237" fill="white" stroke="gray" d="M753.5,24576.5A6,6,0,1,1,741.5,24576.5A6,6,0,1,1,753.5,24576.5"></path><path id="kity_path_26238" fill="none" stroke="gray" d="M743,24576.5L752,24576.5"></path></g><path id="node_outline1906" fill="none" stroke="none" d="M758.5,24567.5h144a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-144a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1906" fill="black"><text id="kity_text_12753" text-rendering="inherit" font-size="12" dy=".8em" y="24568.700000047684" x="758.5">频繁yong gc的原因有哪些</text></g></g><g id="minder_node1910"><g id="node_expander1904" style="cursor: pointer;" display="none"><path id="kity_path_26234" fill="white" stroke="gray" d="M923.5,24576.5A6,6,0,1,1,911.5,24576.5A6,6,0,1,1,923.5,24576.5"></path><path id="kity_path_26235" fill="none" stroke="gray"></path></g><path id="node_outline1905" fill="none" stroke="none" d="M928.5,24558.5h270a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-270a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1905" fill="black"><text id="kity_text_12750" text-rendering="inherit" font-size="12" dy=".8em" y="24559.700000047684" x="928.5">1.</text><text id="kity_text_12751" text-rendering="inherit" font-size="12" dy=".8em" y="24577.700000047684" x="928.5">Minor GC 频繁一般是短周期的 Java 小对象较多。</text></g></g><g id="minder_node1911"><g id="node_expander1907" style="cursor: pointer;"><path id="kity_path_26243" fill="white" stroke="gray" d="M753.5,24629.5A6,6,0,1,1,741.5,24629.5A6,6,0,1,1,753.5,24629.5"></path><path id="kity_path_26244" fill="none" stroke="gray" d="M743,24629.5L752,24629.5"></path></g><path id="node_outline1908" fill="none" stroke="none" d="M758.5,24620.5h144a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-144a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1908" fill="black"><text id="kity_text_12759" text-rendering="inherit" font-size="12" dy=".8em" y="24621.700000047684" x="758.5">频繁yong gc怎么排查解决</text></g></g><g id="minder_node1912"><g id="node_expander1906" style="cursor: pointer;" display="none"><path id="kity_path_26240" fill="white" stroke="gray" d="M923.5,24629.5A6,6,0,1,1,911.5,24629.5A6,6,0,1,1,923.5,24629.5"></path><path id="kity_path_26241" fill="none" stroke="gray"></path></g><path id="node_outline1907" fill="none" stroke="none" d="M928.5,24602.5h643a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-643a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1907" fill="black"><text id="kity_text_12755" text-rendering="inherit" font-size="12" dy=".8em" y="24603.700000047684" x="928.5">1.</text><text id="kity_text_12756" text-rendering="inherit" font-size="12" dy=".8em" y="24621.700000047684" x="928.5">（1）先考虑是不是 Eden 区/新生代设置的太小了，看能否通过调整 -Xmn、-XX:SurvivorRatio 等参数设置来解决问题。</text><text id="kity_text_12757" text-rendering="inherit" font-size="12" dy=".8em" y="24639.700000047684" x="928.5">（2）如果参数正常，但是 Minor GC 频率还是太高，就需要使用 jmap 和 MAT 对 dump 文件进行进一步诊断了。</text></g></g><g id="minder_node1913"><g id="node_expander1909" style="cursor: pointer;"><path id="kity_path_26249" fill="white" stroke="gray" d="M753.5,24673.5A6,6,0,1,1,741.5,24673.5A6,6,0,1,1,753.5,24673.5"></path><path id="kity_path_26250" fill="none" stroke="gray" d="M743,24673.5L752,24673.5"></path></g><path id="node_outline1910" fill="none" stroke="none" d="M758.5,24664.5h107a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-107a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1910" fill="black"><text id="kity_text_12763" text-rendering="inherit" font-size="12" dy=".8em" y="24665.700000047684" x="758.5">yong gc时间过长？</text></g></g><g id="minder_node1914"><g id="node_expander1908" style="cursor: pointer;" display="none"><path id="kity_path_26246" fill="white" stroke="gray" d="M886.5,24673.5A6,6,0,1,1,874.5,24673.5A6,6,0,1,1,886.5,24673.5"></path><path id="kity_path_26247" fill="none" stroke="gray"></path></g><path id="node_outline1909" fill="none" stroke="none" d="M891.5,24664.5h345a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-345a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1909" fill="black"><text id="kity_text_12761" text-rendering="inherit" font-size="12" dy=".8em" y="24665.700000047684" x="891.5">1.Minor GC 耗时过长问题就要看 GC 日志里耗时耗在哪一块了。</text></g></g><g id="minder_node1915"><g id="node_expander1920" style="cursor: pointer;"><path id="kity_path_26282" fill="white" stroke="gray" d="M680.5,24864.5A6,6,0,1,1,668.5,24864.5A6,6,0,1,1,680.5,24864.5"></path><path id="kity_path_26283" fill="none" stroke="gray" d="M670,24864.5L679,24864.5"></path></g><path id="node_outline1921" fill="none" stroke="none" d="M685.5,24855.5h35a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-35a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1921" fill="black"><text id="kity_text_12802" text-rendering="inherit" font-size="12" dy=".8em" y="24856.700000047684" x="685.5">full gc</text></g></g><g id="minder_node1916"><g id="node_expander1913" style="cursor: pointer;"><path id="kity_path_26261" fill="white" stroke="gray" d="M741.5,24744.5A6,6,0,1,1,729.5,24744.5A6,6,0,1,1,741.5,24744.5"></path><path id="kity_path_26262" fill="none" stroke="gray" d="M731,24744.5L740,24744.5"></path></g><path id="node_outline1914" fill="none" stroke="none" d="M746.5,24735.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1914" fill="black"><text id="kity_text_12776" text-rendering="inherit" font-size="12" dy=".8em" y="24736.700000047684" x="746.5">频繁full gc的原因有哪些</text></g></g><g id="minder_node1917"><g id="node_expander1912" style="cursor: pointer;"><path id="kity_path_26258" fill="white" stroke="gray" d="M900.5,24744.5A6,6,0,1,1,888.5,24744.5A6,6,0,1,1,900.5,24744.5"></path><path id="kity_path_26259" fill="none" stroke="gray" d="M890,24744.5L899,24744.5"></path></g><path id="node_outline1913" fill="none" stroke="none" d="M905.5,24690.5h1083a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1083a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text1913" fill="black"><text id="kity_text_12769" text-rendering="inherit" font-size="12" dy=".8em" y="24691.700000047684" x="905.5">1.CMS full gc</text><text id="kity_text_12770" text-rendering="inherit" font-size="12" dy=".8em" y="24709.700000047684" x="905.5">当CMS在执行回收时，新生代发生垃圾回收，同时老年代又没有足够的空间容纳晋升的对象时，CMS 垃圾回收就会退化成单线程的Full GC。所有的应用线程都会被暂停，老年代中所有的无效对象都被回收</text><text id="kity_text_12771" text-rendering="inherit" font-size="12" dy=".8em" y="24727.700000047684" x="905.5">当新生代发生垃圾回收，老年代有足够的空间可以容纳晋升的对象，但是由于空闲空间的碎片化，导致晋升失败，此时会触发单线程且带压缩动作的Full GC</text><text id="kity_text_12772" text-rendering="inherit" font-size="12" dy=".8em" y="24745.700000047684" x="905.5">2.解决</text><text id="kity_text_12773" text-rendering="inherit" font-size="12" dy=".8em" y="24763.700000047684" x="905.5">降低触发CMS GC的阈值，即参数-XX:CMSInitiatingOccupancyFraction的值，让CMS GC尽早执行，以保证有足够的空间</text><text id="kity_text_12774" text-rendering="inherit" font-size="12" dy=".8em" y="24781.700000047684" x="905.5">增加CMS线程数，即参数-XX:ConcGCThreads，增大老年代空间 让对象尽量在新生代回收，避免进入老年代</text></g></g><g id="minder_node1918"><g id="node_expander1911" style="cursor: pointer;" display="none"><path id="kity_path_26255" fill="white" stroke="gray" d="M2009.5,24744.5A6,6,0,1,1,1997.5,24744.5A6,6,0,1,1,2009.5,24744.5"></path><path id="kity_path_26256" fill="none" stroke="gray"></path></g><path id="node_outline1912" fill="none" stroke="none" d="M2014.5,24735.5h326a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1912" fill="black"><text id="kity_text_12767" text-rendering="inherit" font-size="12" dy=".8em" y="24736.700000047684" x="2014.5">https://juejin.cn/post/6844903953004494856#heading-6</text></g></g><g id="minder_node1919"><g id="node_expander1916" style="cursor: pointer;"><path id="kity_path_26270" fill="white" stroke="gray" d="M741.5,24851.5A6,6,0,1,1,729.5,24851.5A6,6,0,1,1,741.5,24851.5"></path><path id="kity_path_26271" fill="none" stroke="gray" d="M731,24851.5L740,24851.5"></path></g><path id="node_outline1917" fill="none" stroke="none" d="M746.5,24842.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1917" fill="black"><text id="kity_text_12786" text-rendering="inherit" font-size="12" dy=".8em" y="24843.700000047684" x="746.5">频繁full gc怎么排查解决</text></g></g><g id="minder_node1920"><g id="node_expander1915" style="cursor: pointer;"><path id="kity_path_26267" fill="white" stroke="gray" d="M900.5,24851.5A6,6,0,1,1,888.5,24851.5A6,6,0,1,1,900.5,24851.5"></path><path id="kity_path_26268" fill="none" stroke="gray" d="M890,24851.5L899,24851.5M894.5,24847L894.5,24856"></path></g><path id="node_outline1916" fill="none" stroke="none" d="M905.5,24806.5h1413a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1413a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1916" fill="black"><text id="kity_text_12780" text-rendering="inherit" font-size="12" dy=".8em" y="24807.700000047684" x="905.5">1.Full GC 相对来说会比 Minor GC 更耗时。减少进入老年代的对象数量可以显著降低 Full GC 的频率。</text><text id="kity_text_12781" text-rendering="inherit" font-size="12" dy=".8em" y="24825.700000047684" x="905.5">减少创建大对象：如果对象占用内存过大，在 Eden 区被创建后会直接被传入老年代。在平常的业务场景中，我们习惯一次性从数据库中查询出一个大对象用于 web 端显示。</text><text id="kity_text_12782" text-rendering="inherit" font-size="12" dy=".8em" y="24843.700000047684" x="905.5">例如，我之前碰到过一个一次性查询出 60 个字段的业务操作，这种大对象如果超过年轻代最大对象阈值，会被直接创建在老年代；即使被创建在了年轻代，由于年轻代的内存空间有限，通过 Minor GC 之后也会进入到老年代。这种大对象很容易产生较多的 Full GC。</text><text id="kity_text_12783" text-rendering="inherit" font-size="12" dy=".8em" y="24861.700000047684" x="905.5">我们可以将这种大对象拆解出来，首次只查询一些比较重要的字段，如果还需要其它字段辅助查看，再通过第二次查询显示剩余的字段。</text><text id="kity_text_12784" text-rendering="inherit" font-size="12" dy=".8em" y="24879.700000047684" x="905.5">**增大堆内存空间：**在堆内存不足的情况下，增大堆内存空间，且设置初始化堆内存为最大堆内存，也可以降低 Full GC 的频率。</text></g></g><g id="minder_node1921" display="none"><g id="node_expander1914" style="cursor: pointer;" display="none"><path id="kity_path_26264" fill="white" stroke="gray" d="M2339.5,24851.5A6,6,0,1,1,2327.5,24851.5A6,6,0,1,1,2339.5,24851.5"></path><path id="kity_path_26265" fill="none" stroke="gray"></path></g><path id="node_outline1915" fill="none" stroke="none" d="M2339.5,24837.5h79a5,5,0,0,1,5,5v18a5,5,0,0,1,-5,5h-79a5,5,0,0,1,-5,-5v-18a5,5,0,0,1,5,-5z"></path><g id="node_text1915" fill="black"><text id="kity_text_12778" text-rendering="inherit" font-size="12" dy=".8em" y="24843.700000047684" x="2339.5">分支主题</text></g><a id="kity_a_16955" xlink:href="https://github.com/dunwu/javacore/blob/master/docs/jvm/jvm-action.md#21-%E8%8E%B7%E5%8F%96-gc-%E6%97%A5%E5%BF%97" target="_blank" xlink:title="https://github.com/dunwu/javacore/blob/master/docs/jvm/jvm-action.md#21-%E8%8E%B7%E5%8F%96-gc-%E6%97%A5%E5%BF%97" style="cursor: pointer;"><path id="kity_path_16957" fill="rgba(255, 255, 255, 0)" stroke="none" d="M2398.5,24840.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16956" fill="#666" stroke="none" d="M2413.114,24856.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V24850.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C2408.766,24847.571,2410.168,24846.5,2411.836,24846.5h1.278c2.116,0,3.834,1.716,3.834,3.834V24852.89C2416.948,24855.008,2415.23,24856.724,2413.114,24856.724zM2401.612,24851.612c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S2411.265,24852.89,2410.558,24852.89H2402.89C2402.185,24852.89,2401.612,24852.319,2401.612,24851.612zM2399.056,24850.334V24852.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H2400.334C2398.216,24856.724,2396.5,24855.008,2396.5,24852.89V24850.334C2396.5,24848.216,2398.216,24846.5,2400.334,24846.5h1.278c1.667,0,3.071,1.071,3.599,2.556H2400.334C2399.629,24849.056,2399.056,24849.627,2399.056,24850.334z"></path></a></g><g id="minder_node1922"><g id="node_expander1919" style="cursor: pointer;"><path id="kity_path_26279" fill="white" stroke="gray" d="M741.5,24985.5A6,6,0,1,1,729.5,24985.5A6,6,0,1,1,741.5,24985.5"></path><path id="kity_path_26280" fill="none" stroke="gray" d="M731,24985.5L740,24985.5"></path></g><path id="node_outline1920" fill="none" stroke="none" d="M746.5,24976.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1920" fill="black"><text id="kity_text_12800" text-rendering="inherit" font-size="12" dy=".8em" y="24977.700000047684" x="746.5">说一下你full gc的调优</text></g></g><g id="minder_node1923"><g id="node_expander1918" style="cursor: pointer;"><path id="kity_path_26276" fill="white" stroke="gray" d="M888.5,24985.5A6,6,0,1,1,876.5,24985.5A6,6,0,1,1,888.5,24985.5"></path><path id="kity_path_26277" fill="none" stroke="gray" d="M878,24985.5L887,24985.5M882.5,24981L882.5,24990"></path></g><path id="node_outline1919" fill="none" stroke="none" d="M893.5,24904.5h1370a5,5,0,0,1,5,5v152a5,5,0,0,1,-5,5h-1370a5,5,0,0,1,-5,-5v-152a5,5,0,0,1,5,-5z"></path><g id="node_text1919" fill="black"><text id="kity_text_12790" text-rendering="inherit" font-size="12" dy=".8em" y="24905.700000047684" x="893.5">1.我们线上机器4核8G，系统留4G，前提4G 堆给3G，新生代给1.5G，其中伊甸园1.2&#xa0; 两个幸存区分别150</text><text id="kity_text_12791" text-rendering="inherit" font-size="12" dy=".8em" y="24923.700000047684" x="893.5">方法区给256，虚拟机栈 1m/thread</text><text id="kity_text_12792" text-rendering="inherit" font-size="12" dy=".8em" y="24941.700000047684" x="893.5">整体配置就是 -Xms3072m -Xmx3072m -Xmn1536m -Xss=1m -XX:PermSize=256m -XX:MaxPermSize=256m&#xa0; -XX:HandlePromotionFailure&#xa0; -XX:SurvivorRatio=8</text><text id="kity_text_12793" text-rendering="inherit" font-size="12" dy=".8em" y="24959.700000047684" x="893.5">2.然后我们估计系统每秒占内存数量</text><text id="kity_text_12794" text-rendering="inherit" font-size="12" dy=".8em" y="24977.700000047684" x="893.5">我们的系统 日活百万，下单量20W左右，一天八个小时，每一秒500个请求 一个请求100k，1秒分配内存大概50m</text><text id="kity_text_12795" text-rendering="inherit" font-size="12" dy=".8em" y="24995.700000047684" x="893.5">因为我们之前伊甸园1.2G，而1秒50m的内存分配，&#xa0; 平均 25s 一次yong gc。</text><text id="kity_text_12796" text-rendering="inherit" font-size="12" dy=".8em" y="25013.700000047684" x="893.5">我们看了下 幸存区，因为25s执行一次yong gc 那每一次gc执行期间，大概100m进入幸存区，然后触发年龄判断，使用幸存区应该大一点，就把新生代增加为2048m，-Xmn2048m</text><text id="kity_text_12797" text-rendering="inherit" font-size="12" dy=".8em" y="25031.700000047684" x="893.5">因为大对象直接进入老年代 大对象一般是长期存活和使用的对象，一般来说设置1M的对象直接进入老年代，这样避免大对象一直处于新生代中来回复制，所以加上PretenureSizeThreshold=1m参数。</text><text id="kity_text_12798" text-rendering="inherit" font-size="12" dy=".8em" y="25049.700000047684" x="893.5">然后合理设置对象年龄阈值 Minor GC后默认躲过15次垃圾回收后自动升入老年代，按照我们的评估25秒触发一次Minor GC，如果按照MaxTenuringThreshold参数的默认值，躲过15次GC后，应该是6分钟之后的事了，结合当前业务场景这里可以降低一点，</text></g></g><g id="minder_node1924" display="none"><g id="node_expander1917" style="cursor: pointer;" display="none"><path id="kity_path_26273" fill="white" stroke="gray" d="M2284.5,24985.5A6,6,0,1,1,2272.5,24985.5A6,6,0,1,1,2284.5,24985.5"></path><path id="kity_path_26274" fill="none" stroke="gray"></path></g><path id="node_outline1918" fill="none" stroke="none" d="M2284.5,24976.5h340a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-340a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1918" fill="black"><text id="kity_text_12788" text-rendering="inherit" font-size="12" dy=".8em" y="24977.700000047684" x="2284.5">https://blog.csdn.net/huaweitman/article/details/50899839</text></g></g><g id="minder_node1925"><g id="node_expander1922" style="cursor: pointer;"><path id="kity_path_26288" fill="white" stroke="gray" d="M680.5,25083.5A6,6,0,1,1,668.5,25083.5A6,6,0,1,1,680.5,25083.5"></path><path id="kity_path_26289" fill="none" stroke="gray" d="M670,25083.5L679,25083.5"></path></g><path id="node_outline1923" fill="none" stroke="none" d="M685.5,25074.5h108a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-108a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1923" fill="black"><text id="kity_text_12806" text-rendering="inherit" font-size="12" dy=".8em" y="25075.700000047684" x="685.5">怎么获取dump文件</text></g></g><g id="minder_node1926"><g id="node_expander1921" style="cursor: pointer;" display="none"><path id="kity_path_26285" fill="white" stroke="gray" d="M814.5,25083.5A6,6,0,1,1,802.5,25083.5A6,6,0,1,1,814.5,25083.5"></path><path id="kity_path_26286" fill="none" stroke="gray"></path></g><path id="node_outline1922" fill="none" stroke="none" d="M819.5,25074.5h604a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-604a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1922" fill="black"><text id="kity_text_12804" text-rendering="inherit" font-size="12" dy=".8em" y="25075.700000047684" x="819.5">1.通过参数设置OOM时打印dump。2.通过工具来实时dump。3.也可以通过参数打印当前堆栈快照dump， jmap</text></g></g><g id="minder_node1927"><g id="node_expander1923" style="cursor: pointer;" display="none"><path id="kity_path_26291" fill="white" stroke="gray" d="M680.5,25109.5A6,6,0,1,1,668.5,25109.5A6,6,0,1,1,680.5,25109.5"></path><path id="kity_path_26292" fill="none" stroke="gray"></path></g><path id="node_outline1924" fill="none" stroke="none" d="M685.5,25100.5h154a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-154a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1924" fill="black"><text id="kity_text_12808" text-rendering="inherit" font-size="12" dy=".8em" y="25101.700000047684" x="685.5">你分析过OOM dump文件吗</text></g></g><g id="minder_node1928"><g id="node_expander1925" style="cursor: pointer;"><path id="kity_path_26297" fill="white" stroke="gray" d="M680.5,25198.5A6,6,0,1,1,668.5,25198.5A6,6,0,1,1,680.5,25198.5"></path><path id="kity_path_26298" fill="none" stroke="gray" d="M670,25198.5L679,25198.5"></path></g><path id="node_outline1926" fill="none" stroke="none" d="M685.5,25189.5h117a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-117a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1926" fill="black"><text id="kity_text_12819" text-rendering="inherit" font-size="12" dy=".8em" y="25190.700000047684" x="685.5">说说OOM有哪些情况</text></g></g><g id="minder_node1929"><g id="node_expander1924" style="cursor: pointer;" display="none"><path id="kity_path_26294" fill="white" stroke="gray" d="M823.5,25198.5A6,6,0,1,1,811.5,25198.5A6,6,0,1,1,823.5,25198.5"></path><path id="kity_path_26295" fill="none" stroke="gray"></path></g><path id="node_outline1925" fill="none" stroke="none" d="M828.5,25126.5h1617a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-1617a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text1925" fill="black"><text id="kity_text_12810" text-rendering="inherit" font-size="12" dy=".8em" y="25127.700000047684" x="828.5">1.OOM原因</text><text id="kity_text_12811" text-rendering="inherit" font-size="12" dy=".8em" y="25145.700000047684" x="828.5">外部引发：分配给 JVM 的内存本来就不够用。</text><text id="kity_text_12812" text-rendering="inherit" font-size="12" dy=".8em" y="25163.700000047684" x="828.5">内部引发：已经无用的对象没有释放或没有及时释放，随着程序的执行，占用内存越来越高，最终内存溢出</text><text id="kity_text_12813" text-rendering="inherit" font-size="12" dy=".8em" y="25181.700000047684" x="828.5">2.OOM类型</text><text id="kity_text_12814" text-rendering="inherit" font-size="12" dy=".8em" y="25199.700000047684" x="828.5">堆内存溢出：通过工具查看泄漏对象到GC Roots的引用链。找到泄漏的对象是通过怎么样的路径与GC Roots相关联的导致垃圾回收机制无法将其回收，最终比较准确地定位泄漏代码的位置。如果不是内存泄漏就分析参数和代码的问题</text><text id="kity_text_12815" text-rendering="inherit" font-size="12" dy=".8em" y="25217.700000047684" x="828.5">虚拟机栈和本地方法栈溢出：StackOverflowError ：线程请求的栈深度超过了虚拟机所允许的最大深度，就会抛出该异常。单线程环境下无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法继续分配的时候，虚拟机抛出的都是StackOverflowError 异常。可以通过-Xss设置栈大小，默认1M，可以调整</text><text id="kity_text_12816" text-rendering="inherit" font-size="12" dy=".8em" y="25235.700000047684" x="828.5">多线程环境下为每个线程的栈分配的内存越大，每个线程获得空间大则可建立的线程数减少了反而越容易产生OOM异常，因此一般通过减少最大堆 和 减少栈容量 来换取更多的线程数量。</text><text id="kity_text_12817" text-rendering="inherit" font-size="12" dy=".8em" y="25253.700000047684" x="828.5">永久代溢出：方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。如Spring、对于类进行增强的时候都会使用到CGLib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成Class可以加载入内存，可能会造成方法区的OOM异常。</text></g></g><g id="minder_node1930"><g id="node_expander1928" style="cursor: pointer;"><path id="kity_path_26306" fill="white" stroke="gray" d="M680.5,25305.5A6,6,0,1,1,668.5,25305.5A6,6,0,1,1,680.5,25305.5"></path><path id="kity_path_26307" fill="none" stroke="gray" d="M670,25305.5L679,25305.5"></path></g><path id="node_outline1929" fill="none" stroke="none" d="M685.5,25296.5h116a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-116a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1929" fill="black"><text id="kity_text_12827" text-rendering="inherit" font-size="12" dy=".8em" y="25297.700000047684" x="685.5">有排查分析过OOM吗</text></g></g><g id="minder_node1931"><g id="node_expander1927" style="cursor: pointer;"><path id="kity_path_26303" fill="white" stroke="gray" d="M822.5,25305.5A6,6,0,1,1,810.5,25305.5A6,6,0,1,1,822.5,25305.5"></path><path id="kity_path_26304" fill="none" stroke="gray" d="M812,25305.5L821,25305.5"></path></g><path id="node_outline1928" fill="none" stroke="none" d="M827.5,25278.5h279a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-279a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1928" fill="black"><text id="kity_text_12823" text-rendering="inherit" font-size="12" dy=".8em" y="25279.700000047684" x="827.5">1.通过 jps 或 ps -ef |grep [pid] 查看进程号</text><text id="kity_text_12824" text-rendering="inherit" font-size="12" dy=".8em" y="25297.700000047684" x="827.5">2.jstat -gc&#xa0; [pid] [刷新时间] [显示条数]&#xa0; 查看gc情况</text><text id="kity_text_12825" text-rendering="inherit" font-size="12" dy=".8em" y="25315.700000047684" x="827.5">3.通过 jmap -histo [pid] 查看具体占用情况</text></g></g><g id="minder_node1932"><g id="node_expander1926" style="cursor: pointer;" display="none"><path id="kity_path_26300" fill="white" stroke="gray" d="M1127.5,25305.5A6,6,0,1,1,1115.5,25305.5A6,6,0,1,1,1127.5,25305.5"></path><path id="kity_path_26301" fill="none" stroke="gray"></path></g><path id="node_outline1927" fill="none" stroke="none" d="M1132.5,25296.5h330a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-330a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1927" fill="black"><text id="kity_text_12821" text-rendering="inherit" font-size="12" dy=".8em" y="25297.700000047684" x="1132.5">https://blog.csdn.net/iteye_9584/article/details/82583093</text></g></g><g id="minder_node1933"><g id="node_expander1930" style="cursor: pointer;"><path id="kity_path_26312" fill="white" stroke="gray" d="M680.5,25349.5A6,6,0,1,1,668.5,25349.5A6,6,0,1,1,680.5,25349.5"></path><path id="kity_path_26313" fill="none" stroke="gray" d="M670,25349.5L679,25349.5"></path></g><path id="node_outline1931" fill="none" stroke="none" d="M685.5,25340.5h241a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-241a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1931" fill="black"><text id="kity_text_12831" text-rendering="inherit" font-size="12" dy=".8em" y="25341.700000047684" x="685.5">遇到过线上问题吗，怎么排查的，怎么解决的</text></g></g><g id="minder_node1934"><g id="node_expander1929" style="cursor: pointer;" display="none"><path id="kity_path_26309" fill="white" stroke="gray" d="M947.5,25349.5A6,6,0,1,1,935.5,25349.5A6,6,0,1,1,947.5,25349.5"></path><path id="kity_path_26310" fill="none" stroke="gray"></path></g><path id="node_outline1930" fill="none" stroke="none" d="M952.5,25340.5h774a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-774a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1930" fill="black"><text id="kity_text_12829" text-rendering="inherit" font-size="12" dy=".8em" y="25341.700000047684" x="952.5">https://github.com/dunwu/javacore/blob/master/docs/jvm/jvm-action.md#21-%E8%8E%B7%E5%8F%96-gc-%E6%97%A5%E5%BF%97</text></g></g><g id="minder_node1935"><g id="node_expander1937" style="cursor: pointer;"><path id="kity_path_26333" fill="white" stroke="gray" d="M680.5,25481.5A6,6,0,1,1,668.5,25481.5A6,6,0,1,1,680.5,25481.5"></path><path id="kity_path_26334" fill="none" stroke="gray" d="M670,25481.5L679,25481.5"></path></g><path id="node_outline1938" fill="none" stroke="none" d="M685.5,25472.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1938" fill="black"><text id="kity_text_12849" text-rendering="inherit" font-size="12" dy=".8em" y="25473.700000047684" x="685.5">堆溢出和栈溢出系列问题？</text></g></g><g id="minder_node1936"><g id="node_expander1932" style="cursor: pointer;"><path id="kity_path_26318" fill="white" stroke="gray" d="M851.5,25411.5A6,6,0,1,1,839.5,25411.5A6,6,0,1,1,851.5,25411.5"></path><path id="kity_path_26319" fill="none" stroke="gray" d="M841,25411.5L850,25411.5"></path></g><path id="node_outline1933" fill="none" stroke="none" d="M856.5,25402.5h169a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-169a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1933" fill="black"><text id="kity_text_12839" text-rendering="inherit" font-size="12" dy=".8em" y="25403.700000047684" x="856.5">线上有遇到堆溢出和栈溢出吗？</text></g></g><g id="minder_node1937"><g id="node_expander1931" style="cursor: pointer;" display="none"><path id="kity_path_26315" fill="white" stroke="gray" d="M1046.5,25411.5A6,6,0,1,1,1034.5,25411.5A6,6,0,1,1,1046.5,25411.5"></path><path id="kity_path_26316" fill="none" stroke="gray"></path></g><path id="node_outline1932" fill="none" stroke="none" d="M1051.5,25366.5h567a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-567a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text1932" fill="black"><text id="kity_text_12833" text-rendering="inherit" font-size="12" dy=".8em" y="25367.700000047684" x="1051.5">https://juejin.cn/post/6916915472214523917#heading-0</text><text id="kity_text_12834" text-rendering="inherit" font-size="12" dy=".8em" y="25385.700000047684" x="1051.5">https://juejin.cn/post/6844903990900031502#heading-11</text><text id="kity_text_12835" text-rendering="inherit" font-size="12" dy=".8em" y="25403.700000047684" x="1051.5">https://juejin.cn/post/6844903506093015053#heading-15</text><text id="kity_text_12836" text-rendering="inherit" font-size="12" dy=".8em" y="25421.700000047684" x="1051.5">https://juejin.cn/post/6844904125696573448#heading-63</text><text id="kity_text_12837" text-rendering="inherit" font-size="12" dy=".8em" y="25439.700000047684" x="1051.5">https://github.com/dunwu/javacore/blob/master/docs/jvm/jvm-memory.md#5-stackoverflowerror</text></g></g><g id="minder_node1938"><g id="node_expander1933" style="cursor: pointer;" display="none"><path id="kity_path_26321" fill="white" stroke="gray" d="M851.5,25473.5A6,6,0,1,1,839.5,25473.5A6,6,0,1,1,851.5,25473.5"></path><path id="kity_path_26322" fill="none" stroke="gray"></path></g><path id="node_outline1934" fill="none" stroke="none" d="M856.5,25464.5h73a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-73a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1934" fill="black"><text id="kity_text_12841" text-rendering="inherit" font-size="12" dy=".8em" y="25465.700000047684" x="856.5">堆溢出的原因</text></g></g><g id="minder_node1939"><g id="node_expander1934" style="cursor: pointer;" display="none"><path id="kity_path_26324" fill="white" stroke="gray" d="M851.5,25499.5A6,6,0,1,1,839.5,25499.5A6,6,0,1,1,851.5,25499.5"></path><path id="kity_path_26325" fill="none" stroke="gray"></path></g><path id="node_outline1935" fill="none" stroke="none" d="M856.5,25490.5h181a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-181a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1935" fill="black"><text id="kity_text_12843" text-rendering="inherit" font-size="12" dy=".8em" y="25491.700000047684" x="856.5">说一下你排查解决堆溢出的过程？</text></g></g><g id="minder_node1940"><g id="node_expander1935" style="cursor: pointer;" display="none"><path id="kity_path_26327" fill="white" stroke="gray" d="M851.5,25525.5A6,6,0,1,1,839.5,25525.5A6,6,0,1,1,851.5,25525.5"></path><path id="kity_path_26328" fill="none" stroke="gray"></path></g><path id="node_outline1936" fill="none" stroke="none" d="M856.5,25516.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1936" fill="black"><text id="kity_text_12845" text-rendering="inherit" font-size="12" dy=".8em" y="25517.700000047684" x="856.5">栈溢出的原因？</text></g></g><g id="minder_node1941"><g id="node_expander1936" style="cursor: pointer;" display="none"><path id="kity_path_26330" fill="white" stroke="gray" d="M851.5,25551.5A6,6,0,1,1,839.5,25551.5A6,6,0,1,1,851.5,25551.5"></path><path id="kity_path_26331" fill="none" stroke="gray"></path></g><path id="node_outline1937" fill="none" stroke="none" d="M856.5,25542.5h181a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-181a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1937" fill="black"><text id="kity_text_12847" text-rendering="inherit" font-size="12" dy=".8em" y="25543.700000047684" x="856.5">说一下你排查解决栈溢出的过程？</text></g></g><g id="minder_node1942"><g id="node_expander1939" style="cursor: pointer;"><path id="kity_path_26339" fill="white" stroke="gray" d="M680.5,25658.5A6,6,0,1,1,668.5,25658.5A6,6,0,1,1,680.5,25658.5"></path><path id="kity_path_26340" fill="none" stroke="gray" d="M670,25658.5L679,25658.5"></path></g><path id="node_outline1940" fill="none" stroke="none" d="M685.5,25649.5h118a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-118a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1940" fill="black"><text id="kity_text_12862" text-rendering="inherit" font-size="12" dy=".8em" y="25650.700000047684" x="685.5">你怎么理解jvm调优？</text></g></g><g id="minder_node1943"><g id="node_expander1938" style="cursor: pointer;" display="none"><path id="kity_path_26336" fill="white" stroke="gray" d="M824.5,25658.5A6,6,0,1,1,812.5,25658.5A6,6,0,1,1,824.5,25658.5"></path><path id="kity_path_26337" fill="none" stroke="gray"></path></g><path id="node_outline1939" fill="none" stroke="none" d="M829.5,25568.5h866a5,5,0,0,1,5,5v170a5,5,0,0,1,-5,5h-866a5,5,0,0,1,-5,-5v-170a5,5,0,0,1,5,-5z"></path><g id="node_text1939" fill="black"><text id="kity_text_12851" text-rendering="inherit" font-size="12" dy=".8em" y="25569.700000047684" x="829.5">核心思想：尽可能让对象在新生代中分配和回收，尽量避免过多对象进入老年代，导致对老年代频繁进行垃圾回收，同时给系统足够的内存减少新生代垃圾回收次数</text><text id="kity_text_12852" text-rendering="inherit" font-size="12" dy=".8em" y="25587.700000047684" x="829.5">1.时间</text><text id="kity_text_12853" text-rendering="inherit" font-size="12" dy=".8em" y="25605.700000047684" x="829.5">&#xa0;Full GC 次数频繁；GC 停顿时间过长； 应用中有使用本地缓存且占用大量内存空间； heap 内存（老年代）持续上涨达到设置的最大内存值；应用出现OOM</text><text id="kity_text_12854" text-rendering="inherit" font-size="12" dy=".8em" y="25623.700000047684" x="829.5">2.原则</text><text id="kity_text_12855" text-rendering="inherit" font-size="12" dy=".8em" y="25641.700000047684" x="829.5">多数导致GC问题的Java应用，都不是因为我们参数设置错误，而是代码问题；减少创建对象的数量；减少使用全局变量和大对象；</text><text id="kity_text_12856" text-rendering="inherit" font-size="12" dy=".8em" y="25659.700000047684" x="829.5">3.目标</text><text id="kity_text_12857" text-rendering="inherit" font-size="12" dy=".8em" y="25677.700000047684" x="829.5">&#xa0;GC低停顿； GC低频率；低内存占用； 高吞吐量；</text><text id="kity_text_12858" text-rendering="inherit" font-size="12" dy=".8em" y="25695.700000047684" x="829.5">4.步骤</text><text id="kity_text_12859" text-rendering="inherit" font-size="12" dy=".8em" y="25713.700000047684" x="829.5">分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点；确定jvm调优参数（根据历史jvm参数来调整）；调优一台服务器，对比观察调优前后的差异；</text><text id="kity_text_12860" text-rendering="inherit" font-size="12" dy=".8em" y="25731.700000047684" x="829.5">&#xa0;不断的分析和调整，找到合适的jvm参数配置；找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。</text></g></g><g id="minder_node1944"><g id="node_expander1943" style="cursor: pointer;"><path id="kity_path_26351" fill="white" stroke="gray" d="M680.5,26007.5A6,6,0,1,1,668.5,26007.5A6,6,0,1,1,680.5,26007.5"></path><path id="kity_path_26352" fill="none" stroke="gray" d="M670,26007.5L679,26007.5"></path></g><path id="node_outline1944" fill="none" stroke="none" d="M685.5,25998.5h107a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-107a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1944" fill="black"><text id="kity_text_12895" text-rendering="inherit" font-size="12" dy=".8em" y="25999.700000047684" x="685.5">jvm调优参数配置？</text></g></g><g id="minder_node1945"><g id="node_expander1941" style="cursor: pointer;"><path id="kity_path_26345" fill="white" stroke="gray" d="M813.5,25936.5A6,6,0,1,1,801.5,25936.5A6,6,0,1,1,813.5,25936.5"></path><path id="kity_path_26346" fill="none" stroke="gray" d="M803,25936.5L812,25936.5"></path></g><path id="node_outline1942" fill="none" stroke="none" d="M818.5,25873.5h736a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-736a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text1942" fill="black"><text id="kity_text_12885" text-rendering="inherit" font-size="12" dy=".8em" y="25874.700000047684" x="818.5">-Xms5m设置JVM初始堆为5M，-Xmx5m设置JVM最大堆为5M。-Xms跟-Xmx值一样时可以避免每次垃圾回收完成后JVM重新分配内存。</text><text id="kity_text_12886" text-rendering="inherit" font-size="12" dy=".8em" y="25892.700000047684" x="818.5">-Xmn2g:设置年轻代大小为2G，一般默认为整个堆区的1/3 ~ 1/4。-Xss每个线程栈空间设置。</text><text id="kity_text_12887" text-rendering="inherit" font-size="12" dy=".8em" y="25910.700000047684" x="818.5">-XX:SurvivorRatio，设置年轻代中Eden区与Survivor区的比值，默认=8，比值为8:1:1。</text><text id="kity_text_12888" text-rendering="inherit" font-size="12" dy=".8em" y="25928.700000047684" x="818.5">-XX:+HeapDumpOnOutOfMemoryError 当JVM发生OOM时，自动生成DUMP文件。</text><text id="kity_text_12889" text-rendering="inherit" font-size="12" dy=".8em" y="25946.700000047684" x="818.5">-XX:PretenureSizeThreshold 当创建的对象超过指定大小时，直接把对象分配在老年代。</text><text id="kity_text_12890" text-rendering="inherit" font-size="12" dy=".8em" y="25964.700000047684" x="818.5">-XX:MaxTenuringThreshold 设定对象在Survivor区最大年龄阈值，超过阈值转移到老年代，默认15。</text><text id="kity_text_12891" text-rendering="inherit" font-size="12" dy=".8em" y="25982.700000047684" x="818.5">开启GC日志对性能影响很小且能帮助我们定位问题，-XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:gc.log</text></g></g><g id="minder_node1946"><g id="node_expander1940" style="cursor: pointer;" display="none"><path id="kity_path_26342" fill="white" stroke="gray" d="M1575.5,25936.5A6,6,0,1,1,1563.5,25936.5A6,6,0,1,1,1575.5,25936.5"></path><path id="kity_path_26343" fill="none" stroke="gray"></path></g><path id="node_outline1941" fill="none" stroke="none" d="M1580.5,25756.5h1778a5,5,0,0,1,5,5v350a5,5,0,0,1,-5,5h-1778a5,5,0,0,1,-5,-5v-350a5,5,0,0,1,5,-5z"></path><g id="node_text1941" fill="black"><text id="kity_text_12864" text-rendering="inherit" font-size="12" dy=".8em" y="25757.700000047684" x="1580.5">1.JVM配置</text><text id="kity_text_12865" text-rendering="inherit" font-size="12" dy=".8em" y="25775.700000047684" x="1580.5">分区大小</text><text id="kity_text_12866" text-rendering="inherit" font-size="12" dy=".8em" y="25793.700000047684" x="1580.5">-XX:+UseG1GC 首先，要指定JVM使用的垃圾回收器。尽量不要靠默认值去保证，要显式的指定一个。</text><text id="kity_text_12867" text-rendering="inherit" font-size="12" dy=".8em" y="25811.700000047684" x="1580.5">-Xmx 设置堆的最大值，一般为操作系统的2/3大小。</text><text id="kity_text_12868" text-rendering="inherit" font-size="12" dy=".8em" y="25829.700000047684" x="1580.5">-Xms 设置堆的初始值，一般设置成和Xmx一样的大小来避免动态扩容。</text><text id="kity_text_12869" text-rendering="inherit" font-size="12" dy=".8em" y="25847.700000047684" x="1580.5">-Xmn 年轻代大小，默认新生代占堆大小的1/3。高并发快消亡场景可适当加大这个区域。对半，或者更多，都是可以的。但是在G1下，就不用再设置这个值了，它会自动调整。</text><text id="kity_text_12870" text-rendering="inherit" font-size="12" dy=".8em" y="25865.700000047684" x="1580.5">-XX:MaxMetaspaceSize 限制元空间的大小，一般256M足够。这一般和初始大小**-XX:MetaspaceSize**设置成一样的。</text><text id="kity_text_12871" text-rendering="inherit" font-size="12" dy=".8em" y="25883.700000047684" x="1580.5">-XX:MaxDirectMemorySize 设置直接内存的最大值，限制通过DirectByteBuffer申请的内存。</text><text id="kity_text_12872" text-rendering="inherit" font-size="12" dy=".8em" y="25901.700000047684" x="1580.5">-XX:ReservedCodeCacheSize 设置JIT编译后的代码存放区大小，如果观察到这个值有限制，可以适当调大，一般够用。</text><text id="kity_text_12873" text-rendering="inherit" font-size="12" dy=".8em" y="25919.700000047684" x="1580.5">-Xss 设置栈的大小，默认为1M，已经足够用了。</text><text id="kity_text_12874" text-rendering="inherit" font-size="12" dy=".8em" y="25937.700000047684" x="1580.5">内存调优</text><text id="kity_text_12875" text-rendering="inherit" font-size="12" dy=".8em" y="25955.700000047684" x="1580.5">-XX:+AlwaysPreTouch 启动时就把参数里说好了的内存全部初始化，启动时间会慢一些，但运行速度会增加。</text><text id="kity_text_12876" text-rendering="inherit" font-size="12" dy=".8em" y="25973.700000047684" x="1580.5">-XX:SurvivorRatio 默认值为8。表示伊甸区和幸存区的比例。</text><text id="kity_text_12877" text-rendering="inherit" font-size="12" dy=".8em" y="25991.700000047684" x="1580.5">-XX:MaxTenuringThreshold 这个值在CMS下默认为6，G1下默认为15(不指定回收器就是15)。这个值和我们前面提到的对象提升有关，改动效果会比较明显。对象的年龄分布可以使用**-XX:+PrintTenuringDistribution**打印，如果后面几代的大小总是差不多，证明过了某个年龄后的对象总能晋升到老生代，就可以把晋升阈值设小。</text><text id="kity_text_12878" text-rendering="inherit" font-size="12" dy=".8em" y="26009.700000047684" x="1580.5">PretenureSizeThreshold 超过一定大小的对象，将直接在老年代分配。</text><text id="kity_text_12879" text-rendering="inherit" font-size="12" dy=".8em" y="26027.700000047684" x="1580.5">垃圾回收器优化</text><text id="kity_text_12880" text-rendering="inherit" font-size="12" dy=".8em" y="26045.700000047684" x="1580.5">-XX:MaxGCPauseMillis 设置目标停顿时间，G1会尽力达成。</text><text id="kity_text_12881" text-rendering="inherit" font-size="12" dy=".8em" y="26063.700000047684" x="1580.5">-XX:G1HeapRegionSize 设置小堆区大小。这个值为2的次幂，不要太大，也不要太小。如果是在不知道如何设置，保持默认。</text><text id="kity_text_12882" text-rendering="inherit" font-size="12" dy=".8em" y="26081.700000047684" x="1580.5">-XX:InitiatingHeapOccupancyPercent 当整个堆内存使用达到一定比例(默认是45%)，并发标记阶段就会被启动。</text><text id="kity_text_12883" text-rendering="inherit" font-size="12" dy=".8em" y="26099.700000047684" x="1580.5">-XX:ConcGCThreads 并发垃圾收集器使用的线程数量。</text></g></g><g id="minder_node1947"><g id="node_expander1942" style="cursor: pointer;" display="none"><path id="kity_path_26348" fill="white" stroke="gray" d="M813.5,26133.5A6,6,0,1,1,801.5,26133.5A6,6,0,1,1,813.5,26133.5"></path><path id="kity_path_26349" fill="none" stroke="gray"></path></g><path id="node_outline1943" fill="none" stroke="none" d="M818.5,26124.5h304a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-304a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1943" fill="black"><text id="kity_text_12893" text-rendering="inherit" font-size="12" dy=".8em" y="26125.700000047684" x="818.5">http://blog.itpub.net/69955379/viewspace-2768572/</text></g></g><g id="minder_node1948"><g id="node_expander1946" style="cursor: pointer;"><path id="kity_path_26360" fill="white" stroke="gray" d="M680.5,26186.5A6,6,0,1,1,668.5,26186.5A6,6,0,1,1,680.5,26186.5"></path><path id="kity_path_26361" fill="none" stroke="gray" d="M670,26186.5L679,26186.5"></path></g><path id="node_outline1947" fill="none" stroke="none" d="M685.5,26177.5h190a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-190a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1947" fill="black"><text id="kity_text_12906" text-rendering="inherit" font-size="12" dy=".8em" y="26178.700000047684" x="685.5">你说你会jvm调优，说说你怎么做的</text></g></g><g id="minder_node1949"><g id="node_expander1945" style="cursor: pointer;"><path id="kity_path_26357" fill="white" stroke="gray" d="M896.5,26186.5A6,6,0,1,1,884.5,26186.5A6,6,0,1,1,896.5,26186.5"></path><path id="kity_path_26358" fill="none" stroke="gray" d="M886,26186.5L895,26186.5"></path></g><path id="node_outline1946" fill="none" stroke="none" d="M901.5,26150.5h1312a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1312a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text1946" fill="black"><text id="kity_text_12901" text-rendering="inherit" font-size="12" dy=".8em" y="26151.700000047684" x="901.5">1.随便先简单吹一个</text><text id="kity_text_12902" text-rendering="inherit" font-size="12" dy=".8em" y="26169.700000047684" x="901.5">我们项目有一个功能是主要对最近一段时间业务办理进行定时分析统计，并支持报表导出的，使用CMS GC算法。客户发现在使用中发现系统页面打开经常卡顿，通过jstat -gc [pid]命令发现系统每次Young GC后大约有10%的存活对象进入老年代。</text><text id="kity_text_12903" text-rendering="inherit" font-size="12" dy=".8em" y="26187.700000047684" x="901.5">原来是因为Survivor区空间设置过小，每次Young GC后存活对象在Survivor区域放不下，提前进入老年代，通过调大Survivor区，使得Survivor区可以容纳Young GC后存活对象，对象在Survivor区经历多次Young GC达到年龄阈值才进入老年代，</text><text id="kity_text_12904" text-rendering="inherit" font-size="12" dy=".8em" y="26205.700000047684" x="901.5">调整之后每次Young GC后进入老年代的存活对象稳定运行时仅几百Kb，Full GC频率大大降低</text></g></g><g id="minder_node1950"><g id="node_expander1944" style="cursor: pointer;" display="none"><path id="kity_path_26354" fill="white" stroke="gray" d="M2234.5,26186.5A6,6,0,1,1,2222.5,26186.5A6,6,0,1,1,2234.5,26186.5"></path><path id="kity_path_26355" fill="none" stroke="gray"></path></g><path id="node_outline1945" fill="none" stroke="none" d="M2239.5,26159.5h504a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-504a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text1945" fill="black"><text id="kity_text_12897" text-rendering="inherit" font-size="12" dy=".8em" y="26160.700000047684" x="2239.5">https://github.com/qiurunze123/memoryoptimization/blob/master/docs/jvmggggo.md</text><text id="kity_text_12898" text-rendering="inherit" font-size="12" dy=".8em" y="26178.700000047684" x="2239.5">https://tech.meituan.com/2017/12/29/jvm-optimize.html</text><text id="kity_text_12899" text-rendering="inherit" font-size="12" dy=".8em" y="26196.700000047684" x="2239.5">https://juejin.cn/post/6844903506093015053#heading-7</text></g></g><g id="minder_node1951"><g id="node_expander1947" style="cursor: pointer;" display="none"><path id="kity_path_26363" fill="white" stroke="gray" d="M680.5,26239.5A6,6,0,1,1,668.5,26239.5A6,6,0,1,1,680.5,26239.5"></path><path id="kity_path_26364" fill="none" stroke="gray"></path></g><path id="node_outline1948" fill="none" stroke="none" d="M685.5,26230.5h386a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-386a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1948" fill="black"><text id="kity_text_12908" text-rendering="inherit" font-size="12" dy=".8em" y="26231.700000047684" x="685.5">如果一个固定的堆内存，当创建线程数很多的时候，JVM参数怎么配置？</text></g></g><g id="minder_node1952"><g id="node_expander1949" style="cursor: pointer;"><path id="kity_path_26369" fill="white" stroke="gray" d="M680.5,26265.5A6,6,0,1,1,668.5,26265.5A6,6,0,1,1,680.5,26265.5"></path><path id="kity_path_26370" fill="none" stroke="gray" d="M670,26265.5L679,26265.5"></path></g><path id="node_outline1950" fill="none" stroke="none" d="M685.5,26256.5h181a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-181a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1950" fill="black"><text id="kity_text_12912" text-rendering="inherit" font-size="12" dy=".8em" y="26257.700000047684" x="685.5">怎么查看某一个java进程下的线程</text></g></g><g id="minder_node1953"><g id="node_expander1948" style="cursor: pointer;" display="none"><path id="kity_path_26366" fill="white" stroke="gray" d="M887.5,26265.5A6,6,0,1,1,875.5,26265.5A6,6,0,1,1,887.5,26265.5"></path><path id="kity_path_26367" fill="none" stroke="gray"></path></g><path id="node_outline1949" fill="none" stroke="none" d="M892.5,26256.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1949" fill="black"><text id="kity_text_12910" text-rendering="inherit" font-size="12" dy=".8em" y="26257.700000047684" x="892.5">1. jps -lv</text></g></g><g id="minder_node1954"><g id="node_expander1951" style="cursor: pointer;"><path id="kity_path_26375" fill="white" stroke="gray" d="M680.5,26291.5A6,6,0,1,1,668.5,26291.5A6,6,0,1,1,680.5,26291.5"></path><path id="kity_path_26376" fill="none" stroke="gray" d="M670,26291.5L679,26291.5"></path></g><path id="node_outline1952" fill="none" stroke="none" d="M685.5,26282.5h122a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-122a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1952" fill="black"><text id="kity_text_12916" text-rendering="inherit" font-size="12" dy=".8em" y="26283.700000047684" x="685.5">怎么查看虚拟机的内存</text></g></g><g id="minder_node1955"><g id="node_expander1950" style="cursor: pointer;" display="none"><path id="kity_path_26372" fill="white" stroke="gray" d="M828.5,26291.5A6,6,0,1,1,816.5,26291.5A6,6,0,1,1,828.5,26291.5"></path><path id="kity_path_26373" fill="none" stroke="gray"></path></g><path id="node_outline1951" fill="none" stroke="none" d="M833.5,26282.5h282a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-282a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1951" fill="black"><text id="kity_text_12914" text-rendering="inherit" font-size="12" dy=".8em" y="26283.700000047684" x="833.5">1.jmap生成虚拟机的内存转储快照，heapdump文件</text></g></g><g id="minder_node1956"><g id="node_expander1953" style="cursor: pointer;"><path id="kity_path_26381" fill="white" stroke="gray" d="M680.5,26326.5A6,6,0,1,1,668.5,26326.5A6,6,0,1,1,680.5,26326.5"></path><path id="kity_path_26382" fill="none" stroke="gray" d="M670,26326.5L679,26326.5"></path></g><path id="node_outline1954" fill="none" stroke="none" d="M685.5,26308.5h259a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-259a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1954" fill="black"><text id="kity_text_12920" text-rendering="inherit" font-size="12" dy=".8em" y="26309.700000047684" x="685.5">怎么定位哪一段代码引起了内存溢出和内存泄漏?</text><text id="kity_text_12921" text-rendering="inherit" font-size="12" dy=".8em" y="26327.700000047684" x="685.5">排查过吗？怎么排查的？</text></g></g><g id="minder_node1957"><g id="node_expander1952" style="cursor: pointer;" display="none"><path id="kity_path_26378" fill="white" stroke="gray" d="M965.5,26326.5A6,6,0,1,1,953.5,26326.5A6,6,0,1,1,965.5,26326.5"></path><path id="kity_path_26379" fill="none" stroke="gray"></path></g><path id="node_outline1953" fill="none" stroke="none" d="M970.5,26317.5h352a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-352a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1953" fill="black"><text id="kity_text_12918" text-rendering="inherit" font-size="12" dy=".8em" y="26318.700000047684" x="970.5">https://blog.csdn.net/wtt945482445/article/details/52483944</text></g></g><g id="minder_node1958"><g id="node_expander1955" style="cursor: pointer;"><path id="kity_path_26387" fill="white" stroke="gray" d="M680.5,26370.5A6,6,0,1,1,668.5,26370.5A6,6,0,1,1,680.5,26370.5"></path><path id="kity_path_26388" fill="none" stroke="gray" d="M670,26370.5L679,26370.5"></path></g><path id="node_outline1956" fill="none" stroke="none" d="M685.5,26361.5h75a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-75a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1956" fill="black"><text id="kity_text_12926" text-rendering="inherit" font-size="12" dy=".8em" y="26362.700000047684" x="685.5">JVM参考文章</text></g></g><g id="minder_node1959"><g id="node_expander1954" style="cursor: pointer;" display="none"><path id="kity_path_26384" fill="white" stroke="gray" d="M781.5,26370.5A6,6,0,1,1,769.5,26370.5A6,6,0,1,1,781.5,26370.5"></path><path id="kity_path_26385" fill="none" stroke="gray"></path></g><path id="node_outline1955" fill="none" stroke="none" d="M786.5,26352.5h517a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-517a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1955" fill="black"><text id="kity_text_12923" text-rendering="inherit" font-size="12" dy=".8em" y="26353.700000047684" x="786.5">https://github.com/dunwu/javacore/blob/master/docs/jvm/trouble-shooting.md#oom</text><text id="kity_text_12924" text-rendering="inherit" font-size="12" dy=".8em" y="26371.700000047684" x="786.5">https://github.com/dunwu/javacore/blob/master/docs/jvm/jvm-action.md#37-heapdump</text></g></g><g id="minder_node1960"><g id="node_expander2157" style="cursor: pointer;"><path id="kity_path_26993" fill="white" stroke="gray" d="M492.5,28225.5A6,6,0,1,1,480.5,28225.5A6,6,0,1,1,492.5,28225.5"></path><path id="kity_path_26994" fill="none" stroke="gray" d="M482,28225.5L491,28225.5"></path></g><path id="node_outline2158" fill="none" stroke="none" d="M497.5,28216.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z" stroke-width="3"></path><g id="node_text2158" fill="black"><text id="kity_text_13373" text-rendering="inherit" font-size="12" dy=".8em" y="28217.700000047684" x="497.5">集合</text></g></g><g id="minder_node1961"><g id="node_expander2030" style="cursor: pointer;"><path id="kity_path_26612" fill="white" stroke="gray" d="M544.5,26889.5A6,6,0,1,1,532.5,26889.5A6,6,0,1,1,544.5,26889.5"></path><path id="kity_path_26613" fill="none" stroke="gray" d="M534,26889.5L543,26889.5"></path></g><path id="node_outline2031" fill="none" stroke="none" d="M549.5,26880.5h20a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-20a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2031" fill="black"><text id="kity_text_13077" text-rendering="inherit" font-size="12" dy=".8em" y="26881.700000047684" x="549.5">list&#xa0;</text></g></g><g id="minder_node1962"><g id="node_expander1982" style="cursor: pointer;"><path id="kity_path_26468" fill="white" stroke="gray" d="M590.5,26549.5A6,6,0,1,1,578.5,26549.5A6,6,0,1,1,590.5,26549.5"></path><path id="kity_path_26469" fill="none" stroke="gray" d="M580,26549.5L589,26549.5"></path></g><path id="node_outline1983" fill="none" stroke="none" d="M595.5,26540.5h52a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-52a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1983" fill="black"><text id="kity_text_12980" text-rendering="inherit" font-size="12" dy=".8em" y="26541.700000047684" x="595.5">ArrayList</text></g></g><g id="minder_node1963"><g id="node_expander1959" style="cursor: pointer;"><path id="kity_path_26399" fill="white" stroke="gray" d="M668.5,26406.5A6,6,0,1,1,656.5,26406.5A6,6,0,1,1,668.5,26406.5"></path><path id="kity_path_26400" fill="none" stroke="gray" d="M658,26406.5L667,26406.5"></path></g><path id="node_outline1960" fill="none" stroke="none" d="M673.5,26397.5h132a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-132a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1960" fill="black"><text id="kity_text_12934" text-rendering="inherit" font-size="12" dy=".8em" y="26398.700000047684" x="673.5">说说Arraylist的底层结构</text></g></g><g id="minder_node1964"><g id="node_expander1958" style="cursor: pointer;" display="none"><path id="kity_path_26396" fill="white" stroke="gray" d="M826.5,26406.5A6,6,0,1,1,814.5,26406.5A6,6,0,1,1,826.5,26406.5"></path><path id="kity_path_26397" fill="none" stroke="gray"></path></g><path id="node_outline1959" fill="none" stroke="none" d="M831.5,26397.5h605a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-605a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1959" fill="black"><text id="kity_text_12932" text-rendering="inherit" font-size="12" dy=".8em" y="26398.700000047684" x="831.5">底层是Object类型数组，两个构造方法，无参和指定初始容量。无参构造时只有添加第一个元素才会默认容量10，</text></g></g><g id="minder_node1965"><g id="node_expander1961" style="cursor: pointer;"><path id="kity_path_26405" fill="white" stroke="gray" d="M668.5,26432.5A6,6,0,1,1,656.5,26432.5A6,6,0,1,1,668.5,26432.5"></path><path id="kity_path_26406" fill="none" stroke="gray" d="M658,26432.5L667,26432.5"></path></g><path id="node_outline1962" fill="none" stroke="none" d="M673.5,26423.5h111a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-111a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1962" fill="black"><text id="kity_text_12938" text-rendering="inherit" font-size="12" dy=".8em" y="26424.700000047684" x="673.5">ArrayList怎么扩容的</text></g></g><g id="minder_node1966"><g id="node_expander1960" style="cursor: pointer;" display="none"><path id="kity_path_26402" fill="white" stroke="gray" d="M805.5,26432.5A6,6,0,1,1,793.5,26432.5A6,6,0,1,1,805.5,26432.5"></path><path id="kity_path_26403" fill="none" stroke="gray"></path></g><path id="node_outline1961" fill="none" stroke="none" d="M810.5,26423.5h1368a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1368a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1961" fill="black"><text id="kity_text_12936" text-rendering="inherit" font-size="12" dy=".8em" y="26424.700000047684" x="810.5">有一个元素数组成员变量，被trantist修饰 也是最后被复制的数组。需要判断是否有必要扩容，比较传参容量和默认容量得到大的那个，然后判断这个返回值减数组长度是否大0，大0就不够 就调用copyOf复制新数组扩容.。最好是指定初始容量，减少扩容次数</text></g></g><g id="minder_node1967"><g id="node_expander1963" style="cursor: pointer;"><path id="kity_path_26411" fill="white" stroke="gray" d="M668.5,26458.5A6,6,0,1,1,656.5,26458.5A6,6,0,1,1,668.5,26458.5"></path><path id="kity_path_26412" fill="none" stroke="gray" d="M658,26458.5L667,26458.5"></path></g><path id="node_outline1964" fill="none" stroke="none" d="M673.5,26449.5h99a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-99a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1964" fill="black"><text id="kity_text_12942" text-rendering="inherit" font-size="12" dy=".8em" y="26450.700000047684" x="673.5">ArrayList的优缺点</text></g></g><g id="minder_node1968"><g id="node_expander1962" style="cursor: pointer;" display="none"><path id="kity_path_26408" fill="white" stroke="gray" d="M793.5,26458.5A6,6,0,1,1,781.5,26458.5A6,6,0,1,1,793.5,26458.5"></path><path id="kity_path_26409" fill="none" stroke="gray"></path></g><path id="node_outline1963" fill="none" stroke="none" d="M798.5,26449.5h680a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-680a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1963" fill="black"><text id="kity_text_12940" text-rendering="inherit" font-size="12" dy=".8em" y="26450.700000047684" x="798.5">查询比较快，如果涉及到操作的一般用LinkedList,如果是顺序插入也比LinkedList有优势。缺点就是频繁操作元素不如LinkedList</text></g></g><g id="minder_node1969"><g id="node_expander1965" style="cursor: pointer;"><path id="kity_path_26417" fill="white" stroke="gray" d="M668.5,26484.5A6,6,0,1,1,656.5,26484.5A6,6,0,1,1,668.5,26484.5"></path><path id="kity_path_26418" fill="none" stroke="gray" d="M658,26484.5L667,26484.5"></path></g><path id="node_outline1966" fill="none" stroke="none" d="M673.5,26475.5h134a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-134a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1966" fill="black"><text id="kity_text_12946" text-rendering="inherit" font-size="12" dy=".8em" y="26476.700000047684" x="673.5">说说ArrayList的add方法</text></g></g><g id="minder_node1970"><g id="node_expander1964" style="cursor: pointer;" display="none"><path id="kity_path_26414" fill="white" stroke="gray" d="M828.5,26484.5A6,6,0,1,1,816.5,26484.5A6,6,0,1,1,828.5,26484.5"></path><path id="kity_path_26415" fill="none" stroke="gray"></path></g><path id="node_outline1965" fill="none" stroke="none" d="M833.5,26475.5h860a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-860a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1965" fill="black"><text id="kity_text_12944" text-rendering="inherit" font-size="12" dy=".8em" y="26476.700000047684" x="833.5">先确认容量 然后+1判断是否有必要扩容，然后再添加元素。如果我们要添加大量元素可以先调用ensureCapacity()减少扩容次数，这个是内部提供给调用者使用的</text></g></g><g id="minder_node1971"><g id="node_expander1967" style="cursor: pointer;"><path id="kity_path_26423" fill="white" stroke="gray" d="M668.5,26510.5A6,6,0,1,1,656.5,26510.5A6,6,0,1,1,668.5,26510.5"></path><path id="kity_path_26424" fill="none" stroke="gray" d="M658,26510.5L667,26510.5"></path></g><path id="node_outline1968" fill="none" stroke="none" d="M673.5,26501.5h131a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-131a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1968" fill="black"><text id="kity_text_12950" text-rendering="inherit" font-size="12" dy=".8em" y="26502.700000047684" x="673.5">说说ArrayList的get方法</text></g></g><g id="minder_node1972"><g id="node_expander1966" style="cursor: pointer;" display="none"><path id="kity_path_26420" fill="white" stroke="gray" d="M825.5,26510.5A6,6,0,1,1,813.5,26510.5A6,6,0,1,1,825.5,26510.5"></path><path id="kity_path_26421" fill="none" stroke="gray"></path></g><path id="node_outline1967" fill="none" stroke="none" d="M830.5,26501.5h194a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-194a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1967" fill="black"><text id="kity_text_12948" text-rendering="inherit" font-size="12" dy=".8em" y="26502.700000047684" x="830.5">先检查下标是否越界，然后返回元素</text></g></g><g id="minder_node1973"><g id="node_expander1969" style="cursor: pointer;"><path id="kity_path_26429" fill="white" stroke="gray" d="M668.5,26536.5A6,6,0,1,1,656.5,26536.5A6,6,0,1,1,668.5,26536.5"></path><path id="kity_path_26430" fill="none" stroke="gray" d="M658,26536.5L667,26536.5"></path></g><path id="node_outline1970" fill="none" stroke="none" d="M673.5,26527.5h155a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-155a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1970" fill="black"><text id="kity_text_12954" text-rendering="inherit" font-size="12" dy=".8em" y="26528.700000047684" x="673.5">说说ArrayList的remove方法</text></g></g><g id="minder_node1974"><g id="node_expander1968" style="cursor: pointer;" display="none"><path id="kity_path_26426" fill="white" stroke="gray" d="M849.5,26536.5A6,6,0,1,1,837.5,26536.5A6,6,0,1,1,849.5,26536.5"></path><path id="kity_path_26427" fill="none" stroke="gray"></path></g><path id="node_outline1969" fill="none" stroke="none" d="M854.5,26527.5h996a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-996a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1969" fill="black"><text id="kity_text_12952" text-rendering="inherit" font-size="12" dy=".8em" y="26528.700000047684" x="854.5">先检查下标，然后删除元素，然后判断左移元素的个数 调用arraycopy()，然后删除的元素就被覆盖了，最后设为null，让gc回收，效率很低，remove不会减少容量，需要调用trimToSize()</text></g></g><g id="minder_node1975"><g id="node_expander1971" style="cursor: pointer;"><path id="kity_path_26435" fill="white" stroke="gray" d="M668.5,26562.5A6,6,0,1,1,656.5,26562.5A6,6,0,1,1,668.5,26562.5"></path><path id="kity_path_26436" fill="none" stroke="gray" d="M658,26562.5L667,26562.5"></path></g><path id="node_outline1972" fill="none" stroke="none" d="M673.5,26553.5h282a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-282a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1972" fill="black"><text id="kity_text_12958" text-rendering="inherit" font-size="12" dy=".8em" y="26554.700000047684" x="673.5">ArrayList实现了RandomAccess接口吗，有什么作用</text></g></g><g id="minder_node1976"><g id="node_expander1970" style="cursor: pointer;" display="none"><path id="kity_path_26432" fill="white" stroke="gray" d="M976.5,26562.5A6,6,0,1,1,964.5,26562.5A6,6,0,1,1,976.5,26562.5"></path><path id="kity_path_26433" fill="none" stroke="gray"></path></g><path id="node_outline1971" fill="none" stroke="none" d="M981.5,26553.5h945a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-945a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1971" fill="black"><text id="kity_text_12956" text-rendering="inherit" font-size="12" dy=".8em" y="26554.700000047684" x="981.5">支持快速随机访问，实现了这个接口的list一般使用foreach比迭代器更快，而linkedlist没有实现这个接口 迭代器快于for循环，而arraylist实现这个接口也是判断他怎么遍历比较快</text></g></g><g id="minder_node1977"><g id="node_expander1973" style="cursor: pointer;"><path id="kity_path_26441" fill="white" stroke="gray" d="M668.5,26588.5A6,6,0,1,1,656.5,26588.5A6,6,0,1,1,668.5,26588.5"></path><path id="kity_path_26442" fill="none" stroke="gray" d="M658,26588.5L667,26588.5"></path></g><path id="node_outline1974" fill="none" stroke="none" d="M673.5,26579.5h268a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-268a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1974" fill="black"><text id="kity_text_12962" text-rendering="inherit" font-size="12" dy=".8em" y="26580.700000047684" x="673.5">知道System.arrayCopy和Arrays.copyOf的区别吗</text></g></g><g id="minder_node1978"><g id="node_expander1972" style="cursor: pointer;" display="none"><path id="kity_path_26438" fill="white" stroke="gray" d="M962.5,26588.5A6,6,0,1,1,950.5,26588.5A6,6,0,1,1,962.5,26588.5"></path><path id="kity_path_26439" fill="none" stroke="gray"></path></g><path id="node_outline1973" fill="none" stroke="none" d="M967.5,26579.5h813a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-813a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1973" fill="black"><text id="kity_text_12960" text-rendering="inherit" font-size="12" dy=".8em" y="26580.700000047684" x="967.5">copyOf其实内部调用了arrayCopy，arrayCopy需要一个源数组和目标数组，并且你可以指定开始下标和长度。copyOf是把源数组复制到内部一个新数组</text></g></g><g id="minder_node1979"><g id="node_expander1975" style="cursor: pointer;"><path id="kity_path_26447" fill="white" stroke="gray" d="M668.5,26614.5A6,6,0,1,1,656.5,26614.5A6,6,0,1,1,668.5,26614.5"></path><path id="kity_path_26448" fill="none" stroke="gray" d="M658,26614.5L667,26614.5"></path></g><path id="node_outline1976" fill="none" stroke="none" d="M673.5,26605.5h123a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-123a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1976" fill="black"><text id="kity_text_12966" text-rendering="inherit" font-size="12" dy=".8em" y="26606.700000047684" x="673.5">ArrayList适合做队列吗</text></g></g><g id="minder_node1980"><g id="node_expander1974" style="cursor: pointer;" display="none"><path id="kity_path_26444" fill="white" stroke="gray" d="M817.5,26614.5A6,6,0,1,1,805.5,26614.5A6,6,0,1,1,817.5,26614.5"></path><path id="kity_path_26445" fill="none" stroke="gray"></path></g><path id="node_outline1975" fill="none" stroke="none" d="M822.5,26605.5h725a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-725a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1975" fill="black"><text id="kity_text_12964" text-rendering="inherit" font-size="12" dy=".8em" y="26606.700000047684" x="822.5">队列一般是FIFO的，如果ArrayList当队列要么在首删元素，尾添加元素，这样其实是涉及到底层数组复制的，是比较浪费性能的，没必要</text></g></g><g id="minder_node1981"><g id="node_expander1977" style="cursor: pointer;"><path id="kity_path_26453" fill="white" stroke="gray" d="M668.5,26640.5A6,6,0,1,1,656.5,26640.5A6,6,0,1,1,668.5,26640.5"></path><path id="kity_path_26454" fill="none" stroke="gray" d="M658,26640.5L667,26640.5"></path></g><path id="node_outline1978" fill="none" stroke="none" d="M673.5,26631.5h148a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-148a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1978" fill="black"><text id="kity_text_12970" text-rendering="inherit" font-size="12" dy=".8em" y="26632.700000047684" x="673.5">ArrayList会不会初始化长度</text></g></g><g id="minder_node1982"><g id="node_expander1976" style="cursor: pointer;" display="none"><path id="kity_path_26450" fill="white" stroke="gray" d="M842.5,26640.5A6,6,0,1,1,830.5,26640.5A6,6,0,1,1,842.5,26640.5"></path><path id="kity_path_26451" fill="none" stroke="gray"></path></g><path id="node_outline1977" fill="none" stroke="none" d="M847.5,26631.5h277a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-277a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1977" fill="black"><text id="kity_text_12968" text-rendering="inherit" font-size="12" dy=".8em" y="26632.700000047684" x="847.5">不会，数组初始化了 当时list没有，返回的size还是0</text></g></g><g id="minder_node1983"><g id="node_expander1979" style="cursor: pointer;"><path id="kity_path_26459" fill="white" stroke="gray" d="M668.5,26666.5A6,6,0,1,1,656.5,26666.5A6,6,0,1,1,668.5,26666.5"></path><path id="kity_path_26460" fill="none" stroke="gray" d="M658,26666.5L667,26666.5"></path></g><path id="node_outline1980" fill="none" stroke="none" d="M673.5,26657.5h147a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-147a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1980" fill="black"><text id="kity_text_12974" text-rendering="inherit" font-size="12" dy=".8em" y="26658.700000047684" x="673.5">ArrayList删除元素一定慢吗</text></g></g><g id="minder_node1984"><g id="node_expander1978" style="cursor: pointer;" display="none"><path id="kity_path_26456" fill="white" stroke="gray" d="M841.5,26666.5A6,6,0,1,1,829.5,26666.5A6,6,0,1,1,841.5,26666.5"></path><path id="kity_path_26457" fill="none" stroke="gray"></path></g><path id="node_outline1979" fill="none" stroke="none" d="M846.5,26657.5h229a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-229a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1979" fill="black"><text id="kity_text_12972" text-rendering="inherit" font-size="12" dy=".8em" y="26658.700000047684" x="846.5">这个需要考虑你删除的元素距离末尾多远。</text></g></g><g id="minder_node1985"><g id="node_expander1981" style="cursor: pointer;"><path id="kity_path_26465" fill="white" stroke="gray" d="M668.5,26692.5A6,6,0,1,1,656.5,26692.5A6,6,0,1,1,668.5,26692.5"></path><path id="kity_path_26466" fill="none" stroke="gray" d="M658,26692.5L667,26692.5"></path></g><path id="node_outline1982" fill="none" stroke="none" d="M673.5,26683.5h296a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-296a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1982" fill="black"><text id="kity_text_12978" text-rendering="inherit" font-size="12" dy=".8em" y="26684.700000047684" x="673.5">ArrayList中的elementData数组为什么被transient修饰</text></g></g><g id="minder_node1986"><g id="node_expander1980" style="cursor: pointer;" display="none"><path id="kity_path_26462" fill="white" stroke="gray" d="M990.5,26692.5A6,6,0,1,1,978.5,26692.5A6,6,0,1,1,990.5,26692.5"></path><path id="kity_path_26463" fill="none" stroke="gray"></path></g><path id="node_outline1981" fill="none" stroke="none" d="M995.5,26683.5h472a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-472a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1981" fill="black"><text id="kity_text_12976" text-rendering="inherit" font-size="12" dy=".8em" y="26684.700000047684" x="995.5">提高序列化速度，只序列化存入的元素，提高速度是因为重写了defaultWriteObject方法</text></g></g><g id="minder_node1987"><g id="node_expander1989" style="cursor: pointer;"><path id="kity_path_26489" fill="white" stroke="gray" d="M590.5,26744.5A6,6,0,1,1,578.5,26744.5A6,6,0,1,1,590.5,26744.5"></path><path id="kity_path_26490" fill="none" stroke="gray" d="M580,26744.5L589,26744.5"></path></g><path id="node_outline1990" fill="none" stroke="none" d="M595.5,26735.5h58a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-58a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1990" fill="black"><text id="kity_text_12994" text-rendering="inherit" font-size="12" dy=".8em" y="26736.700000047684" x="595.5">LinkedList</text></g></g><g id="minder_node1988"><g id="node_expander1984" style="cursor: pointer;"><path id="kity_path_26474" fill="white" stroke="gray" d="M674.5,26718.5A6,6,0,1,1,662.5,26718.5A6,6,0,1,1,674.5,26718.5"></path><path id="kity_path_26475" fill="none" stroke="gray" d="M664,26718.5L673,26718.5"></path></g><path id="node_outline1985" fill="none" stroke="none" d="M679.5,26709.5h142a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-142a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1985" fill="black"><text id="kity_text_12984" text-rendering="inherit" font-size="12" dy=".8em" y="26710.700000047684" x="679.5">说说LinkedList的底层结构</text></g></g><g id="minder_node1989"><g id="node_expander1983" style="cursor: pointer;" display="none"><path id="kity_path_26471" fill="white" stroke="gray" d="M842.5,26718.5A6,6,0,1,1,830.5,26718.5A6,6,0,1,1,842.5,26718.5"></path><path id="kity_path_26472" fill="none" stroke="gray"></path></g><path id="node_outline1984" fill="none" stroke="none" d="M847.5,26709.5h763a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-763a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1984" fill="black"><text id="kity_text_12982" text-rendering="inherit" font-size="12" dy=".8em" y="26710.700000047684" x="847.5">基于双向链表实现，所以对频繁操作元素效率就比较高，都是访问效率就比较低。内部维持一个双向链表的node类，保存着前驱节点和后驱节点</text></g></g><g id="minder_node1990"><g id="node_expander1986" style="cursor: pointer;"><path id="kity_path_26480" fill="white" stroke="gray" d="M674.5,26744.5A6,6,0,1,1,662.5,26744.5A6,6,0,1,1,674.5,26744.5"></path><path id="kity_path_26481" fill="none" stroke="gray" d="M664,26744.5L673,26744.5"></path></g><path id="node_outline1987" fill="none" stroke="none" d="M679.5,26735.5h105a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-105a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1987" fill="black"><text id="kity_text_12988" text-rendering="inherit" font-size="12" dy=".8em" y="26736.700000047684" x="679.5">LinkedList的优缺点</text></g></g><g id="minder_node1991"><g id="node_expander1985" style="cursor: pointer;" display="none"><path id="kity_path_26477" fill="white" stroke="gray" d="M805.5,26744.5A6,6,0,1,1,793.5,26744.5A6,6,0,1,1,805.5,26744.5"></path><path id="kity_path_26478" fill="none" stroke="gray"></path></g><path id="node_outline1986" fill="none" stroke="none" d="M810.5,26735.5h640a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-640a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1986" fill="black"><text id="kity_text_12986" text-rendering="inherit" font-size="12" dy=".8em" y="26736.700000047684" x="810.5">linkedList是线性存储 随机访问效率比较低，但是频繁操作元素是比较适合，相比较arrayList，linkedList是更加占内存，</text></g></g><g id="minder_node1992"><g id="node_expander1988" style="cursor: pointer;"><path id="kity_path_26486" fill="white" stroke="gray" d="M674.5,26770.5A6,6,0,1,1,662.5,26770.5A6,6,0,1,1,674.5,26770.5"></path><path id="kity_path_26487" fill="none" stroke="gray" d="M664,26770.5L673,26770.5"></path></g><path id="node_outline1989" fill="none" stroke="none" d="M679.5,26761.5h152a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-152a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1989" fill="black"><text id="kity_text_12992" text-rendering="inherit" font-size="12" dy=".8em" y="26762.700000047684" x="679.5">说说LinkedList的add方法，</text></g></g><g id="minder_node1993"><g id="node_expander1987" style="cursor: pointer;" display="none"><path id="kity_path_26483" fill="white" stroke="gray" d="M852.5,26770.5A6,6,0,1,1,840.5,26770.5A6,6,0,1,1,852.5,26770.5"></path><path id="kity_path_26484" fill="none" stroke="gray"></path></g><path id="node_outline1988" fill="none" stroke="none" d="M857.5,26761.5h448a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-448a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1988" fill="black"><text id="kity_text_12990" text-rendering="inherit" font-size="12" dy=".8em" y="26762.700000047684" x="857.5">add方法在尾插入一个元素，可以指定位置，指定位置内部会先去找这个位置的node</text></g></g><g id="minder_node1994"><g id="node_expander2018" style="cursor: pointer;"><path id="kity_path_26576" fill="white" stroke="gray" d="M590.5,26974.5A6,6,0,1,1,578.5,26974.5A6,6,0,1,1,590.5,26974.5"></path><path id="kity_path_26577" fill="none" stroke="gray" d="M580,26974.5L589,26974.5"></path></g><path id="node_outline2019" fill="none" stroke="none" d="M595.5,26965.5h17a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-17a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2019" fill="black"><text id="kity_text_13053" text-rendering="inherit" font-size="12" dy=".8em" y="26966.700000047684" x="595.5">list</text></g></g><g id="minder_node1995"><g id="node_expander1991" style="cursor: pointer;"><path id="kity_path_26495" fill="white" stroke="gray" d="M633.5,26796.5A6,6,0,1,1,621.5,26796.5A6,6,0,1,1,633.5,26796.5"></path><path id="kity_path_26496" fill="none" stroke="gray" d="M623,26796.5L632,26796.5"></path></g><path id="node_outline1992" fill="none" stroke="none" d="M638.5,26787.5h77a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-77a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1992" fill="black"><text id="kity_text_12998" text-rendering="inherit" font-size="12" dy=".8em" y="26788.700000047684" x="638.5">说说list的特点</text></g></g><g id="minder_node1996"><g id="node_expander1990" style="cursor: pointer;" display="none"><path id="kity_path_26492" fill="white" stroke="gray" d="M736.5,26796.5A6,6,0,1,1,724.5,26796.5A6,6,0,1,1,736.5,26796.5"></path><path id="kity_path_26493" fill="none" stroke="gray"></path></g><path id="node_outline1991" fill="none" stroke="none" d="M741.5,26787.5h330a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-330a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1991" fill="black"><text id="kity_text_12996" text-rendering="inherit" font-size="12" dy=".8em" y="26788.700000047684" x="741.5">list是有序的，元素可以null 底层是数组不影响，允许元素重复</text></g></g><g id="minder_node1997"><g id="node_expander1993" style="cursor: pointer;"><path id="kity_path_26501" fill="white" stroke="gray" d="M633.5,26822.5A6,6,0,1,1,621.5,26822.5A6,6,0,1,1,633.5,26822.5"></path><path id="kity_path_26502" fill="none" stroke="gray" d="M623,26822.5L632,26822.5"></path></g><path id="node_outline1994" fill="none" stroke="none" d="M638.5,26813.5h113a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-113a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1994" fill="black"><text id="kity_text_13002" text-rendering="inherit" font-size="12" dy=".8em" y="26814.700000047684" x="638.5">怎么遍历一个list呢，</text></g></g><g id="minder_node1998"><g id="node_expander1992" style="cursor: pointer;" display="none"><path id="kity_path_26498" fill="white" stroke="gray" d="M772.5,26822.5A6,6,0,1,1,760.5,26822.5A6,6,0,1,1,772.5,26822.5"></path><path id="kity_path_26499" fill="none" stroke="gray"></path></g><path id="node_outline1993" fill="none" stroke="none" d="M777.5,26813.5h479a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-479a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1993" fill="black"><text id="kity_text_13000" text-rendering="inherit" font-size="12" dy=".8em" y="26814.700000047684" x="777.5">遍历一个list 可以使用for循环，foreach，迭代器，foreach底层其实是迭代器和while循环</text></g></g><g id="minder_node1999"><g id="node_expander1995" style="cursor: pointer;"><path id="kity_path_26507" fill="white" stroke="gray" d="M633.5,26848.5A6,6,0,1,1,621.5,26848.5A6,6,0,1,1,633.5,26848.5"></path><path id="kity_path_26508" fill="none" stroke="gray" d="M623,26848.5L632,26848.5"></path></g><path id="node_outline1996" fill="none" stroke="none" d="M638.5,26839.5h289a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-289a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1996" fill="black"><text id="kity_text_13006" text-rendering="inherit" font-size="12" dy=".8em" y="26840.700000047684" x="638.5">你说了迭代器，那我在里面修改集合元素会导致什么，</text></g></g><g id="minder_node2000"><g id="node_expander1994" style="cursor: pointer;" display="none"><path id="kity_path_26504" fill="white" stroke="gray" d="M948.5,26848.5A6,6,0,1,1,936.5,26848.5A6,6,0,1,1,948.5,26848.5"></path><path id="kity_path_26505" fill="none" stroke="gray"></path></g><path id="node_outline1995" fill="none" stroke="none" d="M953.5,26839.5h289a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-289a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1995" fill="black"><text id="kity_text_13004" text-rendering="inherit" font-size="12" dy=".8em" y="26840.700000047684" x="953.5">会出现并发修改异常，检测到了并发修改，而不被允许</text></g></g><g id="minder_node2001"><g id="node_expander1997" style="cursor: pointer;"><path id="kity_path_26513" fill="white" stroke="gray" d="M633.5,26874.5A6,6,0,1,1,621.5,26874.5A6,6,0,1,1,633.5,26874.5"></path><path id="kity_path_26514" fill="none" stroke="gray" d="M623,26874.5L632,26874.5"></path></g><path id="node_outline1998" fill="none" stroke="none" d="M638.5,26865.5h218a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-218a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1998" fill="black"><text id="kity_text_13010" text-rendering="inherit" font-size="12" dy=".8em" y="26866.700000047684" x="638.5">你说了快速失败，那你简单说说快速失败</text></g></g><g id="minder_node2002"><g id="node_expander1996" style="cursor: pointer;" display="none"><path id="kity_path_26510" fill="white" stroke="gray" d="M877.5,26874.5A6,6,0,1,1,865.5,26874.5A6,6,0,1,1,877.5,26874.5"></path><path id="kity_path_26511" fill="none" stroke="gray"></path></g><path id="node_outline1997" fill="none" stroke="none" d="M882.5,26865.5h1146a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1146a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text1997" fill="black"><text id="kity_text_13008" text-rendering="inherit" font-size="12" dy=".8em" y="26866.700000047684" x="882.5">快速失败是集合的一种容错检测机制，在集合迭代器访问元素时维持一个count变量，每一次都会去检测是否是预期值，如果不是就马上报异常，停止遍历，这里只是检测并发修改。java util包下集合类都是快速失败的</text></g></g><g id="minder_node2003"><g id="node_expander1999" style="cursor: pointer;"><path id="kity_path_26519" fill="white" stroke="gray" d="M633.5,26909.5A6,6,0,1,1,621.5,26909.5A6,6,0,1,1,633.5,26909.5"></path><path id="kity_path_26520" fill="none" stroke="gray" d="M623,26909.5L632,26909.5"></path></g><path id="node_outline2000" fill="none" stroke="none" d="M638.5,26900.5h97a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-97a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2000" fill="black"><text id="kity_text_13015" text-rendering="inherit" font-size="12" dy=".8em" y="26901.700000047684" x="638.5">有知道安全失败吗</text></g></g><g id="minder_node2004"><g id="node_expander1998" style="cursor: pointer;" display="none"><path id="kity_path_26516" fill="white" stroke="gray" d="M756.5,26909.5A6,6,0,1,1,744.5,26909.5A6,6,0,1,1,756.5,26909.5"></path><path id="kity_path_26517" fill="none" stroke="gray"></path></g><path id="node_outline1999" fill="none" stroke="none" d="M761.5,26891.5h1133a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1133a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text1999" fill="black"><text id="kity_text_13012" text-rendering="inherit" font-size="12" dy=".8em" y="26892.700000047684" x="761.5">这是一种容错保护机制，当遇到错误 程序不会马上通知，但是会记录错误，采用安全失败机制的容器，在遍历时不是直接操作原集合，而是先拷贝复制再操作，在拷贝的集合上操作，这样可能你读的数据不是最新的</text><text id="kity_text_13013" text-rendering="inherit" font-size="12" dy=".8em" y="26910.700000047684" x="761.5">ConcurrentHashMap 和CopyOnWriteArrayList都是安全失败的。concurrent包都是安全失败的，支持并发修改。</text></g></g><g id="minder_node2005"><g id="node_expander2001" style="cursor: pointer;"><path id="kity_path_26525" fill="white" stroke="gray" d="M633.5,26944.5A6,6,0,1,1,621.5,26944.5A6,6,0,1,1,633.5,26944.5"></path><path id="kity_path_26526" fill="none" stroke="gray" d="M623,26944.5L632,26944.5"></path></g><path id="node_outline2002" fill="none" stroke="none" d="M638.5,26935.5h120a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-120a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2002" fill="black"><text id="kity_text_13019" text-rendering="inherit" font-size="12" dy=".8em" y="26936.700000047684" x="638.5">为什么会有快速失败呢</text></g></g><g id="minder_node2006"><g id="node_expander2000" style="cursor: pointer;" display="none"><path id="kity_path_26522" fill="white" stroke="gray" d="M779.5,26944.5A6,6,0,1,1,767.5,26944.5A6,6,0,1,1,779.5,26944.5"></path><path id="kity_path_26523" fill="none" stroke="gray"></path></g><path id="node_outline2001" fill="none" stroke="none" d="M784.5,26935.5h301a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-301a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2001" fill="black"><text id="kity_text_13017" text-rendering="inherit" font-size="12" dy=".8em" y="26936.700000047684" x="784.5">这是表明迭代过程中不支持并发修改，及时告诉我们异常</text></g></g><g id="minder_node2007"><g id="node_expander2003" style="cursor: pointer;"><path id="kity_path_26531" fill="white" stroke="gray" d="M633.5,26970.5A6,6,0,1,1,621.5,26970.5A6,6,0,1,1,633.5,26970.5"></path><path id="kity_path_26532" fill="none" stroke="gray" d="M623,26970.5L632,26970.5"></path></g><path id="node_outline2004" fill="none" stroke="none" d="M638.5,26961.5h229a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-229a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2004" fill="black"><text id="kity_text_13023" text-rendering="inherit" font-size="12" dy=".8em" y="26962.700000047684" x="638.5">ArrayList和LinkedList线程安全吗，为什么</text></g></g><g id="minder_node2008"><g id="node_expander2002" style="cursor: pointer;" display="none"><path id="kity_path_26528" fill="white" stroke="gray" d="M888.5,26970.5A6,6,0,1,1,876.5,26970.5A6,6,0,1,1,888.5,26970.5"></path><path id="kity_path_26529" fill="none" stroke="gray"></path></g><path id="node_outline2003" fill="none" stroke="none" d="M893.5,26961.5h277a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-277a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2003" fill="black"><text id="kity_text_13021" text-rendering="inherit" font-size="12" dy=".8em" y="26962.700000047684" x="893.5">都不是线程安全，都没有实现同步。只有vector是，</text></g></g><g id="minder_node2009"><g id="node_expander2005" style="cursor: pointer;"><path id="kity_path_26537" fill="white" stroke="gray" d="M633.5,26996.5A6,6,0,1,1,621.5,26996.5A6,6,0,1,1,633.5,26996.5"></path><path id="kity_path_26538" fill="none" stroke="gray" d="M623,26996.5L632,26996.5"></path></g><path id="node_outline2006" fill="none" stroke="none" d="M638.5,26987.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2006" fill="black"><text id="kity_text_13027" text-rendering="inherit" font-size="12" dy=".8em" y="26988.700000047684" x="638.5">那我要使用线程安全的怎么办</text></g></g><g id="minder_node2010"><g id="node_expander2004" style="cursor: pointer;" display="none"><path id="kity_path_26534" fill="white" stroke="gray" d="M816.5,26996.5A6,6,0,1,1,804.5,26996.5A6,6,0,1,1,816.5,26996.5"></path><path id="kity_path_26535" fill="none" stroke="gray"></path></g><path id="node_outline2005" fill="none" stroke="none" d="M821.5,26987.5h936a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-936a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2005" fill="black"><text id="kity_text_13025" text-rendering="inherit" font-size="12" dy=".8em" y="26988.700000047684" x="821.5">调用Collections的SynchronizedList方法，他在方法内部加了同步锁。vector数组声明加锁，都是内部getLast 给addLast并不是原子性，并发可以交替，在操作前加锁可以解决</text></g></g><g id="minder_node2011"><g id="node_expander2007" style="cursor: pointer;"><path id="kity_path_26543" fill="white" stroke="gray" d="M633.5,27022.5A6,6,0,1,1,621.5,27022.5A6,6,0,1,1,633.5,27022.5"></path><path id="kity_path_26544" fill="none" stroke="gray" d="M623,27022.5L632,27022.5"></path></g><path id="node_outline2008" fill="none" stroke="none" d="M638.5,27013.5h274a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-274a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2008" fill="black"><text id="kity_text_13031" text-rendering="inherit" font-size="12" dy=".8em" y="27014.700000047684" x="638.5">Arraylist和LinkedList的哪些区别，使用场景是什么</text></g></g><g id="minder_node2012"><g id="node_expander2006" style="cursor: pointer;" display="none"><path id="kity_path_26540" fill="white" stroke="gray" d="M933.5,27022.5A6,6,0,1,1,921.5,27022.5A6,6,0,1,1,933.5,27022.5"></path><path id="kity_path_26541" fill="none" stroke="gray"></path></g><path id="node_outline2007" fill="none" stroke="none" d="M938.5,27013.5h798a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-798a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2007" fill="black"><text id="kity_text_13029" text-rendering="inherit" font-size="12" dy=".8em" y="27014.700000047684" x="938.5">主要区别就是他们的特点，使用场景就是 对于大量的查询访问操作建议arraylist，频繁的操作元素建议linkedlist，如果是顺序存储 arraylist也是很适合</text></g></g><g id="minder_node2013"><g id="node_expander2009" style="cursor: pointer;"><path id="kity_path_26549" fill="white" stroke="gray" d="M633.5,27048.5A6,6,0,1,1,621.5,27048.5A6,6,0,1,1,633.5,27048.5"></path><path id="kity_path_26550" fill="none" stroke="gray" d="M623,27048.5L632,27048.5"></path></g><path id="node_outline2010" fill="none" stroke="none" d="M638.5,27039.5h351a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-351a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2010" fill="black"><text id="kity_text_13035" text-rendering="inherit" font-size="12" dy=".8em" y="27040.700000047684" x="638.5">当数据量很大的时侯，ArrayList和LinkedList哪个效率高， 思考下</text></g></g><g id="minder_node2014"><g id="node_expander2008" style="cursor: pointer;" display="none"><path id="kity_path_26546" fill="white" stroke="gray" d="M1010.5,27048.5A6,6,0,1,1,998.5,27048.5A6,6,0,1,1,1010.5,27048.5"></path><path id="kity_path_26547" fill="none" stroke="gray"></path></g><path id="node_outline2009" fill="none" stroke="none" d="M1015.5,27039.5h670a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-670a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2009" fill="black"><text id="kity_text_13033" text-rendering="inherit" font-size="12" dy=".8em" y="27040.700000047684" x="1015.5">当数据量很大时，大的new 一个node的时间比数组扩容还长，arraylist效率就比较高了，一般情况下都是linkedlist插入效率高</text></g></g><g id="minder_node2015"><g id="node_expander2011" style="cursor: pointer;"><path id="kity_path_26555" fill="white" stroke="gray" d="M633.5,27074.5A6,6,0,1,1,621.5,27074.5A6,6,0,1,1,633.5,27074.5"></path><path id="kity_path_26556" fill="none" stroke="gray" d="M623,27074.5L632,27074.5"></path></g><path id="node_outline2012" fill="none" stroke="none" d="M638.5,27065.5h101a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-101a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2012" fill="black"><text id="kity_text_13039" text-rendering="inherit" font-size="12" dy=".8em" y="27066.700000047684" x="638.5">怎么把数组转list呢</text></g></g><g id="minder_node2016"><g id="node_expander2010" style="cursor: pointer;" display="none"><path id="kity_path_26552" fill="white" stroke="gray" d="M760.5,27074.5A6,6,0,1,1,748.5,27074.5A6,6,0,1,1,760.5,27074.5"></path><path id="kity_path_26553" fill="none" stroke="gray"></path></g><path id="node_outline2011" fill="none" stroke="none" d="M765.5,27065.5h1013a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1013a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2011" fill="black"><text id="kity_text_13037" text-rendering="inherit" font-size="12" dy=".8em" y="27066.700000047684" x="765.5">可以使用Arrays.asList,转list后不可以对list结构做修改，因为他得到的只是一个Arrays内部类。之后可以再包一层ArrayList，重新构造列表，List list = new ArrayList&lt;&gt;(Arrays.asList(“a”))</text></g></g><g id="minder_node2017"><g id="node_expander2013" style="cursor: pointer;"><path id="kity_path_26561" fill="white" stroke="gray" d="M633.5,27100.5A6,6,0,1,1,621.5,27100.5A6,6,0,1,1,633.5,27100.5"></path><path id="kity_path_26562" fill="none" stroke="gray" d="M623,27100.5L632,27100.5"></path></g><path id="node_outline2014" fill="none" stroke="none" d="M638.5,27091.5h169a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-169a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2014" fill="black"><text id="kity_text_13043" text-rendering="inherit" font-size="12" dy=".8em" y="27092.700000047684" x="638.5">知道Collections.sort()的原理吗</text></g></g><g id="minder_node2018"><g id="node_expander2012" style="cursor: pointer;" display="none"><path id="kity_path_26558" fill="white" stroke="gray" d="M828.5,27100.5A6,6,0,1,1,816.5,27100.5A6,6,0,1,1,828.5,27100.5"></path><path id="kity_path_26559" fill="none" stroke="gray"></path></g><path id="node_outline2013" fill="none" stroke="none" d="M833.5,27091.5h451a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-451a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2013" fill="black"><text id="kity_text_13041" text-rendering="inherit" font-size="12" dy=".8em" y="27092.700000047684" x="833.5">Collection.sort底层是调用的list.sort,是对list排序，list.sort底层调用的是Arrays.sort</text></g></g><g id="minder_node2019"><g id="node_expander2015" style="cursor: pointer;"><path id="kity_path_26567" fill="white" stroke="gray" d="M633.5,27126.5A6,6,0,1,1,621.5,27126.5A6,6,0,1,1,633.5,27126.5"></path><path id="kity_path_26568" fill="none" stroke="gray" d="M623,27126.5L632,27126.5"></path></g><path id="node_outline2016" fill="none" stroke="none" d="M638.5,27117.5h143a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-143a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2016" fill="black"><text id="kity_text_13047" text-rendering="inherit" font-size="12" dy=".8em" y="27118.700000047684" x="638.5">Arrays.sort()的原理也说说</text></g></g><g id="minder_node2020"><g id="node_expander2014" style="cursor: pointer;" display="none"><path id="kity_path_26564" fill="white" stroke="gray" d="M802.5,27126.5A6,6,0,1,1,790.5,27126.5A6,6,0,1,1,802.5,27126.5"></path><path id="kity_path_26565" fill="none" stroke="gray"></path></g><path id="node_outline2015" fill="none" stroke="none" d="M807.5,27117.5h686a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-686a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2015" fill="black"><text id="kity_text_13045" text-rendering="inherit" font-size="12" dy=".8em" y="27118.700000047684" x="807.5">Arrays.sort是对数组进行排序，可以对基本数据类型排序，也可以对对象数组排序，底层根据长度决定使用的是归并还是直接插入</text></g></g><g id="minder_node2021"><g id="node_expander2017" style="cursor: pointer;"><path id="kity_path_26573" fill="white" stroke="gray" d="M633.5,27152.5A6,6,0,1,1,621.5,27152.5A6,6,0,1,1,633.5,27152.5"></path><path id="kity_path_26574" fill="none" stroke="gray" d="M623,27152.5L632,27152.5"></path></g><path id="node_outline2018" fill="none" stroke="none" d="M638.5,27143.5h105a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-105a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2018" fill="black"><text id="kity_text_13051" text-rendering="inherit" font-size="12" dy=".8em" y="27144.700000047684" x="638.5">知道ArrayDeque吗</text></g></g><g id="minder_node2022"><g id="node_expander2016" style="cursor: pointer;" display="none"><path id="kity_path_26570" fill="white" stroke="gray" d="M764.5,27152.5A6,6,0,1,1,752.5,27152.5A6,6,0,1,1,764.5,27152.5"></path><path id="kity_path_26571" fill="none" stroke="gray"></path></g><path id="node_outline2017" fill="none" stroke="none" d="M769.5,27143.5h663a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-663a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2017" fill="black"><text id="kity_text_13049" text-rendering="inherit" font-size="12" dy=".8em" y="27144.700000047684" x="769.5">ArrayDeque实现了Deque接口，是FIFO，底层使用循环数组和双向队列，如果作为栈和队列 建议选择它，而不是LinkedList</text></g></g><g id="minder_node2023"><g id="node_expander2029" style="cursor: pointer;"><path id="kity_path_26609" fill="white" stroke="gray" d="M590.5,27230.5A6,6,0,1,1,578.5,27230.5A6,6,0,1,1,590.5,27230.5"></path><path id="kity_path_26610" fill="none" stroke="gray" d="M580,27230.5L589,27230.5"></path></g><path id="node_outline2030" fill="none" stroke="none" d="M595.5,27221.5h129a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-129a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2030" fill="black"><text id="kity_text_13075" text-rendering="inherit" font-size="12" dy=".8em" y="27222.700000047684" x="595.5">CopyOnWriteArrayList</text></g></g><g id="minder_node2024"><g id="node_expander2020" style="cursor: pointer;"><path id="kity_path_26582" fill="white" stroke="gray" d="M745.5,27178.5A6,6,0,1,1,733.5,27178.5A6,6,0,1,1,745.5,27178.5"></path><path id="kity_path_26583" fill="none" stroke="gray" d="M735,27178.5L744,27178.5"></path></g><path id="node_outline2021" fill="none" stroke="none" d="M750.5,27169.5h202a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-202a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2021" fill="black"><text id="kity_text_13057" text-rendering="inherit" font-size="12" dy=".8em" y="27170.700000047684" x="750.5">知道CopyOnWriteArrayList吗，说说</text></g></g><g id="minder_node2025"><g id="node_expander2019" style="cursor: pointer;" display="none"><path id="kity_path_26579" fill="white" stroke="gray" d="M973.5,27178.5A6,6,0,1,1,961.5,27178.5A6,6,0,1,1,973.5,27178.5"></path><path id="kity_path_26580" fill="none" stroke="gray"></path></g><path id="node_outline2020" fill="none" stroke="none" d="M978.5,27169.5h1285a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1285a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2020" fill="black"><text id="kity_text_13055" text-rendering="inherit" font-size="12" dy=".8em" y="27170.700000047684" x="978.5">其实要得安全的arraylist 还可以使用COWA，他读写分离，读容器写容器，支持并发共享读，写时复制一份出去，修改复制的，然后把原引用引用到新的数组，写时加锁。支持高效率并发。使用迭代器修改不加锁也不异常，他的元素可以为null</text></g></g><g id="minder_node2026"><g id="node_expander2022" style="cursor: pointer;"><path id="kity_path_26588" fill="white" stroke="gray" d="M745.5,27204.5A6,6,0,1,1,733.5,27204.5A6,6,0,1,1,745.5,27204.5"></path><path id="kity_path_26589" fill="none" stroke="gray" d="M735,27204.5L744,27204.5"></path></g><path id="node_outline2023" fill="none" stroke="none" d="M750.5,27195.5h214a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-214a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2023" fill="black"><text id="kity_text_13061" text-rendering="inherit" font-size="12" dy=".8em" y="27196.700000047684" x="750.5">简单说说CopyOnWriteArrayList的底层</text></g></g><g id="minder_node2027"><g id="node_expander2021" style="cursor: pointer;" display="none"><path id="kity_path_26585" fill="white" stroke="gray" d="M985.5,27204.5A6,6,0,1,1,973.5,27204.5A6,6,0,1,1,985.5,27204.5"></path><path id="kity_path_26586" fill="none" stroke="gray"></path></g><path id="node_outline2022" fill="none" stroke="none" d="M990.5,27195.5h656a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-656a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2022" fill="black"><text id="kity_text_13059" text-rendering="inherit" font-size="12" dy=".8em" y="27196.700000047684" x="990.5">他的底层数组是被volatile修饰的，它的add方法是加锁的，用了ReentrantLock，操作完并指向新数组就解锁。set也加锁了</text></g></g><g id="minder_node2028"><g id="node_expander2024" style="cursor: pointer;"><path id="kity_path_26594" fill="white" stroke="gray" d="M745.5,27230.5A6,6,0,1,1,733.5,27230.5A6,6,0,1,1,745.5,27230.5"></path><path id="kity_path_26595" fill="none" stroke="gray" d="M735,27230.5L744,27230.5"></path></g><path id="node_outline2025" fill="none" stroke="none" d="M750.5,27221.5h213a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-213a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2025" fill="black"><text id="kity_text_13065" text-rendering="inherit" font-size="12" dy=".8em" y="27222.700000047684" x="750.5">说说CopyOnWriteArrayList的使用场景</text></g></g><g id="minder_node2029"><g id="node_expander2023" style="cursor: pointer;" display="none"><path id="kity_path_26591" fill="white" stroke="gray" d="M984.5,27230.5A6,6,0,1,1,972.5,27230.5A6,6,0,1,1,984.5,27230.5"></path><path id="kity_path_26592" fill="none" stroke="gray"></path></g><path id="node_outline2024" fill="none" stroke="none" d="M989.5,27221.5h289a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-289a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2024" fill="black"><text id="kity_text_13063" text-rendering="inherit" font-size="12" dy=".8em" y="27222.700000047684" x="989.5">适合读多写少的并发场景，如黑名单，商品类别的访问</text></g></g><g id="minder_node2030"><g id="node_expander2026" style="cursor: pointer;"><path id="kity_path_26600" fill="white" stroke="gray" d="M745.5,27256.5A6,6,0,1,1,733.5,27256.5A6,6,0,1,1,745.5,27256.5"></path><path id="kity_path_26601" fill="none" stroke="gray" d="M735,27256.5L744,27256.5"></path></g><path id="node_outline2027" fill="none" stroke="none" d="M750.5,27247.5h98a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-98a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2027" fill="black"><text id="kity_text_13069" text-rendering="inherit" font-size="12" dy=".8em" y="27248.700000047684" x="750.5">COWA有什么缺点</text></g></g><g id="minder_node2031"><g id="node_expander2025" style="cursor: pointer;" display="none"><path id="kity_path_26597" fill="white" stroke="gray" d="M869.5,27256.5A6,6,0,1,1,857.5,27256.5A6,6,0,1,1,869.5,27256.5"></path><path id="kity_path_26598" fill="none" stroke="gray"></path></g><path id="node_outline2026" fill="none" stroke="none" d="M874.5,27247.5h518a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-518a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2026" fill="black"><text id="kity_text_13067" text-rendering="inherit" font-size="12" dy=".8em" y="27248.700000047684" x="874.5">他占内存，因为写操作复制一个新数组，可能导致数据不一致，因为读时数据还没有同步到读数组</text></g></g><g id="minder_node2032"><g id="node_expander2028" style="cursor: pointer;"><path id="kity_path_26606" fill="white" stroke="gray" d="M745.5,27282.5A6,6,0,1,1,733.5,27282.5A6,6,0,1,1,745.5,27282.5"></path><path id="kity_path_26607" fill="none" stroke="gray" d="M735,27282.5L744,27282.5"></path></g><path id="node_outline2029" fill="none" stroke="none" d="M750.5,27273.5h160a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-160a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2029" fill="black"><text id="kity_text_13073" text-rendering="inherit" font-size="12" dy=".8em" y="27274.700000047684" x="750.5">COWA和ArrayList有什么区别</text></g></g><g id="minder_node2033"><g id="node_expander2027" style="cursor: pointer;" display="none"><path id="kity_path_26603" fill="white" stroke="gray" d="M931.5,27282.5A6,6,0,1,1,919.5,27282.5A6,6,0,1,1,931.5,27282.5"></path><path id="kity_path_26604" fill="none" stroke="gray"></path></g><path id="node_outline2028" fill="none" stroke="none" d="M936.5,27273.5h427a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-427a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2028" fill="black"><text id="kity_text_13071" text-rendering="inherit" font-size="12" dy=".8em" y="27274.700000047684" x="936.5">他线程安全，然后对于可变操作add set开销大，需要复制数组，使用迭代器很快</text></g></g><g id="minder_node2034"><g id="node_expander2137" style="cursor: pointer;"><path id="kity_path_26933" fill="white" stroke="gray" d="M544.5,28623.5A6,6,0,1,1,532.5,28623.5A6,6,0,1,1,544.5,28623.5"></path><path id="kity_path_26934" fill="none" stroke="gray" d="M534,28623.5L543,28623.5"></path></g><path id="node_outline2138" fill="none" stroke="none" d="M549.5,28614.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2138" fill="black"><text id="kity_text_13333" text-rendering="inherit" font-size="12" dy=".8em" y="28615.700000047684" x="549.5">map</text></g></g><g id="minder_node2035"><g id="node_expander2087" style="cursor: pointer;"><path id="kity_path_26783" fill="white" stroke="gray" d="M596.5,27919.5A6,6,0,1,1,584.5,27919.5A6,6,0,1,1,596.5,27919.5"></path><path id="kity_path_26784" fill="none" stroke="gray" d="M586,27919.5L595,27919.5"></path></g><path id="node_outline2088" fill="none" stroke="none" d="M601.5,27910.5h53a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-53a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2088" fill="black"><text id="kity_text_13220" text-rendering="inherit" font-size="12" dy=".8em" y="27911.700000047684" x="601.5">hashmap</text></g></g><g id="minder_node2036"><g id="node_expander2032" style="cursor: pointer;"><path id="kity_path_26618" fill="white" stroke="gray" d="M675.5,27317.5A6,6,0,1,1,663.5,27317.5A6,6,0,1,1,675.5,27317.5"></path><path id="kity_path_26619" fill="none" stroke="gray" d="M665,27317.5L674,27317.5"></path></g><path id="node_outline2033" fill="none" stroke="none" d="M680.5,27308.5h126a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-126a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2033" fill="black"><text id="kity_text_13082" text-rendering="inherit" font-size="12" dy=".8em" y="27309.700000047684" x="680.5">说说hashmap是否null&#xa0;</text></g></g><g id="minder_node2037"><g id="node_expander2031" style="cursor: pointer;" display="none"><path id="kity_path_26615" fill="white" stroke="gray" d="M827.5,27317.5A6,6,0,1,1,815.5,27317.5A6,6,0,1,1,827.5,27317.5"></path><path id="kity_path_26616" fill="none" stroke="gray"></path></g><path id="node_outline2032" fill="none" stroke="none" d="M832.5,27299.5h414a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-414a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2032" fill="black"><text id="kity_text_13079" text-rendering="inherit" font-size="12" dy=".8em" y="27300.700000047684" x="832.5">1.hashmap可以存在一个key为null value 为null ,hashmap无序，不可以重复</text><text id="kity_text_13080" text-rendering="inherit" font-size="12" dy=".8em" y="27318.700000047684" x="832.5">2.可以为null 是因为底层hash做了处理，null 就赋0</text></g></g><g id="minder_node2038"><g id="node_expander2034" style="cursor: pointer;"><path id="kity_path_26624" fill="white" stroke="gray" d="M675.5,27352.5A6,6,0,1,1,663.5,27352.5A6,6,0,1,1,675.5,27352.5"></path><path id="kity_path_26625" fill="none" stroke="gray" d="M665,27352.5L674,27352.5"></path></g><path id="node_outline2035" fill="none" stroke="none" d="M680.5,27343.5h199a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-199a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2035" fill="black"><text id="kity_text_13086" text-rendering="inherit" font-size="12" dy=".8em" y="27344.700000047684" x="680.5">说说hashmap的底层核心参数有哪些</text></g></g><g id="minder_node2039"><g id="node_expander2033" style="cursor: pointer;" display="none"><path id="kity_path_26621" fill="white" stroke="gray" d="M900.5,27352.5A6,6,0,1,1,888.5,27352.5A6,6,0,1,1,900.5,27352.5"></path><path id="kity_path_26622" fill="none" stroke="gray"></path></g><path id="node_outline2034" fill="none" stroke="none" d="M905.5,27343.5h670a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-670a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2034" fill="black"><text id="kity_text_13084" text-rendering="inherit" font-size="12" dy=".8em" y="27344.700000047684" x="905.5">table数组，内部是Node&lt;K,V&gt;的来存储元素，size 键值对的数量 默认16，加载因子，默认是0.75，然后是下一次扩容后的值</text></g></g><g id="minder_node2040"><g id="node_expander2037" style="cursor: pointer;"><path id="kity_path_26633" fill="white" stroke="gray" d="M675.5,27405.5A6,6,0,1,1,663.5,27405.5A6,6,0,1,1,675.5,27405.5"></path><path id="kity_path_26634" fill="none" stroke="gray" d="M665,27405.5L674,27405.5"></path></g><path id="node_outline2038" fill="none" stroke="none" d="M680.5,27396.5h175a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-175a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2038" fill="black"><text id="kity_text_13097" text-rendering="inherit" font-size="12" dy=".8em" y="27397.700000047684" x="680.5">说说hashmap为什么线程不安全</text></g></g><g id="minder_node2041"><g id="node_expander2036" style="cursor: pointer;"><path id="kity_path_26630" fill="white" stroke="gray" d="M876.5,27405.5A6,6,0,1,1,864.5,27405.5A6,6,0,1,1,876.5,27405.5"></path><path id="kity_path_26631" fill="none" stroke="gray" d="M866,27405.5L875,27405.5"></path></g><path id="node_outline2037" fill="none" stroke="none" d="M881.5,27378.5h905a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-905a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2037" fill="black"><text id="kity_text_13093" text-rendering="inherit" font-size="12" dy=".8em" y="27379.700000047684" x="881.5">1.在1.7时并发下扩容在transfer函数中会发生死循环，因为是头插，扩容转移后前后链表顺序倒置，在转移过程中修改了原来链表中节点的引用关系。</text><text id="kity_text_13094" text-rendering="inherit" font-size="12" dy=".8em" y="27397.700000047684" x="881.5">在1.8是尾插，不会发生死循环，但是并发下会发生覆盖和丢失，在put方法中，</text><text id="kity_text_13095" text-rendering="inherit" font-size="12" dy=".8em" y="27415.700000047684" x="881.5">2.因为是线程不安全的，并发情况死循环导致cpu100，多线程put同时扩容进行链表元素转移&#xa0; 会同时反转 然后链表首位元素A指向B ，B又指向A 就导致 一直遍历死循环，</text></g></g><g id="minder_node2042"><g id="node_expander2035" style="cursor: pointer;" display="none"><path id="kity_path_26627" fill="white" stroke="gray" d="M1807.5,27405.5A6,6,0,1,1,1795.5,27405.5A6,6,0,1,1,1807.5,27405.5"></path><path id="kity_path_26628" fill="none" stroke="gray"></path></g><path id="node_outline2036" fill="none" stroke="none" d="M1812.5,27369.5h644a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-644a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text2036" fill="black"><text id="kity_text_13088" text-rendering="inherit" font-size="12" dy=".8em" y="27370.700000047684" x="1812.5">https://www.cnblogs.com/andy-zhou/p/5402984.html</text><text id="kity_text_13089" text-rendering="inherit" font-size="12" dy=".8em" y="27388.700000047684" x="1812.5">http://ifeve.com/hashmap-infinite-loop/</text><text id="kity_text_13090" text-rendering="inherit" font-size="12" dy=".8em" y="27406.700000047684" x="1812.5">http://upheart.cn/2021/04/17/Java%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88%E7%B1%BB/HashMap/</text><text id="kity_text_13091" text-rendering="inherit" font-size="12" dy=".8em" y="27424.700000047684" x="1812.5">https://blog.csdn.net/qq_40574571/article/details/97612100#t5</text></g></g><g id="minder_node2043"><g id="node_expander2039" style="cursor: pointer;"><path id="kity_path_26639" fill="white" stroke="gray" d="M675.5,27458.5A6,6,0,1,1,663.5,27458.5A6,6,0,1,1,675.5,27458.5"></path><path id="kity_path_26640" fill="none" stroke="gray" d="M665,27458.5L674,27458.5"></path></g><path id="node_outline2040" fill="none" stroke="none" d="M680.5,27449.5h138a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-138a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2040" fill="black"><text id="kity_text_13101" text-rendering="inherit" font-size="12" dy=".8em" y="27450.700000047684" x="680.5">说说hashmap的数据结构</text></g></g><g id="minder_node2044"><g id="node_expander2038" style="cursor: pointer;" display="none"><path id="kity_path_26636" fill="white" stroke="gray" d="M839.5,27458.5A6,6,0,1,1,827.5,27458.5A6,6,0,1,1,839.5,27458.5"></path><path id="kity_path_26637" fill="none" stroke="gray"></path></g><path id="node_outline2039" fill="none" stroke="none" d="M844.5,27449.5h1051a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1051a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2039" fill="black"><text id="kity_text_13099" text-rendering="inherit" font-size="12" dy=".8em" y="27450.700000047684" x="844.5">1.8是底层是数组+链表(桶)+红黑树，桶大于8 转 红黑树(可以优化查询效率 从O n 减到O log n)，不过当数组长度小于64时先扩容， 而不是转红黑树。1.7是数组+链表，使用链表解决冲突(拉链法)。</text></g></g><g id="minder_node2045"><g id="node_expander2041" style="cursor: pointer;"><path id="kity_path_26645" fill="white" stroke="gray" d="M675.5,27484.5A6,6,0,1,1,663.5,27484.5A6,6,0,1,1,675.5,27484.5"></path><path id="kity_path_26646" fill="none" stroke="gray" d="M665,27484.5L674,27484.5"></path></g><path id="node_outline2042" fill="none" stroke="none" d="M680.5,27475.5h227a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-227a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2042" fill="black"><text id="kity_text_13105" text-rendering="inherit" font-size="12" dy=".8em" y="27476.700000047684" x="680.5">hashmap新链表插入entry是头插还是尾插</text></g></g><g id="minder_node2046"><g id="node_expander2040" style="cursor: pointer;" display="none"><path id="kity_path_26642" fill="white" stroke="gray" d="M928.5,27484.5A6,6,0,1,1,916.5,27484.5A6,6,0,1,1,928.5,27484.5"></path><path id="kity_path_26643" fill="none" stroke="gray"></path></g><path id="node_outline2041" fill="none" stroke="none" d="M933.5,27475.5h180a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-180a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2041" fill="black"><text id="kity_text_13103" text-rendering="inherit" font-size="12" dy=".8em" y="27476.700000047684" x="933.5">在1.7之前是头插，1.8之后是尾插</text></g></g><g id="minder_node2047"><g id="node_expander2043" style="cursor: pointer;"><path id="kity_path_26651" fill="white" stroke="gray" d="M675.5,27519.5A6,6,0,1,1,663.5,27519.5A6,6,0,1,1,675.5,27519.5"></path><path id="kity_path_26652" fill="none" stroke="gray" d="M665,27519.5L674,27519.5"></path></g><path id="node_outline2044" fill="none" stroke="none" d="M680.5,27510.5h61a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-61a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2044" fill="black"><text id="kity_text_13110" text-rendering="inherit" font-size="12" dy=".8em" y="27511.700000047684" x="680.5">为什么尾插</text></g></g><g id="minder_node2048"><g id="node_expander2042" style="cursor: pointer;" display="none"><path id="kity_path_26648" fill="white" stroke="gray" d="M762.5,27519.5A6,6,0,1,1,750.5,27519.5A6,6,0,1,1,762.5,27519.5"></path><path id="kity_path_26649" fill="none" stroke="gray"></path></g><path id="node_outline2043" fill="none" stroke="none" d="M767.5,27501.5h951a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-951a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2043" fill="black"><text id="kity_text_13107" text-rendering="inherit" font-size="12" dy=".8em" y="27502.700000047684" x="767.5">1.主要是为了安全，因为1.7在并发环境下插入会形成环形链表，死循环，形成的原因是 因为并发情况在转移数据时 数据需要翻转 123 变321 而转移时会改变原来节点的引用关系。</text><text id="kity_text_13108" text-rendering="inherit" font-size="12" dy=".8em" y="27520.700000047684" x="767.5">2.尾插的好处是 在扩容时会保持链表元素原本的顺序，防止环化的问题</text></g></g><g id="minder_node2049"><g id="node_expander2045" style="cursor: pointer;"><path id="kity_path_26657" fill="white" stroke="gray" d="M675.5,27554.5A6,6,0,1,1,663.5,27554.5A6,6,0,1,1,675.5,27554.5"></path><path id="kity_path_26658" fill="none" stroke="gray" d="M665,27554.5L674,27554.5"></path></g><path id="node_outline2046" fill="none" stroke="none" d="M680.5,27545.5h177a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-177a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2046" fill="black"><text id="kity_text_13114" text-rendering="inherit" font-size="12" dy=".8em" y="27546.700000047684" x="680.5">JDK1.8对hashmap的优化有哪些</text></g></g><g id="minder_node2050"><g id="node_expander2044" style="cursor: pointer;" display="none"><path id="kity_path_26654" fill="white" stroke="gray" d="M878.5,27554.5A6,6,0,1,1,866.5,27554.5A6,6,0,1,1,878.5,27554.5"></path><path id="kity_path_26655" fill="none" stroke="gray"></path></g><path id="node_outline2045" fill="none" stroke="none" d="M883.5,27545.5h860a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-860a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2045" fill="black"><text id="kity_text_13112" text-rendering="inherit" font-size="12" dy=".8em" y="27546.700000047684" x="883.5">结构改为桶超过8后 数组+链表+红黑树。使用了尾插法防止table翻转。在扩容时元素顺序不变，要么原地，原理偏移2的次幂。优化hash算法只进行一次与运算。</text></g></g><g id="minder_node2051"><g id="node_expander2047" style="cursor: pointer;"><path id="kity_path_26663" fill="white" stroke="gray" d="M675.5,27580.5A6,6,0,1,1,663.5,27580.5A6,6,0,1,1,675.5,27580.5"></path><path id="kity_path_26664" fill="none" stroke="gray" d="M665,27580.5L674,27580.5"></path></g><path id="node_outline2048" fill="none" stroke="none" d="M680.5,27571.5h136a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-136a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2048" fill="black"><text id="kity_text_13118" text-rendering="inherit" font-size="12" dy=".8em" y="27572.700000047684" x="680.5">说说HashMap的put方法</text></g></g><g id="minder_node2052"><g id="node_expander2046" style="cursor: pointer;" display="none"><path id="kity_path_26660" fill="white" stroke="gray" d="M837.5,27580.5A6,6,0,1,1,825.5,27580.5A6,6,0,1,1,837.5,27580.5"></path><path id="kity_path_26661" fill="none" stroke="gray"></path></g><path id="node_outline2047" fill="none" stroke="none" d="M842.5,27571.5h1227a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1227a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2047" fill="black"><text id="kity_text_13116" text-rendering="inherit" font-size="12" dy=".8em" y="27572.700000047684" x="842.5">1.根据key获取hash值 先判断桶数组是否为空，为空扩容初始化容量 2.如果key重复 就直接覆盖 返回覆盖值 3.插入的key不存在就插入链表或者红黑树 4.插入链表时判断是否转红黑树 5.判断是否需要扩容&#xa0; &#xa0;插入的方法是尾插顺序插入</text></g></g><g id="minder_node2053"><g id="node_expander2049" style="cursor: pointer;"><path id="kity_path_26669" fill="white" stroke="gray" d="M675.5,27624.5A6,6,0,1,1,663.5,27624.5A6,6,0,1,1,675.5,27624.5"></path><path id="kity_path_26670" fill="none" stroke="gray" d="M665,27624.5L674,27624.5"></path></g><path id="node_outline2050" fill="none" stroke="none" d="M680.5,27615.5h147a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-147a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2050" fill="black"><text id="kity_text_13124" text-rendering="inherit" font-size="12" dy=".8em" y="27616.700000047684" x="680.5">知道HashMap的get方法吗</text></g></g><g id="minder_node2054"><g id="node_expander2048" style="cursor: pointer;" display="none"><path id="kity_path_26666" fill="white" stroke="gray" d="M848.5,27624.5A6,6,0,1,1,836.5,27624.5A6,6,0,1,1,848.5,27624.5"></path><path id="kity_path_26667" fill="none" stroke="gray"></path></g><path id="node_outline2049" fill="none" stroke="none" d="M853.5,27597.5h784a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-784a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2049" fill="black"><text id="kity_text_13120" text-rendering="inherit" font-size="12" dy=".8em" y="27598.700000047684" x="853.5">1.对key进行一次hash算法 定位数组位置，如果在hash表上取得，直接返回，然后判断当前节点是否有下一个节点，如果有再判断是链表还是红黑树</text><text id="kity_text_13121" text-rendering="inherit" font-size="12" dy=".8em" y="27616.700000047684" x="853.5">2.如果在链表首位取得 直接返回，否则继续自旋循环判断&#xa0; 如果 hash相同和key相同 就返回这个节点&#xa0;</text><text id="kity_text_13122" text-rendering="inherit" font-size="12" dy=".8em" y="27634.700000047684" x="853.5">3.如果在红黑树中去取，从根节点开始递归判断，根据hashcode 和红黑树左大右小的特点去寻找，一般来说查找次数是树的深度&#xa0;</text></g></g><g id="minder_node2055"><g id="node_expander2051" style="cursor: pointer;"><path id="kity_path_26675" fill="white" stroke="gray" d="M675.5,27686.5A6,6,0,1,1,663.5,27686.5A6,6,0,1,1,675.5,27686.5"></path><path id="kity_path_26676" fill="none" stroke="gray" d="M665,27686.5L674,27686.5"></path></g><path id="node_outline2052" fill="none" stroke="none" d="M680.5,27677.5h140a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-140a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2052" fill="black"><text id="kity_text_13130" text-rendering="inherit" font-size="12" dy=".8em" y="27678.700000047684" x="680.5">说说HashMap怎么扩容的</text></g></g><g id="minder_node2056"><g id="node_expander2050" style="cursor: pointer;" display="none"><path id="kity_path_26672" fill="white" stroke="gray" d="M841.5,27686.5A6,6,0,1,1,829.5,27686.5A6,6,0,1,1,841.5,27686.5"></path><path id="kity_path_26673" fill="none" stroke="gray"></path></g><path id="node_outline2051" fill="none" stroke="none" d="M846.5,27659.5h550a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-550a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2051" fill="black"><text id="kity_text_13126" text-rendering="inherit" font-size="12" dy=".8em" y="27660.700000047684" x="846.5">一次扩容一次resize(重新计算容量)一次全遍历+重新hash，循环性能。</text><text id="kity_text_13127" text-rendering="inherit" font-size="12" dy=".8em" y="27678.700000047684" x="846.5">1.如果原数组长度大于最大容量 就直接返回 如果为空就初始化桶数组 如果不为空就左移扩容2倍 </text><text id="kity_text_13128" text-rendering="inherit" font-size="12" dy=".8em" y="27696.700000047684" x="846.5">2. 新建数组 遍历老数组 重新计算在新数组存储位置，放入新数组 重新引用hashmap的table，设置阈值</text></g></g><g id="minder_node2057"><g id="node_expander2053" style="cursor: pointer;"><path id="kity_path_26681" fill="white" stroke="gray" d="M675.5,27730.5A6,6,0,1,1,663.5,27730.5A6,6,0,1,1,675.5,27730.5"></path><path id="kity_path_26682" fill="none" stroke="gray" d="M665,27730.5L674,27730.5"></path></g><path id="node_outline2054" fill="none" stroke="none" d="M680.5,27721.5h151a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-151a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2054" fill="black"><text id="kity_text_13134" text-rendering="inherit" font-size="12" dy=".8em" y="27722.700000047684" x="680.5">hashmap扩容后会rehash吗</text></g></g><g id="minder_node2058"><g id="node_expander2052" style="cursor: pointer;" display="none"><path id="kity_path_26678" fill="white" stroke="gray" d="M852.5,27730.5A6,6,0,1,1,840.5,27730.5A6,6,0,1,1,852.5,27730.5"></path><path id="kity_path_26679" fill="none" stroke="gray"></path></g><path id="node_outline2053" fill="none" stroke="none" d="M857.5,27721.5h927a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-927a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2053" fill="black"><text id="kity_text_13132" text-rendering="inherit" font-size="12" dy=".8em" y="27722.700000047684" x="857.5">1.不会，他把数据的hash和扩容前的长度进行与操作，如果e.hash &amp; oldCap结果是0 说明位置没变化，如果不为0 说明位置发生了变化，新的位置=老的位置+老的数组长度。</text></g></g><g id="minder_node2059"><g id="node_expander2055" style="cursor: pointer;"><path id="kity_path_26687" fill="white" stroke="gray" d="M675.5,27765.5A6,6,0,1,1,663.5,27765.5A6,6,0,1,1,675.5,27765.5"></path><path id="kity_path_26688" fill="none" stroke="gray" d="M665,27765.5L674,27765.5"></path></g><path id="node_outline2056" fill="none" stroke="none" d="M680.5,27756.5h240a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-240a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2056" fill="black"><text id="kity_text_13139" text-rendering="inherit" font-size="12" dy=".8em" y="27757.700000047684" x="680.5">hashmap的定位元素hash函数？1.8的优化？</text></g></g><g id="minder_node2060"><g id="node_expander2054" style="cursor: pointer;" display="none"><path id="kity_path_26684" fill="white" stroke="gray" d="M941.5,27765.5A6,6,0,1,1,929.5,27765.5A6,6,0,1,1,941.5,27765.5"></path><path id="kity_path_26685" fill="none" stroke="gray"></path></g><path id="node_outline2055" fill="none" stroke="none" d="M946.5,27747.5h825a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-825a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2055" fill="black"><text id="kity_text_13136" text-rendering="inherit" font-size="12" dy=".8em" y="27748.700000047684" x="946.5">1.对key的hashCode做hash操作（高16bit不变，低16bit和高16bit做了一个异或）；h &amp; (length-1); //通过位操作得到下标index。</text><text id="kity_text_13137" text-rendering="inherit" font-size="12" dy=".8em" y="27766.700000047684" x="946.5">2.只做一次16位右位移异或混合，而不是四次；优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的，主要是从速度、功效、质量来考虑的</text></g></g><g id="minder_node2061"><g id="node_expander2057" style="cursor: pointer;"><path id="kity_path_26693" fill="white" stroke="gray" d="M675.5,27800.5A6,6,0,1,1,663.5,27800.5A6,6,0,1,1,675.5,27800.5"></path><path id="kity_path_26694" fill="none" stroke="gray" d="M665,27800.5L674,27800.5"></path></g><path id="node_outline2058" fill="none" stroke="none" d="M680.5,27791.5h194a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-194a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2058" fill="black"><text id="kity_text_13143" text-rendering="inherit" font-size="12" dy=".8em" y="27792.700000047684" x="680.5">HashMap的长度为什么是2的幂次方</text></g></g><g id="minder_node2062"><g id="node_expander2056" style="cursor: pointer;" display="none"><path id="kity_path_26690" fill="white" stroke="gray" d="M895.5,27800.5A6,6,0,1,1,883.5,27800.5A6,6,0,1,1,895.5,27800.5"></path><path id="kity_path_26691" fill="none" stroke="gray"></path></g><path id="node_outline2057" fill="none" stroke="none" d="M900.5,27791.5h954a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-954a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2057" fill="black"><text id="kity_text_13141" text-rendering="inherit" font-size="12" dy=".8em" y="27792.700000047684" x="900.5">可以看源码中对有大量的与运算，只是为了与运算有更快的效率，与运算比取余更快。如果构造函数设置的初始容量不是 2 的次幂，那么会返回一个大于且最靠近它的 2 的次幂的值</text></g></g><g id="minder_node2063"><g id="node_expander2059" style="cursor: pointer;"><path id="kity_path_26699" fill="white" stroke="gray" d="M675.5,27826.5A6,6,0,1,1,663.5,27826.5A6,6,0,1,1,675.5,27826.5"></path><path id="kity_path_26700" fill="none" stroke="gray" d="M665,27826.5L674,27826.5"></path></g><path id="node_outline2060" fill="none" stroke="none" d="M680.5,27817.5h317a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-317a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2060" fill="black"><text id="kity_text_13147" text-rendering="inherit" font-size="12" dy=".8em" y="27818.700000047684" x="680.5">hashmap为什么是8才转红黑树，为什么不是7 为什么不是9</text></g></g><g id="minder_node2064"><g id="node_expander2058" style="cursor: pointer;" display="none"><path id="kity_path_26696" fill="white" stroke="gray" d="M1018.5,27826.5A6,6,0,1,1,1006.5,27826.5A6,6,0,1,1,1018.5,27826.5"></path><path id="kity_path_26697" fill="none" stroke="gray"></path></g><path id="node_outline2059" fill="none" stroke="none" d="M1023.5,27817.5h499a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-499a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2059" fill="black"><text id="kity_text_13145" text-rendering="inherit" font-size="12" dy=".8em" y="27818.700000047684" x="1023.5">链表中元素个数为8时的概率非常非常小了。还原阈值是6 因为防止链表和树之间频繁的转换。</text></g></g><g id="minder_node2065"><g id="node_expander2061" style="cursor: pointer;"><path id="kity_path_26705" fill="white" stroke="gray" d="M675.5,27852.5A6,6,0,1,1,663.5,27852.5A6,6,0,1,1,675.5,27852.5"></path><path id="kity_path_26706" fill="none" stroke="gray" d="M665,27852.5L674,27852.5"></path></g><path id="node_outline2062" fill="none" stroke="none" d="M680.5,27843.5h199a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-199a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2062" fill="black"><text id="kity_text_13151" text-rendering="inherit" font-size="12" dy=".8em" y="27844.700000047684" x="680.5">hashmap的默认初始容量为什么是16</text></g></g><g id="minder_node2066"><g id="node_expander2060" style="cursor: pointer;" display="none"><path id="kity_path_26702" fill="white" stroke="gray" d="M900.5,27852.5A6,6,0,1,1,888.5,27852.5A6,6,0,1,1,900.5,27852.5"></path><path id="kity_path_26703" fill="none" stroke="gray"></path></g><path id="node_outline2061" fill="none" stroke="none" d="M905.5,27843.5h206a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-206a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2061" fill="black"><text id="kity_text_13149" text-rendering="inherit" font-size="12" dy=".8em" y="27844.700000047684" x="905.5">从扩容频繁的角度和占内存的角度考虑</text></g></g><g id="minder_node2067"><g id="node_expander2063" style="cursor: pointer;"><path id="kity_path_26711" fill="white" stroke="gray" d="M675.5,27878.5A6,6,0,1,1,663.5,27878.5A6,6,0,1,1,675.5,27878.5"></path><path id="kity_path_26712" fill="none" stroke="gray" d="M665,27878.5L674,27878.5"></path></g><path id="node_outline2064" fill="none" stroke="none" d="M680.5,27869.5h323a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-323a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2064" fill="black"><text id="kity_text_13155" text-rendering="inherit" font-size="12" dy=".8em" y="27870.700000047684" x="680.5">解决hash冲突有哪些办法。hashmap怎么解决的hash冲突，</text></g></g><g id="minder_node2068"><g id="node_expander2062" style="cursor: pointer;" display="none"><path id="kity_path_26708" fill="white" stroke="gray" d="M1024.5,27878.5A6,6,0,1,1,1012.5,27878.5A6,6,0,1,1,1024.5,27878.5"></path><path id="kity_path_26709" fill="none" stroke="gray"></path></g><path id="node_outline2063" fill="none" stroke="none" d="M1029.5,27869.5h800a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-800a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2063" fill="black"><text id="kity_text_13153" text-rendering="inherit" font-size="12" dy=".8em" y="27870.700000047684" x="1029.5">主要是分离链表法和开放地址法，hashmap中使用的是拉链法，相同hash保存到同一个桶，查找元素时先查找对应的链表，再从链表中查找相应的元素</text></g></g><g id="minder_node2069"><g id="node_expander2065" style="cursor: pointer;"><path id="kity_path_26717" fill="white" stroke="gray" d="M675.5,27940.5A6,6,0,1,1,663.5,27940.5A6,6,0,1,1,675.5,27940.5"></path><path id="kity_path_26718" fill="none" stroke="gray" d="M665,27940.5L674,27940.5"></path></g><path id="node_outline2066" fill="none" stroke="none" d="M680.5,27931.5h205a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-205a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2066" fill="black"><text id="kity_text_13163" text-rendering="inherit" font-size="12" dy=".8em" y="27932.700000047684" x="680.5">你说了红黑树，那你说说红黑树的特点</text></g></g><g id="minder_node2070"><g id="node_expander2064" style="cursor: pointer;" display="none"><path id="kity_path_26714" fill="white" stroke="gray" d="M906.5,27940.5A6,6,0,1,1,894.5,27940.5A6,6,0,1,1,906.5,27940.5"></path><path id="kity_path_26715" fill="none" stroke="gray"></path></g><path id="node_outline2065" fill="none" stroke="none" d="M911.5,27895.5h545a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-545a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text2065" fill="black"><text id="kity_text_13157" text-rendering="inherit" font-size="12" dy=".8em" y="27896.700000047684" x="911.5">在hashmap中使用红黑树还可以减少时间复杂度，而红黑树的本身特点是 他是平衡二叉搜索树</text><text id="kity_text_13158" text-rendering="inherit" font-size="12" dy=".8em" y="27914.700000047684" x="911.5">任意结点都有颜色，红色或者黑色，红色不能与红色相邻，根节点一定是黑色的，&#xa0;null 位置看作是黑色</text><text id="kity_text_13159" text-rendering="inherit" font-size="12" dy=".8em" y="27932.700000047684" x="911.5">从根到所有 null 的路径上黑色结点的个数相同</text><text id="kity_text_13160" text-rendering="inherit" font-size="12" dy=".8em" y="27950.700000047684" x="911.5">红黑树中，最长的路径的长度，不会超过最短的路径的长度的2倍</text><text id="kity_text_13161" text-rendering="inherit" font-size="12" dy=".8em" y="27968.700000047684" x="911.5">时间复杂度：Olog（n）</text></g></g><g id="minder_node2071"><g id="node_expander2067" style="cursor: pointer;"><path id="kity_path_26723" fill="white" stroke="gray" d="M675.5,28002.5A6,6,0,1,1,663.5,28002.5A6,6,0,1,1,675.5,28002.5"></path><path id="kity_path_26724" fill="none" stroke="gray" d="M665,28002.5L674,28002.5"></path></g><path id="node_outline2068" fill="none" stroke="none" d="M680.5,27993.5h144a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-144a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2068" fill="black"><text id="kity_text_13167" text-rendering="inherit" font-size="12" dy=".8em" y="27994.700000047684" x="680.5">红黑树和平衡二叉树区别？</text></g></g><g id="minder_node2072"><g id="node_expander2066" style="cursor: pointer;" display="none"><path id="kity_path_26720" fill="white" stroke="gray" d="M845.5,28002.5A6,6,0,1,1,833.5,28002.5A6,6,0,1,1,845.5,28002.5"></path><path id="kity_path_26721" fill="none" stroke="gray"></path></g><path id="node_outline2067" fill="none" stroke="none" d="M850.5,27993.5h813a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-813a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2067" fill="black"><text id="kity_text_13165" text-rendering="inherit" font-size="12" dy=".8em" y="27994.700000047684" x="850.5">相对于对平衡要求严格的平衡二叉树树来说，红黑树它的旋转次数少，插入最多两次旋转，删除最多三次旋转，要的是基本平衡，查询 修改 删除性能都好</text></g></g><g id="minder_node2073"><g id="node_expander2069" style="cursor: pointer;"><path id="kity_path_26729" fill="white" stroke="gray" d="M675.5,28055.5A6,6,0,1,1,663.5,28055.5A6,6,0,1,1,675.5,28055.5"></path><path id="kity_path_26730" fill="none" stroke="gray" d="M665,28055.5L674,28055.5"></path></g><path id="node_outline2070" fill="none" stroke="none" d="M680.5,28046.5h205a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-205a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2070" fill="black"><text id="kity_text_13174" text-rendering="inherit" font-size="12" dy=".8em" y="28047.700000047684" x="680.5">知道红黑树插入过程吗，有什么原则吗</text></g></g><g id="minder_node2074"><g id="node_expander2068" style="cursor: pointer;" display="none"><path id="kity_path_26726" fill="white" stroke="gray" d="M906.5,28055.5A6,6,0,1,1,894.5,28055.5A6,6,0,1,1,906.5,28055.5"></path><path id="kity_path_26727" fill="none" stroke="gray"></path></g><path id="node_outline2069" fill="none" stroke="none" d="M911.5,28019.5h445a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-445a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text2069" fill="black"><text id="kity_text_13169" text-rendering="inherit" font-size="12" dy=".8em" y="28020.700000047684" x="911.5">插入的结点一定是红色的，如果为黑色如果插入的结点是根节点，将颜色改为黑色</text><text id="kity_text_13170" text-rendering="inherit" font-size="12" dy=".8em" y="28038.700000047684" x="911.5">插入的结点的父结点是黑色的，则插入完成</text><text id="kity_text_13171" text-rendering="inherit" font-size="12" dy=".8em" y="28056.700000047684" x="911.5">插入的结点的父结点是红色的，则需要修复，且继续向上调整，直到为根或满足规则</text><text id="kity_text_13172" text-rendering="inherit" font-size="12" dy=".8em" y="28074.700000047684" x="911.5">如果根修改之后为红色，一定要改过来，改为黑色</text></g></g><g id="minder_node2075"><g id="node_expander2070" style="cursor: pointer;" display="none"><path id="kity_path_26732" fill="white" stroke="gray" d="M675.5,28108.5A6,6,0,1,1,663.5,28108.5A6,6,0,1,1,675.5,28108.5"></path><path id="kity_path_26733" fill="none" stroke="gray"></path></g><path id="node_outline2071" fill="none" stroke="none" d="M680.5,28099.5h168a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-168a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2071" fill="black"><text id="kity_text_13176" text-rendering="inherit" font-size="12" dy=".8em" y="28100.700000047684" x="680.5">为什么不在一开始就有红黑树？</text></g></g><g id="minder_node2076"><g id="node_expander2072" style="cursor: pointer;"><path id="kity_path_26738" fill="white" stroke="gray" d="M675.5,28134.5A6,6,0,1,1,663.5,28134.5A6,6,0,1,1,675.5,28134.5"></path><path id="kity_path_26739" fill="none" stroke="gray" d="M665,28134.5L674,28134.5"></path></g><path id="node_outline2073" fill="none" stroke="none" d="M680.5,28125.5h171a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-171a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2073" fill="black"><text id="kity_text_13180" text-rendering="inherit" font-size="12" dy=".8em" y="28126.700000047684" x="680.5">hashmap1.7和1.8的区别你说说</text></g></g><g id="minder_node2077"><g id="node_expander2071" style="cursor: pointer;" display="none"><path id="kity_path_26735" fill="white" stroke="gray" d="M872.5,28134.5A6,6,0,1,1,860.5,28134.5A6,6,0,1,1,872.5,28134.5"></path><path id="kity_path_26736" fill="none" stroke="gray"></path></g><path id="node_outline2072" fill="none" stroke="none" d="M877.5,28125.5h426a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-426a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2072" fill="black"><text id="kity_text_13178" text-rendering="inherit" font-size="12" dy=".8em" y="28126.700000047684" x="877.5">1.7底层 数组+链表&#xa0; 头插&#xa0; 1.8 底层数组+链表+红黑树 尾插 红黑树优化查询速度</text></g></g><g id="minder_node2078"><g id="node_expander2074" style="cursor: pointer;"><path id="kity_path_26744" fill="white" stroke="gray" d="M675.5,28160.5A6,6,0,1,1,663.5,28160.5A6,6,0,1,1,675.5,28160.5"></path><path id="kity_path_26745" fill="none" stroke="gray" d="M665,28160.5L674,28160.5"></path></g><path id="node_outline2075" fill="none" stroke="none" d="M680.5,28151.5h222a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-222a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2075" fill="black"><text id="kity_text_13184" text-rendering="inherit" font-size="12" dy=".8em" y="28152.700000047684" x="680.5">为什么实例化时建议要指定hashmap容量</text></g></g><g id="minder_node2079"><g id="node_expander2073" style="cursor: pointer;" display="none"><path id="kity_path_26741" fill="white" stroke="gray" d="M923.5,28160.5A6,6,0,1,1,911.5,28160.5A6,6,0,1,1,923.5,28160.5"></path><path id="kity_path_26742" fill="none" stroke="gray"></path></g><path id="node_outline2074" fill="none" stroke="none" d="M928.5,28151.5h156a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-156a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2074" fill="black"><text id="kity_text_13182" text-rendering="inherit" font-size="12" dy=".8em" y="28152.700000047684" x="928.5">因为扩容是非常消耗性能的。</text></g></g><g id="minder_node2080"><g id="node_expander2076" style="cursor: pointer;"><path id="kity_path_26750" fill="white" stroke="gray" d="M675.5,28186.5A6,6,0,1,1,663.5,28186.5A6,6,0,1,1,675.5,28186.5"></path><path id="kity_path_26751" fill="none" stroke="gray" d="M665,28186.5L674,28186.5"></path></g><path id="node_outline2077" fill="none" stroke="none" d="M680.5,28177.5h205a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-205a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2077" fill="black"><text id="kity_text_13188" text-rendering="inherit" font-size="12" dy=".8em" y="28178.700000047684" x="680.5">为什么hashmap的key都是一些包装类</text></g></g><g id="minder_node2081"><g id="node_expander2075" style="cursor: pointer;" display="none"><path id="kity_path_26747" fill="white" stroke="gray" d="M906.5,28186.5A6,6,0,1,1,894.5,28186.5A6,6,0,1,1,906.5,28186.5"></path><path id="kity_path_26748" fill="none" stroke="gray"></path></g><path id="node_outline2076" fill="none" stroke="none" d="M911.5,28177.5h460a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-460a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2076" fill="black"><text id="kity_text_13186" text-rendering="inherit" font-size="12" dy=".8em" y="28178.700000047684" x="911.5">这些都是被final修饰的，保证key不可变的&#xa0;内部已重写了equals()、hashCode()等方法</text></g></g><g id="minder_node2082"><g id="node_expander2078" style="cursor: pointer;"><path id="kity_path_26756" fill="white" stroke="gray" d="M675.5,28221.5A6,6,0,1,1,663.5,28221.5A6,6,0,1,1,675.5,28221.5"></path><path id="kity_path_26757" fill="none" stroke="gray" d="M665,28221.5L674,28221.5"></path></g><path id="node_outline2079" fill="none" stroke="none" d="M680.5,28212.5h204a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-204a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2079" fill="black"><text id="kity_text_13193" text-rendering="inherit" font-size="12" dy=".8em" y="28213.700000047684" x="680.5">那hashmap的key是可变类会怎么样呢</text></g></g><g id="minder_node2083"><g id="node_expander2077" style="cursor: pointer;" display="none"><path id="kity_path_26753" fill="white" stroke="gray" d="M905.5,28221.5A6,6,0,1,1,893.5,28221.5A6,6,0,1,1,905.5,28221.5"></path><path id="kity_path_26754" fill="none" stroke="gray"></path></g><path id="node_outline2078" fill="none" stroke="none" d="M910.5,28203.5h324a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-324a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2078" fill="black"><text id="kity_text_13190" text-rendering="inherit" font-size="12" dy=".8em" y="28204.700000047684" x="910.5">1.可能会导致hashcode的值发生变化，导致put的值 无法get</text><text id="kity_text_13191" text-rendering="inherit" font-size="12" dy=".8em" y="28222.700000047684" x="910.5">2.而且获取对象时用到了equals和hashcode方法，</text></g></g><g id="minder_node2084"><g id="node_expander2080" style="cursor: pointer;"><path id="kity_path_26762" fill="white" stroke="gray" d="M675.5,28301.5A6,6,0,1,1,663.5,28301.5A6,6,0,1,1,675.5,28301.5"></path><path id="kity_path_26763" fill="none" stroke="gray" d="M665,28301.5L674,28301.5"></path></g><path id="node_outline2081" fill="none" stroke="none" d="M680.5,28292.5h174a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-174a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2081" fill="black"><text id="kity_text_13202" text-rendering="inherit" font-size="12" dy=".8em" y="28293.700000047684" x="680.5">hashmap底层查找的时间复杂度</text></g></g><g id="minder_node2085"><g id="node_expander2079" style="cursor: pointer;" display="none"><path id="kity_path_26759" fill="white" stroke="gray" d="M875.5,28301.5A6,6,0,1,1,863.5,28301.5A6,6,0,1,1,875.5,28301.5"></path><path id="kity_path_26760" fill="none" stroke="gray"></path></g><path id="node_outline2080" fill="none" stroke="none" d="M880.5,28247.5h1131a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1131a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text2080" fill="black"><text id="kity_text_13195" text-rendering="inherit" font-size="12" dy=".8em" y="28248.700000047684" x="880.5">不管插入还是查找，由key获取hash值然后定位到桶的最优时间复杂度都是O（1），最差O(n)</text><text id="kity_text_13196" text-rendering="inherit" font-size="12" dy=".8em" y="28266.700000047684" x="880.5">1.get</text><text id="kity_text_13197" text-rendering="inherit" font-size="12" dy=".8em" y="28284.700000047684" x="880.5">首先根据key计算出hash值，然后定位它所在的index，在最好的情况下，该index恰好只有一个节点且hash值和key的hash值相同，那么时间复杂度就是O(1)，当该节点为链表时为 O(n )，红黑树时就是 O(log n)，</text><text id="kity_text_13198" text-rendering="inherit" font-size="12" dy=".8em" y="28302.700000047684" x="880.5">但是由于HashMap的优化（链表长度、红黑树长度相对于HashMap容量不会过长，过长会触发resize操作），所以最坏的情况也就是O(n),可能还会小于这个值。</text><text id="kity_text_13199" text-rendering="inherit" font-size="12" dy=".8em" y="28320.700000047684" x="880.5">2.put</text><text id="kity_text_13200" text-rendering="inherit" font-size="12" dy=".8em" y="28338.700000047684" x="880.5">插入一个元素，该index位置恰好没有元素的话，时间复杂度就是O(1),当该位置有元素且为链表或者红黑树的情况下，时间复杂度会上升，但是最坏的情况下也就是O(n)。</text></g></g><g id="minder_node2086"><g id="node_expander2082" style="cursor: pointer;"><path id="kity_path_26768" fill="white" stroke="gray" d="M675.5,28408.5A6,6,0,1,1,663.5,28408.5A6,6,0,1,1,675.5,28408.5"></path><path id="kity_path_26769" fill="none" stroke="gray" d="M665,28408.5L674,28408.5"></path></g><path id="node_outline2083" fill="none" stroke="none" d="M680.5,28399.5h343a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-343a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2083" fill="black"><text id="kity_text_13210" text-rendering="inherit" font-size="12" dy=".8em" y="28400.700000047684" x="680.5">如果有很大数据容量需要去操作，hashmap中怎么办，怎么优化</text></g></g><g id="minder_node2087"><g id="node_expander2081" style="cursor: pointer;" display="none"><path id="kity_path_26765" fill="white" stroke="gray" d="M1044.5,28408.5A6,6,0,1,1,1032.5,28408.5A6,6,0,1,1,1044.5,28408.5"></path><path id="kity_path_26766" fill="none" stroke="gray"></path></g><path id="node_outline2082" fill="none" stroke="none" d="M1049.5,28363.5h1119a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1119a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text2082" fill="black"><text id="kity_text_13204" text-rendering="inherit" font-size="12" dy=".8em" y="28364.700000047684" x="1049.5">1.提前知道大概存储数据，防止因为数据过多而多次resize</text><text id="kity_text_13205" text-rendering="inherit" font-size="12" dy=".8em" y="28382.700000047684" x="1049.5">存储大量数据 可以处理合适的负载因子，如果数据确实很多，存储空间足够，并且为了保持查询速度，可以减少负载因子。</text><text id="kity_text_13206" text-rendering="inherit" font-size="12" dy=".8em" y="28400.700000047684" x="1049.5">要存储上百万或千万数据时一般会预先初始化一个大容量的map，防止扩容导致数据拷贝，除了扩容时会影响存储读取效率之外其它的原因就是散列算法的碰撞率了，碰撞的数据越多存储和读取的性能都会下降。</text><text id="kity_text_13207" text-rendering="inherit" font-size="12" dy=".8em" y="28418.700000047684" x="1049.5">2.get的优化，</text><text id="kity_text_13208" text-rendering="inherit" font-size="12" dy=".8em" y="28436.700000047684" x="1049.5">比如 重新 key 值的 hashCode() 方法，降低哈希冲突，从而减少链表的产生，高效利用哈希表，达到提高性能的效果。</text></g></g><g id="minder_node2088"><g id="node_expander2083" style="cursor: pointer;" display="none"><path id="kity_path_26771" fill="white" stroke="gray" d="M675.5,28470.5A6,6,0,1,1,663.5,28470.5A6,6,0,1,1,675.5,28470.5"></path><path id="kity_path_26772" fill="none" stroke="gray"></path></g><path id="node_outline2084" fill="none" stroke="none" d="M680.5,28461.5h241a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-241a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2084" fill="black"><text id="kity_text_13212" text-rendering="inherit" font-size="12" dy=".8em" y="28462.700000047684" x="680.5">什么是hash碰撞(冲突)，为什么有，怎么解决</text></g></g><g id="minder_node2089"><g id="node_expander2084" style="cursor: pointer;" display="none"><path id="kity_path_26774" fill="white" stroke="gray" d="M675.5,28496.5A6,6,0,1,1,663.5,28496.5A6,6,0,1,1,675.5,28496.5"></path><path id="kity_path_26775" fill="none" stroke="gray"></path></g><path id="node_outline2085" fill="none" stroke="none" d="M680.5,28487.5h236a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-236a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2085" fill="black"><text id="kity_text_13214" text-rendering="inherit" font-size="12" dy=".8em" y="28488.700000047684" x="680.5">hashmap初始化1000，怎么扩容，10000呢</text></g></g><g id="minder_node2090"><g id="node_expander2086" style="cursor: pointer;"><path id="kity_path_26780" fill="white" stroke="gray" d="M675.5,28522.5A6,6,0,1,1,663.5,28522.5A6,6,0,1,1,675.5,28522.5"></path><path id="kity_path_26781" fill="none" stroke="gray" d="M665,28522.5L674,28522.5"></path></g><path id="node_outline2087" fill="none" stroke="none" d="M680.5,28513.5h252a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-252a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2087" fill="black"><text id="kity_text_13218" text-rendering="inherit" font-size="12" dy=".8em" y="28514.700000047684" x="680.5">一个1000万HashMap，会占用多少空间内存？</text></g></g><g id="minder_node2091"><g id="node_expander2085" style="cursor: pointer;" display="none"><path id="kity_path_26777" fill="white" stroke="gray" d="M953.5,28522.5A6,6,0,1,1,941.5,28522.5A6,6,0,1,1,953.5,28522.5"></path><path id="kity_path_26778" fill="none" stroke="gray"></path></g><path id="node_outline2086" fill="none" stroke="none" d="M958.5,28513.5h367a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-367a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2086" fill="black"><text id="kity_text_13216" text-rendering="inherit" font-size="12" dy=".8em" y="28514.700000047684" x="958.5">https://blog.csdn.net/weixin_34343000/article/details/91993030</text></g></g><g id="minder_node2092"><g id="node_expander2094" style="cursor: pointer;"><path id="kity_path_26804" fill="white" stroke="gray" d="M596.5,28573.5A6,6,0,1,1,584.5,28573.5A6,6,0,1,1,596.5,28573.5"></path><path id="kity_path_26805" fill="none" stroke="gray" d="M586,28573.5L595,28573.5"></path></g><path id="node_outline2095" fill="none" stroke="none" d="M601.5,28564.5h93a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-93a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2095" fill="black"><text id="kity_text_13234" text-rendering="inherit" font-size="12" dy=".8em" y="28565.700000047684" x="601.5">LinkedHashMap</text></g></g><g id="minder_node2093"><g id="node_expander2089" style="cursor: pointer;"><path id="kity_path_26789" fill="white" stroke="gray" d="M715.5,28547.5A6,6,0,1,1,703.5,28547.5A6,6,0,1,1,715.5,28547.5"></path><path id="kity_path_26790" fill="none" stroke="gray" d="M705,28547.5L714,28547.5"></path></g><path id="node_outline2090" fill="none" stroke="none" d="M720.5,28538.5h172a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-172a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2090" fill="black"><text id="kity_text_13224" text-rendering="inherit" font-size="12" dy=".8em" y="28539.700000047684" x="720.5">说说linkedhashmap的底层结构</text></g></g><g id="minder_node2094"><g id="node_expander2088" style="cursor: pointer;" display="none"><path id="kity_path_26786" fill="white" stroke="gray" d="M913.5,28547.5A6,6,0,1,1,901.5,28547.5A6,6,0,1,1,913.5,28547.5"></path><path id="kity_path_26787" fill="none" stroke="gray"></path></g><path id="node_outline2089" fill="none" stroke="none" d="M918.5,28538.5h776a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-776a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2089" fill="black"><text id="kity_text_13222" text-rendering="inherit" font-size="12" dy=".8em" y="28539.700000047684" x="918.5">LinkedHashMap使用数组+双向链表+红黑树，拉链式散列表结构。只是用了双向链表让遍历顺序和插入顺序一致，底层多了个entry 来连接Node</text></g></g><g id="minder_node2095"><g id="node_expander2091" style="cursor: pointer;"><path id="kity_path_26795" fill="white" stroke="gray" d="M715.5,28573.5A6,6,0,1,1,703.5,28573.5A6,6,0,1,1,715.5,28573.5"></path><path id="kity_path_26796" fill="none" stroke="gray" d="M705,28573.5L714,28573.5"></path></g><path id="node_outline2092" fill="none" stroke="none" d="M720.5,28564.5h257a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-257a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2092" fill="black"><text id="kity_text_13228" text-rendering="inherit" font-size="12" dy=".8em" y="28565.700000047684" x="720.5">知道LinkedHashMap和HashMap有什么区别吗</text></g></g><g id="minder_node2096"><g id="node_expander2090" style="cursor: pointer;" display="none"><path id="kity_path_26792" fill="white" stroke="gray" d="M998.5,28573.5A6,6,0,1,1,986.5,28573.5A6,6,0,1,1,998.5,28573.5"></path><path id="kity_path_26793" fill="none" stroke="gray"></path></g><path id="node_outline2091" fill="none" stroke="none" d="M1003.5,28564.5h725a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-725a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2091" fill="black"><text id="kity_text_13226" text-rendering="inherit" font-size="12" dy=".8em" y="28565.700000047684" x="1003.5">因为LinkedHashMap保存了插入的顺序 遍历是有序的，默认是插入的序。因为hashmap是无序的 所以需要有序就选择LinkedHashMap</text></g></g><g id="minder_node2097"><g id="node_expander2093" style="cursor: pointer;"><path id="kity_path_26801" fill="white" stroke="gray" d="M715.5,28599.5A6,6,0,1,1,703.5,28599.5A6,6,0,1,1,715.5,28599.5"></path><path id="kity_path_26802" fill="none" stroke="gray" d="M705,28599.5L714,28599.5"></path></g><path id="node_outline2094" fill="none" stroke="none" d="M720.5,28590.5h153a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-153a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2094" fill="black"><text id="kity_text_13232" text-rendering="inherit" font-size="12" dy=".8em" y="28591.700000047684" x="720.5">LinkedHashMap有什么特点</text></g></g><g id="minder_node2098"><g id="node_expander2092" style="cursor: pointer;" display="none"><path id="kity_path_26798" fill="white" stroke="gray" d="M894.5,28599.5A6,6,0,1,1,882.5,28599.5A6,6,0,1,1,894.5,28599.5"></path><path id="kity_path_26799" fill="none" stroke="gray"></path></g><path id="node_outline2093" fill="none" stroke="none" d="M899.5,28590.5h574a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-574a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2093" fill="black"><text id="kity_text_13230" text-rendering="inherit" font-size="12" dy=".8em" y="28591.700000047684" x="899.5">LinkedHashMap的removeEldestEntry方法 删除老entry，可以来维持entry的数量，可以用来实现LRU算法</text></g></g><g id="minder_node2099"><g id="node_expander2118" style="cursor: pointer;"><path id="kity_path_26876" fill="white" stroke="gray" d="M596.5,28876.5A6,6,0,1,1,584.5,28876.5A6,6,0,1,1,596.5,28876.5"></path><path id="kity_path_26877" fill="none" stroke="gray" d="M586,28876.5L595,28876.5"></path></g><path id="node_outline2119" fill="none" stroke="none" d="M601.5,28867.5h118a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-118a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2119" fill="black"><text id="kity_text_13294" text-rendering="inherit" font-size="12" dy=".8em" y="28868.700000047684" x="601.5">concurrentHashMap</text></g></g><g id="minder_node2100"><g id="node_expander2096" style="cursor: pointer;"><path id="kity_path_26810" fill="white" stroke="gray" d="M740.5,28625.5A6,6,0,1,1,728.5,28625.5A6,6,0,1,1,740.5,28625.5"></path><path id="kity_path_26811" fill="none" stroke="gray" d="M730,28625.5L739,28625.5"></path></g><path id="node_outline2097" fill="none" stroke="none" d="M745.5,28616.5h74a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-74a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2097" fill="black"><text id="kity_text_13238" text-rendering="inherit" font-size="12" dy=".8em" y="28617.700000047684" x="745.5">说说他是什么</text></g></g><g id="minder_node2101"><g id="node_expander2095" style="cursor: pointer;" display="none"><path id="kity_path_26807" fill="white" stroke="gray" d="M840.5,28625.5A6,6,0,1,1,828.5,28625.5A6,6,0,1,1,840.5,28625.5"></path><path id="kity_path_26808" fill="none" stroke="gray"></path></g><path id="node_outline2096" fill="none" stroke="none" d="M845.5,28616.5h740a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-740a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2096" fill="black"><text id="kity_text_13236" text-rendering="inherit" font-size="12" dy=".8em" y="28617.700000047684" x="845.5">在并发环境下使用concurrenthashmap，他是线程安全的，性能相比于hashtable和synchronizedmap来说好。key和value都不可以为null</text></g></g><g id="minder_node2102"><g id="node_expander2098" style="cursor: pointer;"><path id="kity_path_26816" fill="white" stroke="gray" d="M740.5,28651.5A6,6,0,1,1,728.5,28651.5A6,6,0,1,1,740.5,28651.5"></path><path id="kity_path_26817" fill="none" stroke="gray" d="M730,28651.5L739,28651.5"></path></g><path id="node_outline2099" fill="none" stroke="none" d="M745.5,28642.5h97a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-97a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2099" fill="black"><text id="kity_text_13242" text-rendering="inherit" font-size="12" dy=".8em" y="28643.700000047684" x="745.5">说说他的数据结构</text></g></g><g id="minder_node2103"><g id="node_expander2097" style="cursor: pointer;" display="none"><path id="kity_path_26813" fill="white" stroke="gray" d="M863.5,28651.5A6,6,0,1,1,851.5,28651.5A6,6,0,1,1,863.5,28651.5"></path><path id="kity_path_26814" fill="none" stroke="gray"></path></g><path id="node_outline2098" fill="none" stroke="none" d="M868.5,28642.5h175a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-175a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2098" fill="black"><text id="kity_text_13240" text-rendering="inherit" font-size="12" dy=".8em" y="28643.700000047684" x="868.5">1.8是node数组+链表转红黑树。</text></g></g><g id="minder_node2104"><g id="node_expander2100" style="cursor: pointer;"><path id="kity_path_26822" fill="white" stroke="gray" d="M740.5,28677.5A6,6,0,1,1,728.5,28677.5A6,6,0,1,1,740.5,28677.5"></path><path id="kity_path_26823" fill="none" stroke="gray" d="M730,28677.5L739,28677.5"></path></g><path id="node_outline2101" fill="none" stroke="none" d="M745.5,28668.5h122a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-122a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2101" fill="black"><text id="kity_text_13246" text-rendering="inherit" font-size="12" dy=".8em" y="28669.700000047684" x="745.5">说说他为什么线程安全</text></g></g><g id="minder_node2105"><g id="node_expander2099" style="cursor: pointer;" display="none"><path id="kity_path_26819" fill="white" stroke="gray" d="M888.5,28677.5A6,6,0,1,1,876.5,28677.5A6,6,0,1,1,888.5,28677.5"></path><path id="kity_path_26820" fill="none" stroke="gray"></path></g><path id="node_outline2100" fill="none" stroke="none" d="M893.5,28668.5h832a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-832a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2100" fill="black"><text id="kity_text_13244" text-rendering="inherit" font-size="12" dy=".8em" y="28669.700000047684" x="893.5">使用CAS无锁操作保证线程安全+失败时的内置synchronized，内部类很多属性如node中的value 通过volatile来修饰。他直接锁node桶数组，减少锁粒度，</text></g></g><g id="minder_node2106"><g id="node_expander2102" style="cursor: pointer;"><path id="kity_path_26828" fill="white" stroke="gray" d="M740.5,28703.5A6,6,0,1,1,728.5,28703.5A6,6,0,1,1,740.5,28703.5"></path><path id="kity_path_26829" fill="none" stroke="gray" d="M730,28703.5L739,28703.5"></path></g><path id="node_outline2103" fill="none" stroke="none" d="M745.5,28694.5h124a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-124a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2103" fill="black"><text id="kity_text_13250" text-rendering="inherit" font-size="12" dy=".8em" y="28695.700000047684" x="745.5">为什么用synchronized</text></g></g><g id="minder_node2107"><g id="node_expander2101" style="cursor: pointer;" display="none"><path id="kity_path_26825" fill="white" stroke="gray" d="M890.5,28703.5A6,6,0,1,1,878.5,28703.5A6,6,0,1,1,890.5,28703.5"></path><path id="kity_path_26826" fill="none" stroke="gray"></path></g><path id="node_outline2102" fill="none" stroke="none" d="M895.5,28694.5h743a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-743a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2102" fill="black"><text id="kity_text_13248" text-rendering="inherit" font-size="12" dy=".8em" y="28695.700000047684" x="895.5">因为在jdk8对同步锁做了很多优化，包括偏向锁，轻量级锁，重量级锁，可以依次向上升级锁状态，性能和ReentrantLock性能是差不多的，</text></g></g><g id="minder_node2108"><g id="node_expander2104" style="cursor: pointer;"><path id="kity_path_26834" fill="white" stroke="gray" d="M740.5,28747.5A6,6,0,1,1,728.5,28747.5A6,6,0,1,1,740.5,28747.5"></path><path id="kity_path_26835" fill="none" stroke="gray" d="M730,28747.5L739,28747.5"></path></g><path id="node_outline2105" fill="none" stroke="none" d="M745.5,28738.5h70a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-70a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2105" fill="black"><text id="kity_text_13256" text-rendering="inherit" font-size="12" dy=".8em" y="28739.700000047684" x="745.5">说说put方法</text></g></g><g id="minder_node2109"><g id="node_expander2103" style="cursor: pointer;" display="none"><path id="kity_path_26831" fill="white" stroke="gray" d="M836.5,28747.5A6,6,0,1,1,824.5,28747.5A6,6,0,1,1,836.5,28747.5"></path><path id="kity_path_26832" fill="none" stroke="gray"></path></g><path id="node_outline2104" fill="none" stroke="none" d="M841.5,28720.5h1196a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1196a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2104" fill="black"><text id="kity_text_13252" text-rendering="inherit" font-size="12" dy=".8em" y="28721.700000047684" x="841.5">put可以指定数量批量执行，put操作采用CAS+synchronized实现并发插入或更新操作 1.计算hash 2.定位索引 3.如果是桶中的第一个元素 尝试CAS成功，说明Node节点已经插入，随后尝试+1检查当前容量是否需要进行扩容.&#xa0;</text><text id="kity_text_13253" text-rendering="inherit" font-size="12" dy=".8em" y="28739.700000047684" x="841.5">CAS失败，说明有其它线程提前插入了节点，自旋重新尝试在这个位置插入节点。</text><text id="kity_text_13254" text-rendering="inherit" font-size="12" dy=".8em" y="28757.700000047684" x="841.5">如果索引为-1插入过程有其它线程正在扩容，则一起进行扩容操作。如果都不是新的Node节点按链表或红黑树的方式插入到合适的位置，这个过程采用同步内置锁实现并发</text></g></g><g id="minder_node2110"><g id="node_expander2106" style="cursor: pointer;"><path id="kity_path_26840" fill="white" stroke="gray" d="M740.5,28845.5A6,6,0,1,1,728.5,28845.5A6,6,0,1,1,740.5,28845.5"></path><path id="kity_path_26841" fill="none" stroke="gray" d="M730,28845.5L739,28845.5"></path></g><path id="node_outline2107" fill="none" stroke="none" d="M745.5,28836.5h173a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-173a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2107" fill="black"><text id="kity_text_13266" text-rendering="inherit" font-size="12" dy=".8em" y="28837.700000047684" x="745.5">说说分段的原理和依据(put为例)</text></g></g><g id="minder_node2111"><g id="node_expander2105" style="cursor: pointer;" display="none"><path id="kity_path_26837" fill="white" stroke="gray" d="M939.5,28845.5A6,6,0,1,1,927.5,28845.5A6,6,0,1,1,939.5,28845.5"></path><path id="kity_path_26838" fill="none" stroke="gray"></path></g><path id="node_outline2106" fill="none" stroke="none" d="M944.5,28782.5h658a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-658a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text2106" fill="black"><text id="kity_text_13258" text-rendering="inherit" font-size="12" dy=".8em" y="28783.700000047684" x="944.5">1、没有hash冲突，如果添加的元素的位置在数组中是空的话，那么就使用CAS的方式来加入元素，加锁粒度是数组中的元素</text><text id="kity_text_13259" text-rendering="inherit" font-size="12" dy=".8em" y="28801.700000047684" x="944.5">2、出现了hash冲突，添加的元素的位置在数组中已经有了值，那么又存在三种情况</text><text id="kity_text_13260" text-rendering="inherit" font-size="12" dy=".8em" y="28819.700000047684" x="944.5">（1）key相同，那么直接用新的元素覆盖旧的元素</text><text id="kity_text_13261" text-rendering="inherit" font-size="12" dy=".8em" y="28837.700000047684" x="944.5">（2）如果数组中的元素是链表的形式，那么将新的元素挂载在链表尾部</text><text id="kity_text_13262" text-rendering="inherit" font-size="12" dy=".8em" y="28855.700000047684" x="944.5">（3）如果数组中的元素是红黑树的形式，那么将新的元素加入到红黑树</text><text id="kity_text_13263" text-rendering="inherit" font-size="12" dy=".8em" y="28873.700000047684" x="944.5">使用的是synchronized加锁，锁住的对象就是数组中的元素，加锁的粒度是数组中元素</text><text id="kity_text_13264" text-rendering="inherit" font-size="12" dy=".8em" y="28891.700000047684" x="944.5">3.ConcurrentHashMap的分段加锁机制，其实锁住的就是数组中的元素，当操作数组中不同的元素时，是不会产生竞争的</text></g></g><g id="minder_node2112"><g id="node_expander2108" style="cursor: pointer;"><path id="kity_path_26846" fill="white" stroke="gray" d="M740.5,28952.5A6,6,0,1,1,728.5,28952.5A6,6,0,1,1,740.5,28952.5"></path><path id="kity_path_26847" fill="none" stroke="gray" d="M730,28952.5L739,28952.5"></path></g><path id="node_outline2109" fill="none" stroke="none" d="M745.5,28943.5h228a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-228a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2109" fill="black"><text id="kity_text_13273" text-rendering="inherit" font-size="12" dy=".8em" y="28944.700000047684" x="745.5">继续上面那个问题，1.7和1.8的区别，优化</text></g></g><g id="minder_node2113"><g id="node_expander2107" style="cursor: pointer;" display="none"><path id="kity_path_26843" fill="white" stroke="gray" d="M994.5,28952.5A6,6,0,1,1,982.5,28952.5A6,6,0,1,1,994.5,28952.5"></path><path id="kity_path_26844" fill="none" stroke="gray"></path></g><path id="node_outline2108" fill="none" stroke="none" d="M999.5,28916.5h1605a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1605a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text2108" fill="black"><text id="kity_text_13268" text-rendering="inherit" font-size="12" dy=".8em" y="28917.700000047684" x="999.5">在JDK1.7中，ConcurrentHashMap使用的是segment锁，是继承自ReentrantLock，一旦初始化完成，就不能再改变了，但是segment数组中的HashEntry数组是可以改变的</text><text id="kity_text_13269" text-rendering="inherit" font-size="12" dy=".8em" y="28935.700000047684" x="999.5">jdk1.8中的ConcurrentHashMap中废弃了segment锁，直接使用了数组元素，数组中的每个元素都可以作为一个锁，在元素中没有值的情况下，可以直接通过CAS操作来设值，同时保证并发安全，如果元素里面已经存在值的话，那么就使用synchronized关键字对元素加锁，再进行之后的hash冲突处理</text><text id="kity_text_13270" text-rendering="inherit" font-size="12" dy=".8em" y="28953.700000047684" x="999.5">随着数组扩容的话，这里面的元素增多，可加的锁也增多了，所以说jdk1.8的ConcurrentHashMap加锁粒度比1.7更细，jdk1.7里的ConcurrentHashMap加锁只能对segment来加锁，而且初始化了就不能改变</text><text id="kity_text_13271" text-rendering="inherit" font-size="12" dy=".8em" y="28971.700000047684" x="999.5">JDK1.8中的ConcurrentHashMap加锁的粒度更细，并发性能更好</text></g></g><g id="minder_node2114"><g id="node_expander2110" style="cursor: pointer;"><path id="kity_path_26852" fill="white" stroke="gray" d="M740.5,29014.5A6,6,0,1,1,728.5,29014.5A6,6,0,1,1,740.5,29014.5"></path><path id="kity_path_26853" fill="none" stroke="gray" d="M730,29014.5L739,29014.5"></path></g><path id="node_outline2111" fill="none" stroke="none" d="M745.5,29005.5h61a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-61a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2111" fill="black"><text id="kity_text_13278" text-rendering="inherit" font-size="12" dy=".8em" y="29006.700000047684" x="745.5">怎么扩容的</text></g></g><g id="minder_node2115"><g id="node_expander2109" style="cursor: pointer;" display="none"><path id="kity_path_26849" fill="white" stroke="gray" d="M827.5,29014.5A6,6,0,1,1,815.5,29014.5A6,6,0,1,1,827.5,29014.5"></path><path id="kity_path_26850" fill="none" stroke="gray"></path></g><path id="node_outline2110" fill="none" stroke="none" d="M832.5,28996.5h746a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-746a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2110" fill="black"><text id="kity_text_13275" text-rendering="inherit" font-size="12" dy=".8em" y="28997.700000047684" x="832.5">1.ConcurrentHashMap是支持并发插入的&#xa0;构建一个nextTable，大小为table的两倍。把table的数据遍历复制到nextTable中。里面使用CAS</text><text id="kity_text_13276" text-rendering="inherit" font-size="12" dy=".8em" y="29015.700000047684" x="832.5">2.每个Node结点的长度&gt; 8时；如果数组大小&lt; 64, 优先扩容resize(rehash) 大于64，优先转红黑树。转时锁逻辑与put锁逻辑一致</text></g></g><g id="minder_node2116"><g id="node_expander2112" style="cursor: pointer;"><path id="kity_path_26858" fill="white" stroke="gray" d="M740.5,29049.5A6,6,0,1,1,728.5,29049.5A6,6,0,1,1,740.5,29049.5"></path><path id="kity_path_26859" fill="none" stroke="gray" d="M730,29049.5L739,29049.5"></path></g><path id="node_outline2113" fill="none" stroke="none" d="M745.5,29040.5h86a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-86a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2113" fill="black"><text id="kity_text_13282" text-rendering="inherit" font-size="12" dy=".8em" y="29041.700000047684" x="745.5">说说他的初始化</text></g></g><g id="minder_node2117"><g id="node_expander2111" style="cursor: pointer;" display="none"><path id="kity_path_26855" fill="white" stroke="gray" d="M852.5,29049.5A6,6,0,1,1,840.5,29049.5A6,6,0,1,1,852.5,29049.5"></path><path id="kity_path_26856" fill="none" stroke="gray"></path></g><path id="node_outline2112" fill="none" stroke="none" d="M857.5,29040.5h540a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-540a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2112" fill="black"><text id="kity_text_13280" text-rendering="inherit" font-size="12" dy=".8em" y="29041.700000047684" x="857.5">初始化延迟到第一次put操作，支持并发put，使用CAS保证put而初始化只有一个线程执行，其他等待</text></g></g><g id="minder_node2118"><g id="node_expander2114" style="cursor: pointer;"><path id="kity_path_26864" fill="white" stroke="gray" d="M740.5,29075.5A6,6,0,1,1,728.5,29075.5A6,6,0,1,1,740.5,29075.5"></path><path id="kity_path_26865" fill="none" stroke="gray" d="M730,29075.5L739,29075.5"></path></g><path id="node_outline2115" fill="none" stroke="none" d="M745.5,29066.5h206a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-206a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2115" fill="black"><text id="kity_text_13286" text-rendering="inherit" font-size="12" dy=".8em" y="29067.700000047684" x="745.5">concurrentHashMap和hashmap区别</text></g></g><g id="minder_node2119"><g id="node_expander2113" style="cursor: pointer;" display="none"><path id="kity_path_26861" fill="white" stroke="gray" d="M972.5,29075.5A6,6,0,1,1,960.5,29075.5A6,6,0,1,1,972.5,29075.5"></path><path id="kity_path_26862" fill="none" stroke="gray"></path></g><path id="node_outline2114" fill="none" stroke="none" d="M977.5,29066.5h1233a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1233a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2114" fill="black"><text id="kity_text_13284" text-rendering="inherit" font-size="12" dy=".8em" y="29067.700000047684" x="977.5">一个线程安全 一个非线程安全。HashMap允许Key和Value为null，而ConcurrentHashMap不允许，HashMap不允许通过Iterator遍历的同时通过HashMap修改，而ConcurrentHashMap允许该行为，并且该更新对后续的遍历可见</text></g></g><g id="minder_node2120"><g id="node_expander2116" style="cursor: pointer;"><path id="kity_path_26870" fill="white" stroke="gray" d="M740.5,29101.5A6,6,0,1,1,728.5,29101.5A6,6,0,1,1,740.5,29101.5"></path><path id="kity_path_26871" fill="none" stroke="gray" d="M730,29101.5L739,29101.5"></path></g><path id="node_outline2117" fill="none" stroke="none" d="M745.5,29092.5h202a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-202a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2117" fill="black"><text id="kity_text_13290" text-rendering="inherit" font-size="12" dy=".8em" y="29093.700000047684" x="745.5">那你说说concurrentHashmap中的锁</text></g></g><g id="minder_node2121"><g id="node_expander2115" style="cursor: pointer;" display="none"><path id="kity_path_26867" fill="white" stroke="gray" d="M968.5,29101.5A6,6,0,1,1,956.5,29101.5A6,6,0,1,1,968.5,29101.5"></path><path id="kity_path_26868" fill="none" stroke="gray"></path></g><path id="node_outline2116" fill="none" stroke="none" d="M973.5,29092.5h149a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-149a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2116" fill="black"><text id="kity_text_13288" text-rendering="inherit" font-size="12" dy=".8em" y="29093.700000047684" x="973.5">使用了内置的synchronized</text></g></g><g id="minder_node2122"><g id="node_expander2117" style="cursor: pointer;" display="none"><path id="kity_path_26873" fill="white" stroke="gray" d="M740.5,29127.5A6,6,0,1,1,728.5,29127.5A6,6,0,1,1,740.5,29127.5"></path><path id="kity_path_26874" fill="none" stroke="gray"></path></g><path id="node_outline2118" fill="none" stroke="none" d="M745.5,29118.5h225a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-225a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2118" fill="black"><text id="kity_text_13292" text-rendering="inherit" font-size="12" dy=".8em" y="29119.700000047684" x="745.5">concurrentHashMap读为什么不用加锁呢</text></g></g><g id="minder_node2123"><g id="node_expander2130" style="cursor: pointer;"><path id="kity_path_26912" fill="white" stroke="gray" d="M596.5,29219.5A6,6,0,1,1,584.5,29219.5A6,6,0,1,1,596.5,29219.5"></path><path id="kity_path_26913" fill="none" stroke="gray" d="M586,29219.5L595,29219.5"></path></g><path id="node_outline2131" fill="none" stroke="none" d="M601.5,29210.5h56a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-56a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2131" fill="black"><text id="kity_text_13319" text-rendering="inherit" font-size="12" dy=".8em" y="29211.700000047684" x="601.5">hashtable</text></g></g><g id="minder_node2124"><g id="node_expander2121" style="cursor: pointer;"><path id="kity_path_26885" fill="white" stroke="gray" d="M678.5,29163.5A6,6,0,1,1,666.5,29163.5A6,6,0,1,1,678.5,29163.5"></path><path id="kity_path_26886" fill="none" stroke="gray" d="M668,29163.5L677,29163.5"></path></g><path id="node_outline2122" fill="none" stroke="none" d="M683.5,29154.5h125a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-125a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2122" fill="black"><text id="kity_text_13301" text-rendering="inherit" font-size="12" dy=".8em" y="29155.700000047684" x="683.5">hashtable可以为null吗</text></g></g><g id="minder_node2125"><g id="node_expander2120" style="cursor: pointer;"><path id="kity_path_26882" fill="white" stroke="gray" d="M829.5,29163.5A6,6,0,1,1,817.5,29163.5A6,6,0,1,1,829.5,29163.5"></path><path id="kity_path_26883" fill="none" stroke="gray" d="M819,29163.5L828,29163.5"></path></g><path id="node_outline2121" fill="none" stroke="none" d="M834.5,29145.5h714a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-714a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2121" fill="black"><text id="kity_text_13298" text-rendering="inherit" font-size="12" dy=".8em" y="29146.700000047684" x="834.5">1.Hashtable不允许键或值为 null ，put 空值的时候会直接抛空指针异常，而且你put&#xa0; null 他无法判断是key不存在 还是 本来就null ，</text><text id="kity_text_13299" text-rendering="inherit" font-size="12" dy=".8em" y="29164.700000047684" x="834.5">并且你put null 他就去获取null的hashcode，这是不允许的，没有像hashmap一样的hash处理为null返回0</text></g></g><g id="minder_node2126"><g id="node_expander2119" style="cursor: pointer;" display="none"><path id="kity_path_26879" fill="white" stroke="gray" d="M1569.5,29163.5A6,6,0,1,1,1557.5,29163.5A6,6,0,1,1,1569.5,29163.5"></path><path id="kity_path_26880" fill="none" stroke="gray"></path></g><path id="node_outline2120" fill="none" stroke="none" d="M1574.5,29154.5h289a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-289a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2120" fill="black"><text id="kity_text_13296" text-rendering="inherit" font-size="12" dy=".8em" y="29155.700000047684" x="1574.5">https://www.cnblogs.com/cswiki/p/14604950.html</text></g></g><g id="minder_node2127"><g id="node_expander2123" style="cursor: pointer;"><path id="kity_path_26891" fill="white" stroke="gray" d="M678.5,29198.5A6,6,0,1,1,666.5,29198.5A6,6,0,1,1,678.5,29198.5"></path><path id="kity_path_26892" fill="none" stroke="gray" d="M668,29198.5L677,29198.5"></path></g><path id="node_outline2124" fill="none" stroke="none" d="M683.5,29189.5h181a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-181a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2124" fill="black"><text id="kity_text_13305" text-rendering="inherit" font-size="12" dy=".8em" y="29190.700000047684" x="683.5">说说hashtable和hashmap的区别</text></g></g><g id="minder_node2128"><g id="node_expander2122" style="cursor: pointer;" display="none"><path id="kity_path_26888" fill="white" stroke="gray" d="M885.5,29198.5A6,6,0,1,1,873.5,29198.5A6,6,0,1,1,885.5,29198.5"></path><path id="kity_path_26889" fill="none" stroke="gray"></path></g><path id="node_outline2123" fill="none" stroke="none" d="M890.5,29189.5h621a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-621a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2123" fill="black"><text id="kity_text_13303" text-rendering="inherit" font-size="12" dy=".8em" y="29190.700000047684" x="890.5">hashmap是非线程安全 并且key value可以为null，hashtable线程安全，底层加了同步锁，key value都不可以为null</text></g></g><g id="minder_node2129"><g id="node_expander2125" style="cursor: pointer;"><path id="kity_path_26897" fill="white" stroke="gray" d="M678.5,29224.5A6,6,0,1,1,666.5,29224.5A6,6,0,1,1,678.5,29224.5"></path><path id="kity_path_26898" fill="none" stroke="gray" d="M668,29224.5L677,29224.5"></path></g><path id="node_outline2126" fill="none" stroke="none" d="M683.5,29215.5h141a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-141a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2126" fill="black"><text id="kity_text_13309" text-rendering="inherit" font-size="12" dy=".8em" y="29216.700000047684" x="683.5">为什么hashtable线程安全</text></g></g><g id="minder_node2130"><g id="node_expander2124" style="cursor: pointer;" display="none"><path id="kity_path_26894" fill="white" stroke="gray" d="M845.5,29224.5A6,6,0,1,1,833.5,29224.5A6,6,0,1,1,845.5,29224.5"></path><path id="kity_path_26895" fill="none" stroke="gray"></path></g><path id="node_outline2125" fill="none" stroke="none" d="M850.5,29215.5h96a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-96a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2125" fill="black"><text id="kity_text_13307" text-rendering="inherit" font-size="12" dy=".8em" y="29216.700000047684" x="850.5">内部加了同步锁，</text></g></g><g id="minder_node2131"><g id="node_expander2127" style="cursor: pointer;"><path id="kity_path_26903" fill="white" stroke="gray" d="M678.5,29250.5A6,6,0,1,1,666.5,29250.5A6,6,0,1,1,678.5,29250.5"></path><path id="kity_path_26904" fill="none" stroke="gray" d="M668,29250.5L677,29250.5"></path></g><path id="node_outline2128" fill="none" stroke="none" d="M683.5,29241.5h254a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-254a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2128" fill="black"><text id="kity_text_13313" text-rendering="inherit" font-size="12" dy=".8em" y="29242.700000047684" x="683.5">你看他的底层吗，他在哪里加锁的，加了什么锁</text></g></g><g id="minder_node2132"><g id="node_expander2126" style="cursor: pointer;" display="none"><path id="kity_path_26900" fill="white" stroke="gray" d="M958.5,29250.5A6,6,0,1,1,946.5,29250.5A6,6,0,1,1,958.5,29250.5"></path><path id="kity_path_26901" fill="none" stroke="gray"></path></g><path id="node_outline2127" fill="none" stroke="none" d="M963.5,29241.5h368a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-368a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2127" fill="black"><text id="kity_text_13311" text-rendering="inherit" font-size="12" dy=".8em" y="29242.700000047684" x="963.5">在put get方法都加了同步锁，所有操作都需要去竞争一把锁，锁对象</text></g></g><g id="minder_node2133"><g id="node_expander2129" style="cursor: pointer;"><path id="kity_path_26909" fill="white" stroke="gray" d="M678.5,29276.5A6,6,0,1,1,666.5,29276.5A6,6,0,1,1,678.5,29276.5"></path><path id="kity_path_26910" fill="none" stroke="gray" d="M668,29276.5L677,29276.5"></path></g><path id="node_outline2130" fill="none" stroke="none" d="M683.5,29267.5h195a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-195a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2130" fill="black"><text id="kity_text_13317" text-rendering="inherit" font-size="12" dy=".8em" y="29268.700000047684" x="683.5">hashtable 快速失败 还是安全失败？</text></g></g><g id="minder_node2134"><g id="node_expander2128" style="cursor: pointer;" display="none"><path id="kity_path_26906" fill="white" stroke="gray" d="M899.5,29276.5A6,6,0,1,1,887.5,29276.5A6,6,0,1,1,899.5,29276.5"></path><path id="kity_path_26907" fill="none" stroke="gray"></path></g><path id="node_outline2129" fill="none" stroke="none" d="M904.5,29267.5h1093a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1093a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2129" fill="black"><text id="kity_text_13315" text-rendering="inherit" font-size="12" dy=".8em" y="29268.700000047684" x="904.5">1.安全失败，读取的数据不一定是最新的数据。不像当其他线程改变了HashMap 的结构，如：增删，将会抛出并发修改异常，而 Hashtable 则不会。Hashtable是Dictionary 类下，集合类下都是快速失败。</text></g></g><g id="minder_node2135"><g id="node_expander2136" style="cursor: pointer;"><path id="kity_path_26930" fill="white" stroke="gray" d="M596.5,29327.5A6,6,0,1,1,584.5,29327.5A6,6,0,1,1,596.5,29327.5"></path><path id="kity_path_26931" fill="none" stroke="gray" d="M586,29327.5L595,29327.5"></path></g><path id="node_outline2137" fill="none" stroke="none" d="M601.5,29318.5h52a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-52a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2137" fill="black"><text id="kity_text_13331" text-rendering="inherit" font-size="12" dy=".8em" y="29319.700000047684" x="601.5">TreeMap</text></g></g><g id="minder_node2136"><g id="node_expander2132" style="cursor: pointer;"><path id="kity_path_26918" fill="white" stroke="gray" d="M674.5,29301.5A6,6,0,1,1,662.5,29301.5A6,6,0,1,1,674.5,29301.5"></path><path id="kity_path_26919" fill="none" stroke="gray" d="M664,29301.5L673,29301.5"></path></g><path id="node_outline2133" fill="none" stroke="none" d="M679.5,29292.5h100a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-100a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2133" fill="black"><text id="kity_text_13323" text-rendering="inherit" font-size="12" dy=".8em" y="29293.700000047684" x="679.5">简单说说TreeMap</text></g></g><g id="minder_node2137"><g id="node_expander2131" style="cursor: pointer;" display="none"><path id="kity_path_26915" fill="white" stroke="gray" d="M800.5,29301.5A6,6,0,1,1,788.5,29301.5A6,6,0,1,1,800.5,29301.5"></path><path id="kity_path_26916" fill="none" stroke="gray"></path></g><path id="node_outline2132" fill="none" stroke="none" d="M805.5,29292.5h648a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-648a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2132" fill="black"><text id="kity_text_13321" text-rendering="inherit" font-size="12" dy=".8em" y="29293.700000047684" x="805.5">treemap是有序的key-value，通过红黑树实现，可以通过Comparator 进行排序。是线程非安全的。允许key value为null</text></g></g><g id="minder_node2138"><g id="node_expander2134" style="cursor: pointer;"><path id="kity_path_26924" fill="white" stroke="gray" d="M674.5,29327.5A6,6,0,1,1,662.5,29327.5A6,6,0,1,1,674.5,29327.5"></path><path id="kity_path_26925" fill="none" stroke="gray" d="M664,29327.5L673,29327.5"></path></g><path id="node_outline2135" fill="none" stroke="none" d="M679.5,29318.5h180a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-180a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2135" fill="black"><text id="kity_text_13327" text-rendering="inherit" font-size="12" dy=".8em" y="29319.700000047684" x="679.5">TreeMap和HashMap的区别说说</text></g></g><g id="minder_node2139"><g id="node_expander2133" style="cursor: pointer;" display="none"><path id="kity_path_26921" fill="white" stroke="gray" d="M880.5,29327.5A6,6,0,1,1,868.5,29327.5A6,6,0,1,1,880.5,29327.5"></path><path id="kity_path_26922" fill="none" stroke="gray"></path></g><path id="node_outline2134" fill="none" stroke="none" d="M885.5,29318.5h270a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-270a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2134" fill="black"><text id="kity_text_13325" text-rendering="inherit" font-size="12" dy=".8em" y="29319.700000047684" x="885.5">需要对一个有序的key集合进行遍历,就用TreeMap,</text></g></g><g id="minder_node2140"><g id="node_expander2135" style="cursor: pointer;" display="none"><path id="kity_path_26927" fill="white" stroke="gray" d="M674.5,29353.5A6,6,0,1,1,662.5,29353.5A6,6,0,1,1,674.5,29353.5"></path><path id="kity_path_26928" fill="none" stroke="gray"></path></g><path id="node_outline2136" fill="none" stroke="none" d="M679.5,29344.5h159a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-159a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2136" fill="black"><text id="kity_text_13329" text-rendering="inherit" font-size="12" dy=".8em" y="29345.700000047684" x="679.5">了解TreeMap的时间复杂度吗</text></g></g><g id="minder_node2141"><g id="node_expander2147" style="cursor: pointer;"><path id="kity_path_26963" fill="white" stroke="gray" d="M544.5,29431.5A6,6,0,1,1,532.5,29431.5A6,6,0,1,1,544.5,29431.5"></path><path id="kity_path_26964" fill="none" stroke="gray" d="M534,29431.5L543,29431.5"></path></g><path id="node_outline2148" fill="none" stroke="none" d="M549.5,29422.5h17a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-17a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2148" fill="black"><text id="kity_text_13353" text-rendering="inherit" font-size="12" dy=".8em" y="29423.700000047684" x="549.5">set</text></g></g><g id="minder_node2142"><g id="node_expander2139" style="cursor: pointer;"><path id="kity_path_26939" fill="white" stroke="gray" d="M587.5,29379.5A6,6,0,1,1,575.5,29379.5A6,6,0,1,1,587.5,29379.5"></path><path id="kity_path_26940" fill="none" stroke="gray" d="M577,29379.5L586,29379.5"></path></g><path id="node_outline2140" fill="none" stroke="none" d="M592.5,29370.5h42a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-42a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2140" fill="black"><text id="kity_text_13337" text-rendering="inherit" font-size="12" dy=".8em" y="29371.700000047684" x="592.5">说说set</text></g></g><g id="minder_node2143"><g id="node_expander2138" style="cursor: pointer;" display="none"><path id="kity_path_26936" fill="white" stroke="gray" d="M655.5,29379.5A6,6,0,1,1,643.5,29379.5A6,6,0,1,1,655.5,29379.5"></path><path id="kity_path_26937" fill="none" stroke="gray"></path></g><path id="node_outline2139" fill="none" stroke="none" d="M660.5,29370.5h231a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-231a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2139" fill="black"><text id="kity_text_13335" text-rendering="inherit" font-size="12" dy=".8em" y="29371.700000047684" x="660.5">set是内部有序的并且唯一，可以接收null值</text></g></g><g id="minder_node2144"><g id="node_expander2141" style="cursor: pointer;"><path id="kity_path_26945" fill="white" stroke="gray" d="M587.5,29405.5A6,6,0,1,1,575.5,29405.5A6,6,0,1,1,587.5,29405.5"></path><path id="kity_path_26946" fill="none" stroke="gray" d="M577,29405.5L586,29405.5"></path></g><path id="node_outline2142" fill="none" stroke="none" d="M592.5,29396.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2142" fill="black"><text id="kity_text_13341" text-rendering="inherit" font-size="12" dy=".8em" y="29397.700000047684" x="592.5">知道HashSet吗，说说</text></g></g><g id="minder_node2145"><g id="node_expander2140" style="cursor: pointer;" display="none"><path id="kity_path_26942" fill="white" stroke="gray" d="M734.5,29405.5A6,6,0,1,1,722.5,29405.5A6,6,0,1,1,734.5,29405.5"></path><path id="kity_path_26943" fill="none" stroke="gray"></path></g><path id="node_outline2141" fill="none" stroke="none" d="M739.5,29396.5h509a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-509a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2141" fill="black"><text id="kity_text_13339" text-rendering="inherit" font-size="12" dy=".8em" y="29397.700000047684" x="739.5">hashmap底层是在hashmap上操作的，&#xa0; 值统一为present，方法基本都是调用hashmap的方法</text></g></g><g id="minder_node2146"><g id="node_expander2143" style="cursor: pointer;"><path id="kity_path_26951" fill="white" stroke="gray" d="M587.5,29431.5A6,6,0,1,1,575.5,29431.5A6,6,0,1,1,587.5,29431.5"></path><path id="kity_path_26952" fill="none" stroke="gray" d="M577,29431.5L586,29431.5"></path></g><path id="node_outline2144" fill="none" stroke="none" d="M592.5,29422.5h155a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-155a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2144" fill="black"><text id="kity_text_13345" text-rendering="inherit" font-size="12" dy=".8em" y="29423.700000047684" x="592.5">HashSet是怎么保证不重复的</text></g></g><g id="minder_node2147"><g id="node_expander2142" style="cursor: pointer;" display="none"><path id="kity_path_26948" fill="white" stroke="gray" d="M768.5,29431.5A6,6,0,1,1,756.5,29431.5A6,6,0,1,1,768.5,29431.5"></path><path id="kity_path_26949" fill="none" stroke="gray"></path></g><path id="node_outline2143" fill="none" stroke="none" d="M773.5,29422.5h402a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-402a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2143" fill="black"><text id="kity_text_13343" text-rendering="inherit" font-size="12" dy=".8em" y="29423.700000047684" x="773.5">hashset的add方法 的key是hashmap的key，而hashmap的key不允许重复</text></g></g><g id="minder_node2148"><g id="node_expander2145" style="cursor: pointer;"><path id="kity_path_26957" fill="white" stroke="gray" d="M587.5,29457.5A6,6,0,1,1,575.5,29457.5A6,6,0,1,1,587.5,29457.5"></path><path id="kity_path_26958" fill="none" stroke="gray" d="M577,29457.5L586,29457.5"></path></g><path id="node_outline2146" fill="none" stroke="none" d="M592.5,29448.5h143a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-143a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2146" fill="black"><text id="kity_text_13349" text-rendering="inherit" font-size="12" dy=".8em" y="29449.700000047684" x="592.5">HashSet是怎么检测重复的</text></g></g><g id="minder_node2149"><g id="node_expander2144" style="cursor: pointer;" display="none"><path id="kity_path_26954" fill="white" stroke="gray" d="M756.5,29457.5A6,6,0,1,1,744.5,29457.5A6,6,0,1,1,756.5,29457.5"></path><path id="kity_path_26955" fill="none" stroke="gray"></path></g><path id="node_outline2145" fill="none" stroke="none" d="M761.5,29448.5h125a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-125a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2145" fill="black"><text id="kity_text_13347" text-rendering="inherit" font-size="12" dy=".8em" y="29449.700000047684" x="761.5">比较hash，比较equals</text></g></g><g id="minder_node2150"><g id="node_expander2146" style="cursor: pointer;" display="none"><path id="kity_path_26960" fill="white" stroke="gray" d="M587.5,29483.5A6,6,0,1,1,575.5,29483.5A6,6,0,1,1,587.5,29483.5"></path><path id="kity_path_26961" fill="none" stroke="gray"></path></g><path id="node_outline2147" fill="none" stroke="none" d="M592.5,29474.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2147" fill="black"><text id="kity_text_13351" text-rendering="inherit" font-size="12" dy=".8em" y="29475.700000047684" x="592.5">LinkedHashSet知道吗</text></g></g><g id="minder_node2151"><g id="node_expander2156" style="cursor: pointer;"><path id="kity_path_26990" fill="white" stroke="gray" d="M544.5,29561.5A6,6,0,1,1,532.5,29561.5A6,6,0,1,1,544.5,29561.5"></path><path id="kity_path_26991" fill="none" stroke="gray" d="M534,29561.5L543,29561.5"></path></g><path id="node_outline2157" fill="none" stroke="none" d="M549.5,29552.5h56a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-56a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2157" fill="black"><text id="kity_text_13371" text-rendering="inherit" font-size="12" dy=".8em" y="29553.700000047684" x="549.5">collection</text></g></g><g id="minder_node2152"><g id="node_expander2149" style="cursor: pointer;"><path id="kity_path_26969" fill="white" stroke="gray" d="M626.5,29509.5A6,6,0,1,1,614.5,29509.5A6,6,0,1,1,626.5,29509.5"></path><path id="kity_path_26970" fill="none" stroke="gray" d="M616,29509.5L625,29509.5"></path></g><path id="node_outline2150" fill="none" stroke="none" d="M631.5,29500.5h189a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-189a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2150" fill="black"><text id="kity_text_13357" text-rendering="inherit" font-size="12" dy=".8em" y="29501.700000047684" x="631.5">知道collection中有哪些设计模式吗</text></g></g><g id="minder_node2153"><g id="node_expander2148" style="cursor: pointer;" display="none"><path id="kity_path_26966" fill="white" stroke="gray" d="M841.5,29509.5A6,6,0,1,1,829.5,29509.5A6,6,0,1,1,841.5,29509.5"></path><path id="kity_path_26967" fill="none" stroke="gray"></path></g><path id="node_outline2149" fill="none" stroke="none" d="M846.5,29500.5h547a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-547a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2149" fill="black"><text id="kity_text_13355" text-rendering="inherit" font-size="12" dy=".8em" y="29501.700000047684" x="846.5">使用了迭代器模式和适配器模式，collection继承了Iterable 接口。Arrays.asList参数为泛型的变长参数</text></g></g><g id="minder_node2154"><g id="node_expander2150" style="cursor: pointer;" display="none"><path id="kity_path_26972" fill="white" stroke="gray" d="M626.5,29535.5A6,6,0,1,1,614.5,29535.5A6,6,0,1,1,626.5,29535.5"></path><path id="kity_path_26973" fill="none" stroke="gray"></path></g><path id="node_outline2151" fill="none" stroke="none" d="M631.5,29526.5h245a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-245a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2151" fill="black"><text id="kity_text_13359" text-rendering="inherit" font-size="12" dy=".8em" y="29527.700000047684" x="631.5">那你说说comparable和compator的区别说说</text></g></g><g id="minder_node2155"><g id="node_expander2152" style="cursor: pointer;"><path id="kity_path_26978" fill="white" stroke="gray" d="M626.5,29561.5A6,6,0,1,1,614.5,29561.5A6,6,0,1,1,626.5,29561.5"></path><path id="kity_path_26979" fill="none" stroke="gray" d="M616,29561.5L625,29561.5"></path></g><path id="node_outline2153" fill="none" stroke="none" d="M631.5,29552.5h97a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-97a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2153" fill="black"><text id="kity_text_13363" text-rendering="inherit" font-size="12" dy=".8em" y="29553.700000047684" x="631.5">怎么选择集合呢，</text></g></g><g id="minder_node2156"><g id="node_expander2151" style="cursor: pointer;" display="none"><path id="kity_path_26975" fill="white" stroke="gray" d="M749.5,29561.5A6,6,0,1,1,737.5,29561.5A6,6,0,1,1,749.5,29561.5"></path><path id="kity_path_26976" fill="none" stroke="gray"></path></g><path id="node_outline2152" fill="none" stroke="none" d="M754.5,29552.5h158a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-158a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2152" fill="black"><text id="kity_text_13361" text-rendering="inherit" font-size="12" dy=".8em" y="29553.700000047684" x="754.5">根据集合接口的特点来做选择</text></g></g><g id="minder_node2157"><g id="node_expander2154" style="cursor: pointer;"><path id="kity_path_26984" fill="white" stroke="gray" d="M626.5,29587.5A6,6,0,1,1,614.5,29587.5A6,6,0,1,1,626.5,29587.5"></path><path id="kity_path_26985" fill="none" stroke="gray" d="M616,29587.5L625,29587.5"></path></g><path id="node_outline2155" fill="none" stroke="none" d="M631.5,29578.5h98a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-98a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2155" fill="black"><text id="kity_text_13367" text-rendering="inherit" font-size="12" dy=".8em" y="29579.700000047684" x="631.5">如何遍历删除元素</text></g></g><g id="minder_node2158"><g id="node_expander2153" style="cursor: pointer;" display="none"><path id="kity_path_26981" fill="white" stroke="gray" d="M750.5,29587.5A6,6,0,1,1,738.5,29587.5A6,6,0,1,1,750.5,29587.5"></path><path id="kity_path_26982" fill="none" stroke="gray"></path></g><path id="node_outline2154" fill="none" stroke="none" d="M755.5,29578.5h141a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-141a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2154" fill="black"><text id="kity_text_13365" text-rendering="inherit" font-size="12" dy=".8em" y="29579.700000047684" x="755.5">使用迭代器的remove方法</text></g></g><g id="minder_node2159"><g id="node_expander2155" style="cursor: pointer;" display="none"><path id="kity_path_26987" fill="white" stroke="gray" d="M626.5,29613.5A6,6,0,1,1,614.5,29613.5A6,6,0,1,1,626.5,29613.5"></path><path id="kity_path_26988" fill="none" stroke="gray"></path></g><path id="node_outline2156" fill="none" stroke="none" d="M631.5,29604.5h221a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-221a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2156" fill="black"><text id="kity_text_13369" text-rendering="inherit" font-size="12" dy=".8em" y="29605.700000047684" x="631.5">为什么往集合设置那么多元素没有被GC？</text></g></g><g id="minder_node2160"><g id="node_expander2207" style="cursor: pointer;"><path id="kity_path_27143" fill="white" stroke="gray" d="M492.5,30411.5A6,6,0,1,1,480.5,30411.5A6,6,0,1,1,492.5,30411.5"></path><path id="kity_path_27144" fill="none" stroke="gray" d="M482,30411.5L491,30411.5"></path></g><path id="node_outline2208" fill="none" stroke="rgb(61, 57, 96)" d="M497.5,30402.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z" stroke-width="3"></path><g id="node_text2208" fill="black"><text id="kity_text_13500" text-rendering="inherit" font-size="12" dy=".8em" y="30403.700000047684" x="497.5">网络编程</text></g></g><g id="minder_node2161"><g id="node_expander2206" style="cursor: pointer;"><path id="kity_path_27140" fill="white" stroke="gray" d="M567.5,30411.5A6,6,0,1,1,555.5,30411.5A6,6,0,1,1,567.5,30411.5"></path><path id="kity_path_27141" fill="none" stroke="gray" d="M557,30411.5L566,30411.5"></path></g><path id="node_outline2207" fill="none" stroke="none" d="M572.5,30402.5h38a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-38a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2207" fill="black"><text id="kity_text_13498" text-rendering="inherit" font-size="12" dy=".8em" y="30403.700000047684" x="572.5">socket</text></g></g><g id="minder_node2162"><g id="node_expander2191" style="cursor: pointer;"><path id="kity_path_27095" fill="white" stroke="gray" d="M631.5,30027.5A6,6,0,1,1,619.5,30027.5A6,6,0,1,1,631.5,30027.5"></path><path id="kity_path_27096" fill="none" stroke="gray" d="M621,30027.5L630,30027.5"></path></g><path id="node_outline2192" fill="none" stroke="none" d="M636.5,30018.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2192" fill="black"><text id="kity_text_13451" text-rendering="inherit" font-size="12" dy=".8em" y="30019.700000047684" x="636.5">基础</text></g></g><g id="minder_node2163"><g id="node_expander2159" style="cursor: pointer;"><path id="kity_path_26999" fill="white" stroke="gray" d="M682.5,29658.5A6,6,0,1,1,670.5,29658.5A6,6,0,1,1,682.5,29658.5"></path><path id="kity_path_27000" fill="none" stroke="gray" d="M672,29658.5L681,29658.5"></path></g><path id="node_outline2160" fill="none" stroke="none" d="M687.5,29649.5h99a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-99a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2160" fill="black"><text id="kity_text_13379" text-rendering="inherit" font-size="12" dy=".8em" y="29650.700000047684" x="687.5">说说socket是什么</text></g></g><g id="minder_node2164"><g id="node_expander2158" style="cursor: pointer;" display="none"><path id="kity_path_26996" fill="white" stroke="gray" d="M807.5,29658.5A6,6,0,1,1,795.5,29658.5A6,6,0,1,1,807.5,29658.5"></path><path id="kity_path_26997" fill="none" stroke="gray"></path></g><path id="node_outline2159" fill="none" stroke="none" d="M812.5,29631.5h851a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-851a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2159" fill="black"><text id="kity_text_13375" text-rendering="inherit" font-size="12" dy=".8em" y="29632.700000047684" x="812.5">1.socket就是网络通信的一种机制，两端都是socket。数据在网络中io传输</text><text id="kity_text_13376" text-rendering="inherit" font-size="12" dy=".8em" y="29650.700000047684" x="812.5">2.一个Socket由一个IP地址和一个端口号唯一确定。</text><text id="kity_text_13377" text-rendering="inherit" font-size="12" dy=".8em" y="29668.700000047684" x="812.5">3.socket连接就是所谓的长连接，客户端和服务器需要互相连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉的，但是有时候网络波动还是有可能的</text></g></g><g id="minder_node2165"><g id="node_expander2160" style="cursor: pointer;" display="none"><path id="kity_path_27002" fill="white" stroke="gray" d="M682.5,29702.5A6,6,0,1,1,670.5,29702.5A6,6,0,1,1,682.5,29702.5"></path><path id="kity_path_27003" fill="none" stroke="gray"></path></g><path id="node_outline2161" fill="none" stroke="none" d="M687.5,29693.5h181a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-181a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2161" fill="black"><text id="kity_text_13381" text-rendering="inherit" font-size="12" dy=".8em" y="29694.700000047684" x="687.5">网络socket连接过程是什么样的？</text></g></g><g id="minder_node2166"><g id="node_expander2162" style="cursor: pointer;"><path id="kity_path_27008" fill="white" stroke="gray" d="M682.5,29728.5A6,6,0,1,1,670.5,29728.5A6,6,0,1,1,682.5,29728.5"></path><path id="kity_path_27009" fill="none" stroke="gray" d="M672,29728.5L681,29728.5"></path></g><path id="node_outline2163" fill="none" stroke="none" d="M687.5,29719.5h98a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-98a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2163" fill="black"><text id="kity_text_13385" text-rendering="inherit" font-size="12" dy=".8em" y="29720.700000047684" x="687.5">socket常用的函数</text></g></g><g id="minder_node2167"><g id="node_expander2161" style="cursor: pointer;" display="none"><path id="kity_path_27005" fill="white" stroke="gray" d="M806.5,29728.5A6,6,0,1,1,794.5,29728.5A6,6,0,1,1,806.5,29728.5"></path><path id="kity_path_27006" fill="none" stroke="gray"></path></g><path id="node_outline2162" fill="none" stroke="none" d="M811.5,29719.5h569a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-569a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2162" fill="black"><text id="kity_text_13383" text-rendering="inherit" font-size="12" dy=".8em" y="29720.700000047684" x="811.5">客户端：socket()&#xa0; connect()&#xa0; &#xa0;write()&#xa0; read() close()。 服务端：多三个，分别是bind() accept() listen()。</text></g></g><g id="minder_node2168"><g id="node_expander2163" style="cursor: pointer;" display="none"><path id="kity_path_27011" fill="white" stroke="gray" d="M682.5,29754.5A6,6,0,1,1,670.5,29754.5A6,6,0,1,1,682.5,29754.5"></path><path id="kity_path_27012" fill="none" stroke="gray"></path></g><path id="node_outline2164" fill="none" stroke="none" d="M687.5,29745.5h97a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-97a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2164" fill="black"><text id="kity_text_13387" text-rendering="inherit" font-size="12" dy=".8em" y="29746.700000047684" x="687.5">socket有什么特点</text></g></g><g id="minder_node2169"><g id="node_expander2164" style="cursor: pointer;" display="none"><path id="kity_path_27014" fill="white" stroke="gray" d="M682.5,29780.5A6,6,0,1,1,670.5,29780.5A6,6,0,1,1,682.5,29780.5"></path><path id="kity_path_27015" fill="none" stroke="gray"></path></g><path id="node_outline2165" fill="none" stroke="none" d="M687.5,29771.5h122a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-122a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2165" fill="black"><text id="kity_text_13389" text-rendering="inherit" font-size="12" dy=".8em" y="29772.700000047684" x="687.5">websocket有什么特点</text></g></g><g id="minder_node2170"><g id="node_expander2166" style="cursor: pointer;"><path id="kity_path_27020" fill="white" stroke="gray" d="M682.5,29806.5A6,6,0,1,1,670.5,29806.5A6,6,0,1,1,682.5,29806.5"></path><path id="kity_path_27021" fill="none" stroke="gray" d="M672,29806.5L681,29806.5"></path></g><path id="node_outline2167" fill="none" stroke="none" d="M687.5,29797.5h174a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-174a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2167" fill="black"><text id="kity_text_13393" text-rendering="inherit" font-size="12" dy=".8em" y="29798.700000047684" x="687.5">那socket和WebSocket的区别呢</text></g></g><g id="minder_node2171"><g id="node_expander2165" style="cursor: pointer;" display="none"><path id="kity_path_27017" fill="white" stroke="gray" d="M882.5,29806.5A6,6,0,1,1,870.5,29806.5A6,6,0,1,1,882.5,29806.5"></path><path id="kity_path_27018" fill="none" stroke="gray"></path></g><path id="node_outline2166" fill="none" stroke="none" d="M887.5,29797.5h562a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-562a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2166" fill="black"><text id="kity_text_13391" text-rendering="inherit" font-size="12" dy=".8em" y="29798.700000047684" x="887.5">socket是TCP/IP协议上的一组接口，而WebSocket是他的实现，我们一般可以用WebSocket的API来实现</text></g></g><g id="minder_node2172"><g id="node_expander2167" style="cursor: pointer;" display="none"><path id="kity_path_27023" fill="white" stroke="gray" d="M682.5,29832.5A6,6,0,1,1,670.5,29832.5A6,6,0,1,1,682.5,29832.5"></path><path id="kity_path_27024" fill="none" stroke="gray"></path></g><path id="node_outline2168" fill="none" stroke="none" d="M687.5,29823.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2168" fill="black"><text id="kity_text_13395" text-rendering="inherit" font-size="12" dy=".8em" y="29824.700000047684" x="687.5">socker和serversocker区别</text></g></g><g id="minder_node2173"><g id="node_expander2169" style="cursor: pointer;"><path id="kity_path_27029" fill="white" stroke="gray" d="M682.5,29858.5A6,6,0,1,1,670.5,29858.5A6,6,0,1,1,682.5,29858.5"></path><path id="kity_path_27030" fill="none" stroke="gray" d="M672,29858.5L681,29858.5"></path></g><path id="node_outline2170" fill="none" stroke="none" d="M687.5,29849.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2170" fill="black"><text id="kity_text_13399" text-rendering="inherit" font-size="12" dy=".8em" y="29850.700000047684" x="687.5">http和websocket的区别呢</text></g></g><g id="minder_node2174"><g id="node_expander2168" style="cursor: pointer;" display="none"><path id="kity_path_27026" fill="white" stroke="gray" d="M853.5,29858.5A6,6,0,1,1,841.5,29858.5A6,6,0,1,1,853.5,29858.5"></path><path id="kity_path_27027" fill="none" stroke="gray"></path></g><path id="node_outline2169" fill="none" stroke="none" d="M858.5,29849.5h887a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-887a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2169" fill="black"><text id="kity_text_13397" text-rendering="inherit" font-size="12" dy=".8em" y="29850.700000047684" x="858.5">http是短连接，请求之后是会关闭连接，下次请求重新建立连接。websocket是长连接，只需要初始化一次连接就可以建立长时间的通信，后续通信都是在TCP连接建立</text></g></g><g id="minder_node2175"><g id="node_expander2172" style="cursor: pointer;"><path id="kity_path_27038" fill="white" stroke="gray" d="M682.5,29911.5A6,6,0,1,1,670.5,29911.5A6,6,0,1,1,682.5,29911.5"></path><path id="kity_path_27039" fill="none" stroke="gray" d="M672,29911.5L681,29911.5"></path></g><path id="node_outline2173" fill="none" stroke="none" d="M687.5,29893.5h169a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-169a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2173" fill="black"><text id="kity_text_13408" text-rendering="inherit" font-size="12" dy=".8em" y="29894.700000047684" x="687.5">全双工，半双工和半工的区别？</text><text id="kity_text_13409" text-rendering="inherit" font-size="12" dy=".8em" y="29912.700000047684" x="687.5">socket?</text></g></g><g id="minder_node2176"><g id="node_expander2171" style="cursor: pointer;"><path id="kity_path_27035" fill="white" stroke="gray" d="M877.5,29911.5A6,6,0,1,1,865.5,29911.5A6,6,0,1,1,877.5,29911.5"></path><path id="kity_path_27036" fill="none" stroke="gray" d="M867,29911.5L876,29911.5"></path></g><path id="node_outline2172" fill="none" stroke="none" d="M882.5,29875.5h272a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-272a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text2172" fill="black"><text id="kity_text_13403" text-rendering="inherit" font-size="12" dy=".8em" y="29876.700000047684" x="882.5">TCP全双工，所以需要执行FIN两次。socker全双工</text><text id="kity_text_13404" text-rendering="inherit" font-size="12" dy=".8em" y="29894.700000047684" x="882.5">全双工：可以同时通信 同时接收发送</text><text id="kity_text_13405" text-rendering="inherit" font-size="12" dy=".8em" y="29912.700000047684" x="882.5">半双工：可以同时通信 但是是一来一回</text><text id="kity_text_13406" text-rendering="inherit" font-size="12" dy=".8em" y="29930.700000047684" x="882.5">单工： 单行道 只能A-&gt;B</text></g></g><g id="minder_node2177"><g id="node_expander2170" style="cursor: pointer;" display="none"><path id="kity_path_27032" fill="white" stroke="gray" d="M1175.5,29911.5A6,6,0,1,1,1163.5,29911.5A6,6,0,1,1,1175.5,29911.5"></path><path id="kity_path_27033" fill="none" stroke="gray"></path></g><path id="node_outline2171" fill="none" stroke="none" d="M1180.5,29902.5h374a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-374a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2171" fill="black"><text id="kity_text_13401" text-rendering="inherit" font-size="12" dy=".8em" y="29903.700000047684" x="1180.5">https://blog.csdn.net/weixin_39203501/article/details/108559302</text></g></g><g id="minder_node2178"><g id="node_expander2176" style="cursor: pointer;"><path id="kity_path_27050" fill="white" stroke="gray" d="M682.5,30066.5A6,6,0,1,1,670.5,30066.5A6,6,0,1,1,682.5,30066.5"></path><path id="kity_path_27051" fill="none" stroke="gray" d="M672,30066.5L681,30066.5"></path></g><path id="node_outline2177" fill="none" stroke="none" d="M687.5,30057.5h206a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-206a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2177" fill="black"><text id="kity_text_13417" text-rendering="inherit" font-size="12" dy=".8em" y="30058.700000047684" x="687.5">java实现socket连接的过程是什么样的</text></g></g><g id="minder_node2179"><g id="node_expander2175" style="cursor: pointer;"><path id="kity_path_27047" fill="white" stroke="gray" d="M914.5,30066.5A6,6,0,1,1,902.5,30066.5A6,6,0,1,1,914.5,30066.5"></path><path id="kity_path_27048" fill="none" stroke="gray" d="M904,30066.5L913,30066.5"></path></g><path id="node_outline2176" fill="none" stroke="none" d="M919.5,30057.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2176" fill="black"><text id="kity_text_13415" text-rendering="inherit" font-size="12" dy=".8em" y="30058.700000047684" x="919.5">分支主题</text></g></g><g id="minder_node2180"><g id="node_expander2174" style="cursor: pointer;"><path id="kity_path_27044" fill="white" stroke="gray" d="M990.5,30067A6,6,0,1,1,978.5,30067A6,6,0,1,1,990.5,30067"></path><path id="kity_path_27045" fill="none" stroke="gray" d="M980,30067L989,30067"></path></g><path id="node_outline2175" fill="none" stroke="none" d="M995.5,29955.5h196a5,5,0,0,1,5,5v213a5,5,0,0,1,-5,5h-196a5,5,0,0,1,-5,-5v-213a5,5,0,0,1,5,-5z"></path><g id="node_text2175" fill="black"><text id="kity_text_13413" text-rendering="inherit" font-size="12" dy=".8em" y="30161.700000047684" x="1068.5">分支主题</text></g><image id="kity_image_17076" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210430181951.png" x="995.5" y="29958.5" width="196" height="200"></image></g><g id="minder_node2181"><g id="node_expander2173" style="cursor: pointer;" display="none"><path id="kity_path_27041" fill="white" stroke="gray" d="M1212.5,30067.5A6,6,0,1,1,1200.5,30067.5A6,6,0,1,1,1212.5,30067.5"></path><path id="kity_path_27042" fill="none" stroke="gray"></path></g><path id="node_outline2174" fill="none" stroke="none" d="M1217.5,30058.5h259a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-259a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2174" fill="black"><text id="kity_text_13411" text-rendering="inherit" font-size="12" dy=".8em" y="30059.700000047684" x="1217.5">https://juejin.cn/post/6844903593808494600</text></g></g><g id="minder_node2182"><g id="node_expander2178" style="cursor: pointer;"><path id="kity_path_27056" fill="white" stroke="gray" d="M682.5,30195.5A6,6,0,1,1,670.5,30195.5A6,6,0,1,1,682.5,30195.5"></path><path id="kity_path_27057" fill="none" stroke="gray" d="M672,30195.5L681,30195.5"></path></g><path id="node_outline2179" fill="none" stroke="none" d="M687.5,30186.5h204a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-204a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2179" fill="black"><text id="kity_text_13421" text-rendering="inherit" font-size="12" dy=".8em" y="30187.700000047684" x="687.5">继续上面的问题，在accept()做了什么</text></g></g><g id="minder_node2183"><g id="node_expander2177" style="cursor: pointer;" display="none"><path id="kity_path_27053" fill="white" stroke="gray" d="M912.5,30195.5A6,6,0,1,1,900.5,30195.5A6,6,0,1,1,912.5,30195.5"></path><path id="kity_path_27054" fill="none" stroke="gray"></path></g><path id="node_outline2178" fill="none" stroke="none" d="M917.5,30186.5h119a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-119a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2178" fill="black"><text id="kity_text_13419" text-rendering="inherit" font-size="12" dy=".8em" y="30187.700000047684" x="917.5">1.阻塞等待客户端连接</text></g></g><g id="minder_node2184"><g id="node_expander2180" style="cursor: pointer;"><path id="kity_path_27062" fill="white" stroke="gray" d="M682.5,30221.5A6,6,0,1,1,670.5,30221.5A6,6,0,1,1,682.5,30221.5"></path><path id="kity_path_27063" fill="none" stroke="gray" d="M672,30221.5L681,30221.5"></path></g><path id="node_outline2181" fill="none" stroke="none" d="M687.5,30212.5h320a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-320a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2181" fill="black"><text id="kity_text_13425" text-rendering="inherit" font-size="12" dy=".8em" y="30213.700000047684" x="687.5">tcp是二进制报文，接收方怎么知道读到的是一个完整的报文</text></g></g><g id="minder_node2185"><g id="node_expander2179" style="cursor: pointer;" display="none"><path id="kity_path_27059" fill="white" stroke="gray" d="M1028.5,30221.5A6,6,0,1,1,1016.5,30221.5A6,6,0,1,1,1028.5,30221.5"></path><path id="kity_path_27060" fill="none" stroke="gray"></path></g><path id="node_outline2180" fill="none" stroke="none" d="M1033.5,30212.5h201a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-201a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2180" fill="black"><text id="kity_text_13423" text-rendering="inherit" font-size="12" dy=".8em" y="30213.700000047684" x="1033.5">1.报文头长度标识符，2.报文尾描述符</text></g></g><g id="minder_node2186"><g id="node_expander2182" style="cursor: pointer;"><path id="kity_path_27068" fill="white" stroke="gray" d="M682.5,30265.5A6,6,0,1,1,670.5,30265.5A6,6,0,1,1,682.5,30265.5"></path><path id="kity_path_27069" fill="none" stroke="gray" d="M672,30265.5L681,30265.5"></path></g><path id="node_outline2183" fill="none" stroke="none" d="M687.5,30256.5h140a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-140a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2183" fill="black"><text id="kity_text_13431" text-rendering="inherit" font-size="12" dy=".8em" y="30257.700000047684" x="687.5">socket基于tcp的通信过程</text></g></g><g id="minder_node2187"><g id="node_expander2181" style="cursor: pointer;" display="none"><path id="kity_path_27065" fill="white" stroke="gray" d="M848.5,30265.5A6,6,0,1,1,836.5,30265.5A6,6,0,1,1,848.5,30265.5"></path><path id="kity_path_27066" fill="none" stroke="gray"></path></g><path id="node_outline2182" fill="none" stroke="none" d="M853.5,30238.5h797a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-797a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2182" fill="black"><text id="kity_text_13427" text-rendering="inherit" font-size="12" dy=".8em" y="30239.700000047684" x="853.5">1.服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。</text><text id="kity_text_13428" text-rendering="inherit" font-size="12" dy=".8em" y="30257.700000047684" x="853.5">2.客户端初始化一个Socket，然后连接服务器(connect)</text><text id="kity_text_13429" text-rendering="inherit" font-size="12" dy=".8em" y="30275.700000047684" x="853.5">如果连接成功 客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</text></g></g><g id="minder_node2188"><g id="node_expander2185" style="cursor: pointer;"><path id="kity_path_27077" fill="white" stroke="gray" d="M682.5,30309.5A6,6,0,1,1,670.5,30309.5A6,6,0,1,1,682.5,30309.5"></path><path id="kity_path_27078" fill="none" stroke="gray" d="M672,30309.5L681,30309.5"></path></g><path id="node_outline2186" fill="none" stroke="none" d="M687.5,30300.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2186" fill="black"><text id="kity_text_13437" text-rendering="inherit" font-size="12" dy=".8em" y="30301.700000047684" x="687.5">socket基于udp的通信过程</text></g></g><g id="minder_node2189"><g id="node_expander2184" style="cursor: pointer;"><path id="kity_path_27074" fill="white" stroke="gray" d="M853.5,30309.5A6,6,0,1,1,841.5,30309.5A6,6,0,1,1,853.5,30309.5"></path><path id="kity_path_27075" fill="none" stroke="gray" d="M843,30309.5L852,30309.5"></path></g><path id="node_outline2185" fill="none" stroke="none" d="M858.5,30300.5h377a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-377a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2185" fill="black"><text id="kity_text_13435" text-rendering="inherit" font-size="12" dy=".8em" y="30301.700000047684" x="858.5">1.和tcp是一样的流程，只是服务端和客户端的socker都是基于udp协议</text></g></g><g id="minder_node2190"><g id="node_expander2183" style="cursor: pointer;" display="none"><path id="kity_path_27071" fill="white" stroke="gray" d="M1256.5,30309.5A6,6,0,1,1,1244.5,30309.5A6,6,0,1,1,1256.5,30309.5"></path><path id="kity_path_27072" fill="none" stroke="gray"></path></g><path id="node_outline2184" fill="none" stroke="none" d="M1261.5,30300.5h333a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2184" fill="black"><text id="kity_text_13433" text-rendering="inherit" font-size="12" dy=".8em" y="30301.700000047684" x="1261.5">https://juejin.cn/post/6844904125692379143#heading-36</text></g></g><g id="minder_node2191"><g id="node_expander2188" style="cursor: pointer;"><path id="kity_path_27086" fill="white" stroke="gray" d="M682.5,30353.5A6,6,0,1,1,670.5,30353.5A6,6,0,1,1,682.5,30353.5"></path><path id="kity_path_27087" fill="none" stroke="gray" d="M672,30353.5L681,30353.5"></path></g><path id="node_outline2189" fill="none" stroke="none" d="M687.5,30344.5h179a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-179a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2189" fill="black"><text id="kity_text_13445" text-rendering="inherit" font-size="12" dy=".8em" y="30345.700000047684" x="687.5">短/长轮询和WebSocket的优缺点</text></g></g><g id="minder_node2192"><g id="node_expander2187" style="cursor: pointer;"><path id="kity_path_27083" fill="white" stroke="gray" d="M887.5,30353.5A6,6,0,1,1,875.5,30353.5A6,6,0,1,1,887.5,30353.5"></path><path id="kity_path_27084" fill="none" stroke="gray" d="M877,30353.5L886,30353.5"></path></g><path id="node_outline2188" fill="none" stroke="none" d="M892.5,30326.5h951a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-951a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2188" fill="black"><text id="kity_text_13441" text-rendering="inherit" font-size="12" dy=".8em" y="30327.700000047684" x="892.5">1.短轮询：定时间隔指定时间发送http request 等待服务器响应。优点：适于小型应用。缺点：浪费带宽和服务器资源，请求中有大半是无用</text><text id="kity_text_13442" text-rendering="inherit" font-size="12" dy=".8em" y="30345.700000047684" x="892.5">2.长轮询：服务端HOLD住请求,会占用大量服务资源;Http请求的请求头每次都需要带很多信息,占用很多网络资源；无法解决服务器端主动发送消息的问题；</text><text id="kity_text_13443" text-rendering="inherit" font-size="12" dy=".8em" y="30363.700000047684" x="892.5">3.WebSocket：基于TCP的全双工通信；服务器端可以主动向客户端推送信息；一个客户端建立一条websocket连接即可,不需要创建大量HTTP连接请求,减少服务端压力和网络带宽</text></g></g><g id="minder_node2193"><g id="node_expander2186" style="cursor: pointer;" display="none"><path id="kity_path_27080" fill="white" stroke="gray" d="M1864.5,30353.5A6,6,0,1,1,1852.5,30353.5A6,6,0,1,1,1864.5,30353.5"></path><path id="kity_path_27081" fill="none" stroke="gray"></path></g><path id="node_outline2187" fill="none" stroke="none" d="M1869.5,30344.5h343a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-343a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2187" fill="black"><text id="kity_text_13439" text-rendering="inherit" font-size="12" dy=".8em" y="30345.700000047684" x="1869.5">https://www.dazhuanlan.com/2019/11/17/5dd03c3b8926e/</text></g></g><g id="minder_node2194"><g id="node_expander2190" style="cursor: pointer;"><path id="kity_path_27092" fill="white" stroke="gray" d="M682.5,30397.5A6,6,0,1,1,670.5,30397.5A6,6,0,1,1,682.5,30397.5"></path><path id="kity_path_27093" fill="none" stroke="gray" d="M672,30397.5L681,30397.5"></path></g><path id="node_outline2191" fill="none" stroke="none" d="M687.5,30388.5h34a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-34a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2191" fill="black"><text id="kity_text_13449" text-rendering="inherit" font-size="12" dy=".8em" y="30389.700000047684" x="687.5">jsonp</text></g></g><g id="minder_node2195"><g id="node_expander2189" style="cursor: pointer;" display="none"><path id="kity_path_27089" fill="white" stroke="gray" d="M742.5,30397.5A6,6,0,1,1,730.5,30397.5A6,6,0,1,1,742.5,30397.5"></path><path id="kity_path_27090" fill="none" stroke="gray"></path></g><path id="node_outline2190" fill="none" stroke="none" d="M747.5,30388.5h268a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-268a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2190" fill="black"><text id="kity_text_13447" text-rendering="inherit" font-size="12" dy=".8em" y="30389.700000047684" x="747.5">https://www.runoob.com/json/json-jsonp.html</text></g></g><g id="minder_node2196"><g id="node_expander2192" style="cursor: pointer;" display="none"><path id="kity_path_27098" fill="white" stroke="gray" d="M631.5,30422.5A6,6,0,1,1,619.5,30422.5A6,6,0,1,1,631.5,30422.5"></path><path id="kity_path_27099" fill="none" stroke="gray"></path></g><path id="node_outline2193" fill="none" stroke="none" d="M636.5,30413.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2193" fill="black"><text id="kity_text_13453" text-rendering="inherit" font-size="12" dy=".8em" y="30414.700000047684" x="636.5">进阶</text></g></g><g id="minder_node2197"><g id="node_expander2203" style="cursor: pointer;"><path id="kity_path_27131" fill="white" stroke="gray" d="M631.5,30611.5A6,6,0,1,1,619.5,30611.5A6,6,0,1,1,631.5,30611.5"></path><path id="kity_path_27132" fill="none" stroke="gray" d="M621,30611.5L630,30611.5"></path></g><path id="node_outline2204" fill="none" stroke="none" d="M636.5,30602.5h84a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-84a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2204" fill="black"><text id="kity_text_13489" text-rendering="inherit" font-size="12" dy=".8em" y="30603.700000047684" x="636.5">问题处理和场景</text></g></g><g id="minder_node2198"><g id="node_expander2196" style="cursor: pointer;"><path id="kity_path_27110" fill="white" stroke="gray" d="M741.5,30489.5A6,6,0,1,1,729.5,30489.5A6,6,0,1,1,741.5,30489.5"></path><path id="kity_path_27111" fill="none" stroke="gray" d="M731,30489.5L740,30489.5"></path></g><path id="node_outline2197" fill="none" stroke="none" d="M746.5,30480.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2197" fill="black"><text id="kity_text_13464" text-rendering="inherit" font-size="12" dy=".8em" y="30481.700000047684" x="746.5">socket通信分包，粘包处理？</text></g></g><g id="minder_node2199"><g id="node_expander2193" style="cursor: pointer;" display="none"><path id="kity_path_27101" fill="white" stroke="gray" d="M924.5,30467.5A6,6,0,1,1,912.5,30467.5A6,6,0,1,1,924.5,30467.5"></path><path id="kity_path_27102" fill="none" stroke="gray"></path></g><path id="node_outline2194" fill="none" stroke="none" d="M929.5,30440.5h341a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-341a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2194" fill="black"><text id="kity_text_13455" text-rendering="inherit" font-size="12" dy=".8em" y="30441.700000047684" x="929.5">https://www.cnblogs.com/yxh168/articles/9033311.html</text><text id="kity_text_13456" text-rendering="inherit" font-size="12" dy=".8em" y="30459.700000047684" x="929.5">https://blog.csdn.net/yqj234/article/details/51729242</text><text id="kity_text_13457" text-rendering="inherit" font-size="12" dy=".8em" y="30477.700000047684" x="929.5">https://blog.csdn.net/Double2hao/article/details/83211334</text></g></g><g id="minder_node2200"><g id="node_expander2195" style="cursor: pointer;"><path id="kity_path_27107" fill="white" stroke="gray" d="M924.5,30520.5A6,6,0,1,1,912.5,30520.5A6,6,0,1,1,924.5,30520.5"></path><path id="kity_path_27108" fill="none" stroke="gray" d="M914,30520.5L923,30520.5"></path></g><path id="node_outline2196" fill="none" stroke="none" d="M929.5,30502.5h646a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-646a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2196" fill="black"><text id="kity_text_13461" text-rendering="inherit" font-size="12" dy=".8em" y="30503.700000047684" x="929.5">1.使用一些特殊的符号来标记一次发送完成，服务端只要读到对应的符号就可以完成一次读取，然后进行相关的处理操作。</text><text id="kity_text_13462" text-rendering="inherit" font-size="12" dy=".8em" y="30521.700000047684" x="929.5">2.先将消息的长度发送出去，当服务端知道消息的长度后，就能够完成一次消息的接收了。比如说前几个表明报文长度</text></g></g><g id="minder_node2201"><g id="node_expander2194" style="cursor: pointer;" display="none"><path id="kity_path_27104" fill="white" stroke="gray" d="M1596.5,30520.5A6,6,0,1,1,1584.5,30520.5A6,6,0,1,1,1596.5,30520.5"></path><path id="kity_path_27105" fill="none" stroke="gray"></path></g><path id="node_outline2195" fill="none" stroke="none" d="M1601.5,30511.5h326a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2195" fill="black"><text id="kity_text_13459" text-rendering="inherit" font-size="12" dy=".8em" y="30512.700000047684" x="1601.5">https://juejin.cn/post/6844903593808494600#heading-5</text></g></g><g id="minder_node2202"><g id="node_expander2199" style="cursor: pointer;"><path id="kity_path_27119" fill="white" stroke="gray" d="M741.5,30627.5A6,6,0,1,1,729.5,30627.5A6,6,0,1,1,741.5,30627.5"></path><path id="kity_path_27120" fill="none" stroke="gray" d="M731,30627.5L740,30627.5"></path></g><path id="node_outline2200" fill="none" stroke="none" d="M746.5,30618.5h181a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-181a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2200" fill="black"><text id="kity_text_13480" text-rendering="inherit" font-size="12" dy=".8em" y="30619.700000047684" x="746.5">socket通信连接异常断开的处理。</text></g></g><g id="minder_node2203"><g id="node_expander2198" style="cursor: pointer;"><path id="kity_path_27116" fill="white" stroke="gray" d="M948.5,30627.5A6,6,0,1,1,936.5,30627.5A6,6,0,1,1,948.5,30627.5"></path><path id="kity_path_27117" fill="none" stroke="gray" d="M938,30627.5L947,30627.5"></path></g><path id="node_outline2199" fill="none" stroke="none" d="M953.5,30546.5h822a5,5,0,0,1,5,5v152a5,5,0,0,1,-5,5h-822a5,5,0,0,1,-5,-5v-152a5,5,0,0,1,5,-5z"></path><g id="node_text2199" fill="black"><text id="kity_text_13470" text-rendering="inherit" font-size="12" dy=".8em" y="30547.700000047684" x="953.5">socket是长连接</text><text id="kity_text_13471" text-rendering="inherit" font-size="12" dy=".8em" y="30565.700000047684" x="953.5">当socket连接成功建立后，如果中途发生异常导致其中一方断开连接，此时另一方是无法发现的，只有在再次尝试发送/接收消息才会因为抛出异常而退出。</text><text id="kity_text_13472" text-rendering="inherit" font-size="12" dy=".8em" y="30583.700000047684" x="953.5">1.定时发送心跳包：对于实时性要求很高的服务，保证连接随时可用的最常见方法就是定时发送心跳包，来检测连接是否正常。</text><text id="kity_text_13473" text-rendering="inherit" font-size="12" dy=".8em" y="30601.700000047684" x="953.5">流程：(1)双方约定好心跳包的格式，要能够区别于普通的消息。客户端每隔一定时间，就向服务端发送一个心跳包</text><text id="kity_text_13474" text-rendering="inherit" font-size="12" dy=".8em" y="30619.700000047684" x="953.5">(2)服务端每接收到心跳包时，将其抛弃,如果客户端的某个心跳包发送失败，就可以判断连接已经断开</text><text id="kity_text_13475" text-rendering="inherit" font-size="12" dy=".8em" y="30637.700000047684" x="953.5">(3)如果对实时性要求很高，服务端也可以定时检查客户端发送心跳包的频率，如果超过一定时间没有发送可以认为连接已经断开</text><text id="kity_text_13476" text-rendering="inherit" font-size="12" dy=".8em" y="30655.700000047684" x="953.5">缺点：心跳包必然会增加带宽和性能的负担</text><text id="kity_text_13477" text-rendering="inherit" font-size="12" dy=".8em" y="30673.700000047684" x="953.5">2. 断开时重连</text><text id="kity_text_13478" text-rendering="inherit" font-size="12" dy=".8em" y="30691.700000047684" x="953.5">对于普通的应用我们其实并没有必要使用这种方案，如果消息发送时抛出了连接异常，直接尝试重新连接就好了。</text></g></g><g id="minder_node2204"><g id="node_expander2197" style="cursor: pointer;" display="none"><path id="kity_path_27113" fill="white" stroke="gray" d="M1796.5,30627.5A6,6,0,1,1,1784.5,30627.5A6,6,0,1,1,1796.5,30627.5"></path><path id="kity_path_27114" fill="none" stroke="gray"></path></g><path id="node_outline2198" fill="none" stroke="none" d="M1801.5,30600.5h367a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-367a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2198" fill="black"><text id="kity_text_13466" text-rendering="inherit" font-size="12" dy=".8em" y="30601.700000047684" x="1801.5">https://blog.csdn.net/u014436243/article/details/106471313</text><text id="kity_text_13467" text-rendering="inherit" font-size="12" dy=".8em" y="30619.700000047684" x="1801.5">https://blog.csdn.net/weixin_41715077/article/details/88791499</text><text id="kity_text_13468" text-rendering="inherit" font-size="12" dy=".8em" y="30637.700000047684" x="1801.5">https://juejin.cn/post/6844903593808494600#heading-11</text></g></g><g id="minder_node2205"><g id="node_expander2202" style="cursor: pointer;"><path id="kity_path_27128" fill="white" stroke="gray" d="M741.5,30734.5A6,6,0,1,1,729.5,30734.5A6,6,0,1,1,741.5,30734.5"></path><path id="kity_path_27129" fill="none" stroke="gray" d="M731,30734.5L740,30734.5"></path></g><path id="node_outline2203" fill="none" stroke="none" d="M746.5,30725.5h134a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-134a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2203" fill="black"><text id="kity_text_13487" text-rendering="inherit" font-size="12" dy=".8em" y="30726.700000047684" x="746.5">socket如何处理多个连接</text></g></g><g id="minder_node2206"><g id="node_expander2201" style="cursor: pointer;"><path id="kity_path_27125" fill="white" stroke="gray" d="M901.5,30734.5A6,6,0,1,1,889.5,30734.5A6,6,0,1,1,901.5,30734.5"></path><path id="kity_path_27126" fill="none" stroke="gray" d="M891,30734.5L900,30734.5"></path></g><path id="node_outline2202" fill="none" stroke="none" d="M906.5,30716.5h567a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-567a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2202" fill="black"><text id="kity_text_13484" text-rendering="inherit" font-size="12" dy=".8em" y="30717.700000047684" x="906.5">服务端如果一次只跟一个客户端建立socket连接，浪费资源，可以让服务端和多个客户端建立多个socket。</text><text id="kity_text_13485" text-rendering="inherit" font-size="12" dy=".8em" y="30735.700000047684" x="906.5">1.用线程池解决，然后处理请求完submit即可</text></g></g><g id="minder_node2207"><g id="node_expander2200" style="cursor: pointer;" display="none"><path id="kity_path_27122" fill="white" stroke="gray" d="M1494.5,30734.5A6,6,0,1,1,1482.5,30734.5A6,6,0,1,1,1494.5,30734.5"></path><path id="kity_path_27123" fill="none" stroke="gray"></path></g><path id="node_outline2201" fill="none" stroke="none" d="M1499.5,30725.5h326a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2201" fill="black"><text id="kity_text_13482" text-rendering="inherit" font-size="12" dy=".8em" y="30726.700000047684" x="1499.5">https://juejin.cn/post/6844903593808494600#heading-9</text></g></g><g id="minder_node2208"><g id="node_expander2205" style="cursor: pointer;"><path id="kity_path_27137" fill="white" stroke="gray" d="M631.5,30795.5A6,6,0,1,1,619.5,30795.5A6,6,0,1,1,631.5,30795.5"></path><path id="kity_path_27138" fill="none" stroke="gray" d="M621,30795.5L630,30795.5"></path></g><path id="node_outline2206" fill="none" stroke="none" d="M636.5,30786.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2206" fill="black"><text id="kity_text_13496" text-rendering="inherit" font-size="12" dy=".8em" y="30787.700000047684" x="636.5">参考文章</text></g></g><g id="minder_node2209"><g id="node_expander2204" style="cursor: pointer;" display="none"><path id="kity_path_27134" fill="white" stroke="gray" d="M706.5,30795.5A6,6,0,1,1,694.5,30795.5A6,6,0,1,1,706.5,30795.5"></path><path id="kity_path_27135" fill="none" stroke="gray"></path></g><path id="node_outline2205" fill="none" stroke="none" d="M711.5,30759.5h346a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-346a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text2205" fill="black"><text id="kity_text_13491" text-rendering="inherit" font-size="12" dy=".8em" y="30760.700000047684" x="711.5">https://juejin.cn/post/6844904125692379143</text><text id="kity_text_13492" text-rendering="inherit" font-size="12" dy=".8em" y="30778.700000047684" x="711.5">https://juejin.cn/post/6844903919756410893</text><text id="kity_text_13493" text-rendering="inherit" font-size="12" dy=".8em" y="30796.700000047684" x="711.5">https://juejin.cn/post/6844903593808494600</text><text id="kity_text_13494" text-rendering="inherit" font-size="12" dy=".8em" y="30814.700000047684" x="711.5">https://blog.csdn.net/qq_41517936/article/details/81015711</text></g></g><g id="minder_node2210"><g id="node_expander2222" style="cursor: pointer;"><path id="kity_path_27188" fill="white" stroke="gray" d="M492.5,30848.5A6,6,0,1,1,480.5,30848.5A6,6,0,1,1,492.5,30848.5"></path><path id="kity_path_27189" fill="none" stroke="gray" d="M482,30848.5L491,30848.5M486.5,30844L486.5,30853"></path></g><path id="node_outline2223" fill="none" stroke="none" d="M497.5,30839.5h98a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-98a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2223" fill="black"><text id="kity_text_13542" text-rendering="inherit" font-size="12" dy=".8em" y="30840.700000047684" x="497.5">javaweb三大组件</text></g></g><g id="minder_node2211" display="none"><g id="node_expander2209" display="none" style="cursor: pointer;"><path id="kity_path_27149" fill="white" stroke="gray" d="M616.5,30792.5A6,6,0,1,1,604.5,30792.5A6,6,0,1,1,616.5,30792.5"></path><path id="kity_path_27150" fill="none" stroke="gray"></path></g><path id="node_outline2210" fill="none" stroke="none" d="M616.5,30783.5h189a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-189a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2210" fill="black"><text id="kity_text_13506" text-rendering="inherit" font-size="12" dy=".8em" y="30784.700000047684" x="616.5">说说cookie和session的区别和特点</text></g></g><g id="minder_node2212" display="none"><g id="node_expander2208" display="none" style="cursor: pointer;"><path id="kity_path_27146" fill="white" stroke="gray" d="M632.5,30792.5A6,6,0,1,1,620.5,30792.5A6,6,0,1,1,632.5,30792.5"></path><path id="kity_path_27147" fill="none" stroke="gray"></path></g><path id="node_outline2209" fill="none" stroke="none" d="M632.5,30765.5h1562a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1562a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2209" fill="black"><text id="kity_text_13502" text-rendering="inherit" font-size="12" dy=".8em" y="30766.700000047684" x="632.5">这两个都是用来维护用户会话的办法，因为http是无状态的</text><text id="kity_text_13503" text-rendering="inherit" font-size="12" dy=".8em" y="30784.700000047684" x="632.5">1.session session底层是cookie，保存在服务端，session是servlet三大域(session request application) 他的实现过程是 第一次访问时 服务端生成sesssionId放到jsessionId中 然后把jsessionId放到cookie中 给浏览器， 浏览器的cookie中就有了jsessionId 就可以和服务端sessionId对应起来了</text><text id="kity_text_13504" text-rendering="inherit" font-size="12" dy=".8em" y="30802.700000047684" x="632.5">2.cookie 服务端产生，保存在客户端，相当于起到一个客户端缓存的作用，有一定的安全问题 一个cookie大概是4kb，可以通过设置cookie的域来实现一二级域名 共享</text></g></g><g id="minder_node2213" display="none"><g id="node_expander2211" display="none" style="cursor: pointer;"><path id="kity_path_27155" fill="white" stroke="gray" d="M616.5,30800.5A6,6,0,1,1,604.5,30800.5A6,6,0,1,1,616.5,30800.5"></path><path id="kity_path_27156" fill="none" stroke="gray"></path></g><path id="node_outline2212" fill="none" stroke="none" d="M616.5,30791.5h123a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-123a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2212" fill="black"><text id="kity_text_13514" text-rendering="inherit" font-size="12" dy=".8em" y="30792.700000047684" x="616.5">说一下servlet生命周期</text></g></g><g id="minder_node2214" display="none"><g id="node_expander2210" display="none" style="cursor: pointer;"><path id="kity_path_27152" fill="white" stroke="gray" d="M632.5,30800.5A6,6,0,1,1,620.5,30800.5A6,6,0,1,1,632.5,30800.5"></path><path id="kity_path_27153" fill="none" stroke="gray"></path></g><path id="node_outline2211" fill="none" stroke="none" d="M632.5,30755.5h590a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-590a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text2211" fill="black"><text id="kity_text_13508" text-rendering="inherit" font-size="12" dy=".8em" y="30756.700000047684" x="632.5">1.加载servlet类；类加载器负责加载servlet类。 当Web容器收到对Servlet的第一个请求时，将加载Servlet类。</text><text id="kity_text_13509" text-rendering="inherit" font-size="12" dy=".8em" y="30774.700000047684" x="632.5">2.实例化；Servlet实例在Servlet生命周期中仅创建一次。</text><text id="kity_text_13510" text-rendering="inherit" font-size="12" dy=".8em" y="30792.700000047684" x="632.5">3.初始化 init方法 生命周期中只调用一次</text><text id="kity_text_13511" text-rendering="inherit" font-size="12" dy=".8em" y="30810.700000047684" x="632.5">4.处理业务逻辑</text><text id="kity_text_13512" text-rendering="inherit" font-size="12" dy=".8em" y="30828.700000047684" x="632.5">5.销毁 destroy方法</text></g></g><g id="minder_node2215" display="none"><g id="node_expander2212" display="none" style="cursor: pointer;"><path id="kity_path_27158" fill="white" stroke="gray" d="M616.5,30808.5A6,6,0,1,1,604.5,30808.5A6,6,0,1,1,616.5,30808.5"></path><path id="kity_path_27159" fill="none" stroke="gray"></path></g><path id="node_outline2213" fill="none" stroke="none" d="M616.5,30799.5h210a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-210a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2213" fill="black"><text id="kity_text_13516" text-rendering="inherit" font-size="12" dy=".8em" y="30800.700000047684" x="616.5">tomcat服务器处理请求的流程简单说说</text></g></g><g id="minder_node2216" display="none"><g id="node_expander2213" display="none" style="cursor: pointer;"><path id="kity_path_27161" fill="white" stroke="gray" d="M616.5,30816.5A6,6,0,1,1,604.5,30816.5A6,6,0,1,1,616.5,30816.5"></path><path id="kity_path_27162" fill="none" stroke="gray"></path></g><path id="node_outline2214" fill="none" stroke="none" d="M616.5,30807.5h87a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-87a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2214" fill="black"><text id="kity_text_13518" text-rendering="inherit" font-size="12" dy=".8em" y="30808.700000047684" x="616.5">说说servlet异步</text></g></g><g id="minder_node2217" display="none"><g id="node_expander2216" display="none" style="cursor: pointer;"><path id="kity_path_27170" fill="white" stroke="gray" d="M616.5,30824.5A6,6,0,1,1,604.5,30824.5A6,6,0,1,1,616.5,30824.5"></path><path id="kity_path_27171" fill="none" stroke="gray"></path></g><path id="node_outline2217" fill="none" stroke="none" d="M616.5,30815.5h128a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-128a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2217" fill="black"><text id="kity_text_13529" text-rendering="inherit" font-size="12" dy=".8em" y="30816.700000047684" x="616.5">get和post有什么区别吗</text></g></g><g id="minder_node2218" display="none"><g id="node_expander2215" display="none" style="cursor: pointer;"><path id="kity_path_27167" fill="white" stroke="gray" d="M632.5,30824.5A6,6,0,1,1,620.5,30824.5A6,6,0,1,1,632.5,30824.5"></path><path id="kity_path_27168" fill="none" stroke="gray"></path></g><path id="node_outline2216" fill="none" stroke="none" d="M632.5,30770.5h1127a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1127a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text2216" fill="black"><text id="kity_text_13522" text-rendering="inherit" font-size="12" dy=".8em" y="30771.700000047684" x="632.5">1.get 方法一般用于请求，post 一般用于提交，相当于是把信息提交给服务器，等待服务器作出响应</text><text id="kity_text_13523" text-rendering="inherit" font-size="12" dy=".8em" y="30789.700000047684" x="632.5">2.get 方法是不安全的，请求参数会拼在 URL 后面。post 方法是把参数放在请求体 body&#xa0;</text><text id="kity_text_13524" text-rendering="inherit" font-size="12" dy=".8em" y="30807.700000047684" x="632.5">3.get 请求的 URL 有长度限制 Post没有</text><text id="kity_text_13525" text-rendering="inherit" font-size="12" dy=".8em" y="30825.700000047684" x="632.5">4.get 请求会被浏览器主动 cache，而 post 不会</text><text id="kity_text_13526" text-rendering="inherit" font-size="12" dy=".8em" y="30843.700000047684" x="632.5">5.get 请求在浏览器反复的 回退/前进 操作是无害的，而 post 操作会再次提交表单请求。</text><text id="kity_text_13527" text-rendering="inherit" font-size="12" dy=".8em" y="30861.700000047684" x="632.5">6.get 请求在发送过程中会产生一个 TCP 数据包；post 在发送过程中会产生两个 TCP 数据包。(post，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。)</text></g></g><g id="minder_node2219" display="none"><g id="node_expander2214" display="none" style="cursor: pointer;"><path id="kity_path_27164" fill="white" stroke="gray" d="M648.5,30824.5A6,6,0,1,1,636.5,30824.5A6,6,0,1,1,648.5,30824.5"></path><path id="kity_path_27165" fill="none" stroke="gray"></path></g><path id="node_outline2215" fill="none" stroke="none" d="M648.5,30815.5h326a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2215" fill="black"><text id="kity_text_13520" text-rendering="inherit" font-size="12" dy=".8em" y="30816.700000047684" x="648.5">https://juejin.cn/post/6844904132067885064#heading-1</text></g></g><g id="minder_node2220" display="none"><g id="node_expander2217" display="none" style="cursor: pointer;"><path id="kity_path_27173" fill="white" stroke="gray" d="M616.5,30832.5A6,6,0,1,1,604.5,30832.5A6,6,0,1,1,616.5,30832.5"></path><path id="kity_path_27174" fill="none" stroke="gray"></path></g><path id="node_outline2218" fill="none" stroke="none" d="M616.5,30823.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2218" fill="black"><text id="kity_text_13531" text-rendering="inherit" font-size="12" dy=".8em" y="30824.700000047684" x="616.5">拦截器和过滤器的区别</text></g></g><g id="minder_node2221" display="none"><g id="node_expander2219" display="none" style="cursor: pointer;"><path id="kity_path_27179" fill="white" stroke="gray" d="M616.5,30840.5A6,6,0,1,1,604.5,30840.5A6,6,0,1,1,616.5,30840.5"></path><path id="kity_path_27180" fill="none" stroke="gray"></path></g><path id="node_outline2220" fill="none" stroke="none" d="M616.5,30831.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2220" fill="black"><text id="kity_text_13536" text-rendering="inherit" font-size="12" dy=".8em" y="30832.700000047684" x="616.5">重定向和请求转发的区别</text></g></g><g id="minder_node2222" display="none"><g id="node_expander2218" display="none" style="cursor: pointer;"><path id="kity_path_27176" fill="white" stroke="gray" d="M632.5,30840.5A6,6,0,1,1,620.5,30840.5A6,6,0,1,1,632.5,30840.5"></path><path id="kity_path_27177" fill="none" stroke="gray"></path></g><path id="node_outline2219" fill="none" stroke="none" d="M632.5,30822.5h798a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-798a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2219" fill="black"><text id="kity_text_13533" text-rendering="inherit" font-size="12" dy=".8em" y="30823.700000047684" x="632.5">1.转发：forword 客户端发送一次请求 然后给服务端处理，地址栏不变；是一个servlet调用另外一个servlet 请求域共享；一般用来内部转发(内部资源)</text><text id="kity_text_13534" text-rendering="inherit" font-size="12" dy=".8em" y="30841.700000047684" x="632.5">2.重定向：redirect是两次请求，在客户端起作用，地址栏变化；发两次请求 不共享request数据，一般是做页面跳转</text></g></g><g id="minder_node2223" display="none"><g id="node_expander2221" display="none" style="cursor: pointer;"><path id="kity_path_27185" fill="white" stroke="gray" d="M616.5,30848.5A6,6,0,1,1,604.5,30848.5A6,6,0,1,1,616.5,30848.5"></path><path id="kity_path_27186" fill="none" stroke="gray"></path></g><path id="node_outline2222" fill="none" stroke="none" d="M616.5,30839.5h114a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-114a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2222" fill="black"><text id="kity_text_13540" text-rendering="inherit" font-size="12" dy=".8em" y="30840.700000047684" x="616.5">session的生命周期？</text></g></g><g id="minder_node2224" display="none"><g id="node_expander2220" display="none" style="cursor: pointer;"><path id="kity_path_27182" fill="white" stroke="gray" d="M632.5,30848.5A6,6,0,1,1,620.5,30848.5A6,6,0,1,1,632.5,30848.5"></path><path id="kity_path_27183" fill="none" stroke="gray"></path></g><path id="node_outline2221" fill="none" stroke="none" d="M632.5,30839.5h84a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-84a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2221" fill="black"><text id="kity_text_13538" text-rendering="inherit" font-size="12" dy=".8em" y="30840.700000047684" x="632.5">1.默认是30分钟</text></g></g><g id="minder_node2225"><g id="node_expander2244" style="cursor: pointer;"><path id="kity_path_27254" fill="white" stroke="gray" d="M492.5,30874.5A6,6,0,1,1,480.5,30874.5A6,6,0,1,1,492.5,30874.5"></path><path id="kity_path_27255" fill="none" stroke="gray" d="M482,30874.5L491,30874.5M486.5,30870L486.5,30879"></path></g><path id="node_outline2245" fill="none" stroke="none" d="M497.5,30865.5h32a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-32a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2245" fill="black"><text id="kity_text_13589" text-rendering="inherit" font-size="12" dy=".8em" y="30866.700000047684" x="497.5">java8</text></g></g><g id="minder_node2226" display="none"><g id="node_expander2231" display="none" style="cursor: pointer;"><path id="kity_path_27215" fill="white" stroke="gray" d="M550.5,30850.5A6,6,0,1,1,538.5,30850.5A6,6,0,1,1,550.5,30850.5"></path><path id="kity_path_27216" fill="none" stroke="gray"></path></g><path id="node_outline2232" fill="none" stroke="none" d="M550.5,30841.5h39a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-39a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2232" fill="black"><text id="kity_text_13563" text-rendering="inherit" font-size="12" dy=".8em" y="30842.700000047684" x="550.5">stream</text></g></g><g id="minder_node2227" display="none"><g id="node_expander2224" display="none" style="cursor: pointer;"><path id="kity_path_27194" fill="white" stroke="gray" d="M566.5,30826.5A6,6,0,1,1,554.5,30826.5A6,6,0,1,1,566.5,30826.5"></path><path id="kity_path_27195" fill="none" stroke="gray"></path></g><path id="node_outline2225" fill="none" stroke="none" d="M566.5,30817.5h128a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-128a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2225" fill="black"><text id="kity_text_13546" text-rendering="inherit" font-size="12" dy=".8em" y="30818.700000047684" x="566.5">说说java8有什么新特性</text></g></g><g id="minder_node2228" display="none"><g id="node_expander2223" display="none" style="cursor: pointer;"><path id="kity_path_27191" fill="white" stroke="gray" d="M582.5,30826.5A6,6,0,1,1,570.5,30826.5A6,6,0,1,1,582.5,30826.5"></path><path id="kity_path_27192" fill="none" stroke="gray"></path></g><path id="node_outline2224" fill="none" stroke="none" d="M582.5,30817.5h311a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-311a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2224" fill="black"><text id="kity_text_13544" text-rendering="inherit" font-size="12" dy=".8em" y="30818.700000047684" x="582.5">1.函数式编程，2.steeam流&#xa0; 简化代码 3.异步编排(在juc那)</text></g></g><g id="minder_node2229" display="none"><g id="node_expander2226" display="none" style="cursor: pointer;"><path id="kity_path_27200" fill="white" stroke="gray" d="M566.5,30834.5A6,6,0,1,1,554.5,30834.5A6,6,0,1,1,566.5,30834.5"></path><path id="kity_path_27201" fill="none" stroke="gray"></path></g><path id="node_outline2227" fill="none" stroke="none" d="M566.5,30825.5h64a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-64a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2227" fill="black"><text id="kity_text_13550" text-rendering="inherit" font-size="12" dy=".8em" y="30826.700000047684" x="566.5">stream操作</text></g></g><g id="minder_node2230" display="none"><g id="node_expander2225" display="none" style="cursor: pointer;"><path id="kity_path_27197" fill="white" stroke="gray" d="M582.5,30834.5A6,6,0,1,1,570.5,30834.5A6,6,0,1,1,582.5,30834.5"></path><path id="kity_path_27198" fill="none" stroke="gray"></path></g><path id="node_outline2226" fill="none" stroke="none" d="M582.5,30825.5h482a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-482a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2226" fill="black"><text id="kity_text_13548" text-rendering="inherit" font-size="12" dy=".8em" y="30826.700000047684" x="582.5">1.用stream做filter过滤 做sorted排序&#xa0; 做map做映射到另外一个对象做收集，做count计算</text></g></g><g id="minder_node2231" display="none"><g id="node_expander2228" display="none" style="cursor: pointer;"><path id="kity_path_27206" fill="white" stroke="gray" d="M566.5,30842.5A6,6,0,1,1,554.5,30842.5A6,6,0,1,1,566.5,30842.5"></path><path id="kity_path_27207" fill="none" stroke="gray"></path></g><path id="node_outline2229" fill="none" stroke="none" d="M566.5,30833.5h172a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-172a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2229" fill="black"><text id="kity_text_13556" text-rendering="inherit" font-size="12" dy=".8em" y="30834.700000047684" x="566.5">有了解过知道stream流的性能吗</text></g></g><g id="minder_node2232" display="none"><g id="node_expander2227" display="none" style="cursor: pointer;"><path id="kity_path_27203" fill="white" stroke="gray" d="M582.5,30842.5A6,6,0,1,1,570.5,30842.5A6,6,0,1,1,582.5,30842.5"></path><path id="kity_path_27204" fill="none" stroke="gray"></path></g><path id="node_outline2228" fill="none" stroke="none" d="M582.5,30815.5h299a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-299a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2228" fill="black"><text id="kity_text_13552" text-rendering="inherit" font-size="12" dy=".8em" y="30816.700000047684" x="582.5">1.数据量小的时侯 for效率高，foreach 和stream 差不多</text><text id="kity_text_13553" text-rendering="inherit" font-size="12" dy=".8em" y="30834.700000047684" x="582.5">2.数据量大 stream效率高 然后是foreach 最后是for</text><text id="kity_text_13554" text-rendering="inherit" font-size="12" dy=".8em" y="30852.700000047684" x="582.5">3.stream代码简洁</text></g></g><g id="minder_node2233" display="none"><g id="node_expander2230" display="none" style="cursor: pointer;"><path id="kity_path_27212" fill="white" stroke="gray" d="M566.5,30850.5A6,6,0,1,1,554.5,30850.5A6,6,0,1,1,566.5,30850.5"></path><path id="kity_path_27213" fill="none" stroke="gray"></path></g><path id="node_outline2231" fill="none" stroke="none" d="M566.5,30841.5h196a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-196a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2231" fill="black"><text id="kity_text_13561" text-rendering="inherit" font-size="12" dy=".8em" y="30842.700000047684" x="566.5">有了解过stream流的线程安全问题吗</text></g></g><g id="minder_node2234" display="none"><g id="node_expander2229" display="none" style="cursor: pointer;"><path id="kity_path_27209" fill="white" stroke="gray" d="M582.5,30850.5A6,6,0,1,1,570.5,30850.5A6,6,0,1,1,582.5,30850.5"></path><path id="kity_path_27210" fill="none" stroke="gray"></path></g><path id="node_outline2230" fill="none" stroke="none" d="M582.5,30832.5h203a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-203a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2230" fill="black"><text id="kity_text_13558" text-rendering="inherit" font-size="12" dy=".8em" y="30833.700000047684" x="582.5">1.并行流有线程安全问题&#xa0; 改 stream</text><text id="kity_text_13559" text-rendering="inherit" font-size="12" dy=".8em" y="30851.700000047684" x="582.5">2.并行流 底层 ForkJobTask 分而治之&#xa0;</text></g></g><g id="minder_node2235" display="none"><g id="node_expander2235" display="none" style="cursor: pointer;"><path id="kity_path_27227" fill="white" stroke="gray" d="M550.5,30858.5A6,6,0,1,1,538.5,30858.5A6,6,0,1,1,550.5,30858.5"></path><path id="kity_path_27228" fill="none" stroke="gray"></path></g><path id="node_outline2236" fill="none" stroke="none" d="M550.5,30849.5h48a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-48a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2236" fill="black"><text id="kity_text_13571" text-rendering="inherit" font-size="12" dy=".8em" y="30850.700000047684" x="550.5">optional</text></g></g><g id="minder_node2236" display="none"><g id="node_expander2234" display="none" style="cursor: pointer;"><path id="kity_path_27224" fill="white" stroke="gray" d="M566.5,30858.5A6,6,0,1,1,554.5,30858.5A6,6,0,1,1,566.5,30858.5"></path><path id="kity_path_27225" fill="none" stroke="gray"></path></g><path id="node_outline2235" fill="none" stroke="none" d="M566.5,30849.5h60a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-60a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2235" fill="black"><text id="kity_text_13569" text-rendering="inherit" font-size="12" dy=".8em" y="30850.700000047684" x="566.5">optional？</text></g></g><g id="minder_node2237" display="none"><g id="node_expander2233" display="none" style="cursor: pointer;"><path id="kity_path_27221" fill="white" stroke="gray" d="M582.5,30858.5A6,6,0,1,1,570.5,30858.5A6,6,0,1,1,582.5,30858.5"></path><path id="kity_path_27222" fill="none" stroke="gray"></path></g><path id="node_outline2234" fill="none" stroke="none" d="M582.5,30849.5h815a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-815a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2234" fill="black"><text id="kity_text_13567" text-rendering="inherit" font-size="12" dy=".8em" y="30850.700000047684" x="582.5">1.可以解决防止空指针异常的检查。当一个方法有可能为null 就可以用optional包装，相当于是一个容器，要么有值 要么为null。不用显式进行空值检测。</text></g></g><g id="minder_node2238" display="none"><g id="node_expander2232" display="none" style="cursor: pointer;"><path id="kity_path_27218" fill="white" stroke="gray" d="M598.5,30858.5A6,6,0,1,1,586.5,30858.5A6,6,0,1,1,598.5,30858.5"></path><path id="kity_path_27219" fill="none" stroke="gray"></path></g><path id="node_outline2233" fill="none" stroke="none" d="M598.5,30849.5h321a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-321a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2233" fill="black"><text id="kity_text_13565" text-rendering="inherit" font-size="12" dy=".8em" y="30850.700000047684" x="598.5">https://www.runoob.com/java/java8-optional-class.html</text></g></g><g id="minder_node2239" display="none"><g id="node_expander2236" display="none" style="cursor: pointer;"><path id="kity_path_27230" fill="white" stroke="gray" d="M550.5,30866.5A6,6,0,1,1,538.5,30866.5A6,6,0,1,1,550.5,30866.5"></path><path id="kity_path_27231" fill="none" stroke="gray"></path></g><path id="node_outline2237" fill="none" stroke="none" d="M550.5,30857.5h43a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-43a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2237" fill="black"><text id="kity_text_13573" text-rendering="inherit" font-size="12" dy=".8em" y="30858.700000047684" x="550.5">lambda</text></g></g><g id="minder_node2240" display="none"><g id="node_expander2243" display="none" style="cursor: pointer;"><path id="kity_path_27251" fill="white" stroke="gray" d="M550.5,30874.5A6,6,0,1,1,538.5,30874.5A6,6,0,1,1,550.5,30874.5"></path><path id="kity_path_27252" fill="none" stroke="gray"></path></g><path id="node_outline2244" fill="none" stroke="none" d="M550.5,30865.5h42a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-42a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2244" fill="black"><text id="kity_text_13587" text-rendering="inherit" font-size="12" dy=".8em" y="30866.700000047684" x="550.5">日期api</text></g></g><g id="minder_node2241" display="none"><g id="node_expander2238" display="none" style="cursor: pointer;"><path id="kity_path_27236" fill="white" stroke="gray" d="M566.5,30858.5A6,6,0,1,1,554.5,30858.5A6,6,0,1,1,566.5,30858.5"></path><path id="kity_path_27237" fill="none" stroke="gray"></path></g><path id="node_outline2239" fill="none" stroke="none" d="M566.5,30849.5h53a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-53a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2239" fill="black"><text id="kity_text_13577" text-rendering="inherit" font-size="12" dy=".8em" y="30850.700000047684" x="566.5">localtime</text></g></g><g id="minder_node2242" display="none"><g id="node_expander2237" display="none" style="cursor: pointer;"><path id="kity_path_27233" fill="white" stroke="gray" d="M582.5,30858.5A6,6,0,1,1,570.5,30858.5A6,6,0,1,1,582.5,30858.5"></path><path id="kity_path_27234" fill="none" stroke="gray"></path></g><path id="node_outline2238" fill="none" stroke="none" d="M582.5,30849.5h200a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2238" fill="black"><text id="kity_text_13575" text-rendering="inherit" font-size="12" dy=".8em" y="30850.700000047684" x="582.5">日历系统上的时间&#xa0; 没有时区的时间类</text></g></g><g id="minder_node2243" display="none"><g id="node_expander2240" display="none" style="cursor: pointer;"><path id="kity_path_27242" fill="white" stroke="gray" d="M566.5,30866.5A6,6,0,1,1,554.5,30866.5A6,6,0,1,1,566.5,30866.5"></path><path id="kity_path_27243" fill="none" stroke="gray"></path></g><path id="node_outline2241" fill="none" stroke="none" d="M566.5,30857.5h78a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-78a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2241" fill="black"><text id="kity_text_13581" text-rendering="inherit" font-size="12" dy=".8em" y="30858.700000047684" x="566.5">localdatatime</text></g></g><g id="minder_node2244" display="none"><g id="node_expander2239" display="none" style="cursor: pointer;"><path id="kity_path_27239" fill="white" stroke="gray" d="M582.5,30866.5A6,6,0,1,1,570.5,30866.5A6,6,0,1,1,582.5,30866.5"></path><path id="kity_path_27240" fill="none" stroke="gray"></path></g><path id="node_outline2240" fill="none" stroke="none" d="M582.5,30857.5h113a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-113a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2240" fill="black"><text id="kity_text_13579" text-rendering="inherit" font-size="12" dy=".8em" y="30858.700000047684" x="582.5">年月日时分秒 带时区</text></g></g><g id="minder_node2245" display="none"><g id="node_expander2242" display="none" style="cursor: pointer;"><path id="kity_path_27248" fill="white" stroke="gray" d="M566.5,30874.5A6,6,0,1,1,554.5,30874.5A6,6,0,1,1,566.5,30874.5"></path><path id="kity_path_27249" fill="none" stroke="gray"></path></g><path id="node_outline2243" fill="none" stroke="none" d="M566.5,30865.5h52a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-52a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2243" fill="black"><text id="kity_text_13585" text-rendering="inherit" font-size="12" dy=".8em" y="30866.700000047684" x="566.5">localdata</text></g></g><g id="minder_node2246" display="none"><g id="node_expander2241" display="none" style="cursor: pointer;"><path id="kity_path_27245" fill="white" stroke="gray" d="M582.5,30874.5A6,6,0,1,1,570.5,30874.5A6,6,0,1,1,582.5,30874.5"></path><path id="kity_path_27246" fill="none" stroke="gray"></path></g><path id="node_outline2242" fill="none" stroke="none" d="M582.5,30865.5h127a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-127a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2242" fill="black"><text id="kity_text_13583" text-rendering="inherit" font-size="12" dy=".8em" y="30866.700000047684" x="582.5">日期&#xa0; 可以加减计算日期</text></g></g><g id="minder_node2247"><g id="node_expander2473" style="cursor: pointer;"><path id="kity_path_27941" fill="white" stroke="gray" d="M397.5,30912.5A6,6,0,1,1,385.5,30912.5A6,6,0,1,1,397.5,30912.5"></path><path id="kity_path_27942" fill="none" stroke="gray" d="M387,30912.5L396,30912.5M391.5,30908L391.5,30917"></path></g><path id="node_outline2474" fill="rgb(239, 238, 246)" stroke="rgb(123, 115, 191)" d="M401.5,30899.5h130a3,3,0,0,1,3,3v20a3,3,0,0,1,-3,3h-130a3,3,0,0,1,-3,-3v-20a3,3,0,0,1,3,-3z" stroke-width="1"></path><g id="node_text2474" fill="black"><text id="kity_text_14309" text-rendering="inherit" font-size="14" dy=".8em" y="30903.400000095367" x="418.5">6.spring全家桶</text></g></g><g id="minder_node2248" display="none"><g id="node_expander2275" display="none" style="cursor: pointer;"><path id="kity_path_27347" fill="white" stroke="gray" d="M550.5,30880.5A6,6,0,1,1,538.5,30880.5A6,6,0,1,1,550.5,30880.5"></path><path id="kity_path_27348" fill="none" stroke="gray"></path></g><path id="node_outline2276" fill="none" stroke="none" d="M550.5,30871.5h64a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-64a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2276" fill="black"><text id="kity_text_13702" text-rendering="inherit" font-size="12" dy=".8em" y="30872.700000047684" x="550.5">springMVC</text></g></g><g id="minder_node2249" display="none"><g id="node_expander2266" display="none" style="cursor: pointer;"><path id="kity_path_27320" fill="white" stroke="gray" d="M566.5,30864.5A6,6,0,1,1,554.5,30864.5A6,6,0,1,1,566.5,30864.5"></path><path id="kity_path_27321" fill="none" stroke="gray"></path></g><path id="node_outline2267" fill="none" stroke="none" d="M566.5,30855.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2267" fill="black"><text id="kity_text_13682" text-rendering="inherit" font-size="12" dy=".8em" y="30856.700000047684" x="566.5">基础</text></g></g><g id="minder_node2250" display="none"><g id="node_expander2247" display="none" style="cursor: pointer;"><path id="kity_path_27263" fill="white" stroke="gray" d="M582.5,30808.5A6,6,0,1,1,570.5,30808.5A6,6,0,1,1,582.5,30808.5"></path><path id="kity_path_27264" fill="none" stroke="gray"></path></g><path id="node_outline2248" fill="none" stroke="none" d="M582.5,30799.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2248" fill="black"><text id="kity_text_13595" text-rendering="inherit" font-size="12" dy=".8em" y="30800.700000047684" x="582.5">说一下spring的mvc</text></g></g><g id="minder_node2251" display="none"><g id="node_expander2246" display="none" style="cursor: pointer;"><path id="kity_path_27260" fill="white" stroke="gray" d="M598.5,30808.5A6,6,0,1,1,586.5,30808.5A6,6,0,1,1,598.5,30808.5"></path><path id="kity_path_27261" fill="none" stroke="gray"></path></g><path id="node_outline2247" fill="none" stroke="none" d="M523.5,30751.5h200a5,5,0,0,1,5,5v56a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-56a5,5,0,0,1,5,-5z"></path><g id="node_text2247" fill="black"><text id="kity_text_13593" text-rendering="inherit" font-size="12" dy=".8em" y="30800.700000047684" x="598.5">分支主题</text></g><image id="kity_image_17077" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20200830223040271.png" x="523.5" y="30754.5" width="200" height="43"></image></g><g id="minder_node2252" display="none"><g id="node_expander2249" display="none" style="cursor: pointer;"><path id="kity_path_27269" fill="white" stroke="gray" d="M582.5,30816.5A6,6,0,1,1,570.5,30816.5A6,6,0,1,1,582.5,30816.5"></path><path id="kity_path_27270" fill="none" stroke="gray"></path></g><path id="node_outline2250" fill="none" stroke="none" d="M582.5,30807.5h169a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-169a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2250" fill="black"><text id="kity_text_13604" text-rendering="inherit" font-size="12" dy=".8em" y="30808.700000047684" x="582.5">说一下springmvc主要的组件？</text></g></g><g id="minder_node2253" display="none"><g id="node_expander2248" display="none" style="cursor: pointer;"><path id="kity_path_27266" fill="white" stroke="gray" d="M598.5,30816.5A6,6,0,1,1,586.5,30816.5A6,6,0,1,1,598.5,30816.5"></path><path id="kity_path_27267" fill="none" stroke="gray"></path></g><path id="node_outline2249" fill="none" stroke="none" d="M598.5,30762.5h441a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-441a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text2249" fill="black"><text id="kity_text_13597" text-rendering="inherit" font-size="12" dy=".8em" y="30763.700000047684" x="598.5">1.前端控制器 DispatcherServlet：接收请求、响应结果，相当于转发器</text><text id="kity_text_13598" text-rendering="inherit" font-size="12" dy=".8em" y="30781.700000047684" x="598.5">2.处理器映射器HandlerMapping 根据请求的URL来查找Handler</text><text id="kity_text_13599" text-rendering="inherit" font-size="12" dy=".8em" y="30799.700000047684" x="598.5">3.处理器适配器HandlerAdapter 相当于这个get方法 是返回页面还是返回json数据</text><text id="kity_text_13600" text-rendering="inherit" font-size="12" dy=".8em" y="30817.700000047684" x="598.5">4.处理器Handler（需要程序员开发）</text><text id="kity_text_13601" text-rendering="inherit" font-size="12" dy=".8em" y="30835.700000047684" x="598.5">5.视图解析器 ViewResolver 进行视图的解析，根据视图逻辑名解析成真正的视图</text><text id="kity_text_13602" text-rendering="inherit" font-size="12" dy=".8em" y="30853.700000047684" x="598.5">6.视图View 需要程序员开发 jsp等</text></g></g><g id="minder_node2254" display="none"><g id="node_expander2251" display="none" style="cursor: pointer;"><path id="kity_path_27275" fill="white" stroke="gray" d="M582.5,30824.5A6,6,0,1,1,570.5,30824.5A6,6,0,1,1,582.5,30824.5"></path><path id="kity_path_27276" fill="none" stroke="gray"></path></g><path id="node_outline2252" fill="none" stroke="none" d="M582.5,30815.5h119a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-119a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2252" fill="black"><text id="kity_text_13612" text-rendering="inherit" font-size="12" dy=".8em" y="30816.700000047684" x="582.5">mvc和mvvm的区别？</text></g></g><g id="minder_node2255" display="none"><g id="node_expander2250" display="none" style="cursor: pointer;"><path id="kity_path_27272" fill="white" stroke="gray" d="M598.5,30824.5A6,6,0,1,1,586.5,30824.5A6,6,0,1,1,598.5,30824.5"></path><path id="kity_path_27273" fill="none" stroke="gray"></path></g><path id="node_outline2251" fill="none" stroke="none" d="M598.5,30779.5h838a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-838a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text2251" fill="black"><text id="kity_text_13606" text-rendering="inherit" font-size="12" dy=".8em" y="30780.700000047684" x="598.5">1.mvc</text><text id="kity_text_13607" text-rendering="inherit" font-size="12" dy=".8em" y="30798.700000047684" x="598.5">Controller把Model中的数据拿过来给View使用。Controller可以直接与Model和View进行通信，而View不能与Controller直接通信。</text><text id="kity_text_13608" text-rendering="inherit" font-size="12" dy=".8em" y="30816.700000047684" x="598.5">MVC流程：　用户操作&gt; View (负责接受用户的输入操作)&gt;Controller（业务逻辑处理）&gt;Model（数据持久化）&gt;View（将结果通过View反馈给用户）</text><text id="kity_text_13609" text-rendering="inherit" font-size="12" dy=".8em" y="30834.700000047684" x="598.5">2.mvvm：更多使用的是前后端分离的MVVM来构建web应用，后端开发REST方式开发业务功能接口，提供给前端调用</text><text id="kity_text_13610" text-rendering="inherit" font-size="12" dy=".8em" y="30852.700000047684" x="598.5">`MVVM`:(Model-View-ViewModel) :M:数据模型(具体的业务模型service和数据模型bean) V:用户界面 VM: ViewModel 是一个同步View 和 Model的对象。</text></g></g><g id="minder_node2256" display="none"><g id="node_expander2253" display="none" style="cursor: pointer;"><path id="kity_path_27281" fill="white" stroke="gray" d="M582.5,30832.5A6,6,0,1,1,570.5,30832.5A6,6,0,1,1,582.5,30832.5"></path><path id="kity_path_27282" fill="none" stroke="gray"></path></g><path id="node_outline2254" fill="none" stroke="none" d="M582.5,30823.5h132a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-132a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2254" fill="black"><text id="kity_text_13620" text-rendering="inherit" font-size="12" dy=".8em" y="30824.700000047684" x="582.5">springmvc的工作原理？</text></g></g><g id="minder_node2257" display="none"><g id="node_expander2252" display="none" style="cursor: pointer;"><path id="kity_path_27278" fill="white" stroke="gray" d="M598.5,30832.5A6,6,0,1,1,586.5,30832.5A6,6,0,1,1,598.5,30832.5"></path><path id="kity_path_27279" fill="none" stroke="gray"></path></g><path id="node_outline2253" fill="none" stroke="none" d="M598.5,30787.5h381a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-381a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text2253" fill="black"><text id="kity_text_13614" text-rendering="inherit" font-size="12" dy=".8em" y="30788.700000047684" x="598.5">1）客户端发送请求到DispatcherServlet</text><text id="kity_text_13615" text-rendering="inherit" font-size="12" dy=".8em" y="30806.700000047684" x="598.5">2）DispatcherServlet查询handlerMapping找到处理请求的Controller</text><text id="kity_text_13616" text-rendering="inherit" font-size="12" dy=".8em" y="30824.700000047684" x="598.5">3）Controller调用业务逻辑后，返回ModelAndView</text><text id="kity_text_13617" text-rendering="inherit" font-size="12" dy=".8em" y="30842.700000047684" x="598.5">4）DispatcherServlet查询ModelAndView，找到指定视图</text><text id="kity_text_13618" text-rendering="inherit" font-size="12" dy=".8em" y="30860.700000047684" x="598.5">5）视图将结果返回到客户端</text></g></g><g id="minder_node2258" display="none"><g id="node_expander2256" display="none" style="cursor: pointer;"><path id="kity_path_27290" fill="white" stroke="gray" d="M582.5,30840.5A6,6,0,1,1,570.5,30840.5A6,6,0,1,1,582.5,30840.5"></path><path id="kity_path_27291" fill="none" stroke="gray"></path></g><path id="node_outline2257" fill="none" stroke="none" d="M582.5,30831.5h153a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-153a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2257" fill="black"><text id="kity_text_13632" text-rendering="inherit" font-size="12" dy=".8em" y="30832.700000047684" x="582.5">说一下 springMVC启动流程</text></g></g><g id="minder_node2259" display="none"><g id="node_expander2255" display="none" style="cursor: pointer;"><path id="kity_path_27287" fill="white" stroke="gray" d="M598.5,30840.5A6,6,0,1,1,586.5,30840.5A6,6,0,1,1,598.5,30840.5"></path><path id="kity_path_27288" fill="none" stroke="gray"></path></g><path id="node_outline2256" fill="none" stroke="none" d="M598.5,30777.5h1409a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-1409a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text2256" fill="black"><text id="kity_text_13624" text-rendering="inherit" font-size="12" dy=".8em" y="30778.700000047684" x="598.5">1.容器初始化&#xa0; 以web.xml配置说明</text><text id="kity_text_13625" text-rendering="inherit" font-size="12" dy=".8em" y="30796.700000047684" x="598.5">从一个ContextLoaderListener 本质是servlet监听器 开始的，能够被web容器发现并加载，初始化这个监听器之后，接着就是根据配置如contextConfigLocation配置文件路径和contextClass创建web容器了，</text><text id="kity_text_13626" text-rendering="inherit" font-size="12" dy=".8em" y="30814.700000047684" x="598.5">然后默认contextClass这个参数值创建的spring web容器类型为XmlWebApplicationContext,然后是根据配置的contextConfigLocation文件路径去配置并刷新容器了。</text><text id="kity_text_13627" text-rendering="inherit" font-size="12" dy=".8em" y="30832.700000047684" x="598.5">2.然后DispatcherServlet</text><text id="kity_text_13628" text-rendering="inherit" font-size="12" dy=".8em" y="30850.700000047684" x="598.5">DispatcherServlet，就是一个servlet，一个用来处理request请求的servlet，它是spring mvc的核心，所有的请求都经过它，并由它指定后续操作该怎么执行。DispatcherServlet继承了HttpServlet这个类 处理http请求的servlet</text><text id="kity_text_13629" text-rendering="inherit" font-size="12" dy=".8em" y="30868.700000047684" x="598.5">他的初始化也是围绕init()方法，servlet的初始化，</text><text id="kity_text_13630" text-rendering="inherit" font-size="12" dy=".8em" y="30886.700000047684" x="598.5">dispactherServlet的初始化做了两件事情，(1)根据根web容器，springmvc容器初始化创建的XmlWebApplicationContext，然后创建一个专门为dispactherServlet服务的web容器，(2)将你在web.xml文件中对dispactherServlet进行的相关配置加载到新容器当中。</text></g></g><g id="minder_node2260" display="none"><g id="node_expander2254" display="none" style="cursor: pointer;"><path id="kity_path_27284" fill="white" stroke="gray" d="M614.5,30840.5A6,6,0,1,1,602.5,30840.5A6,6,0,1,1,614.5,30840.5"></path><path id="kity_path_27285" fill="none" stroke="gray"></path></g><path id="node_outline2255" fill="none" stroke="none" d="M614.5,30831.5h326a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2255" fill="black"><text id="kity_text_13622" text-rendering="inherit" font-size="12" dy=".8em" y="30832.700000047684" x="614.5">https://juejin.cn/post/6844903645100638215#heading-3</text></g></g><g id="minder_node2261" display="none"><g id="node_expander2260" display="none" style="cursor: pointer;"><path id="kity_path_27302" fill="white" stroke="gray" d="M582.5,30848.5A6,6,0,1,1,570.5,30848.5A6,6,0,1,1,582.5,30848.5"></path><path id="kity_path_27303" fill="none" stroke="gray"></path></g><path id="node_outline2261" fill="none" stroke="none" d="M582.5,30839.5h150a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-150a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2261" fill="black"><text id="kity_text_13652" text-rendering="inherit" font-size="12" dy=".8em" y="30840.700000047684" x="582.5">说一下springMVC处理流程</text></g></g><g id="minder_node2262" display="none"><g id="node_expander2259" display="none" style="cursor: pointer;"><path id="kity_path_27299" fill="white" stroke="gray" d="M598.5,30848.5A6,6,0,1,1,586.5,30848.5A6,6,0,1,1,598.5,30848.5"></path><path id="kity_path_27300" fill="none" stroke="gray"></path></g><path id="node_outline2260" fill="none" stroke="none" d="M598.5,30731.5h1013a5,5,0,0,1,5,5v224a5,5,0,0,1,-5,5h-1013a5,5,0,0,1,-5,-5v-224a5,5,0,0,1,5,-5z"></path><g id="node_text2260" fill="black"><text id="kity_text_13638" text-rendering="inherit" font-size="12" dy=".8em" y="30732.700000047684" x="598.5">1.向服务器发送 HTTP 请求，请求被前端控制器 DispatcherServlet 捕获处理。他是请求的入口</text><text id="kity_text_13639" text-rendering="inherit" font-size="12" dy=".8em" y="30750.700000047684" x="598.5">2.DispatcherServlet 根据 -servlet.xml 中的配置对请求的 URL 进行解析，得到请求资源标识符（URI）。</text><text id="kity_text_13640" text-rendering="inherit" font-size="12" dy=".8em" y="30768.700000047684" x="598.5">然后根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以HandlerExecutionChain 对象的形式返回。</text><text id="kity_text_13641" text-rendering="inherit" font-size="12" dy=".8em" y="30786.700000047684" x="598.5">3.DispatcherServlet 根据获得的Handler，选择一个合适的 HandlerAdapter。（如果成功获得HandlerAdapter后，此时将开始执行拦截器的 preHandler(...)方法）。</text><text id="kity_text_13642" text-rendering="inherit" font-size="12" dy=".8em" y="30804.700000047684" x="598.5">4.提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据配置，Spring 将帮你做一些额外的工作：</text><text id="kity_text_13643" text-rendering="inherit" font-size="12" dy=".8em" y="30822.700000047684" x="598.5">(1) HttpMessageConveter： 将请求消息（如 Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。</text><text id="kity_text_13644" text-rendering="inherit" font-size="12" dy=".8em" y="30840.700000047684" x="598.5">(2)数据转换：对请求消息进行数据转换。如String转换成Integer、Double等。</text><text id="kity_text_13645" text-rendering="inherit" font-size="12" dy=".8em" y="30858.700000047684" x="598.5">(3)数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等。</text><text id="kity_text_13646" text-rendering="inherit" font-size="12" dy=".8em" y="30876.700000047684" x="598.5">(4)数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中。</text><text id="kity_text_13647" text-rendering="inherit" font-size="12" dy=".8em" y="30894.700000047684" x="598.5">5.Handler(Controller)执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象；</text><text id="kity_text_13648" text-rendering="inherit" font-size="12" dy=".8em" y="30912.700000047684" x="598.5">6.根据返回的ModelAndView，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的ViewResolver)返回给DispatcherServlet。</text><text id="kity_text_13649" text-rendering="inherit" font-size="12" dy=".8em" y="30930.700000047684" x="598.5">7.ViewResolver 结合Model和View，来渲染视图。</text><text id="kity_text_13650" text-rendering="inherit" font-size="12" dy=".8em" y="30948.700000047684" x="598.5">8.视图负责将渲染结果返回给客户端。</text></g></g><g id="minder_node2263" display="none"><g id="node_expander2258" display="none" style="cursor: pointer;"><path id="kity_path_27296" fill="white" stroke="gray" d="M614.5,30848.5A6,6,0,1,1,602.5,30848.5A6,6,0,1,1,614.5,30848.5"></path><path id="kity_path_27297" fill="none" stroke="gray"></path></g><path id="node_outline2259" fill="none" stroke="none" d="M539.5,30637.5h200a5,5,0,0,1,5,5v210a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-210a5,5,0,0,1,5,-5z"></path><g id="node_text2259" fill="black"><text id="kity_text_13636" text-rendering="inherit" font-size="12" dy=".8em" y="30840.700000047684" x="614.5">分支主题</text></g><image id="kity_image_17079" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20200830223825554.png" x="539.5" y="30640.5" width="200" height="197"></image></g><g id="minder_node2264" display="none"><g id="node_expander2257" display="none" style="cursor: pointer;"><path id="kity_path_27293" fill="white" stroke="gray" d="M630.5,30848.5A6,6,0,1,1,618.5,30848.5A6,6,0,1,1,630.5,30848.5"></path><path id="kity_path_27294" fill="none" stroke="gray"></path></g><path id="node_outline2258" fill="none" stroke="none" d="M555.5,30757.5h200a5,5,0,0,1,5,5v90a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-90a5,5,0,0,1,5,-5z"></path><g id="node_text2258" fill="black"><text id="kity_text_13634" text-rendering="inherit" font-size="12" dy=".8em" y="30840.700000047684" x="630.5">分支主题</text></g><image id="kity_image_17078" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210402103028.png" x="555.5" y="30760.5" width="200" height="77"></image></g><g id="minder_node2265" display="none"><g id="node_expander2263" display="none" style="cursor: pointer;"><path id="kity_path_27311" fill="white" stroke="gray" d="M582.5,30856.5A6,6,0,1,1,570.5,30856.5A6,6,0,1,1,582.5,30856.5"></path><path id="kity_path_27312" fill="none" stroke="gray"></path></g><path id="node_outline2264" fill="none" stroke="none" d="M582.5,30847.5h265a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-265a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2264" fill="black"><text id="kity_text_13671" text-rendering="inherit" font-size="12" dy=".8em" y="30848.700000047684" x="582.5">兄弟，说一下hander mapping是怎么处理映射的</text></g></g><g id="minder_node2266" display="none"><g id="node_expander2262" display="none" style="cursor: pointer;"><path id="kity_path_27308" fill="white" stroke="gray" d="M598.5,30856.5A6,6,0,1,1,586.5,30856.5A6,6,0,1,1,598.5,30856.5"></path><path id="kity_path_27309" fill="none" stroke="gray"></path></g><path id="node_outline2263" fill="none" stroke="none" d="M598.5,30739.5h1246a5,5,0,0,1,5,5v224a5,5,0,0,1,-5,5h-1246a5,5,0,0,1,-5,-5v-224a5,5,0,0,1,5,-5z"></path><g id="node_text2263" fill="black"><text id="kity_text_13657" text-rendering="inherit" font-size="12" dy=".8em" y="30740.700000047684" x="598.5">1.主要是的类</text><text id="kity_text_13658" text-rendering="inherit" font-size="12" dy=".8em" y="30758.700000047684" x="598.5">HandlerExecutionChain , 这个是执行链 HandlerMethod&#xa0; 这个就是我们常用的请求的封装 HandlerAdapter 适配器(处理请求的就是从它开始) HandlerExecutionChain.handler 属性 就是 HandlerMethod</text><text id="kity_text_13659" text-rendering="inherit" font-size="12" dy=".8em" y="30776.700000047684" x="598.5">2.handler的定义</text><text id="kity_text_13660" text-rendering="inherit" font-size="12" dy=".8em" y="30794.700000047684" x="598.5">Controller 接口是SpringMvc提供的控制器接口，实现此接口的类，可以看做是一个Handler。我们平常用的比较多的都是注解@RequestMapping，一个方法就是一个handler， 一类中可以写多个handler。比如类上加，比如方法上加</text><text id="kity_text_13661" text-rendering="inherit" font-size="12" dy=".8em" y="30812.700000047684" x="598.5">一个handler可能是一个方法，也可能是一个 Controller 对象、</text><text id="kity_text_13662" text-rendering="inherit" font-size="12" dy=".8em" y="30830.700000047684" x="598.5">3.HandlerMapping(映射关系)</text><text id="kity_text_13663" text-rendering="inherit" font-size="12" dy=".8em" y="30848.700000047684" x="598.5">通过定义hnadler最后通过url访问到他们进行业务的处理,HandlerMapping 会把他们，按照url 与Handler的映射关系登记在册。我们就可以通过url找到对应的Handler了。</text><text id="kity_text_13664" text-rendering="inherit" font-size="12" dy=".8em" y="30866.700000047684" x="598.5">注册主要是通过spring-ioc 容器初始化 requestMappingHandlerMapping 的时候 把对应关系注册 存放在mappingLookup</text><text id="kity_text_13665" text-rendering="inherit" font-size="12" dy=".8em" y="30884.700000047684" x="598.5">执行的时候 根绝请求路径 查找urlLookup,再根据 urlLookup 的val 当做key 去 mappingLookup 中查找</text><text id="kity_text_13666" text-rendering="inherit" font-size="12" dy=".8em" y="30902.700000047684" x="598.5">mappingLookup 是一个LinkedHashMap mappingLookup 是 MappingRegistry 的属性 MappingRegistry 是 AbstractHandlerMethodMapping的内部类</text><text id="kity_text_13667" text-rendering="inherit" font-size="12" dy=".8em" y="30920.700000047684" x="598.5">4.面试简单点可以这样说</text><text id="kity_text_13668" text-rendering="inherit" font-size="12" dy=".8em" y="30938.700000047684" x="598.5">我们在写接口时，其实就是在定义handler，并配置一个Url与之映射。springmvc 为我们提供了4种定义handler的形式我们定义handler 被HandlerMapping登记在册，这样我们就可以使用url从HandlerMapping找到对应handler。</text><text id="kity_text_13669" text-rendering="inherit" font-size="12" dy=".8em" y="30956.700000047684" x="598.5">这就是Handler与HandlerMapping的关系了。</text></g></g><g id="minder_node2267" display="none"><g id="node_expander2261" display="none" style="cursor: pointer;"><path id="kity_path_27305" fill="white" stroke="gray" d="M614.5,30856.5A6,6,0,1,1,602.5,30856.5A6,6,0,1,1,614.5,30856.5"></path><path id="kity_path_27306" fill="none" stroke="gray"></path></g><path id="node_outline2262" fill="none" stroke="none" d="M614.5,30838.5h333a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2262" fill="black"><text id="kity_text_13654" text-rendering="inherit" font-size="12" dy=".8em" y="30839.700000047684" x="614.5">https://juejin.cn/post/6844904009048965127#heading-0</text><text id="kity_text_13655" text-rendering="inherit" font-size="12" dy=".8em" y="30857.700000047684" x="614.5">https://juejin.cn/post/6844904048810803207#heading-10</text></g></g><g id="minder_node2268" display="none"><g id="node_expander2265" display="none" style="cursor: pointer;"><path id="kity_path_27317" fill="white" stroke="gray" d="M582.5,30864.5A6,6,0,1,1,570.5,30864.5A6,6,0,1,1,582.5,30864.5"></path><path id="kity_path_27318" fill="none" stroke="gray"></path></g><path id="node_outline2266" fill="none" stroke="none" d="M582.5,30855.5h266a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-266a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2266" fill="black"><text id="kity_text_13680" text-rendering="inherit" font-size="12" dy=".8em" y="30856.700000047684" x="582.5">说一下你平常基础用的哪些注解分别表示什么意思</text></g></g><g id="minder_node2269" display="none"><g id="node_expander2264" display="none" style="cursor: pointer;"><path id="kity_path_27314" fill="white" stroke="gray" d="M598.5,30864.5A6,6,0,1,1,586.5,30864.5A6,6,0,1,1,598.5,30864.5"></path><path id="kity_path_27315" fill="none" stroke="gray"></path></g><path id="node_outline2265" fill="none" stroke="none" d="M598.5,30810.5h791a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-791a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text2265" fill="black"><text id="kity_text_13673" text-rendering="inherit" font-size="12" dy=".8em" y="30811.700000047684" x="598.5">1.@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</text><text id="kity_text_13674" text-rendering="inherit" font-size="12" dy=".8em" y="30829.700000047684" x="598.5">2.@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。</text><text id="kity_text_13675" text-rendering="inherit" font-size="12" dy=".8em" y="30847.700000047684" x="598.5">3.@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。</text><text id="kity_text_13676" text-rendering="inherit" font-size="12" dy=".8em" y="30865.700000047684" x="598.5">4.@Conntroller：控制器的注解，表示是表现层,不能用用别的注解代替</text><text id="kity_text_13677" text-rendering="inherit" font-size="12" dy=".8em" y="30883.700000047684" x="598.5">5.@RestController 相当于@ResponseBody ＋ @Controller</text><text id="kity_text_13678" text-rendering="inherit" font-size="12" dy=".8em" y="30901.700000047684" x="598.5">6.@RequestParam 获取请求request中的参数值</text></g></g><g id="minder_node2270" display="none"><g id="node_expander2269" display="none" style="cursor: pointer;"><path id="kity_path_27329" fill="white" stroke="gray" d="M566.5,30872.5A6,6,0,1,1,554.5,30872.5A6,6,0,1,1,566.5,30872.5"></path><path id="kity_path_27330" fill="none" stroke="gray"></path></g><path id="node_outline2270" fill="none" stroke="none" d="M566.5,30863.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2270" fill="black"><text id="kity_text_13689" text-rendering="inherit" font-size="12" dy=".8em" y="30864.700000047684" x="566.5">进阶</text></g></g><g id="minder_node2271" display="none"><g id="node_expander2268" display="none" style="cursor: pointer;"><path id="kity_path_27326" fill="white" stroke="gray" d="M582.5,30872.5A6,6,0,1,1,570.5,30872.5A6,6,0,1,1,582.5,30872.5"></path><path id="kity_path_27327" fill="none" stroke="gray"></path></g><path id="node_outline2269" fill="none" stroke="none" d="M582.5,30863.5h162a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-162a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2269" fill="black"><text id="kity_text_13687" text-rendering="inherit" font-size="12" dy=".8em" y="30864.700000047684" x="582.5">怎么在springMVC实现拦截器</text></g></g><g id="minder_node2272" display="none"><g id="node_expander2267" display="none" style="cursor: pointer;"><path id="kity_path_27323" fill="white" stroke="gray" d="M598.5,30872.5A6,6,0,1,1,586.5,30872.5A6,6,0,1,1,598.5,30872.5"></path><path id="kity_path_27324" fill="none" stroke="gray"></path></g><path id="node_outline2268" fill="none" stroke="none" d="M598.5,30854.5h428a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-428a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2268" fill="black"><text id="kity_text_13684" text-rendering="inherit" font-size="12" dy=".8em" y="30855.700000047684" x="598.5">1.实现HandlerInterceptor接口 在方法中去实现处理逻辑 然后在配置文件中配置</text><text id="kity_text_13685" text-rendering="inherit" font-size="12" dy=".8em" y="30873.700000047684" x="598.5">拦截部分什么请求之类的</text></g></g><g id="minder_node2273" display="none"><g id="node_expander2274" display="none" style="cursor: pointer;"><path id="kity_path_27344" fill="white" stroke="gray" d="M566.5,30880.5A6,6,0,1,1,554.5,30880.5A6,6,0,1,1,566.5,30880.5"></path><path id="kity_path_27345" fill="none" stroke="gray"></path></g><path id="node_outline2275" fill="none" stroke="none" d="M566.5,30871.5h86a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-86a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2275" fill="black"><text id="kity_text_13700" text-rendering="inherit" font-size="12" dy=".8em" y="30872.700000047684" x="566.5">场景和问题优化</text></g></g><g id="minder_node2274" display="none"><g id="node_expander2271" display="none" style="cursor: pointer;"><path id="kity_path_27335" fill="white" stroke="gray" d="M582.5,30872.5A6,6,0,1,1,570.5,30872.5A6,6,0,1,1,582.5,30872.5"></path><path id="kity_path_27336" fill="none" stroke="gray"></path></g><path id="node_outline2272" fill="none" stroke="none" d="M582.5,30863.5h289a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-289a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2272" fill="black"><text id="kity_text_13693" text-rendering="inherit" font-size="12" dy=".8em" y="30864.700000047684" x="582.5">SpringMvc是单例模式？如果是,有什么问题,怎么解决?</text></g></g><g id="minder_node2275" display="none"><g id="node_expander2270" display="none" style="cursor: pointer;"><path id="kity_path_27332" fill="white" stroke="gray" d="M598.5,30872.5A6,6,0,1,1,586.5,30872.5A6,6,0,1,1,598.5,30872.5"></path><path id="kity_path_27333" fill="none" stroke="gray"></path></g><path id="node_outline2271" fill="none" stroke="none" d="M598.5,30863.5h652a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-652a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2271" fill="black"><text id="kity_text_13691" text-rendering="inherit" font-size="12" dy=".8em" y="30864.700000047684" x="598.5">1.是单例模式，所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的，解决方案是在控制器里面不能写字段。</text></g></g><g id="minder_node2276" display="none"><g id="node_expander2273" display="none" style="cursor: pointer;"><path id="kity_path_27341" fill="white" stroke="gray" d="M582.5,30880.5A6,6,0,1,1,570.5,30880.5A6,6,0,1,1,582.5,30880.5"></path><path id="kity_path_27342" fill="none" stroke="gray"></path></g><path id="node_outline2274" fill="none" stroke="none" d="M582.5,30871.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2274" fill="black"><text id="kity_text_13698" text-rendering="inherit" font-size="12" dy=".8em" y="30872.700000047684" x="582.5">springmvc参考文章</text></g></g><g id="minder_node2277" display="none"><g id="node_expander2272" display="none" style="cursor: pointer;"><path id="kity_path_27338" fill="white" stroke="gray" d="M598.5,30880.5A6,6,0,1,1,586.5,30880.5A6,6,0,1,1,598.5,30880.5"></path><path id="kity_path_27339" fill="none" stroke="gray"></path></g><path id="node_outline2273" fill="none" stroke="none" d="M598.5,30862.5h343a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-343a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2273" fill="black"><text id="kity_text_13695" text-rendering="inherit" font-size="12" dy=".8em" y="30863.700000047684" x="598.5">1.https://juejin.cn/post/6844904127059722253#heading-26</text><text id="kity_text_13696" text-rendering="inherit" font-size="12" dy=".8em" y="30881.700000047684" x="598.5">2.https://juejin.cn/post/6867043599096217607#heading-8</text></g></g><g id="minder_node2278" display="none"><g id="node_expander2417" display="none" style="cursor: pointer;"><path id="kity_path_27773" fill="white" stroke="gray" d="M550.5,30888.5A6,6,0,1,1,538.5,30888.5A6,6,0,1,1,550.5,30888.5"></path><path id="kity_path_27774" fill="none" stroke="gray"></path></g><path id="node_outline2418" fill="none" stroke="none" d="M550.5,30879.5h36a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-36a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2418" fill="black"><text id="kity_text_14140" text-rendering="inherit" font-size="12" dy=".8em" y="30880.700000047684" x="550.5">spring</text></g></g><g id="minder_node2279" display="none"><g id="node_expander2280" display="none" style="cursor: pointer;"><path id="kity_path_27362" fill="white" stroke="gray" d="M566.5,30808.5A6,6,0,1,1,554.5,30808.5A6,6,0,1,1,566.5,30808.5"></path><path id="kity_path_27363" fill="none" stroke="gray"></path></g><path id="node_outline2281" fill="none" stroke="none" d="M566.5,30799.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2281" fill="black"><text id="kity_text_13715" text-rendering="inherit" font-size="12" dy=".8em" y="30800.700000047684" x="566.5">基础</text></g></g><g id="minder_node2280" display="none"><g id="node_expander2277" display="none" style="cursor: pointer;"><path id="kity_path_27353" fill="white" stroke="gray" d="M582.5,30800.5A6,6,0,1,1,570.5,30800.5A6,6,0,1,1,582.5,30800.5"></path><path id="kity_path_27354" fill="none" stroke="gray"></path></g><path id="node_outline2278" fill="none" stroke="none" d="M582.5,30791.5h182a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-182a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2278" fill="black"><text id="kity_text_13709" text-rendering="inherit" font-size="12" dy=".8em" y="30792.700000047684" x="582.5">说说spring的属性注入有哪些方式</text></g></g><g id="minder_node2281" display="none"><g id="node_expander2276" display="none" style="cursor: pointer;"><path id="kity_path_27350" fill="white" stroke="gray" d="M598.5,30800.5A6,6,0,1,1,586.5,30800.5A6,6,0,1,1,598.5,30800.5"></path><path id="kity_path_27351" fill="none" stroke="gray"></path></g><path id="node_outline2277" fill="none" stroke="none" d="M598.5,30764.5h753a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-753a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text2277" fill="black"><text id="kity_text_13704" text-rendering="inherit" font-size="12" dy=".8em" y="30765.700000047684" x="598.5">1.一般用的就是，构造器依赖注入，Setter方法注入</text><text id="kity_text_13705" text-rendering="inherit" font-size="12" dy=".8em" y="30783.700000047684" x="598.5">构造器：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</text><text id="kity_text_13706" text-rendering="inherit" font-size="12" dy=".8em" y="30801.700000047684" x="598.5">setter方法：是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</text><text id="kity_text_13707" text-rendering="inherit" font-size="12" dy=".8em" y="30819.700000047684" x="598.5">2.构造函数注入 任意修改都会创建一个新实例 适用于设置很多属性&#xa0; setter 注入 	任意修改不会创建一个新实例 适用于设置少量属性</text></g></g><g id="minder_node2282" display="none"><g id="node_expander2279" display="none" style="cursor: pointer;"><path id="kity_path_27359" fill="white" stroke="gray" d="M582.5,30808.5A6,6,0,1,1,570.5,30808.5A6,6,0,1,1,582.5,30808.5"></path><path id="kity_path_27360" fill="none" stroke="gray"></path></g><path id="node_outline2280" fill="none" stroke="none" d="M582.5,30799.5h131a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-131a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2280" fill="black"><text id="kity_text_13713" text-rendering="inherit" font-size="12" dy=".8em" y="30800.700000047684" x="582.5">spring怎么给静态变量di</text></g></g><g id="minder_node2283" display="none"><g id="node_expander2278" display="none" style="cursor: pointer;"><path id="kity_path_27356" fill="white" stroke="gray" d="M598.5,30808.5A6,6,0,1,1,586.5,30808.5A6,6,0,1,1,598.5,30808.5"></path><path id="kity_path_27357" fill="none" stroke="gray"></path></g><path id="node_outline2279" fill="none" stroke="none" d="M598.5,30799.5h662a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-662a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2279" fill="black"><text id="kity_text_13711" text-rendering="inherit" font-size="12" dy=".8em" y="30800.700000047684" x="598.5">1.Spring 依赖注入是依赖set方法，静态变量不属于对象，只属于类。解决方法就是加上非静态的set方法 然后再加autowired</text></g></g><g id="minder_node2284" display="none"><g id="node_expander2285" display="none" style="cursor: pointer;"><path id="kity_path_27377" fill="white" stroke="gray" d="M566.5,30816.5A6,6,0,1,1,554.5,30816.5A6,6,0,1,1,566.5,30816.5"></path><path id="kity_path_27378" fill="none" stroke="gray"></path></g><path id="node_outline2286" fill="none" stroke="none" d="M566.5,30807.5h11a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-11a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2286" fill="black"><text id="kity_text_13732" text-rendering="inherit" font-size="12" dy=".8em" y="30808.700000047684" x="566.5">di</text></g></g><g id="minder_node2285" display="none"><g id="node_expander2282" display="none" style="cursor: pointer;"><path id="kity_path_27368" fill="white" stroke="gray" d="M582.5,30808.5A6,6,0,1,1,570.5,30808.5A6,6,0,1,1,582.5,30808.5"></path><path id="kity_path_27369" fill="none" stroke="gray"></path></g><path id="node_outline2283" fill="none" stroke="none" d="M582.5,30799.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2283" fill="black"><text id="kity_text_13723" text-rendering="inherit" font-size="12" dy=".8em" y="30800.700000047684" x="582.5">说一下spring的依赖注入？</text></g></g><g id="minder_node2286" display="none"><g id="node_expander2281" display="none" style="cursor: pointer;"><path id="kity_path_27365" fill="white" stroke="gray" d="M598.5,30808.5A6,6,0,1,1,586.5,30808.5A6,6,0,1,1,598.5,30808.5"></path><path id="kity_path_27366" fill="none" stroke="gray"></path></g><path id="node_outline2282" fill="none" stroke="none" d="M598.5,30763.5h1242a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1242a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text2282" fill="black"><text id="kity_text_13717" text-rendering="inherit" font-size="12" dy=".8em" y="30764.700000047684" x="598.5">1.就是相当于spring 组件只提供普通的Java方法，让容器自己去决定依赖关系。容器来负责的组件的装配工作，它会把符合依赖关系的对象通过JavaBean属性或者构造函数传递给需要的对象。</text><text id="kity_text_13718" text-rendering="inherit" font-size="12" dy=".8em" y="30782.700000047684" x="598.5">相当于组件之间的依赖关系由容器在应用系统运行期来决定，也就是由容器动态地将某种依赖关系的目标对象实例注入到应用系统中的各个关联的组件之中</text><text id="kity_text_13719" text-rendering="inherit" font-size="12" dy=".8em" y="30800.700000047684" x="598.5">通过JavaBean属性注射依赖关系的做法称为set方法注入；将依赖关系作为构造函数参数传入的做法称为构造注入</text><text id="kity_text_13720" text-rendering="inherit" font-size="12" dy=".8em" y="30818.700000047684" x="598.5">2.创建对象实例时，为这个对象注入属性值或其它对象实例。应用程序启动需要容器给他创建并注入它所需要的外部资源。3.di是实现ioc的方式之一，另外一个是依赖查找。</text><text id="kity_text_13721" text-rendering="inherit" font-size="12" dy=".8em" y="30836.700000047684" x="598.5">4.总结一句话就是，你应用程序要启动就需要很多实例资源，你现在只需要告诉我你要什么，然后各个资源之间的关联，那么在你启动时侯 这些外部资源都由我容器动态的帮你创建好，你要的资源都在我的容器中， 你启动去取就行了。</text></g></g><g id="minder_node2287" display="none"><g id="node_expander2284" display="none" style="cursor: pointer;"><path id="kity_path_27374" fill="white" stroke="gray" d="M582.5,30816.5A6,6,0,1,1,570.5,30816.5A6,6,0,1,1,582.5,30816.5"></path><path id="kity_path_27375" fill="none" stroke="gray"></path></g><path id="node_outline2285" fill="none" stroke="none" d="M582.5,30807.5h83a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-83a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2285" fill="black"><text id="kity_text_13730" text-rendering="inherit" font-size="12" dy=".8em" y="30808.700000047684" x="582.5">di有什么好处？</text></g></g><g id="minder_node2288" display="none"><g id="node_expander2283" display="none" style="cursor: pointer;"><path id="kity_path_27371" fill="white" stroke="gray" d="M598.5,30816.5A6,6,0,1,1,586.5,30816.5A6,6,0,1,1,598.5,30816.5"></path><path id="kity_path_27372" fill="none" stroke="gray"></path></g><path id="node_outline2284" fill="none" stroke="none" d="M598.5,30780.5h1031a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1031a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text2284" fill="black"><text id="kity_text_13725" text-rendering="inherit" font-size="12" dy=".8em" y="30781.700000047684" x="598.5">本质是解耦合.具体为容易测试，如方法内部的实例无法mock。其次不需要自己实现单例模式。再其次方便容器统一管理bean，复用公共逻辑</text><text id="kity_text_13726" text-rendering="inherit" font-size="12" dy=".8em" y="30799.700000047684" x="598.5">1.di的好处就是让容器去查询资源的依赖关系，并且容器管理的组件 需要暴露出 可供容器di的方式方法 让他来管理，就是set方法和构造器注入，这样容器就可以在初始化时组装对象的依赖关系。</text><text id="kity_text_13727" text-rendering="inherit" font-size="12" dy=".8em" y="30817.700000047684" x="598.5">应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC/DI容器来创建并注入它所需要的资源了。</text><text id="kity_text_13728" text-rendering="inherit" font-size="12" dy=".8em" y="30835.700000047684" x="598.5">2.依赖注入和依赖查找的相比较：我们的代码不需要去编写具体查找依赖的代码，只需要编写自己的逻辑代码，也不需要直接去依赖容器的相关api，可以在容器以外的地方使用应用对象</text></g></g><g id="minder_node2289" display="none"><g id="node_expander2300" display="none" style="cursor: pointer;"><path id="kity_path_27422" fill="white" stroke="gray" d="M566.5,30824.5A6,6,0,1,1,554.5,30824.5A6,6,0,1,1,566.5,30824.5"></path><path id="kity_path_27423" fill="none" stroke="gray"></path></g><path id="node_outline2301" fill="none" stroke="none" d="M566.5,30815.5h21a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-21a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2301" fill="black"><text id="kity_text_13781" text-rendering="inherit" font-size="12" dy=".8em" y="30816.700000047684" x="566.5">IOC  </text></g></g><g id="minder_node2290" display="none"><g id="node_expander2288" display="none" style="cursor: pointer;"><path id="kity_path_27386" fill="white" stroke="gray" d="M582.5,30792.5A6,6,0,1,1,570.5,30792.5A6,6,0,1,1,582.5,30792.5"></path><path id="kity_path_27387" fill="none" stroke="gray"></path></g><path id="node_outline2289" fill="none" stroke="none" d="M582.5,30783.5h126a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-126a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2289" fill="black"><text id="kity_text_13740" text-rendering="inherit" font-size="12" dy=".8em" y="30784.700000047684" x="582.5">说说ioc你怎么理解的？</text></g></g><g id="minder_node2291" display="none"><g id="node_expander2287" display="none" style="cursor: pointer;"><path id="kity_path_27383" fill="white" stroke="gray" d="M598.5,30792.5A6,6,0,1,1,586.5,30792.5A6,6,0,1,1,598.5,30792.5"></path><path id="kity_path_27384" fill="none" stroke="gray"></path></g><path id="node_outline2288" fill="none" stroke="none" d="M598.5,30765.5h1434a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1434a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2288" fill="black"><text id="kity_text_13736" text-rendering="inherit" font-size="12" dy=".8em" y="30766.700000047684" x="598.5">1.IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</text><text id="kity_text_13737" text-rendering="inherit" font-size="12" dy=".8em" y="30784.700000047684" x="598.5">2.在spring中IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。它来管理对象之间的相互依赖关系，并完成对象的注入。</text><text id="kity_text_13738" text-rendering="inherit" font-size="12" dy=".8em" y="30802.700000047684" x="598.5">它把应用从复杂的依赖关系中解放出来。在实际项目中有很多Service 类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这比较繁琐。如果利用 IoC 的话，只需要配置好，然后在需要的地方引用就行了，降低了开发难度。</text></g></g><g id="minder_node2292" display="none"><g id="node_expander2286" display="none" style="cursor: pointer;"><path id="kity_path_27380" fill="white" stroke="gray" d="M614.5,30792.5A6,6,0,1,1,602.5,30792.5A6,6,0,1,1,614.5,30792.5"></path><path id="kity_path_27381" fill="none" stroke="gray"></path></g><path id="node_outline2287" fill="none" stroke="none" d="M614.5,30783.5h326a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2287" fill="black"><text id="kity_text_13734" text-rendering="inherit" font-size="12" dy=".8em" y="30784.700000047684" x="614.5">https://juejin.cn/post/6844904128175423496#heading-0</text></g></g><g id="minder_node2293" display="none"><g id="node_expander2290" display="none" style="cursor: pointer;"><path id="kity_path_27392" fill="white" stroke="gray" d="M582.5,30800.5A6,6,0,1,1,570.5,30800.5A6,6,0,1,1,582.5,30800.5"></path><path id="kity_path_27393" fill="none" stroke="gray"></path></g><path id="node_outline2291" fill="none" stroke="none" d="M582.5,30791.5h65a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-65a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2291" fill="black"><text id="kity_text_13744" text-rendering="inherit" font-size="12" dy=".8em" y="30792.700000047684" x="582.5">ioc的原理？</text></g></g><g id="minder_node2294" display="none"><g id="node_expander2289" display="none" style="cursor: pointer;"><path id="kity_path_27389" fill="white" stroke="gray" d="M598.5,30800.5A6,6,0,1,1,586.5,30800.5A6,6,0,1,1,598.5,30800.5"></path><path id="kity_path_27390" fill="none" stroke="gray"></path></g><path id="node_outline2290" fill="none" stroke="none" d="M598.5,30791.5h178a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-178a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2290" fill="black"><text id="kity_text_13742" text-rendering="inherit" font-size="12" dy=".8em" y="30792.700000047684" x="598.5">1.IoC 内部核心原理就是反射技术</text></g></g><g id="minder_node2295" display="none"><g id="node_expander2294" display="none" style="cursor: pointer;"><path id="kity_path_27404" fill="white" stroke="gray" d="M582.5,30808.5A6,6,0,1,1,570.5,30808.5A6,6,0,1,1,582.5,30808.5"></path><path id="kity_path_27405" fill="none" stroke="gray"></path></g><path id="node_outline2295" fill="none" stroke="none" d="M582.5,30799.5h102a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-102a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2295" fill="black"><text id="kity_text_13766" text-rendering="inherit" font-size="12" dy=".8em" y="30800.700000047684" x="582.5">ioc容器的加载流程</text></g></g><g id="minder_node2296" display="none"><g id="node_expander2291" display="none" style="cursor: pointer;"><path id="kity_path_27395" fill="white" stroke="gray" d="M598.5,30800.5A6,6,0,1,1,586.5,30800.5A6,6,0,1,1,598.5,30800.5"></path><path id="kity_path_27396" fill="none" stroke="gray"></path></g><path id="node_outline2292" fill="none" stroke="none" d="M598.5,30755.5h1336a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1336a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text2292" fill="black"><text id="kity_text_13746" text-rendering="inherit" font-size="12" dy=".8em" y="30756.700000047684" x="598.5">第一步：解析成BeanDefinition：将bean定义信息解析为BeanDefinition类，不管bean信息是定义在xml中，还是通过@Bean注解标注，都能通过不同的BeanDefinitionReader转为BeanDefinition类。</text><text id="kity_text_13747" text-rendering="inherit" font-size="12" dy=".8em" y="30774.700000047684" x="598.5">这里分两种BeanDefinition，RootBeanDefintion和BeanDefinition。RootBeanDefinition这种是系统级别的，是启动Spring必须加载的6个Bean。BeanDefinition是我们定义的Bean。</text><text id="kity_text_13748" text-rendering="inherit" font-size="12" dy=".8em" y="30792.700000047684" x="598.5">第二步：参照BeanDefintion定义的类信息，通过BeanFactory生成bean实例存放在缓存中。</text><text id="kity_text_13749" text-rendering="inherit" font-size="12" dy=".8em" y="30810.700000047684" x="598.5">这里的BeanFactoryPostProcessor是一个拦截器，在BeanDefinition实例化后，BeanFactory生成该Bean之前，可以对BeanDefinition进行修改。BeanDefinition 它存储了 bean 对象的所有特征信息，如是否单例，是否懒加载，factoryBeanName 等</text><text id="kity_text_13750" text-rendering="inherit" font-size="12" dy=".8em" y="30828.700000047684" x="598.5">BeanFactory根据BeanDefinition定义使用反射实例化Bean，实例化和初始化Bean的过程中就涉及到Bean的生命周期了，典型的问题就是Bean的循环依赖。接着，Bean实例化前会判断该Bean是否需要增强，并决定具体使用哪种代理来生成Bean。</text></g></g><g id="minder_node2297" display="none"><g id="node_expander2293" display="none" style="cursor: pointer;"><path id="kity_path_27401" fill="white" stroke="gray" d="M598.5,30808.5A6,6,0,1,1,586.5,30808.5A6,6,0,1,1,598.5,30808.5"></path><path id="kity_path_27402" fill="none" stroke="gray"></path></g><path id="node_outline2294" fill="none" stroke="none" d="M598.5,30718.5h1803a5,5,0,0,1,5,5v170a5,5,0,0,1,-5,5h-1803a5,5,0,0,1,-5,-5v-170a5,5,0,0,1,5,-5z"></path><g id="node_text2294" fill="black"><text id="kity_text_13755" text-rendering="inherit" font-size="12" dy=".8em" y="30719.700000047684" x="598.5">new一个ApplicationContext容器</text><text id="kity_text_13756" text-rendering="inherit" font-size="12" dy=".8em" y="30737.700000047684" x="598.5">1.this</text><text id="kity_text_13757" text-rendering="inherit" font-size="12" dy=".8em" y="30755.700000047684" x="598.5">注册了6个RootBeanDefinition，即系统级别的BeanDefinition。然后放到BeanFactory的缓存中。这些类回调的代码在refresh()中才会执行的。然后会去拦截解析类是否是配置类。然后是就解析配置类，然后解析@Import和@Bean这些注解</text><text id="kity_text_13758" text-rendering="inherit" font-size="12" dy=".8em" y="30773.700000047684" x="598.5">2.register</text><text id="kity_text_13759" text-rendering="inherit" font-size="12" dy=".8em" y="30791.700000047684" x="598.5">然后注册new AnnotationConfigApplicationContext()传进来的配置类</text><text id="kity_text_13760" text-rendering="inherit" font-size="12" dy=".8em" y="30809.700000047684" x="598.5">3.refresh</text><text id="kity_text_13761" text-rendering="inherit" font-size="12" dy=".8em" y="30827.700000047684" x="598.5">调用BeanFactory后置处理器，bean的解析在这里调用启动。 然后registerBeanPostProcessors(beanFactory)注册bean后置处理器，然后初始化&#xa0; 然后通过 finishBeanFactoryInitialization(beanFactory)实例化bean，可以通过@Bean来定义，也可以通过FactoryBean来初始化。然后就是getBean(beanName)&#xa0; 然后createBean创建bean</text><text id="kity_text_13762" text-rendering="inherit" font-size="12" dy=".8em" y="30845.700000047684" x="598.5">4.bean的创建</text><text id="kity_text_13763" text-rendering="inherit" font-size="12" dy=".8em" y="30863.700000047684" x="598.5">bean创建过程可以分为两步，实例化Instantiation和初始化Initialization。实例化指的是创建bean实例，初始化指的是为填充bean实例属性（为属性赋值）。resolveBeforeInstantiation()方法在bean还没实例化之前执行。</text><text id="kity_text_13764" text-rendering="inherit" font-size="12" dy=".8em" y="30881.700000047684" x="598.5">提供给Bean后置处理器一个返回代理的机会，当你调用被代理的bean时，实际上是执行了增强了的代理对象。不需要代理的bean 就是 doCreateBean，然后就是bean的生命周期了</text></g></g><g id="minder_node2298" display="none"><g id="node_expander2292" display="none" style="cursor: pointer;"><path id="kity_path_27398" fill="white" stroke="gray" d="M614.5,30808.5A6,6,0,1,1,602.5,30808.5A6,6,0,1,1,614.5,30808.5"></path><path id="kity_path_27399" fill="none" stroke="gray"></path></g><path id="node_outline2293" fill="none" stroke="none" d="M614.5,30790.5h323a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-323a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2293" fill="black"><text id="kity_text_13752" text-rendering="inherit" font-size="12" dy=".8em" y="30791.700000047684" x="614.5">https://mp.weixin.qq.com/s/ut3mRwhfqXNjrBtTmI0oWg</text><text id="kity_text_13753" text-rendering="inherit" font-size="12" dy=".8em" y="30809.700000047684" x="614.5">https://juejin.cn/post/6847902217777709063</text></g></g><g id="minder_node2299" display="none"><g id="node_expander2297" display="none" style="cursor: pointer;"><path id="kity_path_27413" fill="white" stroke="gray" d="M582.5,30816.5A6,6,0,1,1,570.5,30816.5A6,6,0,1,1,582.5,30816.5"></path><path id="kity_path_27414" fill="none" stroke="gray"></path></g><path id="node_outline2298" fill="none" stroke="none" d="M582.5,30807.5h184a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-184a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2298" fill="black"><text id="kity_text_13775" text-rendering="inherit" font-size="12" dy=".8em" y="30808.700000047684" x="582.5">BeanFacory和FactoryBean区别？</text></g></g><g id="minder_node2300" display="none"><g id="node_expander2296" display="none" style="cursor: pointer;"><path id="kity_path_27410" fill="white" stroke="gray" d="M598.5,30816.5A6,6,0,1,1,586.5,30816.5A6,6,0,1,1,598.5,30816.5"></path><path id="kity_path_27411" fill="none" stroke="gray"></path></g><path id="node_outline2297" fill="none" stroke="none" d="M598.5,30780.5h1565a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1565a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text2297" fill="black"><text id="kity_text_13770" text-rendering="inherit" font-size="12" dy=".8em" y="30781.700000047684" x="598.5">1.beanfactory是我们从ioc去获取bean，实例化bean的容器，他是ioc的核心接口，主要是的功能就是 资源定位，实例化应用程序的对象等。比如BeanFactory的子类ClassPathXmlApplicationContext可以从xml中解析标签得到bean对象，然后管理他们</text><text id="kity_text_13771" text-rendering="inherit" font-size="12" dy=".8em" y="30799.700000047684" x="598.5">factorybean是把我们的bean放入bean工厂，在spring中有两种bean，一种是普通bean，一个是工厂bean。工厂bean可以产生其他bean实例。工厂bean也是一个bean，他的设计模式有工厂模式和修饰器模式，能在需要的时候生产一个对象，且不仅仅限于它自身，它能返回任何Bean的实例。</text><text id="kity_text_13772" text-rendering="inherit" font-size="12" dy=".8em" y="30817.700000047684" x="598.5">2.FactoryBean在Spring中最为典型的一个应用就是用来创建AOP的代理对象。</text><text id="kity_text_13773" text-rendering="inherit" font-size="12" dy=".8em" y="30835.700000047684" x="598.5">AOP代理对象通过Java的反射机制，在运行时创建了一个代理对象，在代理对象的目标方法中根据业务要求织入了相应的方法。这个对象在Spring中就是——ProxyFactoryBean。</text></g></g><g id="minder_node2301" display="none"><g id="node_expander2295" display="none" style="cursor: pointer;"><path id="kity_path_27407" fill="white" stroke="gray" d="M614.5,30816.5A6,6,0,1,1,602.5,30816.5A6,6,0,1,1,614.5,30816.5"></path><path id="kity_path_27408" fill="none" stroke="gray"></path></g><path id="node_outline2296" fill="none" stroke="none" d="M614.5,30807.5h259a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-259a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2296" fill="black"><text id="kity_text_13768" text-rendering="inherit" font-size="12" dy=".8em" y="30808.700000047684" x="614.5">https://juejin.cn/post/6844903967600836621</text></g></g><g id="minder_node2302" display="none"><g id="node_expander2299" display="none" style="cursor: pointer;"><path id="kity_path_27419" fill="white" stroke="gray" d="M582.5,30824.5A6,6,0,1,1,570.5,30824.5A6,6,0,1,1,582.5,30824.5"></path><path id="kity_path_27420" fill="none" stroke="gray"></path></g><path id="node_outline2300" fill="none" stroke="none" d="M582.5,30815.5h229a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-229a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2300" fill="black"><text id="kity_text_13779" text-rendering="inherit" font-size="12" dy=".8em" y="30816.700000047684" x="582.5">BeanFactory和ApplicationContext的区别</text></g></g><g id="minder_node2303" display="none"><g id="node_expander2298" display="none" style="cursor: pointer;"><path id="kity_path_27416" fill="white" stroke="gray" d="M598.5,30824.5A6,6,0,1,1,586.5,30824.5A6,6,0,1,1,598.5,30824.5"></path><path id="kity_path_27417" fill="none" stroke="gray"></path></g><path id="node_outline2299" fill="none" stroke="none" d="M598.5,30815.5h973a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-973a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2299" fill="black"><text id="kity_text_13777" text-rendering="inherit" font-size="12" dy=".8em" y="30816.700000047684" x="598.5">1.ApplicationContext是BeanFactory的扩展类子接口，他除了有读取Bean的加载&#xa0; 实例化 维护bean之间的依赖关系 负责bean的生命周期以外 还支持一些国际化 资源访问 等一些功能</text></g></g><g id="minder_node2304" display="none"><g id="node_expander2330" display="none" style="cursor: pointer;"><path id="kity_path_27512" fill="white" stroke="gray" d="M566.5,30832.5A6,6,0,1,1,554.5,30832.5A6,6,0,1,1,566.5,30832.5"></path><path id="kity_path_27513" fill="none" stroke="gray"></path></g><path id="node_outline2331" fill="none" stroke="none" d="M566.5,30823.5h29a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-29a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2331" fill="black"><text id="kity_text_13864" text-rendering="inherit" font-size="12" dy=".8em" y="30824.700000047684" x="566.5">bean</text></g></g><g id="minder_node2305" display="none"><g id="node_expander2304" display="none" style="cursor: pointer;"><path id="kity_path_27434" fill="white" stroke="gray" d="M582.5,30752.5A6,6,0,1,1,570.5,30752.5A6,6,0,1,1,582.5,30752.5"></path><path id="kity_path_27435" fill="none" stroke="gray"></path></g><path id="node_outline2305" fill="none" stroke="none" d="M582.5,30743.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2305" fill="black"><text id="kity_text_13793" text-rendering="inherit" font-size="12" dy=".8em" y="30744.700000047684" x="582.5">说说 spring bean的生命周期</text></g></g><g id="minder_node2306" display="none"><g id="node_expander2303" display="none" style="cursor: pointer;"><path id="kity_path_27431" fill="white" stroke="gray" d="M598.5,30752.5A6,6,0,1,1,586.5,30752.5A6,6,0,1,1,598.5,30752.5"></path><path id="kity_path_27432" fill="none" stroke="gray"></path></g><path id="node_outline2304" fill="none" stroke="none" d="M598.5,30707.5h1133a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1133a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text2304" fill="black"><text id="kity_text_13787" text-rendering="inherit" font-size="12" dy=".8em" y="30708.700000047684" x="598.5">1.实例化，Bean 容器找到配置文件中 Spring Bean 的定义。利用 反射 创建一个Bean的实例。</text><text id="kity_text_13788" text-rendering="inherit" font-size="12" dy=".8em" y="30726.700000047684" x="598.5">2.属性赋值，为 bean 设置相关属性和依赖；</text><text id="kity_text_13789" text-rendering="inherit" font-size="12" dy=".8em" y="30744.700000047684" x="598.5">3.初始化bean。 如果实现了其他 *.Aware接口，就调用相应的方法。比如BeanNameAware 接口，调用 setBeanName()方法，传入Bean的名字。</text><text id="kity_text_13790" text-rendering="inherit" font-size="12" dy=".8em" y="30762.700000047684" x="598.5">然后就是看是否有前置处理器 后置处理器，执行对应的方法postProcessBeforeInitialization和postProcessAfterInitialization，如果有实现InitializingBean接口，执行afterPropertiesSet()方法 执行指定init方法。</text><text id="kity_text_13791" text-rendering="inherit" font-size="12" dy=".8em" y="30780.700000047684" x="598.5">4.销毁。若实现 DisposableBean 接口，则执行 destory()方法。 若配置中有自定义的 detory-method 方法，则执行指定相关方法</text></g></g><g id="minder_node2307" display="none"><g id="node_expander2301" display="none" style="cursor: pointer;"><path id="kity_path_27425" fill="white" stroke="gray" d="M614.5,30744.5A6,6,0,1,1,602.5,30744.5A6,6,0,1,1,614.5,30744.5"></path><path id="kity_path_27426" fill="none" stroke="gray"></path></g><path id="node_outline2302" fill="none" stroke="none" d="M614.5,30735.5h326a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2302" fill="black"><text id="kity_text_13783" text-rendering="inherit" font-size="12" dy=".8em" y="30736.700000047684" x="614.5">https://juejin.cn/post/6844904065457979405#heading-6</text></g></g><g id="minder_node2308" display="none"><g id="node_expander2302" display="none" style="cursor: pointer;"><path id="kity_path_27428" fill="white" stroke="gray" d="M614.5,30752.5A6,6,0,1,1,602.5,30752.5A6,6,0,1,1,614.5,30752.5"></path><path id="kity_path_27429" fill="none" stroke="gray"></path></g><path id="node_outline2303" fill="none" stroke="none" d="M539.5,30653.5h200a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text2303" fill="black"><text id="kity_text_13785" text-rendering="inherit" font-size="12" dy=".8em" y="30744.700000047684" x="614.5">分支主题</text></g><image id="kity_image_17080" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210516144119.png" x="539.5" y="30656.5" width="200" height="85"></image></g><g id="minder_node2309" display="none"><g id="node_expander2307" display="none" style="cursor: pointer;"><path id="kity_path_27443" fill="white" stroke="gray" d="M582.5,30760.5A6,6,0,1,1,570.5,30760.5A6,6,0,1,1,582.5,30760.5"></path><path id="kity_path_27444" fill="none" stroke="gray"></path></g><path id="node_outline2308" fill="none" stroke="none" d="M582.5,30751.5h244a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-244a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2308" fill="black"><text id="kity_text_13802" text-rendering="inherit" font-size="12" dy=".8em" y="30752.700000047684" x="582.5">知道spring 配置 bean 实例化的方式有哪些吗</text></g></g><g id="minder_node2310" display="none"><g id="node_expander2306" display="none" style="cursor: pointer;"><path id="kity_path_27440" fill="white" stroke="gray" d="M598.5,30760.5A6,6,0,1,1,586.5,30760.5A6,6,0,1,1,598.5,30760.5"></path><path id="kity_path_27441" fill="none" stroke="gray"></path></g><path id="node_outline2307" fill="none" stroke="none" d="M598.5,30724.5h1410a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1410a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text2307" fill="black"><text id="kity_text_13797" text-rendering="inherit" font-size="12" dy=".8em" y="30725.700000047684" x="598.5">1.基于xml配置方式实例化有三种形式</text><text id="kity_text_13798" text-rendering="inherit" font-size="12" dy=".8em" y="30743.700000047684" x="598.5">1.1通过无参构造实例化；使用bean节点来创建对象 id属性表示对象 class属性表示要交给容器管理的对象的全路径。如果不指定构造函数，系统会生成默认的无参构造函数；如果指定有有参构造函数，必须显性的指定一个无参构造函数，否则实例化对象会抛出异常。</text><text id="kity_text_13799" text-rendering="inherit" font-size="12" dy=".8em" y="30761.700000047684" x="598.5">1.2基于静态工厂方式实例化；首先使用一个工厂的静态方法返回一个对象。在配置文件中使用静态方法返回对象。使用class来执行静态类，Factory-method指定工厂方法</text><text id="kity_text_13800" text-rendering="inherit" font-size="12" dy=".8em" y="30779.700000047684" x="598.5">1.3基于普通工厂方式实例化；通过工厂的非静态方法得到当前的一个对象。 首先创建一个工厂对象。然后指定工厂对象和工厂方法</text></g></g><g id="minder_node2311" display="none"><g id="node_expander2305" display="none" style="cursor: pointer;"><path id="kity_path_27437" fill="white" stroke="gray" d="M614.5,30760.5A6,6,0,1,1,602.5,30760.5A6,6,0,1,1,614.5,30760.5"></path><path id="kity_path_27438" fill="none" stroke="gray"></path></g><path id="node_outline2306" fill="none" stroke="none" d="M614.5,30751.5h342a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-342a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2306" fill="black"><text id="kity_text_13795" text-rendering="inherit" font-size="12" dy=".8em" y="30752.700000047684" x="614.5">https://blog.csdn.net/Sampson_S/article/details/106835889</text></g></g><g id="minder_node2312" display="none"><g id="node_expander2310" display="none" style="cursor: pointer;"><path id="kity_path_27452" fill="white" stroke="gray" d="M582.5,30768.5A6,6,0,1,1,570.5,30768.5A6,6,0,1,1,582.5,30768.5"></path><path id="kity_path_27453" fill="none" stroke="gray"></path></g><path id="node_outline2311" fill="none" stroke="none" d="M582.5,30759.5h189a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-189a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2311" fill="black"><text id="kity_text_13813" text-rendering="inherit" font-size="12" dy=".8em" y="30760.700000047684" x="582.5">知道spring bean单例的实现原理吗</text></g></g><g id="minder_node2313" display="none"><g id="node_expander2309" display="none" style="cursor: pointer;"><path id="kity_path_27449" fill="white" stroke="gray" d="M598.5,30768.5A6,6,0,1,1,586.5,30768.5A6,6,0,1,1,598.5,30768.5"></path><path id="kity_path_27450" fill="none" stroke="gray"></path></g><path id="node_outline2310" fill="none" stroke="none" d="M598.5,30732.5h1720a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1720a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text2310" fill="black"><text id="kity_text_13808" text-rendering="inherit" font-size="12" dy=".8em" y="30733.700000047684" x="598.5">1.Spring 对 Bean 实例的创建是采用单例注册表的方式进行实现的，创建Bean的时候 通过BeanDefinition 设置的是否单例属性，来判断该bean是否是单例，默认是单例的，而这个注册表的缓存是 ConcurrentHashMap 对象。并且被final修饰，其中获取单例的代码放置在同步块中。</text><text id="kity_text_13809" text-rendering="inherit" font-size="12" dy=".8em" y="30751.700000047684" x="598.5">他会先从singletonCache去检查单例缓存中是否有注册的单例。有就返回合适的bean，没有就再次检查单例注册表，如果真的为null不是正在创建才真正的去创建bean实例，然后向单例注册表注册创建的这个Bean实例。如果是正在创建就从二级缓存earlySingletonObjects（Map结构）获取，这个过程可能还有bean转换。</text><text id="kity_text_13810" text-rendering="inherit" font-size="12" dy=".8em" y="30769.700000047684" x="598.5">后续再次获取时，只需直接从缓存里获取即可。</text><text id="kity_text_13811" text-rendering="inherit" font-size="12" dy=".8em" y="30787.700000047684" x="598.5"> </text></g></g><g id="minder_node2314" display="none"><g id="node_expander2308" display="none" style="cursor: pointer;"><path id="kity_path_27446" fill="white" stroke="gray" d="M614.5,30768.5A6,6,0,1,1,602.5,30768.5A6,6,0,1,1,614.5,30768.5"></path><path id="kity_path_27447" fill="none" stroke="gray"></path></g><path id="node_outline2309" fill="none" stroke="none" d="M614.5,30741.5h369a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-369a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2309" fill="black"><text id="kity_text_13804" text-rendering="inherit" font-size="12" dy=".8em" y="30742.700000047684" x="614.5">https://cloud.tencent.com/developer/article/1593023</text><text id="kity_text_13805" text-rendering="inherit" font-size="12" dy=".8em" y="30760.700000047684" x="614.5">https://blog.csdn.net/u011305680/article/details/79717238</text><text id="kity_text_13806" text-rendering="inherit" font-size="12" dy=".8em" y="30778.700000047684" x="614.5">https://juejin.cn/post/6844904181451456526#heading-5</text></g><a id="kity_a_16958" xlink:href="http://www.tianxiaobo.com/2018/06/01/Spring-IOC-%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%8E%B7%E5%8F%96%E5%8D%95%E4%BE%8B-bean/" target="_blank" xlink:title="http://www.tianxiaobo.com/2018/06/01/Spring-IOC-%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%8E%B7%E5%8F%96%E5%8D%95%E4%BE%8B-bean/" style="cursor: pointer;"><path id="kity_path_16960" fill="rgba(255, 255, 255, 0)" stroke="none" d="M963.5,30757.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16959" fill="#666" stroke="none" d="M978.114,30773.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V30767.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C973.766,30764.571,975.168,30763.5,976.836,30763.5h1.278c2.116,0,3.834,1.716,3.834,3.834V30769.89C981.948,30772.008,980.23,30773.724,978.114,30773.724zM966.612,30768.612c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S976.265,30769.89,975.558,30769.89H967.89C967.185,30769.89,966.612,30769.319,966.612,30768.612zM964.056,30767.334V30769.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H965.334C963.216,30773.724,961.5,30772.008,961.5,30769.89V30767.334C961.5,30765.216,963.216,30763.5,965.334,30763.5h1.278c1.667,0,3.071,1.071,3.599,2.556H965.334C964.629,30766.056,964.056,30766.627,964.056,30767.334z"></path></a></g><g id="minder_node2315" display="none"><g id="node_expander2312" display="none" style="cursor: pointer;"><path id="kity_path_27458" fill="white" stroke="gray" d="M582.5,30776.5A6,6,0,1,1,570.5,30776.5A6,6,0,1,1,582.5,30776.5"></path><path id="kity_path_27459" fill="none" stroke="gray"></path></g><path id="node_outline2313" fill="none" stroke="none" d="M582.5,30767.5h153a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-153a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2313" fill="black"><text id="kity_text_13821" text-rendering="inherit" font-size="12" dy=".8em" y="30768.700000047684" x="582.5">知道spring bean的作用域吗</text></g></g><g id="minder_node2316" display="none"><g id="node_expander2311" display="none" style="cursor: pointer;"><path id="kity_path_27455" fill="white" stroke="gray" d="M598.5,30776.5A6,6,0,1,1,586.5,30776.5A6,6,0,1,1,598.5,30776.5"></path><path id="kity_path_27456" fill="none" stroke="gray"></path></g><path id="node_outline2312" fill="none" stroke="none" d="M598.5,30731.5h941a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-941a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text2312" fill="black"><text id="kity_text_13815" text-rendering="inherit" font-size="12" dy=".8em" y="30732.700000047684" x="598.5">1.singleton : bean在每个Spring ioc 容器中只有一个实例。spring默认的。</text><text id="kity_text_13816" text-rendering="inherit" font-size="12" dy=".8em" y="30750.700000047684" x="598.5">2.prototype：一个bean的定义可以有多个实例。每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例。频繁创建和销毁 bean 会带来很大的性能开销。</text><text id="kity_text_13817" text-rendering="inherit" font-size="12" dy=".8em" y="30768.700000047684" x="598.5">3.request(请求bean)：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。</text><text id="kity_text_13818" text-rendering="inherit" font-size="12" dy=".8em" y="30786.700000047684" x="598.5">4.session(会话bean)：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</text><text id="kity_text_13819" text-rendering="inherit" font-size="12" dy=".8em" y="30804.700000047684" x="598.5">5.global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</text></g></g><g id="minder_node2317" display="none"><g id="node_expander2315" display="none" style="cursor: pointer;"><path id="kity_path_27467" fill="white" stroke="gray" d="M582.5,30784.5A6,6,0,1,1,570.5,30784.5A6,6,0,1,1,582.5,30784.5"></path><path id="kity_path_27468" fill="none" stroke="gray"></path></g><path id="node_outline2316" fill="none" stroke="none" d="M582.5,30775.5h176a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-176a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2316" fill="black"><text id="kity_text_13827" text-rendering="inherit" font-size="12" dy=".8em" y="30776.700000047684" x="582.5">知道spring 中 创建对象的过程吗</text></g></g><g id="minder_node2318" display="none"><g id="node_expander2314" display="none" style="cursor: pointer;"><path id="kity_path_27464" fill="white" stroke="gray" d="M598.5,30784.5A6,6,0,1,1,586.5,30784.5A6,6,0,1,1,598.5,30784.5"></path><path id="kity_path_27465" fill="none" stroke="gray"></path></g><path id="node_outline2315" fill="none" stroke="none" d="M598.5,30775.5h424a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-424a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2315" fill="black"><text id="kity_text_13825" text-rendering="inherit" font-size="12" dy=".8em" y="30776.700000047684" x="598.5">1.就是ioc 启动流程 + bean生命周期，在容器启动时就会把单例对象实例化完成</text></g></g><g id="minder_node2319" display="none"><g id="node_expander2313" display="none" style="cursor: pointer;"><path id="kity_path_27461" fill="white" stroke="gray" d="M614.5,30784.5A6,6,0,1,1,602.5,30784.5A6,6,0,1,1,614.5,30784.5"></path><path id="kity_path_27462" fill="none" stroke="gray"></path></g><path id="node_outline2314" fill="none" stroke="none" d="M614.5,30775.5h306a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-306a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2314" fill="black"><text id="kity_text_13823" text-rendering="inherit" font-size="12" dy=".8em" y="30776.700000047684" x="614.5">https://cloud.tencent.com/developer/article/1593023</text></g></g><g id="minder_node2320" display="none"><g id="node_expander2317" display="none" style="cursor: pointer;"><path id="kity_path_27473" fill="white" stroke="gray" d="M582.5,30792.5A6,6,0,1,1,570.5,30792.5A6,6,0,1,1,582.5,30792.5"></path><path id="kity_path_27474" fill="none" stroke="gray"></path></g><path id="node_outline2318" fill="none" stroke="none" d="M582.5,30783.5h212a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-212a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2318" fill="black"><text id="kity_text_13833" text-rendering="inherit" font-size="12" dy=".8em" y="30784.700000047684" x="582.5">了解spring 单例bean的线程安全问题吗</text></g></g><g id="minder_node2321" display="none"><g id="node_expander2316" display="none" style="cursor: pointer;"><path id="kity_path_27470" fill="white" stroke="gray" d="M598.5,30792.5A6,6,0,1,1,586.5,30792.5A6,6,0,1,1,598.5,30792.5"></path><path id="kity_path_27471" fill="none" stroke="gray"></path></g><path id="node_outline2317" fill="none" stroke="none" d="M598.5,30765.5h1002a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1002a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2317" fill="black"><text id="kity_text_13829" text-rendering="inherit" font-size="12" dy=".8em" y="30766.700000047684" x="598.5">1.spring单例bean不是线程安全的，但是spring默认bean是单例模式</text><text id="kity_text_13830" text-rendering="inherit" font-size="12" dy=".8em" y="30784.700000047684" x="598.5">2.实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要自己去保证线程安全了，</text><text id="kity_text_13831" text-rendering="inherit" font-size="12" dy=".8em" y="30802.700000047684" x="598.5">最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</text></g></g><g id="minder_node2322" display="none"><g id="node_expander2320" display="none" style="cursor: pointer;"><path id="kity_path_27482" fill="white" stroke="gray" d="M582.5,30800.5A6,6,0,1,1,570.5,30800.5A6,6,0,1,1,582.5,30800.5"></path><path id="kity_path_27483" fill="none" stroke="gray"></path></g><path id="node_outline2321" fill="none" stroke="none" d="M582.5,30791.5h186a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-186a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2321" fill="black"><text id="kity_text_13840" text-rendering="inherit" font-size="12" dy=".8em" y="30792.700000047684" x="582.5">那单例bean线程安全问题怎么解决</text></g></g><g id="minder_node2323" display="none"><g id="node_expander2319" display="none" style="cursor: pointer;"><path id="kity_path_27479" fill="white" stroke="gray" d="M598.5,30800.5A6,6,0,1,1,586.5,30800.5A6,6,0,1,1,598.5,30800.5"></path><path id="kity_path_27480" fill="none" stroke="gray"></path></g><path id="node_outline2320" fill="none" stroke="none" d="M598.5,30782.5h953a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-953a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2320" fill="black"><text id="kity_text_13837" text-rendering="inherit" font-size="12" dy=".8em" y="30783.700000047684" x="598.5">1.像一些有状态的bean&#xa0; spring 通过 ThreadLocal来标志安全 Spring对一些Bean中非线程安全状态采用ThreadLocal进行处理，解决线程安全问题。</text><text id="kity_text_13838" text-rendering="inherit" font-size="12" dy=".8em" y="30801.700000047684" x="598.5">使用 threadLocal 进行处理，ThreadLocal 是线程本地变量，每个线程拥有变量的一个独立副本，隔离了多个线程对数据的访问冲突，所以各个线程之间互不影响，保证了线程安全</text></g></g><g id="minder_node2324" display="none"><g id="node_expander2318" display="none" style="cursor: pointer;"><path id="kity_path_27476" fill="white" stroke="gray" d="M614.5,30800.5A6,6,0,1,1,602.5,30800.5A6,6,0,1,1,614.5,30800.5"></path><path id="kity_path_27477" fill="none" stroke="gray"></path></g><path id="node_outline2319" fill="none" stroke="none" d="M614.5,30791.5h240a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-240a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2319" fill="black"><text id="kity_text_13835" text-rendering="inherit" font-size="12" dy=".8em" y="30792.700000047684" x="614.5">https://www.jianshu.com/p/e04491f3550f</text></g></g><g id="minder_node2325" display="none"><g id="node_expander2322" display="none" style="cursor: pointer;"><path id="kity_path_27488" fill="white" stroke="gray" d="M582.5,30808.5A6,6,0,1,1,570.5,30808.5A6,6,0,1,1,582.5,30808.5"></path><path id="kity_path_27489" fill="none" stroke="gray"></path></g><path id="node_outline2323" fill="none" stroke="none" d="M582.5,30799.5h168a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-168a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2323" fill="black"><text id="kity_text_13844" text-rendering="inherit" font-size="12" dy=".8em" y="30800.700000047684" x="582.5">spring怎么解决并发安全问题？</text></g></g><g id="minder_node2326" display="none"><g id="node_expander2321" display="none" style="cursor: pointer;"><path id="kity_path_27485" fill="white" stroke="gray" d="M598.5,30808.5A6,6,0,1,1,586.5,30808.5A6,6,0,1,1,598.5,30808.5"></path><path id="kity_path_27486" fill="none" stroke="gray"></path></g><path id="node_outline2322" fill="none" stroke="none" d="M598.5,30799.5h95a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-95a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2322" fill="black"><text id="kity_text_13842" text-rendering="inherit" font-size="12" dy=".8em" y="30800.700000047684" x="598.5">1.和上面问题一样</text></g></g><g id="minder_node2327" display="none"><g id="node_expander2324" display="none" style="cursor: pointer;"><path id="kity_path_27494" fill="white" stroke="gray" d="M582.5,30816.5A6,6,0,1,1,570.5,30816.5A6,6,0,1,1,582.5,30816.5"></path><path id="kity_path_27495" fill="none" stroke="gray"></path></g><path id="node_outline2325" fill="none" stroke="none" d="M582.5,30807.5h249a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-249a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2325" fill="black"><text id="kity_text_13850" text-rendering="inherit" font-size="12" dy=".8em" y="30808.700000047684" x="582.5">知道autowird这个bean注入过程是怎么样的吗</text></g></g><g id="minder_node2328" display="none"><g id="node_expander2323" display="none" style="cursor: pointer;"><path id="kity_path_27491" fill="white" stroke="gray" d="M598.5,30816.5A6,6,0,1,1,586.5,30816.5A6,6,0,1,1,598.5,30816.5"></path><path id="kity_path_27492" fill="none" stroke="gray"></path></g><path id="node_outline2324" fill="none" stroke="none" d="M598.5,30789.5h1574a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1574a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2324" fill="black"><text id="kity_text_13846" text-rendering="inherit" font-size="12" dy=".8em" y="30790.700000047684" x="598.5">1.@Autowired自动装配，在启动spring IOC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，然后被注册到ioc容器中，</text><text id="kity_text_13847" text-rendering="inherit" font-size="12" dy=".8em" y="30808.700000047684" x="598.5">当容器扫描到@Autowied、@Resource ， 就会在IOC容器自动查找需要的bean，并装配给该对象的属性，如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据，如果查询的结果不止一个，那么@Autowired会根据名称来查找；如果为空就报错，解决就是设置required=false。</text><text id="kity_text_13848" text-rendering="inherit" font-size="12" dy=".8em" y="30826.700000047684" x="598.5">2.而扫描过程中，autowire注解后置处理器会把bean依赖信息封装起来 当bean 实例化和初始化 时负责注入进来</text></g></g><g id="minder_node2329" display="none"><g id="node_expander2326" display="none" style="cursor: pointer;"><path id="kity_path_27500" fill="white" stroke="gray" d="M582.5,30824.5A6,6,0,1,1,570.5,30824.5A6,6,0,1,1,582.5,30824.5"></path><path id="kity_path_27501" fill="none" stroke="gray"></path></g><path id="node_outline2327" fill="none" stroke="none" d="M582.5,30815.5h247a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-247a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2327" fill="black"><text id="kity_text_13854" text-rendering="inherit" font-size="12" dy=".8em" y="30816.700000047684" x="582.5">知道resource这个bean注入过程是怎么样的吗</text></g></g><g id="minder_node2330" display="none"><g id="node_expander2325" display="none" style="cursor: pointer;"><path id="kity_path_27497" fill="white" stroke="gray" d="M598.5,30824.5A6,6,0,1,1,586.5,30824.5A6,6,0,1,1,598.5,30824.5"></path><path id="kity_path_27498" fill="none" stroke="gray"></path></g><path id="node_outline2326" fill="none" stroke="none" d="M598.5,30815.5h71a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-71a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2326" fill="black"><text id="kity_text_13852" text-rendering="inherit" font-size="12" dy=".8em" y="30816.700000047684" x="598.5">1.和上面一样</text></g></g><g id="minder_node2331" display="none"><g id="node_expander2329" display="none" style="cursor: pointer;"><path id="kity_path_27509" fill="white" stroke="gray" d="M582.5,30832.5A6,6,0,1,1,570.5,30832.5A6,6,0,1,1,582.5,30832.5"></path><path id="kity_path_27510" fill="none" stroke="gray"></path></g><path id="node_outline2330" fill="none" stroke="none" d="M582.5,30823.5h257a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-257a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2330" fill="black"><text id="kity_text_13862" text-rendering="inherit" font-size="12" dy=".8em" y="30824.700000047684" x="582.5">bean初始化前、中、后想执行一些代码怎么办？</text></g></g><g id="minder_node2332" display="none"><g id="node_expander2328" display="none" style="cursor: pointer;"><path id="kity_path_27506" fill="white" stroke="gray" d="M598.5,30832.5A6,6,0,1,1,586.5,30832.5A6,6,0,1,1,598.5,30832.5"></path><path id="kity_path_27507" fill="none" stroke="gray"></path></g><path id="node_outline2329" fill="none" stroke="none" d="M598.5,30814.5h1182a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1182a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2329" fill="black"><text id="kity_text_13859" text-rendering="inherit" font-size="12" dy=".8em" y="30815.700000047684" x="598.5">1.利用自定义后置处理器， 自定义PostProcessor实现BeanPostProcessor接口 实现接口中的&#xa0; postProcessBeforeInitialization（bean初始化前执行的方法） ，postProcessAfterInitialization（bean初始化后执行的方法）</text><text id="kity_text_13860" text-rendering="inherit" font-size="12" dy=".8em" y="30833.700000047684" x="598.5">2.可以实现 ioc容器创建bean时 增加我们自定义处理逻辑，</text></g></g><g id="minder_node2333" display="none"><g id="node_expander2327" display="none" style="cursor: pointer;"><path id="kity_path_27503" fill="white" stroke="gray" d="M614.5,30832.5A6,6,0,1,1,602.5,30832.5A6,6,0,1,1,614.5,30832.5"></path><path id="kity_path_27504" fill="none" stroke="gray"></path></g><path id="node_outline2328" fill="none" stroke="none" d="M614.5,30814.5h346a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-346a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2328" fill="black"><text id="kity_text_13856" text-rendering="inherit" font-size="12" dy=".8em" y="30815.700000047684" x="614.5">https://www.cnblogs.com/tuyang1129/p/12866484.html</text><text id="kity_text_13857" text-rendering="inherit" font-size="12" dy=".8em" y="30833.700000047684" x="614.5">https://blog.csdn.net/qq_30908729/article/details/94614359</text></g></g><g id="minder_node2334" display="none"><g id="node_expander2359" display="none" style="cursor: pointer;"><path id="kity_path_27599" fill="white" stroke="gray" d="M566.5,30840.5A6,6,0,1,1,554.5,30840.5A6,6,0,1,1,566.5,30840.5"></path><path id="kity_path_27600" fill="none" stroke="gray"></path></g><path id="node_outline2360" fill="none" stroke="none" d="M566.5,30831.5h27a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-27a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2360" fill="black"><text id="kity_text_13952" text-rendering="inherit" font-size="12" dy=".8em" y="30832.700000047684" x="566.5">AOP</text></g></g><g id="minder_node2335" display="none"><g id="node_expander2332" display="none" style="cursor: pointer;"><path id="kity_path_27518" fill="white" stroke="gray" d="M582.5,30760.5A6,6,0,1,1,570.5,30760.5A6,6,0,1,1,582.5,30760.5"></path><path id="kity_path_27519" fill="none" stroke="gray"></path></g><path id="node_outline2333" fill="none" stroke="none" d="M582.5,30751.5h99a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-99a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2333" fill="black"><text id="kity_text_13870" text-rendering="inherit" font-size="12" dy=".8em" y="30752.700000047684" x="582.5">说一下spring aop</text></g></g><g id="minder_node2336" display="none"><g id="node_expander2331" display="none" style="cursor: pointer;"><path id="kity_path_27515" fill="white" stroke="gray" d="M598.5,30760.5A6,6,0,1,1,586.5,30760.5A6,6,0,1,1,598.5,30760.5"></path><path id="kity_path_27516" fill="none" stroke="gray"></path></g><path id="node_outline2332" fill="none" stroke="none" d="M598.5,30733.5h1356a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1356a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2332" fill="black"><text id="kity_text_13866" text-rendering="inherit" font-size="12" dy=".8em" y="30734.700000047684" x="598.5">1.spring aop本质是通过动态代理和反射实现运行时生成 AOP 代理类，这个动态代理主要是不会去修改字节码，而是在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法</text><text id="kity_text_13867" text-rendering="inherit" font-size="12" dy=".8em" y="30752.700000047684" x="598.5">基于AOP不会破坏原来程序逻辑，因此它可以很好的对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</text><text id="kity_text_13868" text-rendering="inherit" font-size="12" dy=".8em" y="30770.700000047684" x="598.5">2.缺点：由于 Spring AOP 需要在每次运行时生成 AOP 代理，性能略差一些。</text></g></g><g id="minder_node2337" display="none"><g id="node_expander2334" display="none" style="cursor: pointer;"><path id="kity_path_27524" fill="white" stroke="gray" d="M582.5,30768.5A6,6,0,1,1,570.5,30768.5A6,6,0,1,1,582.5,30768.5"></path><path id="kity_path_27525" fill="none" stroke="gray"></path></g><path id="node_outline2335" fill="none" stroke="none" d="M582.5,30759.5h134a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-134a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2335" fill="black"><text id="kity_text_13875" text-rendering="inherit" font-size="12" dy=".8em" y="30760.700000047684" x="582.5">spring aop你怎么理解？</text></g></g><g id="minder_node2338" display="none"><g id="node_expander2333" display="none" style="cursor: pointer;"><path id="kity_path_27521" fill="white" stroke="gray" d="M598.5,30768.5A6,6,0,1,1,586.5,30768.5A6,6,0,1,1,598.5,30768.5"></path><path id="kity_path_27522" fill="none" stroke="gray"></path></g><path id="node_outline2334" fill="none" stroke="none" d="M598.5,30750.5h1806a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1806a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2334" fill="black"><text id="kity_text_13872" text-rendering="inherit" font-size="12" dy=".8em" y="30751.700000047684" x="598.5">1.首先需要定义一个切面，这个切面是一个类，里面的方法就是关注点(也是通知)，或者说里面的方法就是用来在执行目标对象方法时需要执行的前置通知，后置通知，异常通知，最终通知，环绕通知等等。</text><text id="kity_text_13873" text-rendering="inherit" font-size="12" dy=".8em" y="30769.700000047684" x="598.5">2.有了切面和通知，要应用到目标对象，就需要定义这些通知的切入点，换句话说就是需要对哪些方法进行拦截，就是去匹配，而这些被拦截的方法就是连接点，所谓连接点也就是在动态执行过程，被织入切面的方法(至少在spring中只能对方法进行拦截)。在动态过程中通知的执行就属于织入过程，而被织入这些通知的对象就是目标对象了。</text></g></g><g id="minder_node2339" display="none"><g id="node_expander2338" display="none" style="cursor: pointer;"><path id="kity_path_27536" fill="white" stroke="gray" d="M582.5,30776.5A6,6,0,1,1,570.5,30776.5A6,6,0,1,1,582.5,30776.5"></path><path id="kity_path_27537" fill="none" stroke="gray"></path></g><path id="node_outline2339" fill="none" stroke="none" d="M582.5,30767.5h170a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-170a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2339" fill="black"><text id="kity_text_13889" text-rendering="inherit" font-size="12" dy=".8em" y="30768.700000047684" x="582.5">spring aop是怎么创建代理的？</text></g></g><g id="minder_node2340" display="none"><g id="node_expander2335" display="none" style="cursor: pointer;"><path id="kity_path_27527" fill="white" stroke="gray" d="M598.5,30768.5A6,6,0,1,1,586.5,30768.5A6,6,0,1,1,598.5,30768.5"></path><path id="kity_path_27528" fill="none" stroke="gray"></path></g><path id="node_outline2336" fill="none" stroke="none" d="M598.5,30741.5h1057a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1057a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2336" fill="black"><text id="kity_text_13877" text-rendering="inherit" font-size="12" dy=".8em" y="30742.700000047684" x="598.5">从流程节度</text><text id="kity_text_13878" text-rendering="inherit" font-size="12" dy=".8em" y="30760.700000047684" x="598.5">1.IoC容器在实例化bean之前，其实是有先判断bean是否需要增强，主要是通过resolveBeforeInstantiation方法，它会先判断是否需要创建代理，如果不需要才会创建bean，否则创建的是代理对象。</text><text id="kity_text_13879" text-rendering="inherit" font-size="12" dy=".8em" y="30778.700000047684" x="598.5">2.这个方法内部其实是调用Bean后置处理器来作为拦截器，拦截Bean实例化阶段，不是初始化阶段，然后调用回调方法生成bean对象</text></g></g><g id="minder_node2341" display="none"><g id="node_expander2337" display="none" style="cursor: pointer;"><path id="kity_path_27533" fill="white" stroke="gray" d="M598.5,30776.5A6,6,0,1,1,586.5,30776.5A6,6,0,1,1,598.5,30776.5"></path><path id="kity_path_27534" fill="none" stroke="gray"></path></g><path id="node_outline2338" fill="none" stroke="none" d="M598.5,30731.5h1471a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1471a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text2338" fill="black"><text id="kity_text_13883" text-rendering="inherit" font-size="12" dy=".8em" y="30732.700000047684" x="598.5">从使用aop的节度</text><text id="kity_text_13884" text-rendering="inherit" font-size="12" dy=".8em" y="30750.700000047684" x="598.5">1.一般使用会写一个@Aspect注解的切面类，并使用@EnableAspectJAutoProxy注解启用代理。它内部是导入了一个类AspectJAutoProxyRegistrar到Spring容器，这个类是BeanDefinitionRegistrar类 它会在会在解析配置类的时候调用registerBeanDefinitions方法。</text><text id="kity_text_13885" text-rendering="inherit" font-size="12" dy=".8em" y="30768.700000047684" x="598.5">而这个方法会向容器中注入一个AnnotationAwareAspectJAutoProxyCreator类的Bean定义。他实质上是BeanPostProcessor后置处理器，一个拦截器，</text><text id="kity_text_13886" text-rendering="inherit" font-size="12" dy=".8em" y="30786.700000047684" x="598.5">2.也就是说实例化bean时现执行InstantiationAwareBeanPostProcessor，如果有返回对象代理对象，则使用该对象，否则才去创建实例。使用@EnableAspectJAutoProxy注解的作用就是向容器中添加一个BeanPostProcessor后置处理器类，拦截bean的创建并生成代理对象。</text><text id="kity_text_13887" text-rendering="inherit" font-size="12" dy=".8em" y="30804.700000047684" x="598.5">3.这个拦截器会在创建一个代理对象后返回，而具体创建是通过createProxy 有两种方式创建，如果该类是接口，则使用JDK动态代理，否则使用的是Cglib代理。</text></g></g><g id="minder_node2342" display="none"><g id="node_expander2336" display="none" style="cursor: pointer;"><path id="kity_path_27530" fill="white" stroke="gray" d="M614.5,30776.5A6,6,0,1,1,602.5,30776.5A6,6,0,1,1,614.5,30776.5"></path><path id="kity_path_27531" fill="none" stroke="gray"></path></g><path id="node_outline2337" fill="none" stroke="none" d="M614.5,30767.5h326a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2337" fill="black"><text id="kity_text_13881" text-rendering="inherit" font-size="12" dy=".8em" y="30768.700000047684" x="614.5">https://juejin.cn/post/6847902217777709063#heading-6</text></g></g><g id="minder_node2343" display="none"><g id="node_expander2340" display="none" style="cursor: pointer;"><path id="kity_path_27542" fill="white" stroke="gray" d="M582.5,30784.5A6,6,0,1,1,570.5,30784.5A6,6,0,1,1,582.5,30784.5"></path><path id="kity_path_27543" fill="none" stroke="gray"></path></g><path id="node_outline2341" fill="none" stroke="none" d="M582.5,30775.5h166a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-166a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2341" fill="black"><text id="kity_text_13897" text-rendering="inherit" font-size="12" dy=".8em" y="30776.700000047684" x="582.5">spring的aop是基于什么实现的</text></g></g><g id="minder_node2344" display="none"><g id="node_expander2339" display="none" style="cursor: pointer;"><path id="kity_path_27539" fill="white" stroke="gray" d="M598.5,30784.5A6,6,0,1,1,586.5,30784.5A6,6,0,1,1,598.5,30784.5"></path><path id="kity_path_27540" fill="none" stroke="gray"></path></g><path id="node_outline2340" fill="none" stroke="none" d="M598.5,30739.5h997a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-997a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text2340" fill="black"><text id="kity_text_13891" text-rendering="inherit" font-size="12" dy=".8em" y="30740.700000047684" x="598.5">1.基于动态代理和反射，而aop动态代理又分为两种，JDK动态代理和CGLIB动态代理。</text><text id="kity_text_13892" text-rendering="inherit" font-size="12" dy=".8em" y="30758.700000047684" x="598.5">2.JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。</text><text id="kity_text_13893" text-rendering="inherit" font-size="12" dy=".8em" y="30776.700000047684" x="598.5">3.如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB是一个代码生成的类库，可以在运行时动态的生成某个类的子类（通过修改字节码来实现代理）。</text><text id="kity_text_13894" text-rendering="inherit" font-size="12" dy=".8em" y="30794.700000047684" x="598.5">CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</text><text id="kity_text_13895" text-rendering="inherit" font-size="12" dy=".8em" y="30812.700000047684" x="598.5">jdk和cglib动态代理来共同实现我们的aop面向切面的功能。</text></g></g><g id="minder_node2345" display="none"><g id="node_expander2343" display="none" style="cursor: pointer;"><path id="kity_path_27551" fill="white" stroke="gray" d="M582.5,30792.5A6,6,0,1,1,570.5,30792.5A6,6,0,1,1,582.5,30792.5"></path><path id="kity_path_27552" fill="none" stroke="gray"></path></g><path id="node_outline2344" fill="none" stroke="none" d="M582.5,30783.5h60a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-60a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2344" fill="black"><text id="kity_text_13903" text-rendering="inherit" font-size="12" dy=".8em" y="30784.700000047684" x="582.5">动态代理？</text></g></g><g id="minder_node2346" display="none"><g id="node_expander2342" display="none" style="cursor: pointer;"><path id="kity_path_27548" fill="white" stroke="gray" d="M598.5,30792.5A6,6,0,1,1,586.5,30792.5A6,6,0,1,1,598.5,30792.5"></path><path id="kity_path_27549" fill="none" stroke="gray"></path></g><path id="node_outline2343" fill="none" stroke="none" d="M598.5,30783.5h552a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-552a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2343" fill="black"><text id="kity_text_13901" text-rendering="inherit" font-size="12" dy=".8em" y="30784.700000047684" x="598.5">1.动态代理就是在加载目标类后，JVM运行期间动态生成目标类的代理类，将你要增强的切面织入代理类</text></g></g><g id="minder_node2347" display="none"><g id="node_expander2341" display="none" style="cursor: pointer;"><path id="kity_path_27545" fill="white" stroke="gray" d="M614.5,30792.5A6,6,0,1,1,602.5,30792.5A6,6,0,1,1,614.5,30792.5"></path><path id="kity_path_27546" fill="none" stroke="gray"></path></g><path id="node_outline2342" fill="none" stroke="none" d="M614.5,30783.5h244a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-244a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2342" fill="black"><text id="kity_text_13899" text-rendering="inherit" font-size="12" dy=".8em" y="30784.700000047684" x="614.5">https://www.jianshu.com/p/8176214e50e2</text></g></g><g id="minder_node2348" display="none"><g id="node_expander2346" display="none" style="cursor: pointer;"><path id="kity_path_27560" fill="white" stroke="gray" d="M582.5,30800.5A6,6,0,1,1,570.5,30800.5A6,6,0,1,1,582.5,30800.5"></path><path id="kity_path_27561" fill="none" stroke="gray"></path></g><path id="node_outline2347" fill="none" stroke="none" d="M582.5,30791.5h359a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-359a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2347" fill="black"><text id="kity_text_13915" text-rendering="inherit" font-size="12" dy=".8em" y="30792.700000047684" x="582.5">你说了jdk动态代理和cglib，那你说说他们的区别，再说说他们原理</text></g></g><g id="minder_node2349" display="none"><g id="node_expander2345" display="none" style="cursor: pointer;"><path id="kity_path_27557" fill="white" stroke="gray" d="M598.5,30800.5A6,6,0,1,1,586.5,30800.5A6,6,0,1,1,598.5,30800.5"></path><path id="kity_path_27558" fill="none" stroke="gray"></path></g><path id="node_outline2346" fill="none" stroke="none" d="M598.5,30737.5h1282a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-1282a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text2346" fill="black"><text id="kity_text_13907" text-rendering="inherit" font-size="12" dy=".8em" y="30738.700000047684" x="598.5">1.看java 进阶 代理&#xa0; 一样的问题</text><text id="kity_text_13908" text-rendering="inherit" font-size="12" dy=".8em" y="30756.700000047684" x="598.5">2.</text><text id="kity_text_13909" text-rendering="inherit" font-size="12" dy=".8em" y="30774.700000047684" x="598.5">JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；</text><text id="kity_text_13910" text-rendering="inherit" font-size="12" dy=".8em" y="30792.700000047684" x="598.5">接着，Proxy类利用 InvocationHandler动态创建一个符合某一接口的的实例, 生成目标类的代理对象，然后调用增强方法即可。</text><text id="kity_text_13911" text-rendering="inherit" font-size="12" dy=".8em" y="30810.700000047684" x="598.5">3.</text><text id="kity_text_13912" text-rendering="inherit" font-size="12" dy=".8em" y="30828.700000047684" x="598.5">如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB，是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。</text><text id="kity_text_13913" text-rendering="inherit" font-size="12" dy=".8em" y="30846.700000047684" x="598.5">CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</text></g></g><g id="minder_node2350" display="none"><g id="node_expander2344" display="none" style="cursor: pointer;"><path id="kity_path_27554" fill="white" stroke="gray" d="M614.5,30800.5A6,6,0,1,1,602.5,30800.5A6,6,0,1,1,614.5,30800.5"></path><path id="kity_path_27555" fill="none" stroke="gray"></path></g><path id="node_outline2345" fill="none" stroke="none" d="M614.5,30786.5h79a5,5,0,0,1,5,5v18a5,5,0,0,1,-5,5h-79a5,5,0,0,1,-5,-5v-18a5,5,0,0,1,5,-5z"></path><g id="node_text2345" fill="black"><text id="kity_text_13905" text-rendering="inherit" font-size="12" dy=".8em" y="30792.700000047684" x="614.5">分支主题</text></g><a id="kity_a_16961" xlink:href="https://juejin.cn/post/6844903762025250824#heading-0" target="_blank" xlink:title="https://juejin.cn/post/6844903762025250824#heading-0" style="cursor: pointer;"><path id="kity_path_16963" fill="rgba(255, 255, 255, 0)" stroke="none" d="M673.5,30789.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16962" fill="#666" stroke="none" d="M688.114,30805.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V30799.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C683.766,30796.571,685.168,30795.5,686.836,30795.5h1.278c2.116,0,3.834,1.716,3.834,3.834V30801.89C691.948,30804.008,690.23,30805.724,688.114,30805.724zM676.612,30800.612c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S686.265,30801.89,685.558,30801.89H677.89C677.185,30801.89,676.612,30801.319,676.612,30800.612zM674.056,30799.334V30801.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H675.334C673.216,30805.724,671.5,30804.008,671.5,30801.89V30799.334C671.5,30797.216,673.216,30795.5,675.334,30795.5h1.278c1.667,0,3.071,1.071,3.599,2.556H675.334C674.629,30798.056,674.056,30798.627,674.056,30799.334z"></path></a></g><g id="minder_node2351" display="none"><g id="node_expander2348" display="none" style="cursor: pointer;"><path id="kity_path_27566" fill="white" stroke="gray" d="M582.5,30808.5A6,6,0,1,1,570.5,30808.5A6,6,0,1,1,582.5,30808.5"></path><path id="kity_path_27567" fill="none" stroke="gray"></path></g><path id="node_outline2349" fill="none" stroke="none" d="M582.5,30799.5h180a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-180a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2349" fill="black"><text id="kity_text_13920" text-rendering="inherit" font-size="12" dy=".8em" y="30800.700000047684" x="582.5">你用aop了解决项目中的什么问题</text></g></g><g id="minder_node2352" display="none"><g id="node_expander2347" display="none" style="cursor: pointer;"><path id="kity_path_27563" fill="white" stroke="gray" d="M598.5,30808.5A6,6,0,1,1,586.5,30808.5A6,6,0,1,1,598.5,30808.5"></path><path id="kity_path_27564" fill="none" stroke="gray"></path></g><path id="node_outline2348" fill="none" stroke="none" d="M598.5,30790.5h1009a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1009a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2348" fill="black"><text id="kity_text_13917" text-rendering="inherit" font-size="12" dy=".8em" y="30791.700000047684" x="598.5">1.日志，在我们的xx模块，然后根据xx的业务不同就行不同的业务日志处理，但是这里面公共的我们提取出来，然后就行了日志记录和有时侯人工对账用</text><text id="kity_text_13918" text-rendering="inherit" font-size="12" dy=".8em" y="30809.700000047684" x="598.5">2.事务，spring 声明式事务就是aop实现的，通过注解Transactional 可以实现。AOP做事务处理 一般在＂事务方法＂前打开一个事务，离开方法后提交事务，方法抛出异常时对事务进行回滚</text></g></g><g id="minder_node2353" display="none"><g id="node_expander2351" display="none" style="cursor: pointer;"><path id="kity_path_27575" fill="white" stroke="gray" d="M582.5,30816.5A6,6,0,1,1,570.5,30816.5A6,6,0,1,1,582.5,30816.5"></path><path id="kity_path_27576" fill="none" stroke="gray"></path></g><path id="node_outline2352" fill="none" stroke="none" d="M582.5,30807.5h106a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-106a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2352" fill="black"><text id="kity_text_13926" text-rendering="inherit" font-size="12" dy=".8em" y="30808.700000047684" x="582.5">aop有哪些应用场景</text></g></g><g id="minder_node2354" display="none"><g id="node_expander2350" display="none" style="cursor: pointer;"><path id="kity_path_27572" fill="white" stroke="gray" d="M598.5,30816.5A6,6,0,1,1,586.5,30816.5A6,6,0,1,1,598.5,30816.5"></path><path id="kity_path_27573" fill="none" stroke="gray"></path></g><path id="node_outline2351" fill="none" stroke="none" d="M598.5,30807.5h298a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-298a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2351" fill="black"><text id="kity_text_13924" text-rendering="inherit" font-size="12" dy=".8em" y="30808.700000047684" x="598.5">1.缓存，统一事务处理，统一日志处理，方法错误处理，</text></g></g><g id="minder_node2355" display="none"><g id="node_expander2349" display="none" style="cursor: pointer;"><path id="kity_path_27569" fill="white" stroke="gray" d="M614.5,30816.5A6,6,0,1,1,602.5,30816.5A6,6,0,1,1,614.5,30816.5"></path><path id="kity_path_27570" fill="none" stroke="gray"></path></g><path id="node_outline2350" fill="none" stroke="none" d="M614.5,30807.5h231a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-231a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2350" fill="black"><text id="kity_text_13922" text-rendering="inherit" font-size="12" dy=".8em" y="30808.700000047684" x="614.5">https://zhuanlan.zhihu.com/p/39196982</text></g></g><g id="minder_node2356" display="none"><g id="node_expander2354" display="none" style="cursor: pointer;"><path id="kity_path_27584" fill="white" stroke="gray" d="M582.5,30824.5A6,6,0,1,1,570.5,30824.5A6,6,0,1,1,582.5,30824.5"></path><path id="kity_path_27585" fill="none" stroke="gray"></path></g><path id="node_outline2355" fill="none" stroke="none" d="M582.5,30815.5h293a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-293a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2355" fill="black"><text id="kity_text_13936" text-rendering="inherit" font-size="12" dy=".8em" y="30816.700000047684" x="582.5">知道aop中的PointCut吗，怎么理解？，joinpoiot呢？</text></g></g><g id="minder_node2357" display="none"><g id="node_expander2353" display="none" style="cursor: pointer;"><path id="kity_path_27581" fill="white" stroke="gray" d="M598.5,30824.5A6,6,0,1,1,586.5,30824.5A6,6,0,1,1,598.5,30824.5"></path><path id="kity_path_27582" fill="none" stroke="gray"></path></g><path id="node_outline2354" fill="none" stroke="none" d="M598.5,30797.5h1440a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1440a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2354" fill="black"><text id="kity_text_13932" text-rendering="inherit" font-size="12" dy=".8em" y="30798.700000047684" x="598.5">1.连接点，连接点是在应用执行过程中能够插入切面的一个点，一个对象有多个方法，每个方法的执行相当于一个连接点，这些连接点也叫拦截点，而切面代码就可以根据这些连接点插入到正常代码流程中，添加一些行为</text><text id="kity_text_13933" text-rendering="inherit" font-size="12" dy=".8em" y="30816.700000047684" x="598.5">2.切入点，通过定义一个切入点，然后在其前后切入不同的执行具体内容，比如常见的有：打开数据库连接/关闭数据库连接、打开事务/关闭事务、记录日志等。切入点是一个匹配连接点的断言或者正则表达式 和切入点表达式语言，然后通知所要切入的一个或多个连接点。</text><text id="kity_text_13934" text-rendering="inherit" font-size="12" dy=".8em" y="30834.700000047684" x="598.5">比如说一个方法A是切入点，也就是说在执行A会执行横切的功能，具体的切入时机和通知有关</text></g></g><g id="minder_node2358" display="none"><g id="node_expander2352" display="none" style="cursor: pointer;"><path id="kity_path_27578" fill="white" stroke="gray" d="M614.5,30824.5A6,6,0,1,1,602.5,30824.5A6,6,0,1,1,614.5,30824.5"></path><path id="kity_path_27579" fill="none" stroke="gray"></path></g><path id="node_outline2353" fill="none" stroke="none" d="M614.5,30797.5h350a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-350a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2353" fill="black"><text id="kity_text_13928" text-rendering="inherit" font-size="12" dy=".8em" y="30798.700000047684" x="614.5">https://blog.csdn.net/jordandandan/article/details/50274423</text><text id="kity_text_13929" text-rendering="inherit" font-size="12" dy=".8em" y="30816.700000047684" x="614.5">https://juejin.cn/post/6844903945861595143</text><text id="kity_text_13930" text-rendering="inherit" font-size="12" dy=".8em" y="30834.700000047684" x="614.5">https://my.oschina.net/u/2474629/blog/1083448</text></g></g><g id="minder_node2359" display="none"><g id="node_expander2356" display="none" style="cursor: pointer;"><path id="kity_path_27590" fill="white" stroke="gray" d="M582.5,30832.5A6,6,0,1,1,570.5,30832.5A6,6,0,1,1,582.5,30832.5"></path><path id="kity_path_27591" fill="none" stroke="gray"></path></g><path id="node_outline2357" fill="none" stroke="none" d="M582.5,30823.5h73a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-73a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2357" fill="black"><text id="kity_text_13945" text-rendering="inherit" font-size="12" dy=".8em" y="30824.700000047684" x="582.5">通知有哪些？</text></g></g><g id="minder_node2360" display="none"><g id="node_expander2355" display="none" style="cursor: pointer;"><path id="kity_path_27587" fill="white" stroke="gray" d="M598.5,30832.5A6,6,0,1,1,586.5,30832.5A6,6,0,1,1,598.5,30832.5"></path><path id="kity_path_27588" fill="none" stroke="gray"></path></g><path id="node_outline2356" fill="none" stroke="none" d="M598.5,30778.5h305a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-305a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text2356" fill="black"><text id="kity_text_13938" text-rendering="inherit" font-size="12" dy=".8em" y="30779.700000047684" x="598.5">拦截到joinpoint之后所要做的事情就是通知</text><text id="kity_text_13939" text-rendering="inherit" font-size="12" dy=".8em" y="30797.700000047684" x="598.5">1.Before（前置通知） 目标方法调用之前执行</text><text id="kity_text_13940" text-rendering="inherit" font-size="12" dy=".8em" y="30815.700000047684" x="598.5">2.After（后置通知） 目标方法调用之后执行</text><text id="kity_text_13941" text-rendering="inherit" font-size="12" dy=".8em" y="30833.700000047684" x="598.5">3.After-returning（返回通知） 目标方法执行成功后执行</text><text id="kity_text_13942" text-rendering="inherit" font-size="12" dy=".8em" y="30851.700000047684" x="598.5">4.After-throwing（异常通知） 目标方法抛出异常后执行</text><text id="kity_text_13943" text-rendering="inherit" font-size="12" dy=".8em" y="30869.700000047684" x="598.5">5.Around（环绕通知） 相当于合并了前置和后置</text></g></g><g id="minder_node2361" display="none"><g id="node_expander2358" display="none" style="cursor: pointer;"><path id="kity_path_27596" fill="white" stroke="gray" d="M582.5,30840.5A6,6,0,1,1,570.5,30840.5A6,6,0,1,1,582.5,30840.5"></path><path id="kity_path_27597" fill="none" stroke="gray"></path></g><path id="node_outline2359" fill="none" stroke="none" d="M582.5,30831.5h246a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-246a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2359" fill="black"><text id="kity_text_13950" text-rendering="inherit" font-size="12" dy=".8em" y="30832.700000047684" x="582.5">joinpoint对象和pointcut注解这两个知道吗，</text></g></g><g id="minder_node2362" display="none"><g id="node_expander2357" display="none" style="cursor: pointer;"><path id="kity_path_27593" fill="white" stroke="gray" d="M598.5,30840.5A6,6,0,1,1,586.5,30840.5A6,6,0,1,1,598.5,30840.5"></path><path id="kity_path_27594" fill="none" stroke="gray"></path></g><path id="node_outline2358" fill="none" stroke="none" d="M598.5,30822.5h936a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-936a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2358" fill="black"><text id="kity_text_13947" text-rendering="inherit" font-size="12" dy=".8em" y="30823.700000047684" x="598.5">1.@Pointcut 定义一个execution切入点表达式,用来确定哪些类需要代理。匹配类的方法都会被代理</text><text id="kity_text_13948" text-rendering="inherit" font-size="12" dy=".8em" y="30841.700000047684" x="598.5">2.JoinPoint对象封装了SpringAop中切面方法的信息,在切面方法中添加JoinPoint参数,就可以获取到封装了该方法信息的JoinPoint对象.然后还可以获取代理和被代理对象的信息</text></g></g><g id="minder_node2363" display="none"><g id="node_expander2375" display="none" style="cursor: pointer;"><path id="kity_path_27647" fill="white" stroke="gray" d="M566.5,30848.5A6,6,0,1,1,554.5,30848.5A6,6,0,1,1,566.5,30848.5"></path><path id="kity_path_27648" fill="none" stroke="gray"></path></g><path id="node_outline2376" fill="none" stroke="none" d="M566.5,30839.5h61a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-61a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2376" fill="black"><text id="kity_text_14008" text-rendering="inherit" font-size="12" dy=".8em" y="30840.700000047684" x="566.5">spring事务</text></g></g><g id="minder_node2364" display="none"><g id="node_expander2362" display="none" style="cursor: pointer;"><path id="kity_path_27608" fill="white" stroke="gray" d="M582.5,30808.5A6,6,0,1,1,570.5,30808.5A6,6,0,1,1,582.5,30808.5"></path><path id="kity_path_27609" fill="none" stroke="gray"></path></g><path id="node_outline2363" fill="none" stroke="none" d="M582.5,30799.5h149a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-149a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2363" fill="black"><text id="kity_text_13964" text-rendering="inherit" font-size="12" dy=".8em" y="30800.700000047684" x="582.5">说说 spring的事务隔离级别</text></g></g><g id="minder_node2365" display="none"><g id="node_expander2361" display="none" style="cursor: pointer;"><path id="kity_path_27605" fill="white" stroke="gray" d="M598.5,30808.5A6,6,0,1,1,586.5,30808.5A6,6,0,1,1,598.5,30808.5"></path><path id="kity_path_27606" fill="none" stroke="gray"></path></g><path id="node_outline2362" fill="none" stroke="none" d="M598.5,30754.5h877a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-877a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text2362" fill="black"><text id="kity_text_13957" text-rendering="inherit" font-size="12" dy=".8em" y="30755.700000047684" x="598.5">spring 有五大隔离级别 ，通过isolation来指定，mysql是RR，oracle是RC</text><text id="kity_text_13958" text-rendering="inherit" font-size="12" dy=".8em" y="30773.700000047684" x="598.5">1.DEFAULT：使用数据库默认的事务隔离级别</text><text id="kity_text_13959" text-rendering="inherit" font-size="12" dy=".8em" y="30791.700000047684" x="598.5">2.READ_UNCOMMITTED：读未提交。事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</text><text id="kity_text_13960" text-rendering="inherit" font-size="12" dy=".8em" y="30809.700000047684" x="598.5">3.READ_COMMITTED：读已提交。一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）</text><text id="kity_text_13961" text-rendering="inherit" font-size="12" dy=".8em" y="30827.700000047684" x="598.5">4.REPEATABLE_READ：可重复读。对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</text><text id="kity_text_13962" text-rendering="inherit" font-size="12" dy=".8em" y="30845.700000047684" x="598.5">5.SERIALIZABLE： 串行化。完全服从ACID的隔离级别。没有问题</text></g></g><g id="minder_node2366" display="none"><g id="node_expander2360" display="none" style="cursor: pointer;"><path id="kity_path_27602" fill="white" stroke="gray" d="M614.5,30808.5A6,6,0,1,1,602.5,30808.5A6,6,0,1,1,614.5,30808.5"></path><path id="kity_path_27603" fill="none" stroke="gray"></path></g><path id="node_outline2361" fill="none" stroke="none" d="M614.5,30790.5h326a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2361" fill="black"><text id="kity_text_13954" text-rendering="inherit" font-size="12" dy=".8em" y="30791.700000047684" x="614.5">https://juejin.cn/post/6844904035753918471#heading-8</text><text id="kity_text_13955" text-rendering="inherit" font-size="12" dy=".8em" y="30809.700000047684" x="614.5">https://juejin.cn/post/6844904033191198733#heading-5</text></g></g><g id="minder_node2367" display="none"><g id="node_expander2364" display="none" style="cursor: pointer;"><path id="kity_path_27614" fill="white" stroke="gray" d="M582.5,30816.5A6,6,0,1,1,570.5,30816.5A6,6,0,1,1,582.5,30816.5"></path><path id="kity_path_27615" fill="none" stroke="gray"></path></g><path id="node_outline2365" fill="none" stroke="none" d="M582.5,30807.5h245a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-245a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2365" fill="black"><text id="kity_text_13968" text-rendering="inherit" font-size="12" dy=".8em" y="30808.700000047684" x="582.5">说说spring的事务和数据库事务不一致怎么办&#xa0;</text></g></g><g id="minder_node2368" display="none"><g id="node_expander2363" display="none" style="cursor: pointer;"><path id="kity_path_27611" fill="white" stroke="gray" d="M598.5,30816.5A6,6,0,1,1,586.5,30816.5A6,6,0,1,1,598.5,30816.5"></path><path id="kity_path_27612" fill="none" stroke="gray"></path></g><path id="node_outline2364" fill="none" stroke="none" d="M598.5,30807.5h263a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-263a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2364" fill="black"><text id="kity_text_13966" text-rendering="inherit" font-size="12" dy=".8em" y="30808.700000047684" x="598.5">1.使用默认的，默认的就是和数据库隔离级别一致</text></g></g><g id="minder_node2369" display="none"><g id="node_expander2366" display="none" style="cursor: pointer;"><path id="kity_path_27620" fill="white" stroke="gray" d="M582.5,30824.5A6,6,0,1,1,570.5,30824.5A6,6,0,1,1,582.5,30824.5"></path><path id="kity_path_27621" fill="none" stroke="gray"></path></g><path id="node_outline2367" fill="none" stroke="none" d="M582.5,30815.5h176a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-176a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2367" fill="black"><text id="kity_text_13973" text-rendering="inherit" font-size="12" dy=".8em" y="30816.700000047684" x="582.5">知道spring 事务的 的回滚规则吗</text></g></g><g id="minder_node2370" display="none"><g id="node_expander2365" display="none" style="cursor: pointer;"><path id="kity_path_27617" fill="white" stroke="gray" d="M598.5,30824.5A6,6,0,1,1,586.5,30824.5A6,6,0,1,1,598.5,30824.5"></path><path id="kity_path_27618" fill="none" stroke="gray"></path></g><path id="node_outline2366" fill="none" stroke="none" d="M598.5,30806.5h1227a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1227a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2366" fill="black"><text id="kity_text_13970" text-rendering="inherit" font-size="12" dy=".8em" y="30807.700000047684" x="598.5">1.如果发生的是检查时异常(需try-catch 和throw)，那么事务不会自动回滚，如果是运行时异常，事务会自动回滚。实际源码中默认情况下，检查时异常(业务异常)不会引起事务回滚，但是RuntimeException及其子类会引起事务回滚</text><text id="kity_text_13971" text-rendering="inherit" font-size="12" dy=".8em" y="30825.700000047684" x="598.5">2.如果是自定义异常，则需要类的完全限定名来指定。</text></g></g><g id="minder_node2371" display="none"><g id="node_expander2369" display="none" style="cursor: pointer;"><path id="kity_path_27629" fill="white" stroke="gray" d="M582.5,30832.5A6,6,0,1,1,570.5,30832.5A6,6,0,1,1,582.5,30832.5"></path><path id="kity_path_27630" fill="none" stroke="gray"></path></g><path id="node_outline2370" fill="none" stroke="none" d="M582.5,30823.5h228a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-228a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2370" fill="black"><text id="kity_text_13986" text-rendering="inherit" font-size="12" dy=".8em" y="30824.700000047684" x="582.5">spring的事务失效了有哪些原因，分析一下</text></g></g><g id="minder_node2372" display="none"><g id="node_expander2368" display="none" style="cursor: pointer;"><path id="kity_path_27626" fill="white" stroke="gray" d="M598.5,30832.5A6,6,0,1,1,586.5,30832.5A6,6,0,1,1,598.5,30832.5"></path><path id="kity_path_27627" fill="none" stroke="gray"></path></g><path id="node_outline2369" fill="none" stroke="none" d="M598.5,30778.5h708a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-708a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text2369" fill="black"><text id="kity_text_13979" text-rendering="inherit" font-size="12" dy=".8em" y="30779.700000047684" x="598.5">1.MySQL 使用的是 MyISAM 引擎，而 MyISAM 是不支持事务的。需要支持使用可以使用 InnoDB 引擎</text><text id="kity_text_13980" text-rendering="inherit" font-size="12" dy=".8em" y="30797.700000047684" x="598.5">2.如果使用了 Spring MVC ，context:component-scan 重复扫描问题可能会引起事务失败</text><text id="kity_text_13981" text-rendering="inherit" font-size="12" dy=".8em" y="30815.700000047684" x="598.5">3.@Transactional 注解只能应用到 public 可见度的方法上。 在其他可见类型上声明，事务会失效。</text><text id="kity_text_13982" text-rendering="inherit" font-size="12" dy=".8em" y="30833.700000047684" x="598.5">4.在接口上使用 @Transactional 注解，只能当你设置了基于接口的代理时它才生效。所以如果强制使用了 CGLIB，那么事物会实效。</text><text id="kity_text_13983" text-rendering="inherit" font-size="12" dy=".8em" y="30851.700000047684" x="598.5">5.@Transactional 同一个类中无事务方法 a() 内部调用有事务方法 b()，那么此时事物不生效。</text><text id="kity_text_13984" text-rendering="inherit" font-size="12" dy=".8em" y="30869.700000047684" x="598.5">6.try-catch异常但是不抛出 也就是不throw xxx 或者抛出类型不对</text></g></g><g id="minder_node2373" display="none"><g id="node_expander2367" display="none" style="cursor: pointer;"><path id="kity_path_27623" fill="white" stroke="gray" d="M614.5,30832.5A6,6,0,1,1,602.5,30832.5A6,6,0,1,1,614.5,30832.5"></path><path id="kity_path_27624" fill="none" stroke="gray"></path></g><path id="node_outline2368" fill="none" stroke="none" d="M614.5,30805.5h333a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2368" fill="black"><text id="kity_text_13975" text-rendering="inherit" font-size="12" dy=".8em" y="30806.700000047684" x="614.5">https://juejin.cn/post/6844904036777345037#heading-5</text><text id="kity_text_13976" text-rendering="inherit" font-size="12" dy=".8em" y="30824.700000047684" x="614.5">https://www.cnblogs.com/javastack/p/12160464.html</text><text id="kity_text_13977" text-rendering="inherit" font-size="12" dy=".8em" y="30842.700000047684" x="614.5">https://juejin.cn/post/6844904033191198733#heading-18</text></g></g><g id="minder_node2374" display="none"><g id="node_expander2371" display="none" style="cursor: pointer;"><path id="kity_path_27635" fill="white" stroke="gray" d="M582.5,30840.5A6,6,0,1,1,570.5,30840.5A6,6,0,1,1,582.5,30840.5"></path><path id="kity_path_27636" fill="none" stroke="gray"></path></g><path id="node_outline2372" fill="none" stroke="none" d="M582.5,30831.5h205a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-205a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2372" fill="black"><text id="kity_text_13991" text-rendering="inherit" font-size="12" dy=".8em" y="30832.700000047684" x="582.5">怎么在一个事务中开启另外一个事务？</text></g></g><g id="minder_node2375" display="none"><g id="node_expander2370" display="none" style="cursor: pointer;"><path id="kity_path_27632" fill="white" stroke="gray" d="M598.5,30840.5A6,6,0,1,1,586.5,30840.5A6,6,0,1,1,598.5,30840.5"></path><path id="kity_path_27633" fill="none" stroke="gray"></path></g><path id="node_outline2371" fill="none" stroke="none" d="M598.5,30822.5h1051a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1051a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2371" fill="black"><text id="kity_text_13988" text-rendering="inherit" font-size="12" dy=".8em" y="30823.700000047684" x="598.5">1.进行拆分，把业务层原来的业务逻辑拆开成两个方法。然后注入这个类 再调用 比如说，a类 方法有两个逻辑1 2 拆成 a类 逻辑1&#xa0; b类 逻辑2，然后在a类 逻辑1 调用逻辑2 并且指定传播为开启新事务</text><text id="kity_text_13989" text-rendering="inherit" font-size="12" dy=".8em" y="30841.700000047684" x="598.5">2.暴露代理对象 expose-proxy="true"，通过代理对象AopContext.currentProxy() 当前代理对象去调用方法。</text></g></g><g id="minder_node2376" display="none"><g id="node_expander2374" display="none" style="cursor: pointer;"><path id="kity_path_27644" fill="white" stroke="gray" d="M582.5,30848.5A6,6,0,1,1,570.5,30848.5A6,6,0,1,1,582.5,30848.5"></path><path id="kity_path_27645" fill="none" stroke="gray"></path></g><path id="node_outline2375" fill="none" stroke="none" d="M582.5,30839.5h206a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-206a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2375" fill="black"><text id="kity_text_14006" text-rendering="inherit" font-size="12" dy=".8em" y="30840.700000047684" x="582.5">说说spring事务的传播属性行为有哪些</text></g></g><g id="minder_node2377" display="none"><g id="node_expander2373" display="none" style="cursor: pointer;"><path id="kity_path_27641" fill="white" stroke="gray" d="M598.5,30848.5A6,6,0,1,1,586.5,30848.5A6,6,0,1,1,598.5,30848.5"></path><path id="kity_path_27642" fill="none" stroke="gray"></path></g><path id="node_outline2374" fill="none" stroke="none" d="M598.5,30758.5h589a5,5,0,0,1,5,5v170a5,5,0,0,1,-5,5h-589a5,5,0,0,1,-5,-5v-170a5,5,0,0,1,5,-5z"></path><g id="node_text2374" fill="black"><text id="kity_text_13995" text-rendering="inherit" font-size="12" dy=".8em" y="30759.700000047684" x="598.5">1.支持当前事务的情况：</text><text id="kity_text_13996" text-rendering="inherit" font-size="12" dy=".8em" y="30777.700000047684" x="598.5">如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</text><text id="kity_text_13997" text-rendering="inherit" font-size="12" dy=".8em" y="30795.700000047684" x="598.5">&#xa0;如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</text><text id="kity_text_13998" text-rendering="inherit" font-size="12" dy=".8em" y="30813.700000047684" x="598.5">&#xa0;如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</text><text id="kity_text_13999" text-rendering="inherit" font-size="12" dy=".8em" y="30831.700000047684" x="598.5">2.不支持当前事务的情况：</text><text id="kity_text_14000" text-rendering="inherit" font-size="12" dy=".8em" y="30849.700000047684" x="598.5">&#xa0;创建一个新的事务，如果当前存在事务，则把当前事务挂起。</text><text id="kity_text_14001" text-rendering="inherit" font-size="12" dy=".8em" y="30867.700000047684" x="598.5">&#xa0;以非事务方式运行，如果当前存在事务，则把当前事务挂起。会出现事务失效的情况，</text><text id="kity_text_14002" text-rendering="inherit" font-size="12" dy=".8em" y="30885.700000047684" x="598.5">&#xa0;以非事务方式运行，如果当前存在事务，则抛出异常。</text><text id="kity_text_14003" text-rendering="inherit" font-size="12" dy=".8em" y="30903.700000047684" x="598.5">3.其他情况：</text><text id="kity_text_14004" text-rendering="inherit" font-size="12" dy=".8em" y="30921.700000047684" x="598.5">如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，创建一个新的事务。</text></g></g><g id="minder_node2378" display="none"><g id="node_expander2372" display="none" style="cursor: pointer;"><path id="kity_path_27638" fill="white" stroke="gray" d="M614.5,30848.5A6,6,0,1,1,602.5,30848.5A6,6,0,1,1,614.5,30848.5"></path><path id="kity_path_27639" fill="none" stroke="gray"></path></g><path id="node_outline2373" fill="none" stroke="none" d="M614.5,30839.5h326a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2373" fill="black"><text id="kity_text_13993" text-rendering="inherit" font-size="12" dy=".8em" y="30840.700000047684" x="614.5">https://juejin.cn/post/6844904035753918471#heading-9</text></g></g><g id="minder_node2379" display="none"><g id="node_expander2386" display="none" style="cursor: pointer;"><path id="kity_path_27680" fill="white" stroke="gray" d="M566.5,30856.5A6,6,0,1,1,554.5,30856.5A6,6,0,1,1,566.5,30856.5"></path><path id="kity_path_27681" fill="none" stroke="gray"></path></g><path id="node_outline2387" fill="none" stroke="none" d="M566.5,30847.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2387" fill="black"><text id="kity_text_14039" text-rendering="inherit" font-size="12" dy=".8em" y="30848.700000047684" x="566.5">循环依赖</text></g></g><g id="minder_node2380" display="none"><g id="node_expander2377" display="none" style="cursor: pointer;"><path id="kity_path_27653" fill="white" stroke="gray" d="M582.5,30832.5A6,6,0,1,1,570.5,30832.5A6,6,0,1,1,582.5,30832.5"></path><path id="kity_path_27654" fill="none" stroke="gray"></path></g><path id="node_outline2378" fill="none" stroke="none" d="M582.5,30823.5h86a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-86a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2378" fill="black"><text id="kity_text_14012" text-rendering="inherit" font-size="12" dy=".8em" y="30824.700000047684" x="582.5">什么是循环依赖</text></g></g><g id="minder_node2381" display="none"><g id="node_expander2376" display="none" style="cursor: pointer;"><path id="kity_path_27650" fill="white" stroke="gray" d="M598.5,30832.5A6,6,0,1,1,586.5,30832.5A6,6,0,1,1,598.5,30832.5"></path><path id="kity_path_27651" fill="none" stroke="gray"></path></g><path id="node_outline2377" fill="none" stroke="none" d="M598.5,30823.5h855a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-855a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2377" fill="black"><text id="kity_text_14010" text-rendering="inherit" font-size="12" dy=".8em" y="30824.700000047684" x="598.5">1.两个对象a,b。创建 a 的时候需要依赖 b，那就创建 b，结果创建 b 的时候又需要依赖 a，那就创建 a，创建 a 的时候需要依赖 b，那就创建 b，这样就死循环了</text></g></g><g id="minder_node2382" display="none"><g id="node_expander2380" display="none" style="cursor: pointer;"><path id="kity_path_27662" fill="white" stroke="gray" d="M582.5,30840.5A6,6,0,1,1,570.5,30840.5A6,6,0,1,1,582.5,30840.5"></path><path id="kity_path_27663" fill="none" stroke="gray"></path></g><path id="node_outline2381" fill="none" stroke="none" d="M582.5,30831.5h170a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-170a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2381" fill="black"><text id="kity_text_14023" text-rendering="inherit" font-size="12" dy=".8em" y="30832.700000047684" x="582.5">说说spring怎么解决的循环依赖</text></g></g><g id="minder_node2383" display="none"><g id="node_expander2379" display="none" style="cursor: pointer;"><path id="kity_path_27659" fill="white" stroke="gray" d="M598.5,30840.5A6,6,0,1,1,586.5,30840.5A6,6,0,1,1,598.5,30840.5"></path><path id="kity_path_27660" fill="none" stroke="gray"></path></g><path id="node_outline2380" fill="none" stroke="none" d="M598.5,30786.5h1552a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1552a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text2380" fill="black"><text id="kity_text_14016" text-rendering="inherit" font-size="12" dy=".8em" y="30787.700000047684" x="598.5">1.spring通过三级缓存解决单例set循环依赖</text><text id="kity_text_14017" text-rendering="inherit" font-size="12" dy=".8em" y="30805.700000047684" x="598.5">一级是 单例缓存池 存放已经经历了完整生命周期的 Bean 对象&#xa0; 二级 早期曝光对象 存放Bean 的生命周期未结束（属性还未填充完），或者正在创建的&#xa0; 三级 早期曝光对象工厂 存放可以生成 Bean 的工厂</text><text id="kity_text_14018" text-rendering="inherit" font-size="12" dy=".8em" y="30823.700000047684" x="598.5">2.当A、B两个类发生循环引用时，在A完成实例化后，就使用实例化后的对象去创建一个对象工厂，并添加到三级缓存中</text><text id="kity_text_14019" text-rendering="inherit" font-size="12" dy=".8em" y="30841.700000047684" x="598.5">如果A被AOP代理，那么通过这个工厂获取到的就是A代理后的对象，如果A没有被AOP代理，那么这个工厂获取到的就是A实例化的对象。</text><text id="kity_text_14020" text-rendering="inherit" font-size="12" dy=".8em" y="30859.700000047684" x="598.5">3.当A进行属性注入时，会去创建B，但是B又依赖了A，所以创建B的同时又会去调用getBean(a)来获取需要的依赖，此时的getBean(a)会分两步从缓存中获取，第一步先获取到三级缓存中的工厂a，第二步，调用对象工工厂的getObject方法来获取到对应的对象，得到这个对象后将其注入到B中</text><text id="kity_text_14021" text-rendering="inherit" font-size="12" dy=".8em" y="30877.700000047684" x="598.5">4.然后B会走完它的生命周期流程，包括初始化、后置处理器等。当B创建完后，会将B再注入到A中，此时A再完成它的整个生命周期。</text></g></g><g id="minder_node2384" display="none"><g id="node_expander2378" display="none" style="cursor: pointer;"><path id="kity_path_27656" fill="white" stroke="gray" d="M614.5,30840.5A6,6,0,1,1,602.5,30840.5A6,6,0,1,1,614.5,30840.5"></path><path id="kity_path_27657" fill="none" stroke="gray"></path></g><path id="node_outline2379" fill="none" stroke="none" d="M566.5,30778.5h200a5,5,0,0,1,5,5v66a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-66a5,5,0,0,1,5,-5z"></path><g id="node_text2379" fill="black"><text id="kity_text_14014" text-rendering="inherit" font-size="12" dy=".8em" y="30832.700000047684" x="614.5">a和b创建过程</text></g><a id="kity_a_16964" xlink:href="https://www.cnblogs.com/daimzh/p/13256413.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%EF%BC%9F" target="_blank" xlink:title="https://www.cnblogs.com/daimzh/p/13256413.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%EF%BC%9F" style="cursor: pointer;"><path id="kity_path_16966" fill="rgba(255, 255, 255, 0)" stroke="none" d="M698.5,30829.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16965" fill="#666" stroke="none" d="M713.114,30845.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V30839.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C708.766,30836.571,710.168,30835.5,711.836,30835.5h1.278c2.116,0,3.834,1.716,3.834,3.834V30841.89C716.948,30844.008,715.23,30845.724,713.114,30845.724zM701.612,30840.612c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S711.265,30841.89,710.558,30841.89H702.89C702.185,30841.89,701.612,30841.319,701.612,30840.612zM699.056,30839.334V30841.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H700.334C698.216,30845.724,696.5,30844.008,696.5,30841.89V30839.334C696.5,30837.216,698.216,30835.5,700.334,30835.5h1.278c1.667,0,3.071,1.071,3.599,2.556H700.334C699.629,30838.056,699.056,30838.627,699.056,30839.334z"></path></a><image id="kity_image_17081" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210414151502.png" x="566.5" y="30781.5" width="200" height="43"></image></g><g id="minder_node2385" display="none"><g id="node_expander2383" display="none" style="cursor: pointer;"><path id="kity_path_27671" fill="white" stroke="gray" d="M582.5,30848.5A6,6,0,1,1,570.5,30848.5A6,6,0,1,1,582.5,30848.5"></path><path id="kity_path_27672" fill="none" stroke="gray"></path></g><path id="node_outline2384" fill="none" stroke="none" d="M582.5,30839.5h192a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-192a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2384" fill="black"><text id="kity_text_14033" text-rendering="inherit" font-size="12" dy=".8em" y="30840.700000047684" x="582.5">为什么要三级缓存，二级可不可以？</text></g></g><g id="minder_node2386" display="none"><g id="node_expander2382" display="none" style="cursor: pointer;"><path id="kity_path_27668" fill="white" stroke="gray" d="M598.5,30848.5A6,6,0,1,1,586.5,30848.5A6,6,0,1,1,598.5,30848.5"></path><path id="kity_path_27669" fill="none" stroke="gray"></path></g><path id="node_outline2383" fill="none" stroke="none" d="M598.5,30812.5h1503a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1503a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text2383" fill="black"><text id="kity_text_14028" text-rendering="inherit" font-size="12" dy=".8em" y="30813.700000047684" x="598.5">最主要解决的就是代理的问题</text><text id="kity_text_14029" text-rendering="inherit" font-size="12" dy=".8em" y="30831.700000047684" x="598.5">1.二级缓存可以解决循环依赖问题。但是如果bean有aop 而 AOP 处理后，往往是需要生成代理对象的，代理对象和原来的对象根本就不是 1 个对象。</text><text id="kity_text_14030" text-rendering="inherit" font-size="12" dy=".8em" y="30849.700000047684" x="598.5">2.比如说 a b两个对象，a 最终的产物是代理 a，那 b 中其实也应该用代理 a，而现在 b 中用的却是原始的 a 代理 a 和原始的 a 不是一个对象，而三级缓存在 bean 的生命周期中，创建完对象之后，就会构造一个这个对象对应的 ObjectFactory 存入 singletonFactories(三级缓存) 中。</text><text id="kity_text_14031" text-rendering="inherit" font-size="12" dy=".8em" y="30867.700000047684" x="598.5">3.这和spring bean的创建过程就不一样了，因为创建过程是会看如果对象是否被aop，有就要生成代理类，而且aop代理并不是在bean实例化后立马就代理，而是在创建完后才代理</text></g></g><g id="minder_node2387" display="none"><g id="node_expander2381" display="none" style="cursor: pointer;"><path id="kity_path_27665" fill="white" stroke="gray" d="M614.5,30848.5A6,6,0,1,1,602.5,30848.5A6,6,0,1,1,614.5,30848.5"></path><path id="kity_path_27666" fill="none" stroke="gray"></path></g><path id="node_outline2382" fill="none" stroke="none" d="M614.5,30830.5h325a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-325a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2382" fill="black"><text id="kity_text_14025" text-rendering="inherit" font-size="12" dy=".8em" y="30831.700000047684" x="614.5">https://www.cnblogs.com/daimzh/p/13256413.html#top</text><text id="kity_text_14026" text-rendering="inherit" font-size="12" dy=".8em" y="30849.700000047684" x="614.5">https://juejin.cn/post/6932762584047157256</text></g></g><g id="minder_node2388" display="none"><g id="node_expander2385" display="none" style="cursor: pointer;"><path id="kity_path_27677" fill="white" stroke="gray" d="M582.5,30856.5A6,6,0,1,1,570.5,30856.5A6,6,0,1,1,582.5,30856.5"></path><path id="kity_path_27678" fill="none" stroke="gray"></path></g><path id="node_outline2386" fill="none" stroke="none" d="M582.5,30847.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2386" fill="black"><text id="kity_text_14037" text-rendering="inherit" font-size="12" dy=".8em" y="30848.700000047684" x="582.5">spring有哪些循环依赖类型</text></g></g><g id="minder_node2389" display="none"><g id="node_expander2384" display="none" style="cursor: pointer;"><path id="kity_path_27674" fill="white" stroke="gray" d="M598.5,30856.5A6,6,0,1,1,586.5,30856.5A6,6,0,1,1,598.5,30856.5"></path><path id="kity_path_27675" fill="none" stroke="gray"></path></g><path id="node_outline2385" fill="none" stroke="none" d="M598.5,30847.5h204a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-204a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2385" fill="black"><text id="kity_text_14035" text-rendering="inherit" font-size="12" dy=".8em" y="30848.700000047684" x="598.5">1.构造器 2.set方法单例 3.set方法原型</text></g></g><g id="minder_node2390" display="none"><g id="node_expander2389" display="none" style="cursor: pointer;"><path id="kity_path_27689" fill="white" stroke="gray" d="M566.5,30864.5A6,6,0,1,1,554.5,30864.5A6,6,0,1,1,566.5,30864.5"></path><path id="kity_path_27690" fill="none" stroke="gray"></path></g><path id="node_outline2390" fill="none" stroke="none" d="M566.5,30855.5h61a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-61a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2390" fill="black"><text id="kity_text_14049" text-rendering="inherit" font-size="12" dy=".8em" y="30856.700000047684" x="566.5">spring标签</text></g></g><g id="minder_node2391" display="none"><g id="node_expander2388" display="none" style="cursor: pointer;"><path id="kity_path_27686" fill="white" stroke="gray" d="M582.5,30864.5A6,6,0,1,1,570.5,30864.5A6,6,0,1,1,582.5,30864.5"></path><path id="kity_path_27687" fill="none" stroke="gray"></path></g><path id="node_outline2389" fill="none" stroke="none" d="M582.5,30855.5h134a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-134a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2389" fill="black"><text id="kity_text_14047" text-rendering="inherit" font-size="12" dy=".8em" y="30856.700000047684" x="582.5">简单说说怎么自定义标签</text></g></g><g id="minder_node2392" display="none"><g id="node_expander2387" display="none" style="cursor: pointer;"><path id="kity_path_27683" fill="white" stroke="gray" d="M598.5,30864.5A6,6,0,1,1,586.5,30864.5A6,6,0,1,1,598.5,30864.5"></path><path id="kity_path_27684" fill="none" stroke="gray"></path></g><path id="node_outline2388" fill="none" stroke="none" d="M598.5,30819.5h1082a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1082a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text2388" fill="black"><text id="kity_text_14041" text-rendering="inherit" font-size="12" dy=".8em" y="30820.700000047684" x="598.5">1. 创建一个需要扩展的组件</text><text id="kity_text_14042" text-rendering="inherit" font-size="12" dy=".8em" y="30838.700000047684" x="598.5">2. 定义一个XSD文件，用来描述组件内容，元素的属性数据</text><text id="kity_text_14043" text-rendering="inherit" font-size="12" dy=".8em" y="30856.700000047684" x="598.5">3. 创建一个实现AbstractSingleBeanDefinitionParser接口的类，或者创建一个实现实现BeanDefinitionParser接口的类，来解析XSD文件中定义和组件定义，这两个实现方法定义不同的XSD文件配置方式</text><text id="kity_text_14044" text-rendering="inherit" font-size="12" dy=".8em" y="30874.700000047684" x="598.5">4. 创建一个Handler，继承NamespaceHandlerSupport,将组件注册到spring容器</text><text id="kity_text_14045" text-rendering="inherit" font-size="12" dy=".8em" y="30892.700000047684" x="598.5">5. 编写spring.handlers和spring.schemas文件</text></g></g><g id="minder_node2393" display="none"><g id="node_expander2400" display="none" style="cursor: pointer;"><path id="kity_path_27722" fill="white" stroke="gray" d="M566.5,30872.5A6,6,0,1,1,554.5,30872.5A6,6,0,1,1,566.5,30872.5"></path><path id="kity_path_27723" fill="none" stroke="gray"></path></g><path id="node_outline2401" fill="none" stroke="none" d="M566.5,30863.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2401" fill="black"><text id="kity_text_14090" text-rendering="inherit" font-size="12" dy=".8em" y="30864.700000047684" x="566.5">spring设计模式</text></g></g><g id="minder_node2394" display="none"><g id="node_expander2391" display="none" style="cursor: pointer;"><path id="kity_path_27695" fill="white" stroke="gray" d="M582.5,30848.5A6,6,0,1,1,570.5,30848.5A6,6,0,1,1,582.5,30848.5"></path><path id="kity_path_27696" fill="none" stroke="gray"></path></g><path id="node_outline2392" fill="none" stroke="none" d="M582.5,30839.5h158a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-158a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2392" fill="black"><text id="kity_text_14061" text-rendering="inherit" font-size="12" dy=".8em" y="30840.700000047684" x="582.5">说说spring中有哪些设计模式</text></g></g><g id="minder_node2395" display="none"><g id="node_expander2390" display="none" style="cursor: pointer;"><path id="kity_path_27692" fill="white" stroke="gray" d="M598.5,30848.5A6,6,0,1,1,586.5,30848.5A6,6,0,1,1,598.5,30848.5"></path><path id="kity_path_27693" fill="none" stroke="gray"></path></g><path id="node_outline2391" fill="none" stroke="none" d="M598.5,30767.5h1587a5,5,0,0,1,5,5v152a5,5,0,0,1,-5,5h-1587a5,5,0,0,1,-5,-5v-152a5,5,0,0,1,5,-5z"></path><g id="node_text2391" fill="black"><text id="kity_text_14051" text-rendering="inherit" font-size="12" dy=".8em" y="30768.700000047684" x="598.5">1.单例模式，Spring 中 bean 的默认作用域就是 singleton(单例)的，</text><text id="kity_text_14052" text-rendering="inherit" font-size="12" dy=".8em" y="30786.700000047684" x="598.5">使用单例模式的好处，对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</text><text id="kity_text_14053" text-rendering="inherit" font-size="12" dy=".8em" y="30804.700000047684" x="598.5">2.工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；将对象的创建及初始化职责交给工厂对象。由一个工厂类根据传入的唯一的标识参数，动态决定应该创建哪一个产品类。&#xa0;</text><text id="kity_text_14054" text-rendering="inherit" font-size="12" dy=".8em" y="30822.700000047684" x="598.5">3.代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；对类进行方法级别的切面增强，即，生成被代理类的代理类， 并在代理类的方法前，设置拦截器，通过执行拦截器重的内容增强了代理方法的功能，实现的面向切面编程。</text><text id="kity_text_14055" text-rendering="inherit" font-size="12" dy=".8em" y="30840.700000047684" x="598.5">4.模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JdbcTemplate 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，让子类去具体实现重定义。</text><text id="kity_text_14056" text-rendering="inherit" font-size="12" dy=".8em" y="30858.700000047684" x="598.5">5.适配器模式，将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，AOP 的通知使用到了适配器模式，通知有不同的类型，，每个类型通知都有对应的拦截器，Spring预定义的通知要通过对应的适配器，适配成MethodInterceptor接口(方法拦截器)类型的对象</text><text id="kity_text_14057" text-rendering="inherit" font-size="12" dy=".8em" y="30876.700000047684" x="598.5">6.观察者模式：Spring 事件有用到观察者模式。他的流程是通过 (1)定义一个事件: 实现一个继承自 ApplicationEvent，并且写相应的构造函数；(2)定义一个事件监听者：实现 ApplicationListener 接口，重写 onApplicationEvent() 方法；</text><text id="kity_text_14058" text-rendering="inherit" font-size="12" dy=".8em" y="30894.700000047684" x="598.5">(3)使用事件发布者发布消息:&#xa0; 可以通过 ApplicationEventPublisher 的 publishEvent() 方法发布消息。</text><text id="kity_text_14059" text-rendering="inherit" font-size="12" dy=".8em" y="30912.700000047684" x="598.5">spring本身有一些事件比如ApplicationContext 启动后触发的事件; 停止后触发的事件;关闭后触发的事件。</text></g></g><g id="minder_node2396" display="none"><g id="node_expander2394" display="none" style="cursor: pointer;"><path id="kity_path_27704" fill="white" stroke="gray" d="M582.5,30856.5A6,6,0,1,1,570.5,30856.5A6,6,0,1,1,582.5,30856.5"></path><path id="kity_path_27705" fill="none" stroke="gray"></path></g><path id="node_outline2395" fill="none" stroke="none" d="M582.5,30847.5h98a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-98a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2395" fill="black"><text id="kity_text_14073" text-rendering="inherit" font-size="12" dy=".8em" y="30848.700000047684" x="582.5">你说到了工厂模式</text></g></g><g id="minder_node2397" display="none"><g id="node_expander2393" display="none" style="cursor: pointer;"><path id="kity_path_27701" fill="white" stroke="gray" d="M598.5,30856.5A6,6,0,1,1,586.5,30856.5A6,6,0,1,1,598.5,30856.5"></path><path id="kity_path_27702" fill="none" stroke="gray"></path></g><path id="node_outline2394" fill="none" stroke="none" d="M598.5,30802.5h1251a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1251a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text2394" fill="black"><text id="kity_text_14066" text-rendering="inherit" font-size="12" dy=".8em" y="30803.700000047684" x="598.5">1.简单工厂模式通过对外提供一个静态方法来统一为类创建实例，目的是实现类与类之间解耦:客户端不需要知道这个对象是如何被穿创建出来的，只需要调用简单工厂模式的方法来统一创建就可以了。三个角色 工厂类 抽象产品&#xa0; 具体产品</text><text id="kity_text_14067" text-rendering="inherit" font-size="12" dy=".8em" y="30821.700000047684" x="598.5">(1)简单工厂模式的核心是工厂类 负责实现创建所有产品实例的内部逻辑&#xa0;&#xa0;</text><text id="kity_text_14068" text-rendering="inherit" font-size="12" dy=".8em" y="30839.700000047684" x="598.5">(2)工厂类所创建的所有对象的父类叫抽象产品，封装了产品对象的公有方法。</text><text id="kity_text_14069" text-rendering="inherit" font-size="12" dy=".8em" y="30857.700000047684" x="598.5">(3)工厂模式的目标是具体产品，每一个具体产品角色都继承了抽象产品这个父类，需要实现在抽象产品中声明的抽象方法</text><text id="kity_text_14070" text-rendering="inherit" font-size="12" dy=".8em" y="30875.700000047684" x="598.5">2.比如说 一个抽象产品类Video 有一个抽象方法，然后具体的产品类需要去继承他 并重写抽象方法，然后工厂类通过类型判断和反射来 根据唯一标识来创建对应的对象，我们只需要在客户端调用工厂类 传入参数即可</text><text id="kity_text_14071" text-rendering="inherit" font-size="12" dy=".8em" y="30893.700000047684" x="598.5">3.优点是 我们通过工厂类 只需要关注消费，而不需要关注酸菜 来达到返回不同类型对象的目到，缺点是 增加类需要修改工厂类，因为逻辑都在工厂类中</text></g></g><g id="minder_node2398" display="none"><g id="node_expander2392" display="none" style="cursor: pointer;"><path id="kity_path_27698" fill="white" stroke="gray" d="M614.5,30856.5A6,6,0,1,1,602.5,30856.5A6,6,0,1,1,614.5,30856.5"></path><path id="kity_path_27699" fill="none" stroke="gray"></path></g><path id="node_outline2393" fill="none" stroke="none" d="M614.5,30838.5h259a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-259a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2393" fill="black"><text id="kity_text_14063" text-rendering="inherit" font-size="12" dy=".8em" y="30839.700000047684" x="614.5">https://juejin.cn/post/6844904012811108365</text><text id="kity_text_14064" text-rendering="inherit" font-size="12" dy=".8em" y="30857.700000047684" x="614.5">https://juejin.cn/post/6844903672569151496</text></g></g><g id="minder_node2399" display="none"><g id="node_expander2397" display="none" style="cursor: pointer;"><path id="kity_path_27713" fill="white" stroke="gray" d="M582.5,30864.5A6,6,0,1,1,570.5,30864.5A6,6,0,1,1,582.5,30864.5"></path><path id="kity_path_27714" fill="none" stroke="gray"></path></g><path id="node_outline2398" fill="none" stroke="none" d="M582.5,30855.5h74a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-74a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2398" fill="black"><text id="kity_text_14081" text-rendering="inherit" font-size="12" dy=".8em" y="30856.700000047684" x="582.5">说说单例模式</text></g></g><g id="minder_node2400" display="none"><g id="node_expander2396" display="none" style="cursor: pointer;"><path id="kity_path_27710" fill="white" stroke="gray" d="M598.5,30864.5A6,6,0,1,1,586.5,30864.5A6,6,0,1,1,598.5,30864.5"></path><path id="kity_path_27711" fill="none" stroke="gray"></path></g><path id="node_outline2397" fill="none" stroke="none" d="M598.5,30837.5h1300a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1300a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2397" fill="black"><text id="kity_text_14077" text-rendering="inherit" font-size="12" dy=".8em" y="30838.700000047684" x="598.5">1.单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个全局对象，这样有利于我们协调系统整体的行为，比如说访问I/O、数据库 线程池、缓存 这一类对象只能有一个实例 如果制造出多个实例就可能会导致一些问题的产生</text><text id="kity_text_14078" text-rendering="inherit" font-size="12" dy=".8em" y="30856.700000047684" x="598.5">2.一般使用DCL 或者静态内部类来实现单例模式，</text><text id="kity_text_14079" text-rendering="inherit" font-size="12" dy=".8em" y="30874.700000047684" x="598.5">3.优点：在内存中只有一个实例，减少内存开支，特别是一个对象需要频繁创建、销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就十分明显。缺点：单例模式一般没有接口，扩展很困难，除非修改代码。</text></g></g><g id="minder_node2401" display="none"><g id="node_expander2395" display="none" style="cursor: pointer;"><path id="kity_path_27707" fill="white" stroke="gray" d="M614.5,30864.5A6,6,0,1,1,602.5,30864.5A6,6,0,1,1,614.5,30864.5"></path><path id="kity_path_27708" fill="none" stroke="gray"></path></g><path id="node_outline2396" fill="none" stroke="none" d="M614.5,30855.5h259a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-259a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2396" fill="black"><text id="kity_text_14075" text-rendering="inherit" font-size="12" dy=".8em" y="30856.700000047684" x="614.5">https://juejin.cn/post/6844903908477763591</text></g></g><g id="minder_node2402" display="none"><g id="node_expander2399" display="none" style="cursor: pointer;"><path id="kity_path_27719" fill="white" stroke="gray" d="M582.5,30872.5A6,6,0,1,1,570.5,30872.5A6,6,0,1,1,582.5,30872.5"></path><path id="kity_path_27720" fill="none" stroke="gray"></path></g><path id="node_outline2400" fill="none" stroke="none" d="M582.5,30863.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2400" fill="black"><text id="kity_text_14088" text-rendering="inherit" font-size="12" dy=".8em" y="30864.700000047684" x="582.5">你在项目中用到过设计模式吗</text></g></g><g id="minder_node2403" display="none"><g id="node_expander2398" display="none" style="cursor: pointer;"><path id="kity_path_27716" fill="white" stroke="gray" d="M598.5,30872.5A6,6,0,1,1,586.5,30872.5A6,6,0,1,1,598.5,30872.5"></path><path id="kity_path_27717" fill="none" stroke="gray"></path></g><path id="node_outline2399" fill="none" stroke="none" d="M598.5,30836.5h1518a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1518a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text2399" fill="black"><text id="kity_text_14083" text-rendering="inherit" font-size="12" dy=".8em" y="30837.700000047684" x="598.5">工厂模式和单例模式，和代理模式， 和结合项目吹</text><text id="kity_text_14084" text-rendering="inherit" font-size="12" dy=".8em" y="30855.700000047684" x="598.5">1.我在项目中就用到工厂模式，在xx模块中，我们有xxx不同的报文，然后大体分为xxx，xx 然后我们 这些报文我们都是通用的，然后只是具体字段数据不一样，每一个报文类型 和作用不一样，我们在发起报文的一个流程中 会去看根据业务类型等等业务组件数据 然后生成调用对应的报文</text><text id="kity_text_14085" text-rendering="inherit" font-size="12" dy=".8em" y="30873.700000047684" x="598.5">2.这个报文我们区分也是通过全局唯一标识码来区分，生成以后 然后对业务交易做检验等一些其他业务逻辑处理，最后把报文给下游记录和核心，后面就是业务处理</text><text id="kity_text_14086" text-rendering="inherit" font-size="12" dy=".8em" y="30891.700000047684" x="598.5">3.使用这个我们就可以不用每一次在处理业务逻辑时去看这个业务对应什么报文，然后去创建，都是一些重复的代码，</text></g></g><g id="minder_node2404" display="none"><g id="node_expander2414" display="none" style="cursor: pointer;"><path id="kity_path_27764" fill="white" stroke="gray" d="M566.5,30880.5A6,6,0,1,1,554.5,30880.5A6,6,0,1,1,566.5,30880.5"></path><path id="kity_path_27765" fill="none" stroke="gray"></path></g><path id="node_outline2415" fill="none" stroke="none" d="M566.5,30871.5h61a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-61a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2415" fill="black"><text id="kity_text_14131" text-rendering="inherit" font-size="12" dy=".8em" y="30872.700000047684" x="566.5">spring注解</text></g></g><g id="minder_node2405" display="none"><g id="node_expander2402" display="none" style="cursor: pointer;"><path id="kity_path_27728" fill="white" stroke="gray" d="M582.5,30840.5A6,6,0,1,1,570.5,30840.5A6,6,0,1,1,582.5,30840.5"></path><path id="kity_path_27729" fill="none" stroke="gray"></path></g><path id="node_outline2403" fill="none" stroke="none" d="M582.5,30831.5h134a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-134a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2403" fill="black"><text id="kity_text_14094" text-rendering="inherit" font-size="12" dy=".8em" y="30832.700000047684" x="582.5">说说你经常用的几个注解</text></g></g><g id="minder_node2406" display="none"><g id="node_expander2401" display="none" style="cursor: pointer;"><path id="kity_path_27725" fill="white" stroke="gray" d="M598.5,30840.5A6,6,0,1,1,586.5,30840.5A6,6,0,1,1,598.5,30840.5"></path><path id="kity_path_27726" fill="none" stroke="gray"></path></g><path id="node_outline2402" fill="none" stroke="none" d="M598.5,30831.5h325a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-325a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2402" fill="black"><text id="kity_text_14092" text-rendering="inherit" font-size="12" dy=".8em" y="30832.700000047684" x="598.5">1.@Component,@Service,@Mapper,@Bean,@Autowired</text></g></g><g id="minder_node2407" display="none"><g id="node_expander2404" display="none" style="cursor: pointer;"><path id="kity_path_27734" fill="white" stroke="gray" d="M582.5,30848.5A6,6,0,1,1,570.5,30848.5A6,6,0,1,1,582.5,30848.5"></path><path id="kity_path_27735" fill="none" stroke="gray"></path></g><path id="node_outline2405" fill="none" stroke="none" d="M582.5,30839.5h181a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-181a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2405" fill="black"><text id="kity_text_14103" text-rendering="inherit" font-size="12" dy=".8em" y="30840.700000047684" x="582.5">说说你刚刚说的这几个注解的作用</text></g></g><g id="minder_node2408" display="none"><g id="node_expander2403" display="none" style="cursor: pointer;"><path id="kity_path_27731" fill="white" stroke="gray" d="M598.5,30848.5A6,6,0,1,1,586.5,30848.5A6,6,0,1,1,598.5,30848.5"></path><path id="kity_path_27732" fill="none" stroke="gray"></path></g><path id="node_outline2404" fill="none" stroke="none" d="M598.5,30794.5h1201a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1201a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text2404" fill="black"><text id="kity_text_14096" text-rendering="inherit" font-size="12" dy=".8em" y="30795.700000047684" x="598.5">1.@Component, ：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</text><text id="kity_text_14097" text-rendering="inherit" font-size="12" dy=".8em" y="30813.700000047684" x="598.5">2.@Service,对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</text><text id="kity_text_14098" text-rendering="inherit" font-size="12" dy=".8em" y="30831.700000047684" x="598.5">3.@Mapper,表示是dao层</text><text id="kity_text_14099" text-rendering="inherit" font-size="12" dy=".8em" y="30849.700000047684" x="598.5">4.@Bean,用于告诉方法，产生一个Bean对象，然后这个Bean对象交给Spring管理。产生这个Bean对象的方法Spring只会调用一次，随后这个Spring将会将这个Bean对象放在自己的IOC容器中。然后@Scope可以控制作用域，</text><text id="kity_text_14100" text-rendering="inherit" font-size="12" dy=".8em" y="30867.700000047684" x="598.5">5.@Autowired 自动导入对象到类中，被注入进的类同样要被 Spring 容器管理</text><text id="kity_text_14101" text-rendering="inherit" font-size="12" dy=".8em" y="30885.700000047684" x="598.5">6.@Controller&#xa0; 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</text></g></g><g id="minder_node2409" display="none"><g id="node_expander2406" display="none" style="cursor: pointer;"><path id="kity_path_27740" fill="white" stroke="gray" d="M582.5,30856.5A6,6,0,1,1,570.5,30856.5A6,6,0,1,1,582.5,30856.5"></path><path id="kity_path_27741" fill="none" stroke="gray"></path></g><path id="node_outline2407" fill="none" stroke="none" d="M582.5,30847.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2407" fill="black"><text id="kity_text_14108" text-rendering="inherit" font-size="12" dy=".8em" y="30848.700000047684" x="582.5">怎么用注解的方式配置spring</text></g></g><g id="minder_node2410" display="none"><g id="node_expander2405" display="none" style="cursor: pointer;"><path id="kity_path_27737" fill="white" stroke="gray" d="M598.5,30856.5A6,6,0,1,1,586.5,30856.5A6,6,0,1,1,598.5,30856.5"></path><path id="kity_path_27738" fill="none" stroke="gray"></path></g><path id="node_outline2406" fill="none" stroke="none" d="M598.5,30838.5h518a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-518a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2406" fill="black"><text id="kity_text_14105" text-rendering="inherit" font-size="12" dy=".8em" y="30839.700000047684" x="598.5">1.spring中我们需要去开启配置，然后就可以使用注解比如 @Autowire&#xa0; @Resource 了装配bean</text><text id="kity_text_14106" text-rendering="inherit" font-size="12" dy=".8em" y="30857.700000047684" x="598.5">2.springboot中我们可以直接使用</text></g></g><g id="minder_node2411" display="none"><g id="node_expander2409" display="none" style="cursor: pointer;"><path id="kity_path_27749" fill="white" stroke="gray" d="M582.5,30864.5A6,6,0,1,1,570.5,30864.5A6,6,0,1,1,582.5,30864.5"></path><path id="kity_path_27750" fill="none" stroke="gray"></path></g><path id="node_outline2410" fill="none" stroke="none" d="M582.5,30855.5h362a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-362a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2410" fill="black"><text id="kity_text_14120" text-rendering="inherit" font-size="12" dy=".8em" y="30856.700000047684" x="582.5">@Autowired和@resource的区别？和@Autowired同作用的注解？</text></g></g><g id="minder_node2412" display="none"><g id="node_expander2408" display="none" style="cursor: pointer;"><path id="kity_path_27746" fill="white" stroke="gray" d="M598.5,30864.5A6,6,0,1,1,586.5,30864.5A6,6,0,1,1,598.5,30864.5"></path><path id="kity_path_27747" fill="none" stroke="gray"></path></g><path id="node_outline2409" fill="none" stroke="none" d="M598.5,30819.5h1046a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1046a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text2409" fill="black"><text id="kity_text_14114" text-rendering="inherit" font-size="12" dy=".8em" y="30820.700000047684" x="598.5">1.这两个都可以来装配bean。可以作用在成员变量和setter方法上。</text><text id="kity_text_14115" text-rendering="inherit" font-size="12" dy=".8em" y="30838.700000047684" x="598.5">@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在（可以设置它required属性为false）。如果要使用我们指定的装配名称 可以加上 @Qualifier&#xa0;按照Name方式来装配。</text><text id="kity_text_14116" text-rendering="inherit" font-size="12" dy=".8em" y="30856.700000047684" x="598.5">@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。如果我们指定了name属性，就只会根据name来查找</text><text id="kity_text_14117" text-rendering="inherit" font-size="12" dy=".8em" y="30874.700000047684" x="598.5">2.这两个注解使用的是不同的后置处理器处理，resource是CommonAnnotation autowire是AutowiredAnnotation，</text><text id="kity_text_14118" text-rendering="inherit" font-size="12" dy=".8em" y="30892.700000047684" x="598.5">3.@Inject&#xa0; 按类型装配，功能比@Autowired少，没有使用的必要。</text></g></g><g id="minder_node2413" display="none"><g id="node_expander2407" display="none" style="cursor: pointer;"><path id="kity_path_27743" fill="white" stroke="gray" d="M614.5,30864.5A6,6,0,1,1,602.5,30864.5A6,6,0,1,1,614.5,30864.5"></path><path id="kity_path_27744" fill="none" stroke="gray"></path></g><path id="node_outline2408" fill="none" stroke="none" d="M614.5,30837.5h367a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-367a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2408" fill="black"><text id="kity_text_14110" text-rendering="inherit" font-size="12" dy=".8em" y="30838.700000047684" x="614.5">https://blog.csdn.net/weixin_40423597/article/details/80643990</text><text id="kity_text_14111" text-rendering="inherit" font-size="12" dy=".8em" y="30856.700000047684" x="614.5">https://blog.csdn.net/CPLASF_/article/details/109225213</text><text id="kity_text_14112" text-rendering="inherit" font-size="12" dy=".8em" y="30874.700000047684" x="614.5">https://blog.csdn.net/gavin_john/article/details/81051343</text></g></g><g id="minder_node2414" display="none"><g id="node_expander2411" display="none" style="cursor: pointer;"><path id="kity_path_27755" fill="white" stroke="gray" d="M582.5,30872.5A6,6,0,1,1,570.5,30872.5A6,6,0,1,1,582.5,30872.5"></path><path id="kity_path_27756" fill="none" stroke="gray"></path></g><path id="node_outline2412" fill="none" stroke="none" d="M582.5,30863.5h138a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-138a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2412" fill="black"><text id="kity_text_14124" text-rendering="inherit" font-size="12" dy=".8em" y="30864.700000047684" x="582.5">控制bean加载顺序注解？</text></g></g><g id="minder_node2415" display="none"><g id="node_expander2410" display="none" style="cursor: pointer;"><path id="kity_path_27752" fill="white" stroke="gray" d="M598.5,30872.5A6,6,0,1,1,586.5,30872.5A6,6,0,1,1,598.5,30872.5"></path><path id="kity_path_27753" fill="none" stroke="gray"></path></g><path id="node_outline2411" fill="none" stroke="none" d="M598.5,30863.5h54a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-54a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2411" fill="black"><text id="kity_text_14122" text-rendering="inherit" font-size="12" dy=".8em" y="30864.700000047684" x="598.5">1.@order</text></g></g><g id="minder_node2416" display="none"><g id="node_expander2413" display="none" style="cursor: pointer;"><path id="kity_path_27761" fill="white" stroke="gray" d="M582.5,30880.5A6,6,0,1,1,570.5,30880.5A6,6,0,1,1,582.5,30880.5"></path><path id="kity_path_27762" fill="none" stroke="gray"></path></g><path id="node_outline2414" fill="none" stroke="none" d="M582.5,30871.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2414" fill="black"><text id="kity_text_14129" text-rendering="inherit" font-size="12" dy=".8em" y="30872.700000047684" x="582.5">参考文章</text></g></g><g id="minder_node2417" display="none"><g id="node_expander2412" display="none" style="cursor: pointer;"><path id="kity_path_27758" fill="white" stroke="gray" d="M598.5,30880.5A6,6,0,1,1,586.5,30880.5A6,6,0,1,1,598.5,30880.5"></path><path id="kity_path_27759" fill="none" stroke="gray"></path></g><path id="node_outline2413" fill="none" stroke="none" d="M598.5,30862.5h333a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2413" fill="black"><text id="kity_text_14126" text-rendering="inherit" font-size="12" dy=".8em" y="30863.700000047684" x="598.5">https://juejin.cn/post/6844904136492711950#heading-27</text><text id="kity_text_14127" text-rendering="inherit" font-size="12" dy=".8em" y="30881.700000047684" x="598.5">https://juejin.cn/post/6844903911250198542</text></g></g><g id="minder_node2418" display="none"><g id="node_expander2416" display="none" style="cursor: pointer;"><path id="kity_path_27770" fill="white" stroke="gray" d="M566.5,30888.5A6,6,0,1,1,554.5,30888.5A6,6,0,1,1,566.5,30888.5"></path><path id="kity_path_27771" fill="none" stroke="gray"></path></g><path id="node_outline2417" fill="none" stroke="none" d="M566.5,30879.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2417" fill="black"><text id="kity_text_14138" text-rendering="inherit" font-size="12" dy=".8em" y="30880.700000047684" x="566.5">spring参考文章</text></g></g><g id="minder_node2419" display="none"><g id="node_expander2415" display="none" style="cursor: pointer;"><path id="kity_path_27767" fill="white" stroke="gray" d="M582.5,30888.5A6,6,0,1,1,570.5,30888.5A6,6,0,1,1,582.5,30888.5"></path><path id="kity_path_27768" fill="none" stroke="gray"></path></g><path id="node_outline2416" fill="none" stroke="none" d="M582.5,30852.5h370a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-370a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text2416" fill="black"><text id="kity_text_14133" text-rendering="inherit" font-size="12" dy=".8em" y="30853.700000047684" x="582.5">1.https://juejin.cn/post/6844904127051513864#heading-34</text><text id="kity_text_14134" text-rendering="inherit" font-size="12" dy=".8em" y="30871.700000047684" x="582.5">2.https://juejin.cn/post/6844904137776168973#heading-10</text><text id="kity_text_14135" text-rendering="inherit" font-size="12" dy=".8em" y="30889.700000047684" x="582.5">3.https://juejin.cn/post/6844904036777345037#heading-9</text><text id="kity_text_14136" text-rendering="inherit" font-size="12" dy=".8em" y="30907.700000047684" x="582.5">4.https://www.yuque.com/itsaysay/mzsmvg/10.spring#e2266f87</text></g></g><g id="minder_node2420" display="none"><g id="node_expander2470" display="none" style="cursor: pointer;"><path id="kity_path_27932" fill="white" stroke="gray" d="M550.5,30896.5A6,6,0,1,1,538.5,30896.5A6,6,0,1,1,550.5,30896.5"></path><path id="kity_path_27933" fill="none" stroke="gray"></path></g><path id="node_outline2471" fill="none" stroke="none" d="M550.5,30887.5h64a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-64a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2471" fill="black"><text id="kity_text_14303" text-rendering="inherit" font-size="12" dy=".8em" y="30888.700000047684" x="550.5">springboot</text></g></g><g id="minder_node2421" display="none"><g id="node_expander2457" display="none" style="cursor: pointer;"><path id="kity_path_27893" fill="white" stroke="gray" d="M566.5,30872.5A6,6,0,1,1,554.5,30872.5A6,6,0,1,1,566.5,30872.5"></path><path id="kity_path_27894" fill="none" stroke="gray"></path></g><path id="node_outline2458" fill="none" stroke="none" d="M566.5,30863.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2458" fill="black"><text id="kity_text_14263" text-rendering="inherit" font-size="12" dy=".8em" y="30864.700000047684" x="566.5">基础</text></g></g><g id="minder_node2422" display="none"><g id="node_expander2420" display="none" style="cursor: pointer;"><path id="kity_path_27782" fill="white" stroke="gray" d="M582.5,30784.5A6,6,0,1,1,570.5,30784.5A6,6,0,1,1,582.5,30784.5"></path><path id="kity_path_27783" fill="none" stroke="gray"></path></g><path id="node_outline2421" fill="none" stroke="none" d="M582.5,30775.5h205a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-205a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2421" fill="black"><text id="kity_text_14149" text-rendering="inherit" font-size="12" dy=".8em" y="30776.700000047684" x="582.5">知道spirng boot starter的工作原理吗</text></g></g><g id="minder_node2423" display="none"><g id="node_expander2419" display="none" style="cursor: pointer;"><path id="kity_path_27779" fill="white" stroke="gray" d="M598.5,30784.5A6,6,0,1,1,586.5,30784.5A6,6,0,1,1,598.5,30784.5"></path><path id="kity_path_27780" fill="none" stroke="gray"></path></g><path id="node_outline2420" fill="none" stroke="none" d="M598.5,30748.5h1118a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1118a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text2420" fill="black"><text id="kity_text_14144" text-rendering="inherit" font-size="12" dy=".8em" y="30749.700000047684" x="598.5">1.starter主要是引入模块所需的jar包，比如mybatis-starter 就把mybatsis相关的依赖给你引入。然后是自动配置引入的各个模块所需的属性</text><text id="kity_text_14145" text-rendering="inherit" font-size="12" dy=".8em" y="30767.700000047684" x="598.5">2.配置starter的属性，当引入starter以后在META-INF下有一个配置文件 表明当前引入的starter在springboot的配置属性 既而解决各个starter的属性配置</text><text id="kity_text_14146" text-rendering="inherit" font-size="12" dy=".8em" y="30785.700000047684" x="598.5">3.自动配置引入的依赖的bean，主要是通过xxxAutoConfiguration,它会通过@Import导入自动配置选择器，然后去读取spring.factories文件,该文件里配置了所有需要被创建spring容器中的bean的全限定类名，</text><text id="kity_text_14147" text-rendering="inherit" font-size="12" dy=".8em" y="30803.700000047684" x="598.5">并且进行自动配置把bean注入SpringContext中，这样在启动的时候自动扫描然后加载实例化相关的bean，放入ioc容器中</text></g></g><g id="minder_node2424" display="none"><g id="node_expander2418" display="none" style="cursor: pointer;"><path id="kity_path_27776" fill="white" stroke="gray" d="M614.5,30784.5A6,6,0,1,1,602.5,30784.5A6,6,0,1,1,614.5,30784.5"></path><path id="kity_path_27777" fill="none" stroke="gray"></path></g><path id="node_outline2419" fill="none" stroke="none" d="M614.5,30775.5h339a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-339a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2419" fill="black"><text id="kity_text_14142" text-rendering="inherit" font-size="12" dy=".8em" y="30776.700000047684" x="614.5">https://blog.csdn.net/songzehao/article/details/100837463</text></g></g><g id="minder_node2425" display="none"><g id="node_expander2422" display="none" style="cursor: pointer;"><path id="kity_path_27788" fill="white" stroke="gray" d="M582.5,30792.5A6,6,0,1,1,570.5,30792.5A6,6,0,1,1,582.5,30792.5"></path><path id="kity_path_27789" fill="none" stroke="gray"></path></g><path id="node_outline2423" fill="none" stroke="none" d="M582.5,30783.5h99a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-99a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2423" fill="black"><text id="kity_text_14155" text-rendering="inherit" font-size="12" dy=".8em" y="30784.700000047684" x="582.5">如何自定义starter</text></g></g><g id="minder_node2426" display="none"><g id="node_expander2421" display="none" style="cursor: pointer;"><path id="kity_path_27785" fill="white" stroke="gray" d="M598.5,30792.5A6,6,0,1,1,586.5,30792.5A6,6,0,1,1,598.5,30792.5"></path><path id="kity_path_27786" fill="none" stroke="gray"></path></g><path id="node_outline2422" fill="none" stroke="none" d="M598.5,30765.5h1521a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1521a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2422" fill="black"><text id="kity_text_14151" text-rendering="inherit" font-size="12" dy=".8em" y="30766.700000047684" x="598.5">1.需要两个模块 都删除启动类和test， 一个自动配置类 模块名-spring-boot-autoconfiguration 编写 自动配置类的proerties 和 serveice 和 serviceAutoConfiguration&#xa0; 并且在全限定类路径 加入 META-INF下的spring.factories， 一个自动配置的启动器 模块名-spring-boot-starter；&#xa0;</text><text id="kity_text_14152" text-rendering="inherit" font-size="12" dy=".8em" y="30784.700000047684" x="598.5">2. 然后在启动器模块pom.xml里面引入我们的自定义自动配置依赖，</text><text id="kity_text_14153" text-rendering="inherit" font-size="12" dy=".8em" y="30802.700000047684" x="598.5">3.后续使用就直接引入我们自定义的starter即可</text></g></g><g id="minder_node2427" display="none"><g id="node_expander2425" display="none" style="cursor: pointer;"><path id="kity_path_27797" fill="white" stroke="gray" d="M582.5,30800.5A6,6,0,1,1,570.5,30800.5A6,6,0,1,1,582.5,30800.5"></path><path id="kity_path_27798" fill="none" stroke="gray"></path></g><path id="node_outline2426" fill="none" stroke="none" d="M582.5,30791.5h218a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-218a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2426" fill="black"><text id="kity_text_14163" text-rendering="inherit" font-size="12" dy=".8em" y="30792.700000047684" x="582.5">怎么在启动时读取配置文件，有哪些方式</text></g></g><g id="minder_node2428" display="none"><g id="node_expander2424" display="none" style="cursor: pointer;"><path id="kity_path_27794" fill="white" stroke="gray" d="M598.5,30800.5A6,6,0,1,1,586.5,30800.5A6,6,0,1,1,598.5,30800.5"></path><path id="kity_path_27795" fill="none" stroke="gray"></path></g><path id="node_outline2425" fill="none" stroke="none" d="M598.5,30773.5h925a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-925a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2425" fill="black"><text id="kity_text_14159" text-rendering="inherit" font-size="12" dy=".8em" y="30774.700000047684" x="598.5">1.通过@Value注解</text><text id="kity_text_14160" text-rendering="inherit" font-size="12" dy=".8em" y="30792.700000047684" x="598.5">2.@ConfigurationProperties和&#xa0; @Compent&#xa0;</text><text id="kity_text_14161" text-rendering="inherit" font-size="12" dy=".8em" y="30810.700000047684" x="598.5">3.如果加载自定义配置文件可以使用 @PropertySource 加载我们的.properties配置文件，如果是yml，就实现PropertySourceFactory接口，重写createPropertySource方法</text></g></g><g id="minder_node2429" display="none"><g id="node_expander2423" display="none" style="cursor: pointer;"><path id="kity_path_27791" fill="white" stroke="gray" d="M614.5,30800.5A6,6,0,1,1,602.5,30800.5A6,6,0,1,1,614.5,30800.5"></path><path id="kity_path_27792" fill="none" stroke="gray"></path></g><path id="node_outline2424" fill="none" stroke="none" d="M614.5,30791.5h306a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-306a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2424" fill="black"><text id="kity_text_14157" text-rendering="inherit" font-size="12" dy=".8em" y="30792.700000047684" x="614.5">https://cloud.tencent.com/developer/article/1481440</text></g></g><g id="minder_node2430" display="none"><g id="node_expander2428" display="none" style="cursor: pointer;"><path id="kity_path_27806" fill="white" stroke="gray" d="M582.5,30808.5A6,6,0,1,1,570.5,30808.5A6,6,0,1,1,582.5,30808.5"></path><path id="kity_path_27807" fill="none" stroke="gray"></path></g><path id="node_outline2429" fill="none" stroke="none" d="M582.5,30799.5h224a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-224a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2429" fill="black"><text id="kity_text_14169" text-rendering="inherit" font-size="12" dy=".8em" y="30800.700000047684" x="582.5">怎么在spring boot启动时执行特定的代码</text></g></g><g id="minder_node2431" display="none"><g id="node_expander2427" display="none" style="cursor: pointer;"><path id="kity_path_27803" fill="white" stroke="gray" d="M598.5,30808.5A6,6,0,1,1,586.5,30808.5A6,6,0,1,1,598.5,30808.5"></path><path id="kity_path_27804" fill="none" stroke="gray"></path></g><path id="node_outline2428" fill="none" stroke="none" d="M598.5,30799.5h583a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-583a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2428" fill="black"><text id="kity_text_14167" text-rendering="inherit" font-size="12" dy=".8em" y="30800.700000047684" x="598.5">1.实现CommandLineRunner 接口重写run方法 或者实现接口 ApplicationRunner ，然后注入bean 调用即可</text></g></g><g id="minder_node2432" display="none"><g id="node_expander2426" display="none" style="cursor: pointer;"><path id="kity_path_27800" fill="white" stroke="gray" d="M614.5,30808.5A6,6,0,1,1,602.5,30808.5A6,6,0,1,1,614.5,30808.5"></path><path id="kity_path_27801" fill="none" stroke="gray"></path></g><path id="node_outline2427" fill="none" stroke="none" d="M614.5,30794.5h384a5,5,0,0,1,5,5v18a5,5,0,0,1,-5,5h-384a5,5,0,0,1,-5,-5v-18a5,5,0,0,1,5,-5z"></path><g id="node_text2427" fill="black"><text id="kity_text_14165" text-rendering="inherit" font-size="12" dy=".8em" y="30800.700000047684" x="614.5">https://blog.csdn.net/qq877728715/article/details/110860306</text></g><a id="kity_a_16967" xlink:href="https://gitee.com/xiaobo97/simple-viw-web/blob/master/edupaas_perent/canal_client/src/main/java/com/viw/canal/CanalApplicationMain.java" target="_blank" xlink:title="https://gitee.com/xiaobo97/simple-viw-web/blob/master/edupaas_perent/canal_client/src/main/java/com/viw/canal/CanalApplicationMain.java" style="cursor: pointer;"><path id="kity_path_16969" fill="rgba(255, 255, 255, 0)" stroke="none" d="M978.5,30797.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16968" fill="#666" stroke="none" d="M993.114,30813.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V30807.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C988.766,30804.571,990.168,30803.5,991.836,30803.5h1.278c2.116,0,3.834,1.716,3.834,3.834V30809.89C996.948,30812.008,995.23,30813.724,993.114,30813.724zM981.612,30808.612c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S991.265,30809.89,990.558,30809.89H982.89C982.185,30809.89,981.612,30809.319,981.612,30808.612zM979.056,30807.334V30809.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H980.334C978.216,30813.724,976.5,30812.008,976.5,30809.89V30807.334C976.5,30805.216,978.216,30803.5,980.334,30803.5h1.278c1.667,0,3.071,1.071,3.599,2.556H980.334C979.629,30806.056,979.056,30806.627,979.056,30807.334z"></path></a></g><g id="minder_node2433" display="none"><g id="node_expander2431" display="none" style="cursor: pointer;"><path id="kity_path_27815" fill="white" stroke="gray" d="M582.5,30816.5A6,6,0,1,1,570.5,30816.5A6,6,0,1,1,582.5,30816.5"></path><path id="kity_path_27816" fill="none" stroke="gray"></path></g><path id="node_outline2432" fill="none" stroke="none" d="M582.5,30807.5h188a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-188a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2432" fill="black"><text id="kity_text_14177" text-rendering="inherit" font-size="12" dy=".8em" y="30808.700000047684" x="582.5">知道spring boot自动配置的原理吗</text></g></g><g id="minder_node2434" display="none"><g id="node_expander2430" display="none" style="cursor: pointer;"><path id="kity_path_27812" fill="white" stroke="gray" d="M598.5,30816.5A6,6,0,1,1,586.5,30816.5A6,6,0,1,1,598.5,30816.5"></path><path id="kity_path_27813" fill="none" stroke="gray"></path></g><path id="node_outline2431" fill="none" stroke="none" d="M598.5,30789.5h1545a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1545a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2431" fill="black"><text id="kity_text_14173" text-rendering="inherit" font-size="12" dy=".8em" y="30790.700000047684" x="598.5">1.主要是Spring Boot的启动类上的核心注解SpringBootApplication注解主配置类，有了这个主配置类启动时就会为SpringBoot开启一个@EnableAutoConfiguration注解自动配置功能。</text><text id="kity_text_14174" text-rendering="inherit" font-size="12" dy=".8em" y="30808.700000047684" x="598.5">然后这个注解通过 @Import 注解导入了AutoConfigurationImportSelector自动配置导入选择器，然后在启动时扫描项目依赖的jar，寻找并从该类 META-INF/spring.factories 的信息中加载可能用到的autoconfigure自动配置类</text><text id="kity_text_14175" text-rendering="inherit" font-size="12" dy=".8em" y="30826.700000047684" x="598.5">2.然后去重并将exclude和excludeName属性携带的类排除，然后过滤筛选条件出以 EnableAutoConfiguration 为 key 的数据，SpringFactoriesLoader能将相应的实现类数据和通过@ComponentScan扫描并注册所有标注了@Component及其子注解的类注入ioc容器中，实现自动配置功能</text></g></g><g id="minder_node2435" display="none"><g id="node_expander2429" display="none" style="cursor: pointer;"><path id="kity_path_27809" fill="white" stroke="gray" d="M614.5,30816.5A6,6,0,1,1,602.5,30816.5A6,6,0,1,1,614.5,30816.5"></path><path id="kity_path_27810" fill="none" stroke="gray"></path></g><path id="node_outline2430" fill="none" stroke="none" d="M614.5,30807.5h304a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-304a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2430" fill="black"><text id="kity_text_14171" text-rendering="inherit" font-size="12" dy=".8em" y="30808.700000047684" x="614.5">http://blog.itpub.net/69912579/viewspace-2767843/</text></g></g><g id="minder_node2436" display="none"><g id="node_expander2433" display="none" style="cursor: pointer;"><path id="kity_path_27821" fill="white" stroke="gray" d="M582.5,30824.5A6,6,0,1,1,570.5,30824.5A6,6,0,1,1,582.5,30824.5"></path><path id="kity_path_27822" fill="none" stroke="gray"></path></g><path id="node_outline2434" fill="none" stroke="none" d="M582.5,30815.5h175a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-175a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2434" fill="black"><text id="kity_text_14182" text-rendering="inherit" font-size="12" dy=".8em" y="30816.700000047684" x="582.5">spring boot怎么解决跨域问题的</text></g></g><g id="minder_node2437" display="none"><g id="node_expander2432" display="none" style="cursor: pointer;"><path id="kity_path_27818" fill="white" stroke="gray" d="M598.5,30824.5A6,6,0,1,1,586.5,30824.5A6,6,0,1,1,598.5,30824.5"></path><path id="kity_path_27819" fill="none" stroke="gray"></path></g><path id="node_outline2433" fill="none" stroke="none" d="M598.5,30806.5h451a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-451a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2433" fill="black"><text id="kity_text_14179" text-rendering="inherit" font-size="12" dy=".8em" y="30807.700000047684" x="598.5">1.可以通过@CrossOrigin 注解来解决跨域问题</text><text id="kity_text_14180" text-rendering="inherit" font-size="12" dy=".8em" y="30825.700000047684" x="598.5">2.不过现在一般都会用网关gateway&#xa0; CorsConfiguration ，也可以统一解决跨域问题</text></g></g><g id="minder_node2438" display="none"><g id="node_expander2435" display="none" style="cursor: pointer;"><path id="kity_path_27827" fill="white" stroke="gray" d="M582.5,30832.5A6,6,0,1,1,570.5,30832.5A6,6,0,1,1,582.5,30832.5"></path><path id="kity_path_27828" fill="none" stroke="gray"></path></g><path id="node_outline2436" fill="none" stroke="none" d="M582.5,30823.5h140a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-140a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2436" fill="black"><text id="kity_text_14187" text-rendering="inherit" font-size="12" dy=".8em" y="30824.700000047684" x="582.5">spring boot怎么实现打包</text></g></g><g id="minder_node2439" display="none"><g id="node_expander2434" display="none" style="cursor: pointer;"><path id="kity_path_27824" fill="white" stroke="gray" d="M598.5,30832.5A6,6,0,1,1,586.5,30832.5A6,6,0,1,1,598.5,30832.5"></path><path id="kity_path_27825" fill="none" stroke="gray"></path></g><path id="node_outline2435" fill="none" stroke="none" d="M598.5,30814.5h535a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-535a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2435" fill="black"><text id="kity_text_14184" text-rendering="inherit" font-size="12" dy=".8em" y="30815.700000047684" x="598.5">1.进入项目目录在控制台输入mvn clean package，clean是清空已存在的项目包，package进行打包</text><text id="kity_text_14185" text-rendering="inherit" font-size="12" dy=".8em" y="30833.700000047684" x="598.5">2.或者点击左边选项栏中的Mavne，先点击clean在点击package</text></g></g><g id="minder_node2440" display="none"><g id="node_expander2437" display="none" style="cursor: pointer;"><path id="kity_path_27833" fill="white" stroke="gray" d="M582.5,30840.5A6,6,0,1,1,570.5,30840.5A6,6,0,1,1,582.5,30840.5"></path><path id="kity_path_27834" fill="none" stroke="gray"></path></g><path id="node_outline2438" fill="none" stroke="none" d="M582.5,30831.5h128a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-128a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2438" fill="black"><text id="kity_text_14192" text-rendering="inherit" font-size="12" dy=".8em" y="30832.700000047684" x="582.5">spring boot怎么热部署</text></g></g><g id="minder_node2441" display="none"><g id="node_expander2436" display="none" style="cursor: pointer;"><path id="kity_path_27830" fill="white" stroke="gray" d="M598.5,30840.5A6,6,0,1,1,586.5,30840.5A6,6,0,1,1,598.5,30840.5"></path><path id="kity_path_27831" fill="none" stroke="gray"></path></g><path id="node_outline2437" fill="none" stroke="none" d="M598.5,30822.5h1729a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1729a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2437" fill="black"><text id="kity_text_14189" text-rendering="inherit" font-size="12" dy=".8em" y="30823.700000047684" x="598.5">1.Spring Boot 实现热部署其实很容易，引入 devtools 依赖即可，这样当编译文件发生变化时，Spring Boot 就会自动重启。在 Eclipse 中，用户按下保存按键，就会自动编译进而重启 Spring Boot，IDEA 中由于是自动保存的，自动保存时并未编译，所以需要开发者按下 Ctrl+F9 进行编译，编译完成后，项目就自动重启了。</text><text id="kity_text_14190" text-rendering="inherit" font-size="12" dy=".8em" y="30841.700000047684" x="598.5">如果仅仅只是页面模板发生变化，Java 类并未发生变化，此时可以不用重启 Spring Boot，使用 LiveReload 插件就可以轻松实现热部署。</text></g></g><g id="minder_node2442" display="none"><g id="node_expander2440" display="none" style="cursor: pointer;"><path id="kity_path_27842" fill="white" stroke="gray" d="M582.5,30848.5A6,6,0,1,1,570.5,30848.5A6,6,0,1,1,582.5,30848.5"></path><path id="kity_path_27843" fill="none" stroke="gray"></path></g><path id="node_outline2441" fill="none" stroke="none" d="M582.5,30839.5h231a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-231a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2441" fill="black"><text id="kity_text_14201" text-rendering="inherit" font-size="12" dy=".8em" y="30840.700000047684" x="582.5">spring boot打成的jar 和普通jar有什么区别</text></g></g><g id="minder_node2443" display="none"><g id="node_expander2439" display="none" style="cursor: pointer;"><path id="kity_path_27839" fill="white" stroke="gray" d="M598.5,30848.5A6,6,0,1,1,586.5,30848.5A6,6,0,1,1,598.5,30848.5"></path><path id="kity_path_27840" fill="none" stroke="gray"></path></g><path id="node_outline2440" fill="none" stroke="none" d="M598.5,30821.5h1001a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1001a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2440" fill="black"><text id="kity_text_14197" text-rendering="inherit" font-size="12" dy=".8em" y="30822.700000047684" x="598.5">1.Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 java -jar xxx.jar 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。</text><text id="kity_text_14198" text-rendering="inherit" font-size="12" dy=".8em" y="30840.700000047684" x="598.5">2.和普通jar结构不一样，普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 \BOOT-INF\classes 目录下才是我们的代码</text><text id="kity_text_14199" text-rendering="inherit" font-size="12" dy=".8em" y="30858.700000047684" x="598.5">3.如果要引用springboot的jar&#xa0; 用默认的maven打包插件，然后打成jar 然后在其他项目中引入座标就可以使用&#xa0;</text></g></g><g id="minder_node2444" display="none"><g id="node_expander2438" display="none" style="cursor: pointer;"><path id="kity_path_27836" fill="white" stroke="gray" d="M614.5,30848.5A6,6,0,1,1,602.5,30848.5A6,6,0,1,1,614.5,30848.5"></path><path id="kity_path_27837" fill="none" stroke="gray"></path></g><path id="node_outline2439" fill="none" stroke="none" d="M614.5,30830.5h377a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-377a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2439" fill="black"><text id="kity_text_14194" text-rendering="inherit" font-size="12" dy=".8em" y="30831.700000047684" x="614.5">1.https://blog.csdn.net/weixin_38903248/article/details/90445216</text><text id="kity_text_14195" text-rendering="inherit" font-size="12" dy=".8em" y="30849.700000047684" x="614.5">2.https://blog.csdn.net/admin_mvip/article/details/104904494</text></g></g><g id="minder_node2445" display="none"><g id="node_expander2442" display="none" style="cursor: pointer;"><path id="kity_path_27848" fill="white" stroke="gray" d="M582.5,30856.5A6,6,0,1,1,570.5,30856.5A6,6,0,1,1,582.5,30856.5"></path><path id="kity_path_27849" fill="none" stroke="gray"></path></g><path id="node_outline2443" fill="none" stroke="none" d="M582.5,30847.5h184a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-184a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2443" fill="black"><text id="kity_text_14214" text-rendering="inherit" font-size="12" dy=".8em" y="30848.700000047684" x="582.5">兄弟 spring boot 启动过程知道不</text></g></g><g id="minder_node2446" display="none"><g id="node_expander2441" display="none" style="cursor: pointer;"><path id="kity_path_27845" fill="white" stroke="gray" d="M598.5,30856.5A6,6,0,1,1,586.5,30856.5A6,6,0,1,1,598.5,30856.5"></path><path id="kity_path_27846" fill="none" stroke="gray"></path></g><path id="node_outline2442" fill="none" stroke="none" d="M598.5,30766.5h895a5,5,0,0,1,5,5v170a5,5,0,0,1,-5,5h-895a5,5,0,0,1,-5,-5v-170a5,5,0,0,1,5,-5z"></path><g id="node_text2442" fill="black"><text id="kity_text_14203" text-rendering="inherit" font-size="12" dy=".8em" y="30767.700000047684" x="598.5">1.启动类调用springapplication.run方法。run方法中里面首先构建SpringApplication对象，然后再调用run方法</text><text id="kity_text_14204" text-rendering="inherit" font-size="12" dy=".8em" y="30785.700000047684" x="598.5">2.构建启动类对象过程中，主要是将要加载sources放入primarySources变量中，然后判断webApplication是什么类型的，</text><text id="kity_text_14205" text-rendering="inherit" font-size="12" dy=".8em" y="30803.700000047684" x="598.5">设置ApplicationContextInitializer，ApplicationListener，通过加载META-INF/spring.factories中配置的类，然后找到main方法找到启动主类</text><text id="kity_text_14206" text-rendering="inherit" font-size="12" dy=".8em" y="30821.700000047684" x="598.5">3.run方法做的工作</text><text id="kity_text_14207" text-rendering="inherit" font-size="12" dy=".8em" y="30839.700000047684" x="598.5">3.1构建StopWatch，主要是监控启动过程，统计启动时间，检测应用是否已经启动或者停止。</text><text id="kity_text_14208" text-rendering="inherit" font-size="12" dy=".8em" y="30857.700000047684" x="598.5">3.2构建加载SpringApplicationRunListener(也是通过META-INF/spring.factories),然后调用starting()方法，然后根据args创建应用参数解析器ApplicationArguments;</text><text id="kity_text_14209" text-rendering="inherit" font-size="12" dy=".8em" y="30875.700000047684" x="598.5">3.3准备环境变量：获取环境变量environment，将应用参数放入到环境变量持有对象中，监听器监听环境变量对象的变化</text><text id="kity_text_14210" text-rendering="inherit" font-size="12" dy=".8em" y="30893.700000047684" x="598.5">3.4打印Banner信息(SpringBootBanner)</text><text id="kity_text_14211" text-rendering="inherit" font-size="12" dy=".8em" y="30911.700000047684" x="598.5">3.5创建SpringBoot的应用上下文，然后做上下文的准备，然后refresh刷新上下文</text><text id="kity_text_14212" text-rendering="inherit" font-size="12" dy=".8em" y="30929.700000047684" x="598.5">3.6然后afterRefresh(ApplicationRunner,CommandLineRunner接口实现类的启动)一些启动时要执行的自定义代码，然后解释返回上下文对象</text></g></g><g id="minder_node2447" display="none"><g id="node_expander2444" display="none" style="cursor: pointer;"><path id="kity_path_27854" fill="white" stroke="gray" d="M582.5,30864.5A6,6,0,1,1,570.5,30864.5A6,6,0,1,1,582.5,30864.5"></path><path id="kity_path_27855" fill="none" stroke="gray"></path></g><path id="node_outline2445" fill="none" stroke="none" d="M582.5,30855.5h171a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-171a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2445" fill="black"><text id="kity_text_14218" text-rendering="inherit" font-size="12" dy=".8em" y="30856.700000047684" x="582.5">spring boot的run方法干了什么</text></g></g><g id="minder_node2448" display="none"><g id="node_expander2443" display="none" style="cursor: pointer;"><path id="kity_path_27851" fill="white" stroke="gray" d="M598.5,30864.5A6,6,0,1,1,586.5,30864.5A6,6,0,1,1,598.5,30864.5"></path><path id="kity_path_27852" fill="none" stroke="gray"></path></g><path id="node_outline2444" fill="none" stroke="none" d="M598.5,30855.5h102a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-102a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2444" fill="black"><text id="kity_text_14216" text-rendering="inherit" font-size="12" dy=".8em" y="30856.700000047684" x="598.5">1.上面run方法一样</text></g></g><g id="minder_node2449" display="none"><g id="node_expander2456" display="none" style="cursor: pointer;"><path id="kity_path_27890" fill="white" stroke="gray" d="M582.5,30872.5A6,6,0,1,1,570.5,30872.5A6,6,0,1,1,582.5,30872.5"></path><path id="kity_path_27891" fill="none" stroke="gray"></path></g><path id="node_outline2457" fill="none" stroke="none" d="M582.5,30863.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2457" fill="black"><text id="kity_text_14261" text-rendering="inherit" font-size="12" dy=".8em" y="30864.700000047684" x="582.5">注解方面</text></g></g><g id="minder_node2450" display="none"><g id="node_expander2446" display="none" style="cursor: pointer;"><path id="kity_path_27860" fill="white" stroke="gray" d="M598.5,30840.5A6,6,0,1,1,586.5,30840.5A6,6,0,1,1,598.5,30840.5"></path><path id="kity_path_27861" fill="none" stroke="gray"></path></g><path id="node_outline2447" fill="none" stroke="none" d="M598.5,30831.5h213a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-213a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2447" fill="black"><text id="kity_text_14225" text-rendering="inherit" font-size="12" dy=".8em" y="30832.700000047684" x="598.5">springboot声明bean的注解你知道哪些</text></g></g><g id="minder_node2451" display="none"><g id="node_expander2445" display="none" style="cursor: pointer;"><path id="kity_path_27857" fill="white" stroke="gray" d="M614.5,30840.5A6,6,0,1,1,602.5,30840.5A6,6,0,1,1,614.5,30840.5"></path><path id="kity_path_27858" fill="none" stroke="gray"></path></g><path id="node_outline2446" fill="none" stroke="none" d="M614.5,30804.5h303a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-303a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text2446" fill="black"><text id="kity_text_14220" text-rendering="inherit" font-size="12" dy=".8em" y="30805.700000047684" x="614.5">1.@Component 没有明确角色的组件</text><text id="kity_text_14221" text-rendering="inherit" font-size="12" dy=".8em" y="30823.700000047684" x="614.5">2.@Service 在业务逻辑层（Service层）使用</text><text id="kity_text_14222" text-rendering="inherit" font-size="12" dy=".8em" y="30841.700000047684" x="614.5">3.@Repositpry 在数据访问层（dao层）使用</text><text id="kity_text_14223" text-rendering="inherit" font-size="12" dy=".8em" y="30859.700000047684" x="614.5">4.@Controller 用于标注控制层组件 和@RestController</text></g></g><g id="minder_node2452" display="none"><g id="node_expander2448" display="none" style="cursor: pointer;"><path id="kity_path_27866" fill="white" stroke="gray" d="M598.5,30848.5A6,6,0,1,1,586.5,30848.5A6,6,0,1,1,598.5,30848.5"></path><path id="kity_path_27867" fill="none" stroke="gray"></path></g><path id="node_outline2449" fill="none" stroke="none" d="M598.5,30839.5h231a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-231a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2449" fill="black"><text id="kity_text_14232" text-rendering="inherit" font-size="12" dy=".8em" y="30840.700000047684" x="598.5">@EnableAutoConfiguratoin的作用是什么</text></g></g><g id="minder_node2453" display="none"><g id="node_expander2447" display="none" style="cursor: pointer;"><path id="kity_path_27863" fill="white" stroke="gray" d="M614.5,30848.5A6,6,0,1,1,602.5,30848.5A6,6,0,1,1,614.5,30848.5"></path><path id="kity_path_27864" fill="none" stroke="gray"></path></g><path id="node_outline2448" fill="none" stroke="none" d="M614.5,30812.5h982a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-982a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text2448" fill="black"><text id="kity_text_14227" text-rendering="inherit" font-size="12" dy=".8em" y="30813.700000047684" x="614.5">1.使用了@EnableAutoConfiguration注解就能实现自动配置。</text><text id="kity_text_14228" text-rendering="inherit" font-size="12" dy=".8em" y="30831.700000047684" x="614.5">2.从classpath中搜索所有META-INF/spring.factories配置文件然后，将其中org.springframework.boot.autoconfigure.EnableAutoConfiguration key对应的配置项加载到spring容器</text><text id="kity_text_14229" text-rendering="inherit" font-size="12" dy=".8em" y="30849.700000047684" x="614.5">只有spring.boot.enableautoconfiguration为true（默认为true）的时候，才启用自动配置</text><text id="kity_text_14230" text-rendering="inherit" font-size="12" dy=".8em" y="30867.700000047684" x="614.5">3.还可以通过exclude来排除</text></g></g><g id="minder_node2454" display="none"><g id="node_expander2450" display="none" style="cursor: pointer;"><path id="kity_path_27872" fill="white" stroke="gray" d="M598.5,30856.5A6,6,0,1,1,586.5,30856.5A6,6,0,1,1,598.5,30856.5"></path><path id="kity_path_27873" fill="none" stroke="gray"></path></g><path id="node_outline2451" fill="none" stroke="none" d="M598.5,30847.5h173a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-173a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2451" fill="black"><text id="kity_text_14242" text-rendering="inherit" font-size="12" dy=".8em" y="30848.700000047684" x="598.5">你知道哪些springboot常用注解</text></g></g><g id="minder_node2455" display="none"><g id="node_expander2449" display="none" style="cursor: pointer;"><path id="kity_path_27869" fill="white" stroke="gray" d="M614.5,30856.5A6,6,0,1,1,602.5,30856.5A6,6,0,1,1,614.5,30856.5"></path><path id="kity_path_27870" fill="none" stroke="gray"></path></g><path id="node_outline2450" fill="none" stroke="none" d="M614.5,30793.5h494a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-494a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text2450" fill="black"><text id="kity_text_14234" text-rendering="inherit" font-size="12" dy=".8em" y="30794.700000047684" x="614.5">和spring是差不多的</text><text id="kity_text_14235" text-rendering="inherit" font-size="12" dy=".8em" y="30812.700000047684" x="614.5">1.@ComponentScan 组件扫描，可自动发现和装配一些Bean。</text><text id="kity_text_14236" text-rendering="inherit" font-size="12" dy=".8em" y="30830.700000047684" x="614.5">2.@Configuration 声明是一个配置bean</text><text id="kity_text_14237" text-rendering="inherit" font-size="12" dy=".8em" y="30848.700000047684" x="614.5">3.@RestController该注解是@Controller和@ResponseBody的合集,表示这是个控制器Bean</text><text id="kity_text_14238" text-rendering="inherit" font-size="12" dy=".8em" y="30866.700000047684" x="614.5">4.@Autowired 自动导入bean</text><text id="kity_text_14239" text-rendering="inherit" font-size="12" dy=".8em" y="30884.700000047684" x="614.5">5.@PathVariable 获取请求参数</text><text id="kity_text_14240" text-rendering="inherit" font-size="12" dy=".8em" y="30902.700000047684" x="614.5">6.@Bean：用@Bean标注方法等价于XML中配置的bean。</text></g></g><g id="minder_node2456" display="none"><g id="node_expander2453" display="none" style="cursor: pointer;"><path id="kity_path_27881" fill="white" stroke="gray" d="M598.5,30864.5A6,6,0,1,1,586.5,30864.5A6,6,0,1,1,598.5,30864.5"></path><path id="kity_path_27882" fill="none" stroke="gray"></path></g><path id="node_outline2454" fill="none" stroke="none" d="M598.5,30855.5h265a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-265a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2454" fill="black"><text id="kity_text_14255" text-rendering="inherit" font-size="12" dy=".8em" y="30856.700000047684" x="598.5">定时任务@schedule和异步调用@async的区别？</text></g></g><g id="minder_node2457" display="none"><g id="node_expander2452" display="none" style="cursor: pointer;"><path id="kity_path_27878" fill="white" stroke="gray" d="M614.5,30864.5A6,6,0,1,1,602.5,30864.5A6,6,0,1,1,614.5,30864.5"></path><path id="kity_path_27879" fill="none" stroke="gray"></path></g><path id="node_outline2453" fill="none" stroke="none" d="M614.5,30810.5h1139a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1139a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text2453" fill="black"><text id="kity_text_14248" text-rendering="inherit" font-size="12" dy=".8em" y="30811.700000047684" x="614.5">1.相同点：都可以实现任务调度，一个是定时任务，一个是异步任务 底层都是juc包下实现的。</text><text id="kity_text_14249" text-rendering="inherit" font-size="12" dy=".8em" y="30829.700000047684" x="614.5">2.不同点：</text><text id="kity_text_14250" text-rendering="inherit" font-size="12" dy=".8em" y="30847.700000047684" x="614.5">(1)schedule：ScheduledAnnotation后置处理器扫描&#xa0; @Scheduled 注解的方法，将其注册到 ScheduledTaskRegistrar 中。TaskScheduler来执行调度。实现类是ScheduledExecutorService。</text><text id="kity_text_14251" text-rendering="inherit" font-size="12" dy=".8em" y="30865.700000047684" x="614.5">如果我们不配置的话 默认线程池是1，而且默认执行任务会阻塞。可以通过配置文件修改配置。</text><text id="kity_text_14252" text-rendering="inherit" font-size="12" dy=".8em" y="30883.700000047684" x="614.5">(2)async：默认情况下线程池是100，表面方法会通过新线程去执行。async可以将串行化的任务并行化。底层会通过@Async的注解的类 通过代理 也就是aop做支持 生成代理对象实现。可以通过配置文件修改配置。</text><text id="kity_text_14253" text-rendering="inherit" font-size="12" dy=".8em" y="30901.700000047684" x="614.5">(3)schedule+async = 多个任务之间串行，单个任务非阻塞异步执行</text></g></g><g id="minder_node2458" display="none"><g id="node_expander2451" display="none" style="cursor: pointer;"><path id="kity_path_27875" fill="white" stroke="gray" d="M630.5,30864.5A6,6,0,1,1,618.5,30864.5A6,6,0,1,1,630.5,30864.5"></path><path id="kity_path_27876" fill="none" stroke="gray"></path></g><path id="node_outline2452" fill="none" stroke="none" d="M630.5,30837.5h333a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2452" fill="black"><text id="kity_text_14244" text-rendering="inherit" font-size="12" dy=".8em" y="30838.700000047684" x="630.5">https://juejin.cn/post/6921006328559173646#heading-15</text><text id="kity_text_14245" text-rendering="inherit" font-size="12" dy=".8em" y="30856.700000047684" x="630.5">https://www.cnblogs.com/binarylei/p/11788465.html</text><text id="kity_text_14246" text-rendering="inherit" font-size="12" dy=".8em" y="30874.700000047684" x="630.5">https://www.jianshu.com/p/6609f73aa3a4</text></g></g><g id="minder_node2459" display="none"><g id="node_expander2455" display="none" style="cursor: pointer;"><path id="kity_path_27887" fill="white" stroke="gray" d="M598.5,30872.5A6,6,0,1,1,586.5,30872.5A6,6,0,1,1,598.5,30872.5"></path><path id="kity_path_27888" fill="none" stroke="gray"></path></g><path id="node_outline2456" fill="none" stroke="none" d="M598.5,30863.5h98a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-98a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2456" fill="black"><text id="kity_text_14259" text-rendering="inherit" font-size="12" dy=".8em" y="30864.700000047684" x="598.5">如何排除自动配置</text></g></g><g id="minder_node2460" display="none"><g id="node_expander2454" display="none" style="cursor: pointer;"><path id="kity_path_27884" fill="white" stroke="gray" d="M614.5,30872.5A6,6,0,1,1,602.5,30872.5A6,6,0,1,1,614.5,30872.5"></path><path id="kity_path_27885" fill="none" stroke="gray"></path></g><path id="node_outline2455" fill="none" stroke="none" d="M614.5,30863.5h260a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-260a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2455" fill="black"><text id="kity_text_14257" text-rendering="inherit" font-size="12" dy=".8em" y="30864.700000047684" x="614.5">1.@EnableAutoConfiguration的exclude属性。</text></g></g><g id="minder_node2461" display="none"><g id="node_expander2464" display="none" style="cursor: pointer;"><path id="kity_path_27914" fill="white" stroke="gray" d="M566.5,30880.5A6,6,0,1,1,554.5,30880.5A6,6,0,1,1,566.5,30880.5"></path><path id="kity_path_27915" fill="none" stroke="gray"></path></g><path id="node_outline2465" fill="none" stroke="none" d="M566.5,30871.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2465" fill="black"><text id="kity_text_14284" text-rendering="inherit" font-size="12" dy=".8em" y="30872.700000047684" x="566.5">进阶</text></g></g><g id="minder_node2462" display="none"><g id="node_expander2460" display="none" style="cursor: pointer;"><path id="kity_path_27902" fill="white" stroke="gray" d="M582.5,30872.5A6,6,0,1,1,570.5,30872.5A6,6,0,1,1,582.5,30872.5"></path><path id="kity_path_27903" fill="none" stroke="gray"></path></g><path id="node_outline2461" fill="none" stroke="none" d="M582.5,30863.5h196a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-196a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2461" fill="black"><text id="kity_text_14272" text-rendering="inherit" font-size="12" dy=".8em" y="30864.700000047684" x="582.5">说说springboot的过滤器和拦截器？</text></g></g><g id="minder_node2463" display="none"><g id="node_expander2459" display="none" style="cursor: pointer;"><path id="kity_path_27899" fill="white" stroke="gray" d="M598.5,30872.5A6,6,0,1,1,586.5,30872.5A6,6,0,1,1,598.5,30872.5"></path><path id="kity_path_27900" fill="none" stroke="gray"></path></g><path id="node_outline2460" fill="none" stroke="none" d="M598.5,30836.5h997a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-997a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text2460" fill="black"><text id="kity_text_14267" text-rendering="inherit" font-size="12" dy=".8em" y="30837.700000047684" x="598.5">1.过滤器的作用阶段是在请求进入容器后，但请求进入servlet之前进行预处理的。请求结束返回也是，是在servlet处理完后，返回给前端之前。拦截器是作用在处理请求后，和处理完请求后</text><text id="kity_text_14268" text-rendering="inherit" font-size="12" dy=".8em" y="30855.700000047684" x="598.5">2.Filter的执行由Servlet容器回调完成，而拦截器通常通过动态代理（反射）的方式来执行。过滤器可以修改request,而拦截器不能</text><text id="kity_text_14269" text-rendering="inherit" font-size="12" dy=".8em" y="30873.700000047684" x="598.5">3.拦截器更加细化 可以处理方法级别，拦截器是spring的一个组件，ioc来管理 过滤器是servlet的</text><text id="kity_text_14270" text-rendering="inherit" font-size="12" dy=".8em" y="30891.700000047684" x="598.5">4.拦截器可以登录验证，判断用户是否登录。权限验证，判断用户是否有权限访问资源，如校验token。过滤器可以设置字符编码，过滤敏感词汇（防止sql注入）</text></g></g><g id="minder_node2464" display="none"><g id="node_expander2458" display="none" style="cursor: pointer;"><path id="kity_path_27896" fill="white" stroke="gray" d="M614.5,30872.5A6,6,0,1,1,602.5,30872.5A6,6,0,1,1,614.5,30872.5"></path><path id="kity_path_27897" fill="none" stroke="gray"></path></g><path id="node_outline2459" fill="none" stroke="none" d="M614.5,30863.5h238a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-238a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2459" fill="black"><text id="kity_text_14265" text-rendering="inherit" font-size="12" dy=".8em" y="30864.700000047684" x="614.5">https://zhuanlan.zhihu.com/p/340397290</text></g></g><g id="minder_node2465" display="none"><g id="node_expander2463" display="none" style="cursor: pointer;"><path id="kity_path_27911" fill="white" stroke="gray" d="M582.5,30880.5A6,6,0,1,1,570.5,30880.5A6,6,0,1,1,582.5,30880.5"></path><path id="kity_path_27912" fill="none" stroke="gray"></path></g><path id="node_outline2464" fill="none" stroke="none" d="M582.5,30871.5h169a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-169a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2464" fill="black"><text id="kity_text_14282" text-rendering="inherit" font-size="12" dy=".8em" y="30872.700000047684" x="582.5">过滤器和拦截器分别怎么实现？</text></g></g><g id="minder_node2466" display="none"><g id="node_expander2462" display="none" style="cursor: pointer;"><path id="kity_path_27908" fill="white" stroke="gray" d="M598.5,30880.5A6,6,0,1,1,586.5,30880.5A6,6,0,1,1,598.5,30880.5"></path><path id="kity_path_27909" fill="none" stroke="gray"></path></g><path id="node_outline2463" fill="none" stroke="none" d="M598.5,30835.5h968a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-968a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text2463" fill="black"><text id="kity_text_14276" text-rendering="inherit" font-size="12" dy=".8em" y="30836.700000047684" x="598.5">1.过滤器</text><text id="kity_text_14277" text-rendering="inherit" font-size="12" dy=".8em" y="30854.700000047684" x="598.5">方式1使用spring boot提供的FilterRegistrationBean注册Filter&#xa0; 需要去自定义实现filter接口，然后注册自定义Filter</text><text id="kity_text_14278" text-rendering="inherit" font-size="12" dy=".8em" y="30872.700000047684" x="598.5">方式2直接用@WebFilter就可以进行配置 定义过滤器名字和过滤url</text><text id="kity_text_14279" text-rendering="inherit" font-size="12" dy=".8em" y="30890.700000047684" x="598.5">2.拦截器</text><text id="kity_text_14280" text-rendering="inherit" font-size="12" dy=".8em" y="30908.700000047684" x="598.5">继承 HandlerInterceptorAdapter类 或者 实现HandlerInterceptor接口 一般是 实现接口，然后重写他的前置拦截方法和后置拦截方法，前置返回ture才会执行后置，然后注册拦截器</text></g></g><g id="minder_node2467" display="none"><g id="node_expander2461" display="none" style="cursor: pointer;"><path id="kity_path_27905" fill="white" stroke="gray" d="M614.5,30880.5A6,6,0,1,1,602.5,30880.5A6,6,0,1,1,614.5,30880.5"></path><path id="kity_path_27906" fill="none" stroke="gray"></path></g><path id="node_outline2462" fill="none" stroke="none" d="M614.5,30866.5h79a5,5,0,0,1,5,5v18a5,5,0,0,1,-5,5h-79a5,5,0,0,1,-5,-5v-18a5,5,0,0,1,5,-5z"></path><g id="node_text2462" fill="black"><text id="kity_text_14274" text-rendering="inherit" font-size="12" dy=".8em" y="30872.700000047684" x="614.5">分支主题</text></g><a id="kity_a_16970" xlink:href="https://gitee.com/xiaobo97/viwmall/blob/master/viwmall-order/src/main/java/com/viw/viwmall/order/interceptor/LoginUserInterceptor.java" target="_blank" xlink:title="https://gitee.com/xiaobo97/viwmall/blob/master/viwmall-order/src/main/java/com/viw/viwmall/order/interceptor/LoginUserInterceptor.java" style="cursor: pointer;"><path id="kity_path_16972" fill="rgba(255, 255, 255, 0)" stroke="none" d="M673.5,30869.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16971" fill="#666" stroke="none" d="M688.114,30885.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V30879.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C683.766,30876.571,685.168,30875.5,686.836,30875.5h1.278c2.116,0,3.834,1.716,3.834,3.834V30881.89C691.948,30884.008,690.23,30885.724,688.114,30885.724zM676.612,30880.612c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S686.265,30881.89,685.558,30881.89H677.89C677.185,30881.89,676.612,30881.319,676.612,30880.612zM674.056,30879.334V30881.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H675.334C673.216,30885.724,671.5,30884.008,671.5,30881.89V30879.334C671.5,30877.216,673.216,30875.5,675.334,30875.5h1.278c1.667,0,3.071,1.071,3.599,2.556H675.334C674.629,30878.056,674.056,30878.627,674.056,30879.334z"></path></a></g><g id="minder_node2468" display="none"><g id="node_expander2467" display="none" style="cursor: pointer;"><path id="kity_path_27923" fill="white" stroke="gray" d="M566.5,30888.5A6,6,0,1,1,554.5,30888.5A6,6,0,1,1,566.5,30888.5"></path><path id="kity_path_27924" fill="none" stroke="gray"></path></g><path id="node_outline2468" fill="none" stroke="none" d="M566.5,30879.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2468" fill="black"><text id="kity_text_14291" text-rendering="inherit" font-size="12" dy=".8em" y="30880.700000047684" x="566.5">问题排查和场景优化</text></g></g><g id="minder_node2469" display="none"><g id="node_expander2466" display="none" style="cursor: pointer;"><path id="kity_path_27920" fill="white" stroke="gray" d="M582.5,30888.5A6,6,0,1,1,570.5,30888.5A6,6,0,1,1,582.5,30888.5"></path><path id="kity_path_27921" fill="none" stroke="gray"></path></g><path id="node_outline2467" fill="none" stroke="none" d="M582.5,30879.5h252a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-252a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2467" fill="black"><text id="kity_text_14289" text-rendering="inherit" font-size="12" dy=".8em" y="30880.700000047684" x="582.5">springboot内置tomcat和外置的tomcat区别？</text></g></g><g id="minder_node2470" display="none"><g id="node_expander2465" display="none" style="cursor: pointer;"><path id="kity_path_27917" fill="white" stroke="gray" d="M598.5,30888.5A6,6,0,1,1,586.5,30888.5A6,6,0,1,1,598.5,30888.5"></path><path id="kity_path_27918" fill="none" stroke="gray"></path></g><path id="node_outline2466" fill="none" stroke="none" d="M598.5,30870.5h847a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-847a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2466" fill="black"><text id="kity_text_14286" text-rendering="inherit" font-size="12" dy=".8em" y="30871.700000047684" x="598.5">1.部署：tomcat上我们丢war包上去后，他会自动地去解包启动，可以不需要重启tomcat或者可以只替换某个文件部署，springboot的话需要重新打包再重启。</text><text id="kity_text_14287" text-rendering="inherit" font-size="12" dy=".8em" y="30889.700000047684" x="598.5">2.jar -r需要重新打包重启，war不需要</text></g></g><g id="minder_node2471" display="none"><g id="node_expander2469" display="none" style="cursor: pointer;"><path id="kity_path_27929" fill="white" stroke="gray" d="M566.5,30896.5A6,6,0,1,1,554.5,30896.5A6,6,0,1,1,566.5,30896.5"></path><path id="kity_path_27930" fill="none" stroke="gray"></path></g><path id="node_outline2470" fill="none" stroke="none" d="M566.5,30887.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2470" fill="black"><text id="kity_text_14301" text-rendering="inherit" font-size="12" dy=".8em" y="30888.700000047684" x="566.5">参考文章</text></g></g><g id="minder_node2472" display="none"><g id="node_expander2468" display="none" style="cursor: pointer;"><path id="kity_path_27926" fill="white" stroke="gray" d="M582.5,30896.5A6,6,0,1,1,570.5,30896.5A6,6,0,1,1,582.5,30896.5"></path><path id="kity_path_27927" fill="none" stroke="gray"></path></g><path id="node_outline2469" fill="none" stroke="none" d="M582.5,30833.5h336a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-336a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text2469" fill="black"><text id="kity_text_14293" text-rendering="inherit" font-size="12" dy=".8em" y="30834.700000047684" x="582.5">1.https://juejin.cn/post/6844903904052772872</text><text id="kity_text_14294" text-rendering="inherit" font-size="12" dy=".8em" y="30852.700000047684" x="582.5">2.https://juejin.cn/post/6844903870749999117</text><text id="kity_text_14295" text-rendering="inherit" font-size="12" dy=".8em" y="30870.700000047684" x="582.5">3.https://juejin.cn/post/6844904005219385358</text><text id="kity_text_14296" text-rendering="inherit" font-size="12" dy=".8em" y="30888.700000047684" x="582.5">4.https://juejin.cn/post/6844904125709156359</text><text id="kity_text_14297" text-rendering="inherit" font-size="12" dy=".8em" y="30906.700000047684" x="582.5">5.https://juejin.cn/post/6844904148316471310#heading-0</text><text id="kity_text_14298" text-rendering="inherit" font-size="12" dy=".8em" y="30924.700000047684" x="582.5">6.https://mp.weixin.qq.com/s/ut3mRwhfqXNjrBtTmI0oWg</text><text id="kity_text_14299" text-rendering="inherit" font-size="12" dy=".8em" y="30942.700000047684" x="582.5">7.https://juejin.cn/post/6844904036777345037</text></g></g><g id="minder_node2473" display="none"><g id="node_expander2471" display="none" style="cursor: pointer;"><path id="kity_path_27935" fill="white" stroke="gray" d="M550.5,30904.5A6,6,0,1,1,538.5,30904.5A6,6,0,1,1,550.5,30904.5"></path><path id="kity_path_27936" fill="none" stroke="gray"></path></g><path id="node_outline2472" fill="none" stroke="none" d="M550.5,30895.5h77a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-77a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2472" fill="black"><text id="kity_text_14305" text-rendering="inherit" font-size="12" dy=".8em" y="30896.700000047684" x="550.5">springsecuity</text></g></g><g id="minder_node2474" display="none"><g id="node_expander2472" display="none" style="cursor: pointer;"><path id="kity_path_27938" fill="white" stroke="gray" d="M550.5,30912.5A6,6,0,1,1,538.5,30912.5A6,6,0,1,1,550.5,30912.5"></path><path id="kity_path_27939" fill="none" stroke="gray"></path></g><path id="node_outline2473" fill="none" stroke="none" d="M550.5,30903.5h78a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-78a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2473" fill="black"><text id="kity_text_14307" text-rendering="inherit" font-size="12" dy=".8em" y="30904.700000047684" x="550.5">springsession</text></g></g><g id="minder_node2475"><g id="node_expander2529" style="cursor: pointer;"><path id="kity_path_28109" fill="white" stroke="gray" d="M397.5,30954.5A6,6,0,1,1,385.5,30954.5A6,6,0,1,1,397.5,30954.5"></path><path id="kity_path_28110" fill="none" stroke="gray" d="M387,30954.5L396,30954.5M391.5,30950L391.5,30959"></path></g><path id="node_outline2530" fill="rgb(239, 238, 246)" stroke="rgb(123, 115, 191)" d="M401.5,30941.5h139a3,3,0,0,1,3,3v20a3,3,0,0,1,-3,3h-139a3,3,0,0,1,-3,-3v-20a3,3,0,0,1,3,-3z" stroke-width="1"></path><g id="node_text2530" fill="black"><text id="kity_text_14469" text-rendering="inherit" font-size="14" dy=".8em" y="30945.400000095367" x="418.5">7.mybatis&amp;plus</text></g></g><g id="minder_node2476" display="none"><g id="node_expander2494" display="none" style="cursor: pointer;"><path id="kity_path_28004" fill="white" stroke="gray" d="M559.5,30922.5A6,6,0,1,1,547.5,30922.5A6,6,0,1,1,559.5,30922.5"></path><path id="kity_path_28005" fill="none" stroke="gray"></path></g><path id="node_outline2495" fill="none" stroke="none" d="M559.5,30913.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2495" fill="black"><text id="kity_text_14367" text-rendering="inherit" font-size="12" dy=".8em" y="30914.700000047684" x="559.5">基础</text></g></g><g id="minder_node2477" display="none"><g id="node_expander2475" display="none" style="cursor: pointer;"><path id="kity_path_27947" fill="white" stroke="gray" d="M575.5,30850.5A6,6,0,1,1,563.5,30850.5A6,6,0,1,1,575.5,30850.5"></path><path id="kity_path_27948" fill="none" stroke="gray"></path></g><path id="node_outline2476" fill="none" stroke="none" d="M575.5,30841.5h124a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-124a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2476" fill="black"><text id="kity_text_14313" text-rendering="inherit" font-size="12" dy=".8em" y="30842.700000047684" x="575.5">#{} 和 ${}的区别是什么</text></g></g><g id="minder_node2478" display="none"><g id="node_expander2474" display="none" style="cursor: pointer;"><path id="kity_path_27944" fill="white" stroke="gray" d="M591.5,30850.5A6,6,0,1,1,579.5,30850.5A6,6,0,1,1,591.5,30850.5"></path><path id="kity_path_27945" fill="none" stroke="gray"></path></g><path id="node_outline2475" fill="none" stroke="none" d="M591.5,30841.5h819a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-819a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2475" fill="black"><text id="kity_text_14311" text-rendering="inherit" font-size="12" dy=".8em" y="30842.700000047684" x="591.5">#{}是占位符，会预编译，在处理时是会处理成？，可以防止sql注入。${}没有预编译，在处理时是直接进行字符替换，${}可以用来处理字符串拼接的情景。</text></g></g><g id="minder_node2479" display="none"><g id="node_expander2477" display="none" style="cursor: pointer;"><path id="kity_path_27953" fill="white" stroke="gray" d="M575.5,30858.5A6,6,0,1,1,563.5,30858.5A6,6,0,1,1,575.5,30858.5"></path><path id="kity_path_27954" fill="none" stroke="gray"></path></g><path id="node_outline2478" fill="none" stroke="none" d="M575.5,30849.5h237a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-237a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2478" fill="black"><text id="kity_text_14321" text-rendering="inherit" font-size="12" dy=".8em" y="30850.700000047684" x="575.5">mybatis的工作执行流程了解吗，大概说一下</text></g></g><g id="minder_node2480" display="none"><g id="node_expander2476" display="none" style="cursor: pointer;"><path id="kity_path_27950" fill="white" stroke="gray" d="M591.5,30858.5A6,6,0,1,1,579.5,30858.5A6,6,0,1,1,591.5,30858.5"></path><path id="kity_path_27951" fill="none" stroke="gray"></path></g><path id="node_outline2477" fill="none" stroke="none" d="M591.5,30813.5h1538a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1538a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text2477" fill="black"><text id="kity_text_14315" text-rendering="inherit" font-size="12" dy=".8em" y="30814.700000047684" x="591.5">1.首先读取主配置文件，加载mapper映射文件，解析xml，生成configuration对象，里面缓存了配置内容。</text><text id="kity_text_14316" text-rendering="inherit" font-size="12" dy=".8em" y="30832.700000047684" x="591.5">2.构建会话工厂，创建sqlsession，里面包含了执行sql的方法。</text><text id="kity_text_14317" text-rendering="inherit" font-size="12" dy=".8em" y="30850.700000047684" x="591.5">3.通过sqlsession获取mapper对象，会通过代理mapper工厂newInstance方法然后加上jdk动态代理得到mapperproxy的代理类，mapper的真实对象是mapperproxy，MapperProxy 继承 InvocationHandler，实现 invoke 方法，调用mapper方法都会执行mapper代理类的invoke方法。</text><text id="kity_text_14318" text-rendering="inherit" font-size="12" dy=".8em" y="30868.700000047684" x="591.5">4.然后是执行器的创建,MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。然后创建MappedStatement 对象 里面存储要映射的sql的信息</text><text id="kity_text_14319" text-rendering="inherit" font-size="12" dy=".8em" y="30886.700000047684" x="591.5">5.然后是对输入参数的映射，最后对结果集进行映射解析。</text></g></g><g id="minder_node2481" display="none"><g id="node_expander2479" display="none" style="cursor: pointer;"><path id="kity_path_27959" fill="white" stroke="gray" d="M575.5,30866.5A6,6,0,1,1,563.5,30866.5A6,6,0,1,1,575.5,30866.5"></path><path id="kity_path_27960" fill="none" stroke="gray"></path></g><path id="node_outline2480" fill="none" stroke="none" d="M575.5,30848.5h223a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-223a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2480" fill="black"><text id="kity_text_14326" text-rendering="inherit" font-size="12" dy=".8em" y="30849.700000047684" x="575.5">mybatis为什么只要写dao而不用写实现？</text><text id="kity_text_14327" text-rendering="inherit" font-size="12" dy=".8em" y="30867.700000047684" x="575.5">或者是dao的工作原理？</text></g></g><g id="minder_node2482" display="none"><g id="node_expander2478" display="none" style="cursor: pointer;"><path id="kity_path_27956" fill="white" stroke="gray" d="M591.5,30866.5A6,6,0,1,1,579.5,30866.5A6,6,0,1,1,591.5,30866.5"></path><path id="kity_path_27957" fill="none" stroke="gray"></path></g><path id="node_outline2479" fill="none" stroke="none" d="M591.5,30848.5h883a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-883a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2479" fill="black"><text id="kity_text_14323" text-rendering="inherit" font-size="12" dy=".8em" y="30849.700000047684" x="591.5">1.Mybatis 提供了 Mapper接口的代理对象，在执行 Mapper接口方法时，实际执行的是Mybatis的代理对象，</text><text id="kity_text_14324" text-rendering="inherit" font-size="12" dy=".8em" y="30867.700000047684" x="591.5">代理对象在 invoke 方法内获取 Mapper接口类全名+方法全名 作为statement的ID，然后通过ID去Statement匹配注册的SQL，然后使用 SqlSession 执行这个 SQL。</text></g></g><g id="minder_node2483" display="none"><g id="node_expander2481" display="none" style="cursor: pointer;"><path id="kity_path_27965" fill="white" stroke="gray" d="M575.5,30874.5A6,6,0,1,1,563.5,30874.5A6,6,0,1,1,575.5,30874.5"></path><path id="kity_path_27966" fill="none" stroke="gray"></path></g><path id="node_outline2482" fill="none" stroke="none" d="M575.5,30865.5h130a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-130a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2482" fill="black"><text id="kity_text_14332" text-rendering="inherit" font-size="12" dy=".8em" y="30866.700000047684" x="575.5">mybatis有哪几种执行器</text></g></g><g id="minder_node2484" display="none"><g id="node_expander2480" display="none" style="cursor: pointer;"><path id="kity_path_27962" fill="white" stroke="gray" d="M591.5,30874.5A6,6,0,1,1,579.5,30874.5A6,6,0,1,1,591.5,30874.5"></path><path id="kity_path_27963" fill="none" stroke="gray"></path></g><path id="node_outline2481" fill="none" stroke="none" d="M591.5,30856.5h1795a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1795a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2481" fill="black"><text id="kity_text_14329" text-rendering="inherit" font-size="12" dy=".8em" y="30857.700000047684" x="591.5">1.Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。</text><text id="kity_text_14330" text-rendering="inherit" font-size="12" dy=".8em" y="30875.700000047684" x="591.5">2.SIMPLE：简易执行器，默认的执行器，每次执行查或改就会创建statement对象，用完就关闭；REUSE：执行重用预处理语句，会以sql作为key查找statement对象，不存在就创建，用完放入map中，下次使用；BATCH:执行重用语句和批量更新，针对批量专用的执行器，改是会添加到批处理等待统一执行，缓存了多个statement对象；</text></g></g><g id="minder_node2485" display="none"><g id="node_expander2483" display="none" style="cursor: pointer;"><path id="kity_path_27971" fill="white" stroke="gray" d="M575.5,30882.5A6,6,0,1,1,563.5,30882.5A6,6,0,1,1,575.5,30882.5"></path><path id="kity_path_27972" fill="none" stroke="gray"></path></g><path id="node_outline2484" fill="none" stroke="none" d="M575.5,30873.5h226a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-226a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2484" fill="black"><text id="kity_text_14337" text-rendering="inherit" font-size="12" dy=".8em" y="30874.700000047684" x="575.5">mybatis的MappedStatement对象是什么</text></g></g><g id="minder_node2486" display="none"><g id="node_expander2482" display="none" style="cursor: pointer;"><path id="kity_path_27968" fill="white" stroke="gray" d="M591.5,30882.5A6,6,0,1,1,579.5,30882.5A6,6,0,1,1,591.5,30882.5"></path><path id="kity_path_27969" fill="none" stroke="gray"></path></g><path id="node_outline2483" fill="none" stroke="none" d="M591.5,30864.5h951a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-951a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2483" fill="black"><text id="kity_text_14334" text-rendering="inherit" font-size="12" dy=".8em" y="30865.700000047684" x="591.5">1.MappedStatement是一个final类型也就是说实例化之后就不允许改变</text><text id="kity_text_14335" text-rendering="inherit" font-size="12" dy=".8em" y="30883.700000047684" x="591.5">2.在Mybatis中，每一个&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签，都会被解析为一个MappedStatement对象。这个对象描述的就是一条SQL语句，是对这些节点的封装</text></g></g><g id="minder_node2487" display="none"><g id="node_expander2485" display="none" style="cursor: pointer;"><path id="kity_path_27977" fill="white" stroke="gray" d="M575.5,30890.5A6,6,0,1,1,563.5,30890.5A6,6,0,1,1,575.5,30890.5"></path><path id="kity_path_27978" fill="none" stroke="gray"></path></g><path id="node_outline2486" fill="none" stroke="none" d="M575.5,30881.5h177a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-177a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2486" fill="black"><text id="kity_text_14343" text-rendering="inherit" font-size="12" dy=".8em" y="30882.700000047684" x="575.5">mybatis支持延迟加载吗，原理呢</text></g></g><g id="minder_node2488" display="none"><g id="node_expander2484" display="none" style="cursor: pointer;"><path id="kity_path_27974" fill="white" stroke="gray" d="M591.5,30890.5A6,6,0,1,1,579.5,30890.5A6,6,0,1,1,591.5,30890.5"></path><path id="kity_path_27975" fill="none" stroke="gray"></path></g><path id="node_outline2485" fill="none" stroke="none" d="M591.5,30863.5h1022a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1022a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2485" fill="black"><text id="kity_text_14339" text-rendering="inherit" font-size="12" dy=".8em" y="30864.700000047684" x="591.5">1.Mybatis仅支持一对一，一对多查询关联对象的延迟加载。可以通过主配置启用延迟加载lazyLoadingEnabled=true|false。</text><text id="kity_text_14340" text-rendering="inherit" font-size="12" dy=".8em" y="30882.700000047684" x="591.5">2.使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，执行数据加载。也就是说对象存在依赖关系我会先去获取依赖对象然后进行属性set方法，再调用被依赖对象的方法</text><text id="kity_text_14341" text-rendering="inherit" font-size="12" dy=".8em" y="30900.700000047684" x="591.5">3.延迟关联对象的select查询，减轻数据库压力</text></g></g><g id="minder_node2489" display="none"><g id="node_expander2487" display="none" style="cursor: pointer;"><path id="kity_path_27983" fill="white" stroke="gray" d="M575.5,30898.5A6,6,0,1,1,563.5,30898.5A6,6,0,1,1,575.5,30898.5"></path><path id="kity_path_27984" fill="none" stroke="gray"></path></g><path id="node_outline2488" fill="none" stroke="none" d="M575.5,30889.5h263a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-263a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2488" fill="black"><text id="kity_text_14349" text-rendering="inherit" font-size="12" dy=".8em" y="30890.700000047684" x="575.5">知道mybatis的一级缓存和二级缓存的原理是什么</text></g></g><g id="minder_node2490" display="none"><g id="node_expander2486" display="none" style="cursor: pointer;"><path id="kity_path_27980" fill="white" stroke="gray" d="M591.5,30898.5A6,6,0,1,1,579.5,30898.5A6,6,0,1,1,591.5,30898.5"></path><path id="kity_path_27981" fill="none" stroke="gray"></path></g><path id="node_outline2487" fill="none" stroke="none" d="M591.5,30871.5h960a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-960a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2487" fill="black"><text id="kity_text_14345" text-rendering="inherit" font-size="12" dy=".8em" y="30872.700000047684" x="591.5">1.一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</text><text id="kity_text_14346" text-rendering="inherit" font-size="12" dy=".8em" y="30890.700000047684" x="591.5">2.二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源。</text><text id="kity_text_14347" text-rendering="inherit" font-size="12" dy=".8em" y="30908.700000047684" x="591.5">默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置</text></g></g><g id="minder_node2491" display="none"><g id="node_expander2489" display="none" style="cursor: pointer;"><path id="kity_path_27989" fill="white" stroke="gray" d="M575.5,30906.5A6,6,0,1,1,563.5,30906.5A6,6,0,1,1,575.5,30906.5"></path><path id="kity_path_27990" fill="none" stroke="gray"></path></g><path id="node_outline2490" fill="none" stroke="none" d="M575.5,30897.5h193a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-193a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2490" fill="black"><text id="kity_text_14354" text-rendering="inherit" font-size="12" dy=".8em" y="30898.700000047684" x="575.5">当类的属性名和字段名不一致怎么办</text></g></g><g id="minder_node2492" display="none"><g id="node_expander2488" display="none" style="cursor: pointer;"><path id="kity_path_27986" fill="white" stroke="gray" d="M591.5,30906.5A6,6,0,1,1,579.5,30906.5A6,6,0,1,1,591.5,30906.5"></path><path id="kity_path_27987" fill="none" stroke="gray"></path></g><path id="node_outline2489" fill="none" stroke="none" d="M591.5,30888.5h429a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-429a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2489" fill="black"><text id="kity_text_14351" text-rendering="inherit" font-size="12" dy=".8em" y="30889.700000047684" x="591.5">1.查询的SQL语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</text><text id="kity_text_14352" text-rendering="inherit" font-size="12" dy=".8em" y="30907.700000047684" x="591.5">2.通过&lt;resultMap&gt;来映射字段名和实体类属性名的对应关系</text></g></g><g id="minder_node2493" display="none"><g id="node_expander2491" display="none" style="cursor: pointer;"><path id="kity_path_27995" fill="white" stroke="gray" d="M575.5,30914.5A6,6,0,1,1,563.5,30914.5A6,6,0,1,1,575.5,30914.5"></path><path id="kity_path_27996" fill="none" stroke="gray"></path></g><path id="node_outline2492" fill="none" stroke="none" d="M575.5,30905.5h146a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-146a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2492" fill="black"><text id="kity_text_14358" text-rendering="inherit" font-size="12" dy=".8em" y="30906.700000047684" x="575.5">如何获取自动增长的主键值</text></g></g><g id="minder_node2494" display="none"><g id="node_expander2490" display="none" style="cursor: pointer;"><path id="kity_path_27992" fill="white" stroke="gray" d="M591.5,30914.5A6,6,0,1,1,579.5,30914.5A6,6,0,1,1,591.5,30914.5"></path><path id="kity_path_27993" fill="none" stroke="gray"></path></g><path id="node_outline2491" fill="none" stroke="none" d="M591.5,30905.5h419a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-419a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2491" fill="black"><text id="kity_text_14356" text-rendering="inherit" font-size="12" dy=".8em" y="30906.700000047684" x="591.5">1.新增标签中添加：keyProperty=" ID " 即可。然后mapper.insert(xx) 返回 id</text></g></g><g id="minder_node2495" display="none"><g id="node_expander2493" display="none" style="cursor: pointer;"><path id="kity_path_28001" fill="white" stroke="gray" d="M575.5,30922.5A6,6,0,1,1,563.5,30922.5A6,6,0,1,1,575.5,30922.5"></path><path id="kity_path_28002" fill="none" stroke="gray"></path></g><path id="node_outline2494" fill="none" stroke="none" d="M575.5,30913.5h142a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-142a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2494" fill="black"><text id="kity_text_14365" text-rendering="inherit" font-size="12" dy=".8em" y="30914.700000047684" x="575.5">mybatis怎么传递多个参数</text></g></g><g id="minder_node2496" display="none"><g id="node_expander2492" display="none" style="cursor: pointer;"><path id="kity_path_27998" fill="white" stroke="gray" d="M591.5,30922.5A6,6,0,1,1,579.5,30922.5A6,6,0,1,1,591.5,30922.5"></path><path id="kity_path_27999" fill="none" stroke="gray"></path></g><path id="node_outline2493" fill="none" stroke="none" d="M591.5,30886.5h1004a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1004a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text2493" fill="black"><text id="kity_text_14360" text-rendering="inherit" font-size="12" dy=".8em" y="30887.700000047684" x="591.5">1.通过 @Param注解&#xa0; #{}里面的名称对应的是注解@Param括号里面修饰的名称。&#xa0; &#xa0;selectUser(@Param("userName") String name&#xa0; &#xa0; &#xa0; &#xa0;#{userName}&#xa0; &#xa0;比较常用这种，&#xa0; 参数不多推荐使用</text><text id="kity_text_14361" text-rendering="inherit" font-size="12" dy=".8em" y="30905.700000047684" x="591.5">2.通过map来传参&#xa0; &#xa0;selectUser(Map&lt;String, Object&gt; params)&#xa0; user_name = #{userName}&#xa0; 然后&#xa0; #{}里面的名称对应的是Map里面的key名称。</text><text id="kity_text_14362" text-rendering="inherit" font-size="12" dy=".8em" y="30923.700000047684" x="591.5">3.也可以通过java pojo来传参， 通过调用传入参数 parameterType="com.xxx.pojo.User"&#xa0; &#xa0; #{userName}</text><text id="kity_text_14363" text-rendering="inherit" font-size="12" dy=".8em" y="30941.700000047684" x="591.5">#{}里面的名称对应的是User类里面的成员属性。 可读性强</text></g></g><g id="minder_node2497" display="none"><g id="node_expander2523" display="none" style="cursor: pointer;"><path id="kity_path_28091" fill="white" stroke="gray" d="M559.5,30930.5A6,6,0,1,1,547.5,30930.5A6,6,0,1,1,559.5,30930.5"></path><path id="kity_path_28092" fill="none" stroke="gray"></path></g><path id="node_outline2524" fill="none" stroke="none" d="M559.5,30921.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2524" fill="black"><text id="kity_text_14450" text-rendering="inherit" font-size="12" dy=".8em" y="30922.700000047684" x="559.5">进阶</text></g></g><g id="minder_node2498" display="none"><g id="node_expander2496" display="none" style="cursor: pointer;"><path id="kity_path_28010" fill="white" stroke="gray" d="M575.5,30842.5A6,6,0,1,1,563.5,30842.5A6,6,0,1,1,575.5,30842.5"></path><path id="kity_path_28011" fill="none" stroke="gray"></path></g><path id="node_outline2497" fill="none" stroke="none" d="M575.5,30833.5h151a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-151a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2497" fill="black"><text id="kity_text_14371" text-rendering="inherit" font-size="12" dy=".8em" y="30834.700000047684" x="575.5">mybatsplus逆向工程是什么</text></g></g><g id="minder_node2499" display="none"><g id="node_expander2495" display="none" style="cursor: pointer;"><path id="kity_path_28007" fill="white" stroke="gray" d="M591.5,30842.5A6,6,0,1,1,579.5,30842.5A6,6,0,1,1,591.5,30842.5"></path><path id="kity_path_28008" fill="none" stroke="gray"></path></g><path id="node_outline2496" fill="none" stroke="none" d="M591.5,30833.5h817a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-817a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2496" fill="black"><text id="kity_text_14369" text-rendering="inherit" font-size="12" dy=".8em" y="30834.700000047684" x="591.5">1.生成我们需要的普通controller&#xa0; service&#xa0; dao&#xa0; bean 这些类，我们只需要去增加我们自己的逻辑，这些重复的代码比较浪费时间，有很多脚手架可以生成</text></g></g><g id="minder_node2500" display="none"><g id="node_expander2498" display="none" style="cursor: pointer;"><path id="kity_path_28016" fill="white" stroke="gray" d="M575.5,30850.5A6,6,0,1,1,563.5,30850.5A6,6,0,1,1,575.5,30850.5"></path><path id="kity_path_28017" fill="none" stroke="gray"></path></g><path id="node_outline2499" fill="none" stroke="none" d="M575.5,30841.5h77a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-77a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2499" fill="black"><text id="kity_text_14376" text-rendering="inherit" font-size="12" dy=".8em" y="30842.700000047684" x="575.5">动态sql是什么</text></g></g><g id="minder_node2501" display="none"><g id="node_expander2497" display="none" style="cursor: pointer;"><path id="kity_path_28013" fill="white" stroke="gray" d="M591.5,30850.5A6,6,0,1,1,579.5,30850.5A6,6,0,1,1,591.5,30850.5"></path><path id="kity_path_28014" fill="none" stroke="gray"></path></g><path id="node_outline2498" fill="none" stroke="none" d="M591.5,30832.5h1069a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1069a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2498" fill="black"><text id="kity_text_14373" text-rendering="inherit" font-size="12" dy=".8em" y="30833.700000047684" x="591.5">1.Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，Mybatis提供了9种动态sql标签，比如说&#xa0; 以if 标签来判断 当传参有值 才拼接到sql中，&#xa0;</text><text id="kity_text_14374" text-rendering="inherit" font-size="12" dy=".8em" y="30851.700000047684" x="591.5">2.执行原理 是 使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</text></g></g><g id="minder_node2502" display="none"><g id="node_expander2500" display="none" style="cursor: pointer;"><path id="kity_path_28022" fill="white" stroke="gray" d="M575.5,30858.5A6,6,0,1,1,563.5,30858.5A6,6,0,1,1,575.5,30858.5"></path><path id="kity_path_28023" fill="none" stroke="gray"></path></g><path id="node_outline2501" fill="none" stroke="none" d="M575.5,30849.5h170a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-170a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2501" fill="black"><text id="kity_text_14380" text-rendering="inherit" font-size="12" dy=".8em" y="30850.700000047684" x="575.5">mybatis的动态sql是怎么样的，</text></g></g><g id="minder_node2503" display="none"><g id="node_expander2499" display="none" style="cursor: pointer;"><path id="kity_path_28019" fill="white" stroke="gray" d="M591.5,30858.5A6,6,0,1,1,579.5,30858.5A6,6,0,1,1,591.5,30858.5"></path><path id="kity_path_28020" fill="none" stroke="gray"></path></g><path id="node_outline2500" fill="none" stroke="none" d="M591.5,30849.5h107a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-107a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2500" fill="black"><text id="kity_text_14378" text-rendering="inherit" font-size="12" dy=".8em" y="30850.700000047684" x="591.5">1.和上面的问题一样</text></g></g><g id="minder_node2504" display="none"><g id="node_expander2502" display="none" style="cursor: pointer;"><path id="kity_path_28028" fill="white" stroke="gray" d="M575.5,30866.5A6,6,0,1,1,563.5,30866.5A6,6,0,1,1,575.5,30866.5"></path><path id="kity_path_28029" fill="none" stroke="gray"></path></g><path id="node_outline2503" fill="none" stroke="none" d="M575.5,30857.5h142a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-142a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2503" fill="black"><text id="kity_text_14387" text-rendering="inherit" font-size="12" dy=".8em" y="30858.700000047684" x="575.5">mybatis的主键策略有哪些</text></g></g><g id="minder_node2505" display="none"><g id="node_expander2501" display="none" style="cursor: pointer;"><path id="kity_path_28025" fill="white" stroke="gray" d="M591.5,30866.5A6,6,0,1,1,579.5,30866.5A6,6,0,1,1,591.5,30866.5"></path><path id="kity_path_28026" fill="none" stroke="gray"></path></g><path id="node_outline2502" fill="none" stroke="none" d="M591.5,30830.5h148a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-148a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text2502" fill="black"><text id="kity_text_14382" text-rendering="inherit" font-size="12" dy=".8em" y="30831.700000047684" x="591.5">1.AUTO （自动增长策略）</text><text id="kity_text_14383" text-rendering="inherit" font-size="12" dy=".8em" y="30849.700000047684" x="591.5">2.Input（自定义输入策略）</text><text id="kity_text_14384" text-rendering="inherit" font-size="12" dy=".8em" y="30867.700000047684" x="591.5">3.ASSIGN_ID（雪花算法）</text><text id="kity_text_14385" text-rendering="inherit" font-size="12" dy=".8em" y="30885.700000047684" x="591.5">4.UUID</text></g></g><g id="minder_node2506" display="none"><g id="node_expander2505" display="none" style="cursor: pointer;"><path id="kity_path_28037" fill="white" stroke="gray" d="M575.5,30874.5A6,6,0,1,1,563.5,30874.5A6,6,0,1,1,575.5,30874.5"></path><path id="kity_path_28038" fill="none" stroke="gray"></path></g><path id="node_outline2506" fill="none" stroke="none" d="M575.5,30865.5h154a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-154a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2506" fill="black"><text id="kity_text_14394" text-rendering="inherit" font-size="12" dy=".8em" y="30866.700000047684" x="575.5">mybatisplus怎么实现乐观锁</text></g></g><g id="minder_node2507" display="none"><g id="node_expander2504" display="none" style="cursor: pointer;"><path id="kity_path_28034" fill="white" stroke="gray" d="M591.5,30874.5A6,6,0,1,1,579.5,30874.5A6,6,0,1,1,591.5,30874.5"></path><path id="kity_path_28035" fill="none" stroke="gray"></path></g><path id="node_outline2505" fill="none" stroke="none" d="M591.5,30856.5h667a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-667a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2505" fill="black"><text id="kity_text_14391" text-rendering="inherit" font-size="12" dy=".8em" y="30857.700000047684" x="591.5">1.通过版本号实现，然后使用@Version注解 然后使用mybatis-plus的乐观锁插件 即可</text><text id="kity_text_14392" text-rendering="inherit" font-size="12" dy=".8em" y="30875.700000047684" x="591.5">有了一个版本号 以后更新数据都会带着版本号去更新&#xa0; 然后更新数据是会先看版本号是不是和之前带的一样，更新完 版本号+1</text></g></g><g id="minder_node2508" display="none"><g id="node_expander2503" display="none" style="cursor: pointer;"><path id="kity_path_28031" fill="white" stroke="gray" d="M607.5,30874.5A6,6,0,1,1,595.5,30874.5A6,6,0,1,1,607.5,30874.5"></path><path id="kity_path_28032" fill="none" stroke="gray"></path></g><path id="node_outline2504" fill="none" stroke="none" d="M607.5,30865.5h346a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-346a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2504" fill="black"><text id="kity_text_14389" text-rendering="inherit" font-size="12" dy=".8em" y="30866.700000047684" x="607.5">https://blog.csdn.net/qq_35158688/article/details/97897028</text></g></g><g id="minder_node2509" display="none"><g id="node_expander2508" display="none" style="cursor: pointer;"><path id="kity_path_28046" fill="white" stroke="gray" d="M575.5,30882.5A6,6,0,1,1,563.5,30882.5A6,6,0,1,1,575.5,30882.5"></path><path id="kity_path_28047" fill="none" stroke="gray"></path></g><path id="node_outline2509" fill="none" stroke="none" d="M575.5,30873.5h214a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-214a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2509" fill="black"><text id="kity_text_14403" text-rendering="inherit" font-size="12" dy=".8em" y="30874.700000047684" x="575.5">mybatis是怎么实现分页的，原理是什么</text></g></g><g id="minder_node2510" display="none"><g id="node_expander2507" display="none" style="cursor: pointer;"><path id="kity_path_28043" fill="white" stroke="gray" d="M591.5,30882.5A6,6,0,1,1,579.5,30882.5A6,6,0,1,1,591.5,30882.5"></path><path id="kity_path_28044" fill="none" stroke="gray"></path></g><path id="node_outline2508" fill="none" stroke="none" d="M591.5,30855.5h1262a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1262a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2508" fill="black"><text id="kity_text_14399" text-rendering="inherit" font-size="12" dy=".8em" y="30856.700000047684" x="591.5">1.可以使用分页插件,主要思想就是 通过插件的拦截方法内拦截待执行的 sql，然后重写 sql 然后进行分页sql和分页参数的填充</text><text id="kity_text_14400" text-rendering="inherit" font-size="12" dy=".8em" y="30874.700000047684" x="591.5">首先通过拦截获取原生sql解析，然后判断是否有page对象，有就分页解析 没有就直接sql操作，根据sql进行conut优化，然后通过count进行分页，进行查进行询总条数的限制，然后对原sql进行limit拼接，执行拼接后的sql达到分页效果。</text><text id="kity_text_14401" text-rendering="inherit" font-size="12" dy=".8em" y="30892.700000047684" x="591.5">page对象就是分页的依据，count就是内部具体怎么分页的依据，最后一个拼接limit</text></g></g><g id="minder_node2511" display="none"><g id="node_expander2506" display="none" style="cursor: pointer;"><path id="kity_path_28040" fill="white" stroke="gray" d="M607.5,30882.5A6,6,0,1,1,595.5,30882.5A6,6,0,1,1,607.5,30882.5"></path><path id="kity_path_28041" fill="none" stroke="gray"></path></g><path id="node_outline2507" fill="none" stroke="none" d="M607.5,30864.5h347a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-347a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2507" fill="black"><text id="kity_text_14396" text-rendering="inherit" font-size="12" dy=".8em" y="30865.700000047684" x="607.5">https://blog.csdn.net/J080624/article/details/108441600</text><text id="kity_text_14397" text-rendering="inherit" font-size="12" dy=".8em" y="30883.700000047684" x="607.5">https://blog.csdn.net/xiaolegeaizy/article/details/108461284</text></g></g><g id="minder_node2512" display="none"><g id="node_expander2511" display="none" style="cursor: pointer;"><path id="kity_path_28055" fill="white" stroke="gray" d="M575.5,30890.5A6,6,0,1,1,563.5,30890.5A6,6,0,1,1,575.5,30890.5"></path><path id="kity_path_28056" fill="none" stroke="gray"></path></g><path id="node_outline2512" fill="none" stroke="none" d="M575.5,30881.5h169a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-169a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2512" fill="black"><text id="kity_text_14414" text-rendering="inherit" font-size="12" dy=".8em" y="30882.700000047684" x="575.5">插件的原理？怎么自定义插件？</text></g></g><g id="minder_node2513" display="none"><g id="node_expander2510" display="none" style="cursor: pointer;"><path id="kity_path_28052" fill="white" stroke="gray" d="M591.5,30890.5A6,6,0,1,1,579.5,30890.5A6,6,0,1,1,591.5,30890.5"></path><path id="kity_path_28053" fill="none" stroke="gray"></path></g><path id="node_outline2511" fill="none" stroke="none" d="M591.5,30854.5h1167a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1167a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text2511" fill="black"><text id="kity_text_14409" text-rendering="inherit" font-size="12" dy=".8em" y="30855.700000047684" x="591.5">1.只能编写4种接口插件:分页插件PaginationInterceptor、执行分析插件SqlExplainInterceptor、性能分析插件PerformanceInterceptor以及乐观锁插件OptimisticLockerInterceptor。</text><text id="kity_text_14410" text-rendering="inherit" font-size="12" dy=".8em" y="30873.700000047684" x="591.5">2.原理：通过动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行 这4种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler的invoke。只会拦截那些你指定需要拦截 的方法。</text><text id="kity_text_14411" text-rendering="inherit" font-size="12" dy=".8em" y="30891.700000047684" x="591.5">3.实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件 编写注解，指定要拦截哪一个接口的哪些方法</text><text id="kity_text_14412" text-rendering="inherit" font-size="12" dy=".8em" y="30909.700000047684" x="591.5">4.自定义插件可以来监控sql时长 和慢查询</text></g></g><g id="minder_node2514" display="none"><g id="node_expander2509" display="none" style="cursor: pointer;"><path id="kity_path_28049" fill="white" stroke="gray" d="M607.5,30890.5A6,6,0,1,1,595.5,30890.5A6,6,0,1,1,607.5,30890.5"></path><path id="kity_path_28050" fill="none" stroke="gray"></path></g><path id="node_outline2510" fill="none" stroke="none" d="M607.5,30863.5h359a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-359a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2510" fill="black"><text id="kity_text_14405" text-rendering="inherit" font-size="12" dy=".8em" y="30864.700000047684" x="607.5">https://blog.csdn.net/shixiaoling123/article/details/107121054</text><text id="kity_text_14406" text-rendering="inherit" font-size="12" dy=".8em" y="30882.700000047684" x="607.5">https://blog.csdn.net/J080624/article/details/108441600</text><text id="kity_text_14407" text-rendering="inherit" font-size="12" dy=".8em" y="30900.700000047684" x="607.5">https://blog.csdn.net/meism5/article/details/109298885</text></g></g><g id="minder_node2515" display="none"><g id="node_expander2513" display="none" style="cursor: pointer;"><path id="kity_path_28061" fill="white" stroke="gray" d="M575.5,30898.5A6,6,0,1,1,563.5,30898.5A6,6,0,1,1,575.5,30898.5"></path><path id="kity_path_28062" fill="none" stroke="gray"></path></g><path id="node_outline2514" fill="none" stroke="none" d="M575.5,30889.5h155a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-155a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2514" fill="black"><text id="kity_text_14418" text-rendering="inherit" font-size="12" dy=".8em" y="30890.700000047684" x="575.5">简单说说mybatis的工作流程</text></g></g><g id="minder_node2516" display="none"><g id="node_expander2512" display="none" style="cursor: pointer;"><path id="kity_path_28058" fill="white" stroke="gray" d="M591.5,30898.5A6,6,0,1,1,579.5,30898.5A6,6,0,1,1,591.5,30898.5"></path><path id="kity_path_28059" fill="none" stroke="gray"></path></g><path id="node_outline2513" fill="none" stroke="none" d="M538.5,30720.5h200a5,5,0,0,1,5,5v177a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-177a5,5,0,0,1,5,-5z"></path><g id="node_text2513" fill="black"><text id="kity_text_14416" text-rendering="inherit" font-size="12" dy=".8em" y="30890.700000047684" x="591.5">mybatis工作流程</text></g><image id="kity_image_17082" xlink:href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL015QmF0aXMlRTYlQTElODYlRTYlOUUlQjYlRTYlODAlQkIlRTclQkIlOTMvTXlCYXRpcyVFNSVCNyVBNSVFNCVCRCU5QyVFNSU4RSU5RiVFNyU5MCU4Ni5wbmc" x="538.5" y="30723.5" width="200" height="164" xlink:title="mybatis的工作流程"></image></g><g id="minder_node2517" display="none"><g id="node_expander2515" display="none" style="cursor: pointer;"><path id="kity_path_28067" fill="white" stroke="gray" d="M575.5,30906.5A6,6,0,1,1,563.5,30906.5A6,6,0,1,1,575.5,30906.5"></path><path id="kity_path_28068" fill="none" stroke="gray"></path></g><path id="node_outline2516" fill="none" stroke="none" d="M575.5,30897.5h169a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-169a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2516" fill="black"><text id="kity_text_14425" text-rendering="inherit" font-size="12" dy=".8em" y="30898.700000047684" x="575.5">mybatis有 哪些执行器？区别？</text></g></g><g id="minder_node2518" display="none"><g id="node_expander2514" display="none" style="cursor: pointer;"><path id="kity_path_28064" fill="white" stroke="gray" d="M591.5,30906.5A6,6,0,1,1,579.5,30906.5A6,6,0,1,1,591.5,30906.5"></path><path id="kity_path_28065" fill="none" stroke="gray"></path></g><path id="node_outline2515" fill="none" stroke="none" d="M591.5,30870.5h872a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-872a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text2515" fill="black"><text id="kity_text_14420" text-rendering="inherit" font-size="12" dy=".8em" y="30871.700000047684" x="591.5">1.有三种基本执行器 SimpleExecutor，ReuseExecutor，BatchExecutor</text><text id="kity_text_14421" text-rendering="inherit" font-size="12" dy=".8em" y="30889.700000047684" x="591.5">(1)SimpleExecutor:每执行一次 update 或 select，就开启一个 Statement对象，用完立刻关闭Statement对象。</text><text id="kity_text_14422" text-rendering="inherit" font-size="12" dy=".8em" y="30907.700000047684" x="591.5">(2)ReuseExecutor :执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map</text><text id="kity_text_14423" text-rendering="inherit" font-size="12" dy=".8em" y="30925.700000047684" x="591.5">(3)BatchExecutor:完成批处理</text></g></g><g id="minder_node2519" display="none"><g id="node_expander2517" display="none" style="cursor: pointer;"><path id="kity_path_28073" fill="white" stroke="gray" d="M575.5,30914.5A6,6,0,1,1,563.5,30914.5A6,6,0,1,1,575.5,30914.5"></path><path id="kity_path_28074" fill="none" stroke="gray"></path></g><path id="node_outline2518" fill="none" stroke="none" d="M575.5,30905.5h86a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-86a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2518" fill="black"><text id="kity_text_14429" text-rendering="inherit" font-size="12" dy=".8em" y="30906.700000047684" x="575.5">怎么指定执行器</text></g></g><g id="minder_node2520" display="none"><g id="node_expander2516" display="none" style="cursor: pointer;"><path id="kity_path_28070" fill="white" stroke="gray" d="M591.5,30914.5A6,6,0,1,1,579.5,30914.5A6,6,0,1,1,591.5,30914.5"></path><path id="kity_path_28071" fill="none" stroke="gray"></path></g><path id="node_outline2517" fill="none" stroke="none" d="M591.5,30905.5h891a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-891a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2517" fill="black"><text id="kity_text_14427" text-rendering="inherit" font-size="12" dy=".8em" y="30906.700000047684" x="591.5">1.在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递 ExecutorType 类型参数。</text></g></g><g id="minder_node2521" display="none"><g id="node_expander2519" display="none" style="cursor: pointer;"><path id="kity_path_28079" fill="white" stroke="gray" d="M575.5,30922.5A6,6,0,1,1,563.5,30922.5A6,6,0,1,1,575.5,30922.5"></path><path id="kity_path_28080" fill="none" stroke="gray"></path></g><path id="node_outline2520" fill="none" stroke="none" d="M575.5,30913.5h188a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-188a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2520" fill="black"><text id="kity_text_14434" text-rendering="inherit" font-size="12" dy=".8em" y="30914.700000047684" x="575.5">使用mybatis的mapper有哪些要求</text></g></g><g id="minder_node2522" display="none"><g id="node_expander2518" display="none" style="cursor: pointer;"><path id="kity_path_28076" fill="white" stroke="gray" d="M591.5,30922.5A6,6,0,1,1,579.5,30922.5A6,6,0,1,1,591.5,30922.5"></path><path id="kity_path_28077" fill="none" stroke="gray"></path></g><path id="node_outline2519" fill="none" stroke="none" d="M591.5,30904.5h504a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-504a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2519" fill="black"><text id="kity_text_14431" text-rendering="inherit" font-size="12" dy=".8em" y="30905.700000047684" x="591.5">1.mapper接口方法 和对应配置文件的sql id要相同，方法入参和parameterType 的类型相同；</text><text id="kity_text_14432" text-rendering="inherit" font-size="12" dy=".8em" y="30923.700000047684" x="591.5">2.出参类型和resultType 相同，</text></g></g><g id="minder_node2523" display="none"><g id="node_expander2522" display="none" style="cursor: pointer;"><path id="kity_path_28088" fill="white" stroke="gray" d="M575.5,30930.5A6,6,0,1,1,563.5,30930.5A6,6,0,1,1,575.5,30930.5"></path><path id="kity_path_28089" fill="none" stroke="gray"></path></g><path id="node_outline2523" fill="none" stroke="none" d="M575.5,30921.5h237a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-237a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2523" fill="black"><text id="kity_text_14448" text-rendering="inherit" font-size="12" dy=".8em" y="30922.700000047684" x="575.5">mybatis怎么实现一对一，一对多，多对多？</text></g></g><g id="minder_node2524" display="none"><g id="node_expander2521" display="none" style="cursor: pointer;"><path id="kity_path_28085" fill="white" stroke="gray" d="M591.5,30930.5A6,6,0,1,1,579.5,30930.5A6,6,0,1,1,591.5,30930.5"></path><path id="kity_path_28086" fill="none" stroke="gray"></path></g><path id="node_outline2522" fill="none" stroke="none" d="M591.5,30849.5h864a5,5,0,0,1,5,5v152a5,5,0,0,1,-5,5h-864a5,5,0,0,1,-5,-5v-152a5,5,0,0,1,5,-5z"></path><g id="node_text2522" fill="black"><text id="kity_text_14438" text-rendering="inherit" font-size="12" dy=".8em" y="30850.700000047684" x="591.5">1.1对1</text><text id="kity_text_14439" text-rendering="inherit" font-size="12" dy=".8em" y="30868.700000047684" x="591.5">有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次, 通过在resultMap 里面配置 association 节点配置一对一的类就可以完成</text><text id="kity_text_14440" text-rendering="inherit" font-size="12" dy=".8em" y="30886.700000047684" x="591.5">嵌套查询是先查一个表，根据这个表里面的结果的 外键 id，去再另外一个表里面查询数据,也是通过 association 配置，但另外一个表的查询通过 select 属性配置。</text><text id="kity_text_14441" text-rendering="inherit" font-size="12" dy=".8em" y="30904.700000047684" x="591.5">2.1对多</text><text id="kity_text_14442" text-rendering="inherit" font-size="12" dy=".8em" y="30922.700000047684" x="591.5">使用collection 标签</text><text id="kity_text_14443" text-rendering="inherit" font-size="12" dy=".8em" y="30940.700000047684" x="591.5">有联合查询和嵌套查询。联合查询是几个表联合查询,只查询一次,通过在resultMap 里面的 collection 节点配置一对多的类就可以完成</text><text id="kity_text_14444" text-rendering="inherit" font-size="12" dy=".8em" y="30958.700000047684" x="591.5">嵌套查询是先查一个表,根据这个表里面的 结果的外键 id,去再另外一个表里面查询数据,也是通过配置 collection,但另外一个表的查询通过 select 节点配置。</text><text id="kity_text_14445" text-rendering="inherit" font-size="12" dy=".8em" y="30976.700000047684" x="591.5">3.多对多</text><text id="kity_text_14446" text-rendering="inherit" font-size="12" dy=".8em" y="30994.700000047684" x="591.5">关联对象查询 单独发送一个SQL去查询关联对象，赋给主对象，然后返回主对象 或者 使用嵌套查询，似JOIN查询&#xa0;&#xa0;</text></g></g><g id="minder_node2525" display="none"><g id="node_expander2520" display="none" style="cursor: pointer;"><path id="kity_path_28082" fill="white" stroke="gray" d="M607.5,30930.5A6,6,0,1,1,595.5,30930.5A6,6,0,1,1,607.5,30930.5"></path><path id="kity_path_28083" fill="none" stroke="gray"></path></g><path id="node_outline2521" fill="none" stroke="none" d="M607.5,30921.5h358a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-358a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2521" fill="black"><text id="kity_text_14436" text-rendering="inherit" font-size="12" dy=".8em" y="30922.700000047684" x="607.5">https://blog.csdn.net/zhangzhenisme/article/details/96506875</text></g></g><g id="minder_node2526" display="none"><g id="node_expander2525" display="none" style="cursor: pointer;"><path id="kity_path_28097" fill="white" stroke="gray" d="M559.5,30938.5A6,6,0,1,1,547.5,30938.5A6,6,0,1,1,559.5,30938.5"></path><path id="kity_path_28098" fill="none" stroke="gray"></path></g><path id="node_outline2526" fill="none" stroke="none" d="M559.5,30929.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2526" fill="black"><text id="kity_text_14454" text-rendering="inherit" font-size="12" dy=".8em" y="30930.700000047684" x="559.5">场景</text></g></g><g id="minder_node2527" display="none"><g id="node_expander2524" display="none" style="cursor: pointer;"><path id="kity_path_28094" fill="white" stroke="gray" d="M575.5,30938.5A6,6,0,1,1,563.5,30938.5A6,6,0,1,1,575.5,30938.5"></path><path id="kity_path_28095" fill="none" stroke="gray"></path></g><path id="node_outline2525" fill="none" stroke="none" d="M575.5,30929.5h259a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-259a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2525" fill="black"><text id="kity_text_14452" text-rendering="inherit" font-size="12" dy=".8em" y="30930.700000047684" x="575.5">https://juejin.cn/post/6844903866270482440</text></g></g><g id="minder_node2528" display="none"><g id="node_expander2526" display="none" style="cursor: pointer;"><path id="kity_path_28100" fill="white" stroke="gray" d="M559.5,30946.5A6,6,0,1,1,547.5,30946.5A6,6,0,1,1,559.5,30946.5"></path><path id="kity_path_28101" fill="none" stroke="gray"></path></g><path id="node_outline2527" fill="none" stroke="none" d="M559.5,30937.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2527" fill="black"><text id="kity_text_14456" text-rendering="inherit" font-size="12" dy=".8em" y="30938.700000047684" x="559.5">问题排查和问题分析</text></g></g><g id="minder_node2529" display="none"><g id="node_expander2528" display="none" style="cursor: pointer;"><path id="kity_path_28106" fill="white" stroke="gray" d="M559.5,30954.5A6,6,0,1,1,547.5,30954.5A6,6,0,1,1,559.5,30954.5"></path><path id="kity_path_28107" fill="none" stroke="gray"></path></g><path id="node_outline2529" fill="none" stroke="none" d="M559.5,30945.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2529" fill="black"><text id="kity_text_14467" text-rendering="inherit" font-size="12" dy=".8em" y="30946.700000047684" x="559.5">参考文章</text></g></g><g id="minder_node2530" display="none"><g id="node_expander2527" display="none" style="cursor: pointer;"><path id="kity_path_28103" fill="white" stroke="gray" d="M575.5,30954.5A6,6,0,1,1,563.5,30954.5A6,6,0,1,1,575.5,30954.5"></path><path id="kity_path_28104" fill="none" stroke="gray"></path></g><path id="node_outline2528" fill="none" stroke="none" d="M575.5,30882.5h270a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-270a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text2528" fill="black"><text id="kity_text_14458" text-rendering="inherit" font-size="12" dy=".8em" y="30883.700000047684" x="575.5">1.https://juejin.cn/post/6844904040380235784</text><text id="kity_text_14459" text-rendering="inherit" font-size="12" dy=".8em" y="30901.700000047684" x="575.5">2.https://juejin.cn/post/6844904079827664903</text><text id="kity_text_14460" text-rendering="inherit" font-size="12" dy=".8em" y="30919.700000047684" x="575.5">3.https://juejin.cn/post/6844904014673362958</text><text id="kity_text_14461" text-rendering="inherit" font-size="12" dy=".8em" y="30937.700000047684" x="575.5">4.https://juejin.cn/post/6844904125935648776</text><text id="kity_text_14462" text-rendering="inherit" font-size="12" dy=".8em" y="30955.700000047684" x="575.5">5.https://juejin.cn/post/6844903984352722951</text><text id="kity_text_14463" text-rendering="inherit" font-size="12" dy=".8em" y="30973.700000047684" x="575.5">6.https://juejin.cn/post/6847902217006448653</text><text id="kity_text_14464" text-rendering="inherit" font-size="12" dy=".8em" y="30991.700000047684" x="575.5">7.https://juejin.cn/post/6880162580422197255</text><text id="kity_text_14465" text-rendering="inherit" font-size="12" dy=".8em" y="31009.700000047684" x="575.5">8.https://juejin.cn/post/6844904101587714061</text></g></g><g id="minder_node2531"><g id="node_expander2641" style="cursor: pointer;"><path id="kity_path_28445" fill="white" stroke="gray" d="M397.5,30996.5A6,6,0,1,1,385.5,30996.5A6,6,0,1,1,397.5,30996.5"></path><path id="kity_path_28446" fill="none" stroke="gray" d="M387,30996.5L396,30996.5M391.5,30992L391.5,31001"></path></g><path id="node_outline2642" fill="rgb(239, 238, 246)" stroke="rgb(123, 115, 191)" d="M401.5,30983.5h102a3,3,0,0,1,3,3v20a3,3,0,0,1,-3,3h-102a3,3,0,0,1,-3,-3v-20a3,3,0,0,1,3,-3z" stroke-width="1"></path><g id="node_text2642" fill="black"><text id="kity_text_14820" text-rendering="inherit" font-size="14" dy=".8em" y="30987.400000095367" x="418.5">8.消息队列</text></g></g><g id="minder_node2532" display="none"><g id="node_expander2625" display="none" style="cursor: pointer;"><path id="kity_path_28397" fill="white" stroke="gray" d="M522.5,30988.5A6,6,0,1,1,510.5,30988.5A6,6,0,1,1,522.5,30988.5"></path><path id="kity_path_28398" fill="none" stroke="gray"></path></g><path id="node_outline2626" fill="none" stroke="none" d="M522.5,30979.5h53a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-53a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2626" fill="black"><text id="kity_text_14788" text-rendering="inherit" font-size="12" dy=".8em" y="30980.700000047684" x="522.5">rabbitmq</text></g></g><g id="minder_node2533" display="none"><g id="node_expander2561" display="none" style="cursor: pointer;"><path id="kity_path_28205" fill="white" stroke="gray" d="M538.5,30948.5A6,6,0,1,1,526.5,30948.5A6,6,0,1,1,538.5,30948.5"></path><path id="kity_path_28206" fill="none" stroke="gray"></path></g><path id="node_outline2562" fill="none" stroke="none" d="M538.5,30939.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2562" fill="black"><text id="kity_text_14562" text-rendering="inherit" font-size="12" dy=".8em" y="30940.700000047684" x="538.5">基础</text></g></g><g id="minder_node2534" display="none"><g id="node_expander2531" display="none" style="cursor: pointer;"><path id="kity_path_28115" fill="white" stroke="gray" d="M554.5,30844.5A6,6,0,1,1,542.5,30844.5A6,6,0,1,1,554.5,30844.5"></path><path id="kity_path_28116" fill="none" stroke="gray"></path></g><path id="node_outline2532" fill="none" stroke="none" d="M554.5,30835.5h96a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-96a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2532" fill="black"><text id="kity_text_14474" text-rendering="inherit" font-size="12" dy=".8em" y="30836.700000047684" x="554.5">为什么用消息队列</text></g></g><g id="minder_node2535" display="none"><g id="node_expander2530" display="none" style="cursor: pointer;"><path id="kity_path_28112" fill="white" stroke="gray" d="M570.5,30844.5A6,6,0,1,1,558.5,30844.5A6,6,0,1,1,570.5,30844.5"></path><path id="kity_path_28113" fill="none" stroke="gray"></path></g><path id="node_outline2531" fill="none" stroke="none" d="M570.5,30826.5h1609a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1609a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2531" fill="black"><text id="kity_text_14471" text-rendering="inherit" font-size="12" dy=".8em" y="30827.700000047684" x="570.5">1.项目中用mq主要是用在分布式事务上来做可靠信息完成最终一致性 和 一个业务交易信息通知的一个异步，业务交易通知 主要是我们有和其他系统数据交互，然后在我们的xxx模块，</text><text id="kity_text_14472" text-rendering="inherit" font-size="12" dy=".8em" y="30845.700000047684" x="570.5">对于贷款来说 我们是下游，信贷系统是上游，而我们是核心系统的上游，通过mq可以完成我们三个系统之间甚至是和其他系统之间的解耦合，我们的一些业务交易报文 和我们自己系统的 交易流水通知功能 都可以用到mq，然后其他就是吹了....把项目中用的mq的地方抛砖引玉说出来，让面试官去问问题</text></g></g><g id="minder_node2536" display="none"><g id="node_expander2533" display="none" style="cursor: pointer;"><path id="kity_path_28121" fill="white" stroke="gray" d="M554.5,30852.5A6,6,0,1,1,542.5,30852.5A6,6,0,1,1,554.5,30852.5"></path><path id="kity_path_28122" fill="none" stroke="gray"></path></g><path id="node_outline2534" fill="none" stroke="none" d="M554.5,30843.5h185a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-185a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2534" fill="black"><text id="kity_text_14484" text-rendering="inherit" font-size="12" dy=".8em" y="30844.700000047684" x="554.5">知道消息队列有什么优点和场景吗&#xa0;</text></g></g><g id="minder_node2537" display="none"><g id="node_expander2532" display="none" style="cursor: pointer;"><path id="kity_path_28118" fill="white" stroke="gray" d="M570.5,30852.5A6,6,0,1,1,558.5,30852.5A6,6,0,1,1,570.5,30852.5"></path><path id="kity_path_28119" fill="none" stroke="gray"></path></g><path id="node_outline2533" fill="none" stroke="none" d="M570.5,30789.5h1484a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-1484a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text2533" fill="black"><text id="kity_text_14476" text-rendering="inherit" font-size="12" dy=".8em" y="30790.700000047684" x="570.5">1.解耦：A 系统发送数据到 BCD 三个系统，通过接口调用发送。防止A 系统跟其它系统严重耦合，A 系统产生一条比较关键的数据，很多系统都需要 A 系统将这个数据发送过来。如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。</text><text id="kity_text_14477" text-rendering="inherit" font-size="12" dy=".8em" y="30808.700000047684" x="570.5">如果新系统需要数据，直接从 MQ 里消费即可，不需要就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。</text><text id="kity_text_14478" text-rendering="inherit" font-size="12" dy=".8em" y="30826.700000047684" x="570.5">就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦。</text><text id="kity_text_14479" text-rendering="inherit" font-size="12" dy=".8em" y="30844.700000047684" x="570.5">2.异步：非核心业务异步执行,保证主业务流程响应速度。A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。</text><text id="kity_text_14480" text-rendering="inherit" font-size="12" dy=".8em" y="30862.700000047684" x="570.5">加起来接近 1s。用户通过浏览器发起请求。如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 = 8ms。</text><text id="kity_text_14481" text-rendering="inherit" font-size="12" dy=".8em" y="30880.700000047684" x="570.5">3.削峰：减少高峰时期对服务器压力。防止打死后端服务。</text><text id="kity_text_14482" text-rendering="inherit" font-size="12" dy=".8em" y="30898.700000047684" x="570.5">4.消息通讯和日志处理 解决大量日志传输</text></g></g><g id="minder_node2538" display="none"><g id="node_expander2535" display="none" style="cursor: pointer;"><path id="kity_path_28127" fill="white" stroke="gray" d="M554.5,30860.5A6,6,0,1,1,542.5,30860.5A6,6,0,1,1,554.5,30860.5"></path><path id="kity_path_28128" fill="none" stroke="gray"></path></g><path id="node_outline2536" fill="none" stroke="none" d="M554.5,30851.5h156a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-156a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2536" fill="black"><text id="kity_text_14490" text-rendering="inherit" font-size="12" dy=".8em" y="30852.700000047684" x="554.5">那使用消息队列有什么缺点吗</text></g></g><g id="minder_node2539" display="none"><g id="node_expander2534" display="none" style="cursor: pointer;"><path id="kity_path_28124" fill="white" stroke="gray" d="M570.5,30860.5A6,6,0,1,1,558.5,30860.5A6,6,0,1,1,570.5,30860.5"></path><path id="kity_path_28125" fill="none" stroke="gray"></path></g><path id="node_outline2535" fill="none" stroke="none" d="M570.5,30833.5h95a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-95a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2535" fill="black"><text id="kity_text_14486" text-rendering="inherit" font-size="12" dy=".8em" y="30834.700000047684" x="570.5">1.系统可用性降低</text><text id="kity_text_14487" text-rendering="inherit" font-size="12" dy=".8em" y="30852.700000047684" x="570.5">2.系统复杂度提高</text><text id="kity_text_14488" text-rendering="inherit" font-size="12" dy=".8em" y="30870.700000047684" x="570.5">3.一致性问题</text></g></g><g id="minder_node2540" display="none"><g id="node_expander2537" display="none" style="cursor: pointer;"><path id="kity_path_28133" fill="white" stroke="gray" d="M554.5,30868.5A6,6,0,1,1,542.5,30868.5A6,6,0,1,1,554.5,30868.5"></path><path id="kity_path_28134" fill="none" stroke="gray"></path></g><path id="node_outline2538" fill="none" stroke="none" d="M554.5,30859.5h181a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-181a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2538" fill="black"><text id="kity_text_14494" text-rendering="inherit" font-size="12" dy=".8em" y="30860.700000047684" x="554.5">你们用的什么消息队列？为什么？</text></g></g><g id="minder_node2541" display="none"><g id="node_expander2536" display="none" style="cursor: pointer;"><path id="kity_path_28130" fill="white" stroke="gray" d="M570.5,30868.5A6,6,0,1,1,558.5,30868.5A6,6,0,1,1,570.5,30868.5"></path><path id="kity_path_28131" fill="none" stroke="gray"></path></g><path id="node_outline2537" fill="none" stroke="none" d="M570.5,30859.5h1862a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1862a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2537" fill="black"><text id="kity_text_14492" text-rendering="inherit" font-size="12" dy=".8em" y="30860.700000047684" x="570.5">1.我们用的是RabbitMQ 主要是因为 支撑高并发、高吞吐、性能很高，同时有非常完善便捷的后台管理界面可以使用，而且后期还可以扩展支持集群化、高可用部署架构、消息高可靠支持，功能较为完善。而且社区活跃度还可以，用的也比较多，较高频率的迭代版本，来修复发现的bug以及进行各种优化，因此综合考虑过后，公司采取了RabbitMQ。</text></g></g><g id="minder_node2542" display="none"><g id="node_expander2540" display="none" style="cursor: pointer;"><path id="kity_path_28142" fill="white" stroke="gray" d="M554.5,30876.5A6,6,0,1,1,542.5,30876.5A6,6,0,1,1,554.5,30876.5"></path><path id="kity_path_28143" fill="none" stroke="gray"></path></g><path id="node_outline2541" fill="none" stroke="none" d="M554.5,30867.5h311a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-311a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2541" fill="black"><text id="kity_text_14504" text-rendering="inherit" font-size="12" dy=".8em" y="30868.700000047684" x="554.5">知道这几种消息队列的使用场景吗？为什么选择这个MQ？</text></g></g><g id="minder_node2543" display="none"><g id="node_expander2539" display="none" style="cursor: pointer;"><path id="kity_path_28139" fill="white" stroke="gray" d="M570.5,30876.5A6,6,0,1,1,558.5,30876.5A6,6,0,1,1,570.5,30876.5"></path><path id="kity_path_28140" fill="none" stroke="gray"></path></g><path id="node_outline2540" fill="none" stroke="none" d="M570.5,30831.5h1254a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1254a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text2540" fill="black"><text id="kity_text_14498" text-rendering="inherit" font-size="12" dy=".8em" y="30832.700000047684" x="570.5">1.一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；</text><text id="kity_text_14499" text-rendering="inherit" font-size="12" dy=".8em" y="30850.700000047684" x="570.5">后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高，而且比较成熟，社区和文档也比较友好；</text><text id="kity_text_14500" text-rendering="inherit" font-size="12" dy=".8em" y="30868.700000047684" x="570.5">不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 Apache，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，</text><text id="kity_text_14501" text-rendering="inherit" font-size="12" dy=".8em" y="30886.700000047684" x="570.5">推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</text><text id="kity_text_14502" text-rendering="inherit" font-size="12" dy=".8em" y="30904.700000047684" x="570.5">kafak的话 主要是做大数据 日志收集 什么的， 我们没有那个场景 就没有使用</text></g></g><g id="minder_node2544" display="none"><g id="node_expander2538" display="none" style="cursor: pointer;"><path id="kity_path_28136" fill="white" stroke="gray" d="M586.5,30876.5A6,6,0,1,1,574.5,30876.5A6,6,0,1,1,586.5,30876.5"></path><path id="kity_path_28137" fill="none" stroke="gray"></path></g><path id="node_outline2539" fill="none" stroke="none" d="M586.5,30867.5h260a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-260a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2539" fill="black"><text id="kity_text_14496" text-rendering="inherit" font-size="12" dy=".8em" y="30868.700000047684" x="586.5">https://juejin.cn/post/6844903993672482824</text></g></g><g id="minder_node2545" display="none"><g id="node_expander2542" display="none" style="cursor: pointer;"><path id="kity_path_28148" fill="white" stroke="gray" d="M554.5,30884.5A6,6,0,1,1,542.5,30884.5A6,6,0,1,1,554.5,30884.5"></path><path id="kity_path_28149" fill="none" stroke="gray"></path></g><path id="node_outline2543" fill="none" stroke="none" d="M554.5,30875.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2543" fill="black"><text id="kity_text_14508" text-rendering="inherit" font-size="12" dy=".8em" y="30876.700000047684" x="554.5">你们的消息队列用在哪方面</text></g></g><g id="minder_node2546" display="none"><g id="node_expander2541" display="none" style="cursor: pointer;"><path id="kity_path_28145" fill="white" stroke="gray" d="M570.5,30884.5A6,6,0,1,1,558.5,30884.5A6,6,0,1,1,570.5,30884.5"></path><path id="kity_path_28146" fill="none" stroke="gray"></path></g><path id="node_outline2542" fill="none" stroke="none" d="M570.5,30875.5h267a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-267a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2542" fill="black"><text id="kity_text_14506" text-rendering="inherit" font-size="12" dy=".8em" y="30876.700000047684" x="570.5">1.分布式事务和 业务交易xxx模块 和一些公共报文&#xa0;</text></g></g><g id="minder_node2547" display="none"><g id="node_expander2545" display="none" style="cursor: pointer;"><path id="kity_path_28157" fill="white" stroke="gray" d="M554.5,30892.5A6,6,0,1,1,542.5,30892.5A6,6,0,1,1,554.5,30892.5"></path><path id="kity_path_28158" fill="none" stroke="gray"></path></g><path id="node_outline2546" fill="none" stroke="none" d="M554.5,30883.5h115a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-115a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2546" fill="black"><text id="kity_text_14515" text-rendering="inherit" font-size="12" dy=".8em" y="30884.700000047684" x="554.5">说说rabbitmq的概念</text></g></g><g id="minder_node2548" display="none"><g id="node_expander2544" display="none" style="cursor: pointer;"><path id="kity_path_28154" fill="white" stroke="gray" d="M570.5,30892.5A6,6,0,1,1,558.5,30892.5A6,6,0,1,1,570.5,30892.5"></path><path id="kity_path_28155" fill="none" stroke="gray"></path></g><path id="node_outline2545" fill="none" stroke="none" d="M570.5,30874.5h658a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-658a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2545" fill="black"><text id="kity_text_14512" text-rendering="inherit" font-size="12" dy=".8em" y="30875.700000047684" x="570.5">1.rabbitmq的场景可以服务间异步通信&#xa0; 顺序消费&#xa0; 定时任务 延时任务 请求削峰</text><text id="kity_text_14513" text-rendering="inherit" font-size="12" dy=".8em" y="30893.700000047684" x="570.5">2.基本概念就是一些 生产者 消费者 ，然后 交换机&#xa0; 和队列 然后就是他们的绑定关系&#xa0; 然后就是路由key&#xa0; 然后就是通信的通道</text></g></g><g id="minder_node2549" display="none"><g id="node_expander2543" display="none" style="cursor: pointer;"><path id="kity_path_28151" fill="white" stroke="gray" d="M586.5,30892.5A6,6,0,1,1,574.5,30892.5A6,6,0,1,1,586.5,30892.5"></path><path id="kity_path_28152" fill="none" stroke="gray"></path></g><path id="node_outline2544" fill="none" stroke="none" d="M522.5,30772.5h200a5,5,0,0,1,5,5v119a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-119a5,5,0,0,1,5,-5z"></path><g id="node_text2544" fill="black"><text id="kity_text_14510" text-rendering="inherit" font-size="12" dy=".8em" y="30884.700000047684" x="586.5">MQ工作流程</text></g><image id="kity_image_17083" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20210310224421870.png" x="522.5" y="30775.5" width="200" height="106"></image></g><g id="minder_node2550" display="none"><g id="node_expander2547" display="none" style="cursor: pointer;"><path id="kity_path_28163" fill="white" stroke="gray" d="M554.5,30900.5A6,6,0,1,1,542.5,30900.5A6,6,0,1,1,554.5,30900.5"></path><path id="kity_path_28164" fill="none" stroke="gray"></path></g><path id="node_outline2548" fill="none" stroke="none" d="M554.5,30891.5h150a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-150a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2548" fill="black"><text id="kity_text_14525" text-rendering="inherit" font-size="12" dy=".8em" y="30892.700000047684" x="554.5">知道rabbitmq的工作模式吗</text></g></g><g id="minder_node2551" display="none"><g id="node_expander2546" display="none" style="cursor: pointer;"><path id="kity_path_28160" fill="white" stroke="gray" d="M570.5,30900.5A6,6,0,1,1,558.5,30900.5A6,6,0,1,1,570.5,30900.5"></path><path id="kity_path_28161" fill="none" stroke="gray"></path></g><path id="node_outline2547" fill="none" stroke="none" d="M570.5,30837.5h1244a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-1244a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text2547" fill="black"><text id="kity_text_14517" text-rendering="inherit" font-size="12" dy=".8em" y="30838.700000047684" x="570.5">1.简单收发模式：生产message放入queue，然后消费者监听队列，如果有message就消费，然后队列删除。</text><text id="kity_text_14518" text-rendering="inherit" font-size="12" dy=".8em" y="30856.700000047684" x="570.5">可能造成消息的队失，因为可能message还没消费掉，而message已经删除掉了，造成了message丢失，可以手动ack确认，然后处理完再反馈给消息队列，防止消息内存溢出</text><text id="kity_text_14519" text-rendering="inherit" font-size="12" dy=".8em" y="30874.700000047684" x="570.5">2.工作模式：多个消费者，监听同一个队列，他们是竞争关系，谁先拿到谁负责消费消息。可能出现的问题 高并发情况下,默认会产生某一个消息被多个消费者共同使用,可以设置一个开关(syncronize) 保证一条消息只能被一个消费者使用</text><text id="kity_text_14520" text-rendering="inherit" font-size="12" dy=".8em" y="30892.700000047684" x="570.5">3.发布订阅模式：每个消费者监听自己的队列，生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息。一条消息可以被多个消费者消费。</text><text id="kity_text_14521" text-rendering="inherit" font-size="12" dy=".8em" y="30910.700000047684" x="570.5">4.路由模式：生产者将消息发送给交换机，需要绑定路由key，队列和交换机也需要绑定路由key，然后按照路由判断,交换机根据路由的key,只能匹配上路由key的队列 交换机才把消息给到对应的队列中,对应的消费者才能消费消息;</text><text id="kity_text_14522" text-rendering="inherit" font-size="12" dy=".8em" y="30928.700000047684" x="570.5">可以把同一天消息给到不同的消费者中，做不同的业务处理</text><text id="kity_text_14523" text-rendering="inherit" font-size="12" dy=".8em" y="30946.700000047684" x="570.5">5.主题模式-和路由模式差不多，可以通过通配符模糊匹配，类似于like一样，然后交换机可以根据路由key的 模糊匹配到对应的队列，然后监听队列的消费者取消息消费，topic可以实现发布订阅和路由模式 更加灵活</text></g></g><g id="minder_node2552" display="none"><g id="node_expander2549" display="none" style="cursor: pointer;"><path id="kity_path_28169" fill="white" stroke="gray" d="M554.5,30908.5A6,6,0,1,1,542.5,30908.5A6,6,0,1,1,554.5,30908.5"></path><path id="kity_path_28170" fill="none" stroke="gray"></path></g><path id="node_outline2550" fill="none" stroke="none" d="M554.5,30899.5h241a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-241a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2550" fill="black"><text id="kity_text_14531" text-rendering="inherit" font-size="12" dy=".8em" y="30900.700000047684" x="554.5">知道消息队列的两种模型是什么？发布说说？</text></g></g><g id="minder_node2553" display="none"><g id="node_expander2548" display="none" style="cursor: pointer;"><path id="kity_path_28166" fill="white" stroke="gray" d="M570.5,30908.5A6,6,0,1,1,558.5,30908.5A6,6,0,1,1,570.5,30908.5"></path><path id="kity_path_28167" fill="none" stroke="gray"></path></g><path id="node_outline2549" fill="none" stroke="none" d="M570.5,30881.5h986a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-986a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2549" fill="black"><text id="kity_text_14527" text-rendering="inherit" font-size="12" dy=".8em" y="30882.700000047684" x="570.5">消息队列有两种模型，一种是队列模型，一种是发布订阅模式</text><text id="kity_text_14528" text-rendering="inherit" font-size="12" dy=".8em" y="30900.700000047684" x="570.5">1.队列模型是 你把消息给某一个队列发送，然后这个队列可以存储多个生产者的消息，一个队列也可以有多个消费者， 但是消费者之间是竞争关系，即每条消息只能被一个消费者消费。</text><text id="kity_text_14529" text-rendering="inherit" font-size="12" dy=".8em" y="30918.700000047684" x="570.5">2.发布订阅模式 生产者给topic发送message，订阅这个topic的消费者都可以消费这一条消息，可以解决一条消息应该能被多个消费者消费的问题，可以让一条消息可以被多个消费者消费</text></g></g><g id="minder_node2554" display="none"><g id="node_expander2551" display="none" style="cursor: pointer;"><path id="kity_path_28175" fill="white" stroke="gray" d="M554.5,30916.5A6,6,0,1,1,542.5,30916.5A6,6,0,1,1,554.5,30916.5"></path><path id="kity_path_28176" fill="none" stroke="gray"></path></g><path id="node_outline2552" fill="none" stroke="none" d="M554.5,30907.5h187a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-187a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2552" fill="black"><text id="kity_text_14536" text-rendering="inherit" font-size="12" dy=".8em" y="30908.700000047684" x="554.5">说一下rabbitmq的生产消息全流程</text></g></g><g id="minder_node2555" display="none"><g id="node_expander2550" display="none" style="cursor: pointer;"><path id="kity_path_28172" fill="white" stroke="gray" d="M570.5,30916.5A6,6,0,1,1,558.5,30916.5A6,6,0,1,1,570.5,30916.5"></path><path id="kity_path_28173" fill="none" stroke="gray"></path></g><path id="node_outline2551" fill="none" stroke="none" d="M570.5,30898.5h673a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-673a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2551" fill="black"><text id="kity_text_14533" text-rendering="inherit" font-size="12" dy=".8em" y="30899.700000047684" x="570.5">1.生产者创建连接，创建连接，连接到rabbitmq server 第一次的话会声明队列并设置相关属性，如是否持久化 是否自动删除等</text><text id="kity_text_14534" text-rendering="inherit" font-size="12" dy=".8em" y="30917.700000047684" x="570.5">2.然后绑定路由key和队列，然后发送消息到broker 然后关闭信道 关闭连接</text></g></g><g id="minder_node2556" display="none"><g id="node_expander2553" display="none" style="cursor: pointer;"><path id="kity_path_28181" fill="white" stroke="gray" d="M554.5,30924.5A6,6,0,1,1,542.5,30924.5A6,6,0,1,1,554.5,30924.5"></path><path id="kity_path_28182" fill="none" stroke="gray"></path></g><path id="node_outline2554" fill="none" stroke="none" d="M554.5,30915.5h175a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-175a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2554" fill="black"><text id="kity_text_14541" text-rendering="inherit" font-size="12" dy=".8em" y="30916.700000047684" x="554.5">说一下rabbitmq消费信息全流程</text></g></g><g id="minder_node2557" display="none"><g id="node_expander2552" display="none" style="cursor: pointer;"><path id="kity_path_28178" fill="white" stroke="gray" d="M570.5,30924.5A6,6,0,1,1,558.5,30924.5A6,6,0,1,1,570.5,30924.5"></path><path id="kity_path_28179" fill="none" stroke="gray"></path></g><path id="node_outline2553" fill="none" stroke="none" d="M570.5,30906.5h854a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-854a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2553" fill="black"><text id="kity_text_14538" text-rendering="inherit" font-size="12" dy=".8em" y="30907.700000047684" x="570.5">1.消费者创建连接，开启一个channel 连接rabbitmq server&#xa0; 向broker请求消费者相应队列中的消息，设置相应的回调函数</text><text id="kity_text_14539" text-rendering="inherit" font-size="12" dy=".8em" y="30925.700000047684" x="570.5">2.等待broker回应 传递到队列中的消息，消费者接收消息 然后ack 或者自动确认 接收到的消息 ，然后从队列中删除已经被确认的消息，然后关闭信道，关闭连接</text></g></g><g id="minder_node2558" display="none"><g id="node_expander2555" display="none" style="cursor: pointer;"><path id="kity_path_28187" fill="white" stroke="gray" d="M554.5,30932.5A6,6,0,1,1,542.5,30932.5A6,6,0,1,1,554.5,30932.5"></path><path id="kity_path_28188" fill="none" stroke="gray"></path></g><path id="node_outline2556" fill="none" stroke="none" d="M554.5,30923.5h205a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-205a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2556" fill="black"><text id="kity_text_14550" text-rendering="inherit" font-size="12" dy=".8em" y="30924.700000047684" x="554.5">消息如何分发？怎么路由？怎么传输？</text></g></g><g id="minder_node2559" display="none"><g id="node_expander2554" display="none" style="cursor: pointer;"><path id="kity_path_28184" fill="white" stroke="gray" d="M570.5,30932.5A6,6,0,1,1,558.5,30932.5A6,6,0,1,1,570.5,30932.5"></path><path id="kity_path_28185" fill="none" stroke="gray"></path></g><path id="node_outline2555" fill="none" stroke="none" d="M570.5,30878.5h1222a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1222a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text2555" fill="black"><text id="kity_text_14543" text-rendering="inherit" font-size="12" dy=".8em" y="30879.700000047684" x="570.5">1.队列有至少一个消费者 可以正常消费的情况下，消息将以循环（round-robin）的方式发送给消费者，每一条消息只会发给一个订阅的消费者。可以通过路由的形式发给多消费者</text><text id="kity_text_14544" text-rendering="inherit" font-size="12" dy=".8em" y="30897.700000047684" x="570.5">2.消息提供方 通过路由 到 交换机然后到队列 消息有一个路由key，这个路由key是通过在创建消息时设定，然后队列和交换机可以通过路由key绑定，消息到达交换机 会通过路由key 和队列的路由key匹配，一般交换机有三种类型，</text><text id="kity_text_14545" text-rendering="inherit" font-size="12" dy=".8em" y="30915.700000047684" x="570.5">广播，交换机会把消息广播到所有绑定的队列中。完全匹配，路由键完全匹配，消息就被投递到相应的队列。主题路由，通过通配符使来自不同源头的消息能够到达同一个队列。</text><text id="kity_text_14546" text-rendering="inherit" font-size="12" dy=".8em" y="30933.700000047684" x="570.5">3.由于 TCP 连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ使⽤信道的⽅式来传输数据。信道是建⽴在真实的TCP连接内的虚拟连接，且每条TCP连接上的信道数量没有限制。</text><text id="kity_text_14547" text-rendering="inherit" font-size="12" dy=".8em" y="30951.700000047684" x="570.5">RabbitMQ采⽤类似NIO（Non-blocking I/O）做法，选择TCP连接复⽤，不仅可以减少性能开销，同时也便于管理。</text><text id="kity_text_14548" text-rendering="inherit" font-size="12" dy=".8em" y="30969.700000047684" x="570.5">每个线程把持⼀个信道，所以信道复⽤了Connection的TCP连接。同时RabbitMQ可以确保每个线程的私密性，就像拥有独⽴的连接⼀样。</text></g></g><g id="minder_node2560" display="none"><g id="node_expander2557" display="none" style="cursor: pointer;"><path id="kity_path_28193" fill="white" stroke="gray" d="M554.5,30940.5A6,6,0,1,1,542.5,30940.5A6,6,0,1,1,554.5,30940.5"></path><path id="kity_path_28194" fill="none" stroke="gray"></path></g><path id="node_outline2558" fill="none" stroke="none" d="M554.5,30931.5h173a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-173a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2558" fill="black"><text id="kity_text_14554" text-rendering="inherit" font-size="12" dy=".8em" y="30932.700000047684" x="554.5">rabbitmq队列和消费者的关系？</text></g></g><g id="minder_node2561" display="none"><g id="node_expander2556" display="none" style="cursor: pointer;"><path id="kity_path_28190" fill="white" stroke="gray" d="M570.5,30940.5A6,6,0,1,1,558.5,30940.5A6,6,0,1,1,570.5,30940.5"></path><path id="kity_path_28191" fill="none" stroke="gray"></path></g><path id="node_outline2557" fill="none" stroke="none" d="M570.5,30931.5h670a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-670a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2557" fill="black"><text id="kity_text_14552" text-rendering="inherit" font-size="12" dy=".8em" y="30932.700000047684" x="570.5">1.⼀个队列可以绑定多个消费者；消息默认以循环的⽅式发送给消费者；消费者收到消息默认⾃动确认，也可以改成⼿动确认。</text></g></g><g id="minder_node2562" display="none"><g id="node_expander2560" display="none" style="cursor: pointer;"><path id="kity_path_28202" fill="white" stroke="gray" d="M554.5,30948.5A6,6,0,1,1,542.5,30948.5A6,6,0,1,1,554.5,30948.5"></path><path id="kity_path_28203" fill="none" stroke="gray"></path></g><path id="node_outline2561" fill="none" stroke="none" d="M554.5,30939.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2561" fill="black"><text id="kity_text_14560" text-rendering="inherit" font-size="12" dy=".8em" y="30940.700000047684" x="554.5">怎么自动扩容消费者，</text></g></g><g id="minder_node2563" display="none"><g id="node_expander2559" display="none" style="cursor: pointer;"><path id="kity_path_28199" fill="white" stroke="gray" d="M570.5,30948.5A6,6,0,1,1,558.5,30948.5A6,6,0,1,1,570.5,30948.5"></path><path id="kity_path_28200" fill="none" stroke="gray"></path></g><path id="node_outline2560" fill="none" stroke="none" d="M570.5,30939.5h433a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-433a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2560" fill="black"><text id="kity_text_14558" text-rendering="inherit" font-size="12" dy=".8em" y="30940.700000047684" x="570.5">1.SimpleMessageListenerContainer，多个消费者监听队列 实现动态扩容消费者</text></g></g><g id="minder_node2564" display="none"><g id="node_expander2558" display="none" style="cursor: pointer;"><path id="kity_path_28196" fill="white" stroke="gray" d="M586.5,30948.5A6,6,0,1,1,574.5,30948.5A6,6,0,1,1,586.5,30948.5"></path><path id="kity_path_28197" fill="none" stroke="gray"></path></g><path id="node_outline2559" fill="none" stroke="none" d="M586.5,30939.5h243a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-243a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2559" fill="black"><text id="kity_text_14556" text-rendering="inherit" font-size="12" dy=".8em" y="30940.700000047684" x="586.5">https://www.jianshu.com/p/213827ebc08c</text></g></g><g id="minder_node2565" display="none"><g id="node_expander2605" display="none" style="cursor: pointer;"><path id="kity_path_28337" fill="white" stroke="gray" d="M538.5,30956.5A6,6,0,1,1,526.5,30956.5A6,6,0,1,1,538.5,30956.5"></path><path id="kity_path_28338" fill="none" stroke="gray"></path></g><path id="node_outline2606" fill="none" stroke="none" d="M538.5,30947.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2606" fill="black"><text id="kity_text_14708" text-rendering="inherit" font-size="12" dy=".8em" y="30948.700000047684" x="538.5">进阶</text></g></g><g id="minder_node2566" display="none"><g id="node_expander2563" display="none" style="cursor: pointer;"><path id="kity_path_28211" fill="white" stroke="gray" d="M554.5,30820.5A6,6,0,1,1,542.5,30820.5A6,6,0,1,1,554.5,30820.5"></path><path id="kity_path_28212" fill="none" stroke="gray"></path></g><path id="node_outline2564" fill="none" stroke="none" d="M554.5,30811.5h140a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-140a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2564" fill="black"><text id="kity_text_14566" text-rendering="inherit" font-size="12" dy=".8em" y="30812.700000047684" x="554.5">你用mq遇到过什么问题吗</text></g></g><g id="minder_node2567" display="none"><g id="node_expander2562" display="none" style="cursor: pointer;"><path id="kity_path_28208" fill="white" stroke="gray" d="M570.5,30820.5A6,6,0,1,1,558.5,30820.5A6,6,0,1,1,570.5,30820.5"></path><path id="kity_path_28209" fill="none" stroke="gray"></path></g><path id="node_outline2563" fill="none" stroke="none" d="M570.5,30811.5h196a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-196a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2563" fill="black"><text id="kity_text_14564" text-rendering="inherit" font-size="12" dy=".8em" y="30812.700000047684" x="570.5">1.下面都是rabbitmq可能出现的问题</text></g></g><g id="minder_node2568" display="none"><g id="node_expander2566" display="none" style="cursor: pointer;"><path id="kity_path_28220" fill="white" stroke="gray" d="M554.5,30828.5A6,6,0,1,1,542.5,30828.5A6,6,0,1,1,554.5,30828.5"></path><path id="kity_path_28221" fill="none" stroke="gray"></path></g><path id="node_outline2567" fill="none" stroke="none" d="M554.5,30819.5h175a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-175a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2567" fill="black"><text id="kity_text_14578" text-rendering="inherit" font-size="12" dy=".8em" y="30820.700000047684" x="554.5">怎么保证rabbitmq消息的顺序性</text></g></g><g id="minder_node2569" display="none"><g id="node_expander2565" display="none" style="cursor: pointer;"><path id="kity_path_28217" fill="white" stroke="gray" d="M570.5,30828.5A6,6,0,1,1,558.5,30828.5A6,6,0,1,1,570.5,30828.5"></path><path id="kity_path_28218" fill="none" stroke="gray"></path></g><path id="node_outline2566" fill="none" stroke="none" d="M570.5,30783.5h1336a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1336a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text2566" fill="black"><text id="kity_text_14572" text-rendering="inherit" font-size="12" dy=".8em" y="30784.700000047684" x="570.5">1.有序的分全局有序和部分有序</text><text id="kity_text_14573" text-rendering="inherit" font-size="12" dy=".8em" y="30802.700000047684" x="570.5">全局：消息只能由一个生产者给topic发送消息，并且一个topic内部只能有一个分区。消费者单线程消费这个队列，这样可以保证全局有序，一般场景不要求全局有序，我们的场景也没有要求全局有序，</text><text id="kity_text_14574" text-rendering="inherit" font-size="12" dy=".8em" y="30820.700000047684" x="570.5">部分：通过多分区也就是多队列，将topic分多个队列，然后通过业务号 取模 hash这种把满足规则的都给同一个队列，相当于同一个类型的消息给同一个队列，然后分区都对应一个单线程的消费者，这样可以满足部分有序，也不会影响太大的性能问题，</text><text id="kity_text_14575" text-rendering="inherit" font-size="12" dy=".8em" y="30838.700000047684" x="570.5">但是mq本身并不是满足强顺序性。如果要保证多个消费者去消费，可以让消费者失败重试。如果一定要求有序 可以用racketmq严格保证分区部分有序</text><text id="kity_text_14576" text-rendering="inherit" font-size="12" dy=".8em" y="30856.700000047684" x="570.5">主要思想是让进队满足有序，顺序消费让消费者去关注，</text></g></g><g id="minder_node2570" display="none"><g id="node_expander2564" display="none" style="cursor: pointer;"><path id="kity_path_28214" fill="white" stroke="gray" d="M586.5,30828.5A6,6,0,1,1,574.5,30828.5A6,6,0,1,1,586.5,30828.5"></path><path id="kity_path_28215" fill="none" stroke="gray"></path></g><path id="node_outline2565" fill="none" stroke="none" d="M586.5,30801.5h355a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-355a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2565" fill="black"><text id="kity_text_14568" text-rendering="inherit" font-size="12" dy=".8em" y="30802.700000047684" x="586.5">https://blog.csdn.net/zw791029369/article/details/109561457</text><text id="kity_text_14569" text-rendering="inherit" font-size="12" dy=".8em" y="30820.700000047684" x="586.5">https://juejin.cn/post/6850418106372882446#heading-18</text><text id="kity_text_14570" text-rendering="inherit" font-size="12" dy=".8em" y="30838.700000047684" x="586.5">https://juejin.cn/post/6844903849103196173</text></g></g><g id="minder_node2571" display="none"><g id="node_expander2569" display="none" style="cursor: pointer;"><path id="kity_path_28229" fill="white" stroke="gray" d="M554.5,30836.5A6,6,0,1,1,542.5,30836.5A6,6,0,1,1,554.5,30836.5"></path><path id="kity_path_28230" fill="none" stroke="gray"></path></g><path id="node_outline2570" fill="none" stroke="none" d="M554.5,30827.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2570" fill="black"><text id="kity_text_14591" text-rendering="inherit" font-size="12" dy=".8em" y="30828.700000047684" x="554.5">怎么保证信息的可靠性传输，</text></g></g><g id="minder_node2572" display="none"><g id="node_expander2568" display="none" style="cursor: pointer;"><path id="kity_path_28226" fill="white" stroke="gray" d="M570.5,30836.5A6,6,0,1,1,558.5,30836.5A6,6,0,1,1,570.5,30836.5"></path><path id="kity_path_28227" fill="none" stroke="gray"></path></g><path id="node_outline2569" fill="none" stroke="none" d="M570.5,30764.5h653a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-653a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text2569" fill="black"><text id="kity_text_14582" text-rendering="inherit" font-size="12" dy=".8em" y="30765.700000047684" x="570.5">1.可靠性传输 一般会是生产者弄丢数据、消息队列弄丢数据、消费者弄丢数据 三个方面考虑</text><text id="kity_text_14583" text-rendering="inherit" font-size="12" dy=".8em" y="30783.700000047684" x="570.5">然后主要是思想就是&#xa0;</text><text id="kity_text_14584" text-rendering="inherit" font-size="12" dy=".8em" y="30801.700000047684" x="570.5">做好容错方法（try-catch），发送消息可能会网络失败，失败后要有重试机制，可记录到数据库，采用定期扫描重发的方式</text><text id="kity_text_14585" text-rendering="inherit" font-size="12" dy=".8em" y="30819.700000047684" x="570.5">&#xa0;做好日志记录，每个消息状态是否都被服务器收到都应该记录</text><text id="kity_text_14586" text-rendering="inherit" font-size="12" dy=".8em" y="30837.700000047684" x="570.5">&#xa0;做好定期重发，如果消息没有发送成功，定期去数据库扫描未成功的消息进行重发。</text><text id="kity_text_14587" text-rendering="inherit" font-size="12" dy=".8em" y="30855.700000047684" x="570.5">&#xa0;然后注意持久化 防止beoker宕机丢消息</text><text id="kity_text_14588" text-rendering="inherit" font-size="12" dy=".8em" y="30873.700000047684" x="570.5">&#xa0;一定开启手动ACK，消费成功才移除，失败或者没来得及处理就noAck并重新入队</text><text id="kity_text_14589" text-rendering="inherit" font-size="12" dy=".8em" y="30891.700000047684" x="570.5">&#xa0;加入确认回调机制，确认成功的消息，修改数据库消息状态。</text></g></g><g id="minder_node2573" display="none"><g id="node_expander2567" display="none" style="cursor: pointer;"><path id="kity_path_28223" fill="white" stroke="gray" d="M586.5,30836.5A6,6,0,1,1,574.5,30836.5A6,6,0,1,1,586.5,30836.5"></path><path id="kity_path_28224" fill="none" stroke="gray"></path></g><path id="node_outline2568" fill="none" stroke="none" d="M586.5,30827.5h374a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-374a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2568" fill="black"><text id="kity_text_14580" text-rendering="inherit" font-size="12" dy=".8em" y="30828.700000047684" x="586.5">https://blog.csdn.net/weixin_42437633/article/details/106671523</text></g></g><g id="minder_node2574" display="none"><g id="node_expander2571" display="none" style="cursor: pointer;"><path id="kity_path_28235" fill="white" stroke="gray" d="M554.5,30844.5A6,6,0,1,1,542.5,30844.5A6,6,0,1,1,554.5,30844.5"></path><path id="kity_path_28236" fill="none" stroke="gray"></path></g><path id="node_outline2572" fill="none" stroke="none" d="M554.5,30835.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2572" fill="black"><text id="kity_text_14598" text-rendering="inherit" font-size="12" dy=".8em" y="30836.700000047684" x="554.5">那生产者丢数据怎么办</text></g></g><g id="minder_node2575" display="none"><g id="node_expander2570" display="none" style="cursor: pointer;"><path id="kity_path_28232" fill="white" stroke="gray" d="M570.5,30844.5A6,6,0,1,1,558.5,30844.5A6,6,0,1,1,570.5,30844.5"></path><path id="kity_path_28233" fill="none" stroke="gray"></path></g><path id="node_outline2571" fill="none" stroke="none" d="M570.5,30808.5h1491a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1491a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text2571" fill="black"><text id="kity_text_14593" text-rendering="inherit" font-size="12" dy=".8em" y="30809.700000047684" x="570.5">1.如果是生产者丢数据，一般是生产者发送消息给mq 然后因为网络问题而丢失数据 server，rabbitmq有事务和confirm模式来保障，confirm模式 他是一个发送方确认机制 主要是通过回调函数实现。</text><text id="kity_text_14594" text-rendering="inherit" font-size="12" dy=".8em" y="30827.700000047684" x="570.5">消息从生产者发送到RabbitMQ，首先会发送到Exchange，对应一个回调函数confirm通知生产者 会返回一个ack 通过ack就可以判断是否成功达到交换机。</text><text id="kity_text_14595" text-rendering="inherit" font-size="12" dy=".8em" y="30845.700000047684" x="570.5">然后从Exchange路由分配到Queue中，对应的回调函数returnMessage，如果失败会返回消息。然后为了让消息从交换机达到队列，会通过mandatory来保证，它会在消息没有被队列正确的接收的时候回调returnMessage，如果return 和mandatory都设置的话&#xa0; 优先 mandatory&#xa0;</text><text id="kity_text_14596" text-rendering="inherit" font-size="12" dy=".8em" y="30863.700000047684" x="570.5">然后在一般会把消息记录下来，然后失败后续做一个补偿，定时任务之类的操作去重新发送。</text></g></g><g id="minder_node2576" display="none"><g id="node_expander2573" display="none" style="cursor: pointer;"><path id="kity_path_28241" fill="white" stroke="gray" d="M554.5,30852.5A6,6,0,1,1,542.5,30852.5A6,6,0,1,1,554.5,30852.5"></path><path id="kity_path_28242" fill="none" stroke="gray"></path></g><path id="node_outline2574" fill="none" stroke="none" d="M554.5,30843.5h110a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-110a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2574" fill="black"><text id="kity_text_14605" text-rendering="inherit" font-size="12" dy=".8em" y="30844.700000047684" x="554.5">消费者丢数据怎么办</text></g></g><g id="minder_node2577" display="none"><g id="node_expander2572" display="none" style="cursor: pointer;"><path id="kity_path_28238" fill="white" stroke="gray" d="M570.5,30852.5A6,6,0,1,1,558.5,30852.5A6,6,0,1,1,570.5,30852.5"></path><path id="kity_path_28239" fill="none" stroke="gray"></path></g><path id="node_outline2573" fill="none" stroke="none" d="M570.5,30816.5h1191a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1191a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text2573" fill="black"><text id="kity_text_14600" text-rendering="inherit" font-size="12" dy=".8em" y="30817.700000047684" x="570.5">1.消费者丢数据一般是因为采用了自动确认消息模式。</text><text id="kity_text_14601" text-rendering="inherit" font-size="12" dy=".8em" y="30835.700000047684" x="570.5">这种模式下，消费者会自动确认收到信息。这时rahbitMQ会立即将消息删除，这种情况下如果消费者出现异常而没能处理该消息，就会丢失该消息。可以通过采用手动ack确认消息解决。把acknowledge-mode: 设置manual&#xa0;</text><text id="kity_text_14602" text-rendering="inherit" font-size="12" dy=".8em" y="30853.700000047684" x="570.5">然后没有异常 就消费成功，有异常再看是否是 需要让消息重回队列，然后需要 就回复basicack重回队列，然后不需要 就回复ack然后删除</text><text id="kity_text_14603" text-rendering="inherit" font-size="12" dy=".8em" y="30871.700000047684" x="570.5">2.超时ack重发 需要保证幂等，</text></g></g><g id="minder_node2578" display="none"><g id="node_expander2575" display="none" style="cursor: pointer;"><path id="kity_path_28247" fill="white" stroke="gray" d="M554.5,30860.5A6,6,0,1,1,542.5,30860.5A6,6,0,1,1,554.5,30860.5"></path><path id="kity_path_28248" fill="none" stroke="gray"></path></g><path id="node_outline2576" fill="none" stroke="none" d="M554.5,30851.5h122a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-122a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2576" fill="black"><text id="kity_text_14611" text-rendering="inherit" font-size="12" dy=".8em" y="30852.700000047684" x="554.5">消息队列丢数据怎么办</text></g></g><g id="minder_node2579" display="none"><g id="node_expander2574" display="none" style="cursor: pointer;"><path id="kity_path_28244" fill="white" stroke="gray" d="M570.5,30860.5A6,6,0,1,1,558.5,30860.5A6,6,0,1,1,570.5,30860.5"></path><path id="kity_path_28245" fill="none" stroke="gray"></path></g><path id="node_outline2575" fill="none" stroke="none" d="M570.5,30833.5h1103a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1103a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2575" fill="black"><text id="kity_text_14607" text-rendering="inherit" font-size="12" dy=".8em" y="30834.700000047684" x="570.5">1.如果消息队列丢失数据，这种情况一般可以通过开启持久化的配置+confirem解决，就是说 在消息在持久化后 给生产者发送ack，然后持久化之前 消息队列有异常，丢数据，生产者收不到ack，就重新发送，</text><text id="kity_text_14608" text-rendering="inherit" font-size="12" dy=".8em" y="30852.700000047684" x="570.5">2.怎么做 可以通过 设置queue的持久化标识durable为true, 然后发送消息的时候将deliveryMode=2 这样就算挂了 也可以重启后也能恢复数据</text><text id="kity_text_14609" text-rendering="inherit" font-size="12" dy=".8em" y="30870.700000047684" x="570.5">3.但是持久化可能影响性能，因为持久化就会可能 交换机持久化，队列持久化，消息持久化，这样影响性能，是否真的有必要需要看业务，看这个数据是否是关键性数据。</text></g></g><g id="minder_node2580" display="none"><g id="node_expander2577" display="none" style="cursor: pointer;"><path id="kity_path_28253" fill="white" stroke="gray" d="M554.5,30868.5A6,6,0,1,1,542.5,30868.5A6,6,0,1,1,554.5,30868.5"></path><path id="kity_path_28254" fill="none" stroke="gray"></path></g><path id="node_outline2578" fill="none" stroke="none" d="M554.5,30859.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2578" fill="black"><text id="kity_text_14615" text-rendering="inherit" font-size="12" dy=".8em" y="30860.700000047684" x="554.5">怎么保证消费成功呢</text></g></g><g id="minder_node2581" display="none"><g id="node_expander2576" display="none" style="cursor: pointer;"><path id="kity_path_28250" fill="white" stroke="gray" d="M570.5,30868.5A6,6,0,1,1,558.5,30868.5A6,6,0,1,1,570.5,30868.5"></path><path id="kity_path_28251" fill="none" stroke="gray"></path></g><path id="node_outline2577" fill="none" stroke="none" d="M570.5,30859.5h95a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-95a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2577" fill="black"><text id="kity_text_14613" text-rendering="inherit" font-size="12" dy=".8em" y="30860.700000047684" x="570.5">1.和上面问题一样</text></g></g><g id="minder_node2582" display="none"><g id="node_expander2579" display="none" style="cursor: pointer;"><path id="kity_path_28259" fill="white" stroke="gray" d="M554.5,30876.5A6,6,0,1,1,542.5,30876.5A6,6,0,1,1,554.5,30876.5"></path><path id="kity_path_28260" fill="none" stroke="gray"></path></g><path id="node_outline2580" fill="none" stroke="none" d="M554.5,30867.5h110a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-110a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2580" fill="black"><text id="kity_text_14619" text-rendering="inherit" font-size="12" dy=".8em" y="30868.700000047684" x="554.5">怎么保证消息不丢失</text></g></g><g id="minder_node2583" display="none"><g id="node_expander2578" display="none" style="cursor: pointer;"><path id="kity_path_28256" fill="white" stroke="gray" d="M570.5,30876.5A6,6,0,1,1,558.5,30876.5A6,6,0,1,1,570.5,30876.5"></path><path id="kity_path_28257" fill="none" stroke="gray"></path></g><path id="node_outline2579" fill="none" stroke="none" d="M570.5,30867.5h95a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-95a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2579" fill="black"><text id="kity_text_14617" text-rendering="inherit" font-size="12" dy=".8em" y="30868.700000047684" x="570.5">1.和上面问题一样</text></g></g><g id="minder_node2584" display="none"><g id="node_expander2582" display="none" style="cursor: pointer;"><path id="kity_path_28268" fill="white" stroke="gray" d="M554.5,30884.5A6,6,0,1,1,542.5,30884.5A6,6,0,1,1,554.5,30884.5"></path><path id="kity_path_28269" fill="none" stroke="gray"></path></g><path id="node_outline2583" fill="none" stroke="none" d="M554.5,30875.5h61a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-61a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2583" fill="black"><text id="kity_text_14636" text-rendering="inherit" font-size="12" dy=".8em" y="30876.700000047684" x="554.5">怎么补偿？</text></g></g><g id="minder_node2585" display="none"><g id="node_expander2581" display="none" style="cursor: pointer;"><path id="kity_path_28265" fill="white" stroke="gray" d="M570.5,30884.5A6,6,0,1,1,558.5,30884.5A6,6,0,1,1,570.5,30884.5"></path><path id="kity_path_28266" fill="none" stroke="gray"></path></g><path id="node_outline2582" fill="none" stroke="none" d="M570.5,30785.5h1181a5,5,0,0,1,5,5v188a5,5,0,0,1,-5,5h-1181a5,5,0,0,1,-5,-5v-188a5,5,0,0,1,5,-5z"></path><g id="node_text2582" fill="black"><text id="kity_text_14624" text-rendering="inherit" font-size="12" dy=".8em" y="30786.700000047684" x="570.5">1.然后补偿的话 可以通过记录 失败的消息 做一个定时任务 或者说是轮训操作 让他们重新发送，或者说 通过 状态表之类的，比如说 发送消息时存储消息，然后记录状态，</text><text id="kity_text_14625" text-rendering="inherit" font-size="12" dy=".8em" y="30804.700000047684" x="570.5">是已发送 未发送，发送中，到达，然后消息状态发送变化&#xa0; 对表中消息状态做一个变更，针对没有到达的消息做一个轮训操作，重新发送。</text><text id="kity_text_14626" text-rendering="inherit" font-size="12" dy=".8em" y="30822.700000047684" x="570.5">对轮训次数也需要做一个限制3-5次。确保消息能够成功的发送.如果重试了还是失败。可能就需要需要人工去补偿对账</text><text id="kity_text_14627" text-rendering="inherit" font-size="12" dy=".8em" y="30840.700000047684" x="570.5">这就是有两次入库操作，做高并发的场景不一定合适</text><text id="kity_text_14628" text-rendering="inherit" font-size="12" dy=".8em" y="30858.700000047684" x="570.5">2.消息的延迟投递，做二次确认，回调检查</text><text id="kity_text_14629" text-rendering="inherit" font-size="12" dy=".8em" y="30876.700000047684" x="570.5">step1:业务消息入库成功后，第一次消息发送。</text><text id="kity_text_14630" text-rendering="inherit" font-size="12" dy=".8em" y="30894.700000047684" x="570.5">step2:然后 发送第二次消息，这两条消息是同时发送的。第二条消息是延迟检查消息，可以设置2min、5min 延迟发送。根据情况而定</text><text id="kity_text_14631" text-rendering="inherit" font-size="12" dy=".8em" y="30912.700000047684" x="570.5">step3:消费端监听指定队列 消费消息</text><text id="kity_text_14632" text-rendering="inherit" font-size="12" dy=".8em" y="30930.700000047684" x="570.5">step4:消费端处理完消息后，发送消息消费确认给MQ server。</text><text id="kity_text_14633" text-rendering="inherit" font-size="12" dy=".8em" y="30948.700000047684" x="570.5">step5: 回调服务监听MQ server 这一步主要是监听消息消费确认 ,如果收到:消费端发送的消息，则可以确定消息发送成功，执行消息存储入库。</text><text id="kity_text_14634" text-rendering="inherit" font-size="12" dy=".8em" y="30966.700000047684" x="570.5">step6：回调服务检查 延迟投递的消息，去消息库中查询延迟检查消息。如果发现之前的消息已经投递成功，则不需要做其他事情。如果检查发现失败，则回调 进行补偿，主动发送RPC 通信。通知上游生产端重新发送消息。</text></g></g><g id="minder_node2586" display="none"><g id="node_expander2580" display="none" style="cursor: pointer;"><path id="kity_path_28262" fill="white" stroke="gray" d="M586.5,30884.5A6,6,0,1,1,574.5,30884.5A6,6,0,1,1,586.5,30884.5"></path><path id="kity_path_28263" fill="none" stroke="gray"></path></g><path id="node_outline2581" fill="none" stroke="none" d="M586.5,30866.5h374a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-374a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2581" fill="black"><text id="kity_text_14621" text-rendering="inherit" font-size="12" dy=".8em" y="30867.700000047684" x="586.5">https://blog.csdn.net/weixin_42437633/article/details/106671523</text><text id="kity_text_14622" text-rendering="inherit" font-size="12" dy=".8em" y="30885.700000047684" x="586.5">https://juejin.cn/post/6844903906804236301#heading-3</text></g></g><g id="minder_node2587" display="none"><g id="node_expander2584" display="none" style="cursor: pointer;"><path id="kity_path_28274" fill="white" stroke="gray" d="M554.5,30892.5A6,6,0,1,1,542.5,30892.5A6,6,0,1,1,554.5,30892.5"></path><path id="kity_path_28275" fill="none" stroke="gray"></path></g><path id="node_outline2585" fill="none" stroke="none" d="M554.5,30883.5h217a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-217a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2585" fill="black"><text id="kity_text_14645" text-rendering="inherit" font-size="12" dy=".8em" y="30884.700000047684" x="554.5">怎么保证消费者的幂等性，防止重复消费</text></g></g><g id="minder_node2588" display="none"><g id="node_expander2583" display="none" style="cursor: pointer;"><path id="kity_path_28271" fill="white" stroke="gray" d="M570.5,30892.5A6,6,0,1,1,558.5,30892.5A6,6,0,1,1,570.5,30892.5"></path><path id="kity_path_28272" fill="none" stroke="gray"></path></g><path id="node_outline2584" fill="none" stroke="none" d="M570.5,30838.5h1306a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1306a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text2584" fill="black"><text id="kity_text_14638" text-rendering="inherit" font-size="12" dy=".8em" y="30839.700000047684" x="570.5">为什么会重复消费：1.mq因为网络原因等等没有ack生产者，生产者重发消息，2.消费者没有ack给mq或者消费完没有ack给mq或者消费者消费了消息但是要ack给mq时 mq挂了，mq重启会再一次投递，mq重发信息</text><text id="kity_text_14639" text-rendering="inherit" font-size="12" dy=".8em" y="30857.700000047684" x="570.5">1.使用唯一id拼接上业务规则号，保障此次操作达到绝对唯一的。实现简单，就一个拼接，而后查询判断是否重复。缺点是高并发下若是是单个数据库就会有写入性能瓶颈 可以通过分库分表 + id路由 保证下一次还是落在同一个库中 就可以提升性能</text><text id="kity_text_14640" text-rendering="inherit" font-size="12" dy=".8em" y="30875.700000047684" x="570.5">2.业务id+防重表，可以是redis或者是mysql，发送消息每一个都有业务的唯一标识，消息过来先看是不是处理过，处理过就不用处理</text><text id="kity_text_14641" text-rendering="inherit" font-size="12" dy=".8em" y="30893.700000047684" x="570.5">3.或者是乐观锁，使用版本号，就比如说，我一开始版本号是1，调用a服务 然后版本+1，但是返回给b服务出现问题，就再一次调用a服务，可是版本号不一致不管调用几次，只会真正的处理一次</text><text id="kity_text_14642" text-rendering="inherit" font-size="12" dy=".8em" y="30911.700000047684" x="570.5">4.也可以通过分布式锁，</text><text id="kity_text_14643" text-rendering="inherit" font-size="12" dy=".8em" y="30929.700000047684" x="570.5">5.保存到redis中，</text></g></g><g id="minder_node2589" display="none"><g id="node_expander2587" display="none" style="cursor: pointer;"><path id="kity_path_28283" fill="white" stroke="gray" d="M554.5,30900.5A6,6,0,1,1,542.5,30900.5A6,6,0,1,1,554.5,30900.5"></path><path id="kity_path_28284" fill="none" stroke="gray"></path></g><path id="node_outline2588" fill="none" stroke="none" d="M554.5,30891.5h108a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-108a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2588" fill="black"><text id="kity_text_14657" text-rendering="inherit" font-size="12" dy=".8em" y="30892.700000047684" x="554.5">那你说说怎么去重的</text></g></g><g id="minder_node2590" display="none"><g id="node_expander2586" display="none" style="cursor: pointer;"><path id="kity_path_28280" fill="white" stroke="gray" d="M570.5,30900.5A6,6,0,1,1,558.5,30900.5A6,6,0,1,1,570.5,30900.5"></path><path id="kity_path_28281" fill="none" stroke="gray"></path></g><path id="node_outline2587" fill="none" stroke="none" d="M570.5,30837.5h814a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-814a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text2587" fill="black"><text id="kity_text_14649" text-rendering="inherit" font-size="12" dy=".8em" y="30838.700000047684" x="570.5">在写入消息队列的数据做唯一标示，消费消息时，根据唯一标识判断是否消费过；</text><text id="kity_text_14650" text-rendering="inherit" font-size="12" dy=".8em" y="30856.700000047684" x="570.5">1. 唯一ID+业务规则流水号</text><text id="kity_text_14651" text-rendering="inherit" font-size="12" dy=".8em" y="30874.700000047684" x="570.5">利用数据库主键去重。 保证唯一性</text><text id="kity_text_14652" text-rendering="inherit" font-size="12" dy=".8em" y="30892.700000047684" x="570.5">SELECT COUNT(1) FROM T_ORDER WHERE ID = 唯一ID + 业务规则流水号 如果查询没有，则添加。有则不需要做任何操作，消费端不需要消费消息。</text><text id="kity_text_14653" text-rendering="inherit" font-size="12" dy=".8em" y="30910.700000047684" x="570.5">好处：实现简单</text><text id="kity_text_14654" text-rendering="inherit" font-size="12" dy=".8em" y="30928.700000047684" x="570.5">坏处：高并发下有数据库写入的性能瓶颈</text><text id="kity_text_14655" text-rendering="inherit" font-size="12" dy=".8em" y="30946.700000047684" x="570.5">解决方案：跟进ID进行分库分表进行算法路由 分摊流量压力。</text></g></g><g id="minder_node2591" display="none"><g id="node_expander2585" display="none" style="cursor: pointer;"><path id="kity_path_28277" fill="white" stroke="gray" d="M586.5,30900.5A6,6,0,1,1,574.5,30900.5A6,6,0,1,1,586.5,30900.5"></path><path id="kity_path_28278" fill="none" stroke="gray"></path></g><path id="node_outline2586" fill="none" stroke="none" d="M586.5,30891.5h333a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2586" fill="black"><text id="kity_text_14647" text-rendering="inherit" font-size="12" dy=".8em" y="30892.700000047684" x="586.5">https://juejin.cn/post/6933502513954062349#heading-11</text></g></g><g id="minder_node2592" display="none"><g id="node_expander2589" display="none" style="cursor: pointer;"><path id="kity_path_28289" fill="white" stroke="gray" d="M554.5,30908.5A6,6,0,1,1,542.5,30908.5A6,6,0,1,1,554.5,30908.5"></path><path id="kity_path_28290" fill="none" stroke="gray"></path></g><path id="node_outline2590" fill="none" stroke="none" d="M554.5,30899.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2590" fill="black"><text id="kity_text_14661" text-rendering="inherit" font-size="12" dy=".8em" y="30900.700000047684" x="554.5">遇到消息堆积的情况吗</text></g></g><g id="minder_node2593" display="none"><g id="node_expander2588" display="none" style="cursor: pointer;"><path id="kity_path_28286" fill="white" stroke="gray" d="M570.5,30908.5A6,6,0,1,1,558.5,30908.5A6,6,0,1,1,570.5,30908.5"></path><path id="kity_path_28287" fill="none" stroke="gray"></path></g><path id="node_outline2589" fill="none" stroke="none" d="M570.5,30899.5h515a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-515a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2589" fill="black"><text id="kity_text_14659" text-rendering="inherit" font-size="12" dy=".8em" y="30900.700000047684" x="570.5">1.有遇到过，主要问题是消息消费代码逻辑的问题，优化了业务处理代码，机器的问题没有遇到过</text></g></g><g id="minder_node2594" display="none"><g id="node_expander2591" display="none" style="cursor: pointer;"><path id="kity_path_28295" fill="white" stroke="gray" d="M554.5,30916.5A6,6,0,1,1,542.5,30916.5A6,6,0,1,1,554.5,30916.5"></path><path id="kity_path_28296" fill="none" stroke="gray"></path></g><path id="node_outline2592" fill="none" stroke="none" d="M554.5,30907.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2592" fill="black"><text id="kity_text_14669" text-rendering="inherit" font-size="12" dy=".8em" y="30908.700000047684" x="554.5">怎么解决消息堆积呢</text></g></g><g id="minder_node2595" display="none"><g id="node_expander2590" display="none" style="cursor: pointer;"><path id="kity_path_28292" fill="white" stroke="gray" d="M570.5,30916.5A6,6,0,1,1,558.5,30916.5A6,6,0,1,1,570.5,30916.5"></path><path id="kity_path_28293" fill="none" stroke="gray"></path></g><path id="node_outline2591" fill="none" stroke="none" d="M570.5,30871.5h1117a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1117a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text2591" fill="black"><text id="kity_text_14663" text-rendering="inherit" font-size="12" dy=".8em" y="30872.700000047684" x="570.5">1.先定位消费慢的原因，是消费者宕机积压 还是说消费者消费能力不足积压，还是说发送者发送流量太大</text><text id="kity_text_14664" text-rendering="inherit" font-size="12" dy=".8em" y="30890.700000047684" x="570.5">如果是因为本身消费能力较弱，我们可以优化下消费逻辑，比如之前是一条一条消息消费处理的，这次我们批量处理，比如数据库的插入，一条一条插和批量插效率是不一样的。</text><text id="kity_text_14665" text-rendering="inherit" font-size="12" dy=".8em" y="30908.700000047684" x="570.5">2.但还是慢，那就得考虑水平扩容了，比如说临时加机器，或者增加Topic的队列数和消费者数量，注意队列数一定要增加，不然新增加的消费者是没东西消费的。一个Topic中，一个队列只会分配给一个消费者。</text><text id="kity_text_14666" text-rendering="inherit" font-size="12" dy=".8em" y="30926.700000047684" x="570.5">3.如果还是不行，可能就是db到了瓶颈问题，那么需要提升扩展db，因为mq怎么优化，下游db到了瓶颈期 也没有办法解决的</text><text id="kity_text_14667" text-rendering="inherit" font-size="12" dy=".8em" y="30944.700000047684" x="570.5">4.那最后一个还可以 上线专门的队列消费服务，将消息先批量取出来，记录数据库，离线慢慢处理</text></g></g><g id="minder_node2596" display="none"><g id="node_expander2594" display="none" style="cursor: pointer;"><path id="kity_path_28304" fill="white" stroke="gray" d="M554.5,30924.5A6,6,0,1,1,542.5,30924.5A6,6,0,1,1,554.5,30924.5"></path><path id="kity_path_28305" fill="none" stroke="gray"></path></g><path id="node_outline2595" fill="none" stroke="none" d="M554.5,30915.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2595" fill="black"><text id="kity_text_14677" text-rendering="inherit" font-size="12" dy=".8em" y="30916.700000047684" x="554.5">说说推模式?拉模式?场景？</text></g></g><g id="minder_node2597" display="none"><g id="node_expander2593" display="none" style="cursor: pointer;"><path id="kity_path_28301" fill="white" stroke="gray" d="M570.5,30924.5A6,6,0,1,1,558.5,30924.5A6,6,0,1,1,570.5,30924.5"></path><path id="kity_path_28302" fill="none" stroke="gray"></path></g><path id="node_outline2594" fill="none" stroke="none" d="M570.5,30897.5h1206a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1206a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2594" fill="black"><text id="kity_text_14673" text-rendering="inherit" font-size="12" dy=".8em" y="30898.700000047684" x="570.5">rabbitmq 默认推。一般可以使用注解@RabbitListener在类上然后标记监听的队类名 和编写@RabbitHandler 来处理消息</text><text id="kity_text_14674" text-rendering="inherit" font-size="12" dy=".8em" y="30916.700000047684" x="570.5">1.push模式：客户端与服务端建立连接后，当服务端有消息时，将消息推送到客户端。使用basicConsume，一般会在之前设置qos 和缓冲区 并且要防止缓冲区溢出；实时性好，可以第一时间获取消息；如果需要吞吐量就推模式</text><text id="kity_text_14675" text-rendering="inherit" font-size="12" dy=".8em" y="30934.700000047684" x="570.5">2.pull模式：客户端不断的轮询请求服务端，来获取新的消息。使用basicGet。但在具体实现时，Push和Pull模式都是采用消费端主动拉取的方式，即consumer轮询从broker拉取消息。</text></g></g><g id="minder_node2598" display="none"><g id="node_expander2592" display="none" style="cursor: pointer;"><path id="kity_path_28298" fill="white" stroke="gray" d="M586.5,30924.5A6,6,0,1,1,574.5,30924.5A6,6,0,1,1,586.5,30924.5"></path><path id="kity_path_28299" fill="none" stroke="gray"></path></g><path id="node_outline2593" fill="none" stroke="none" d="M586.5,30915.5h354a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-354a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2593" fill="black"><text id="kity_text_14671" text-rendering="inherit" font-size="12" dy=".8em" y="30916.700000047684" x="586.5">https://blog.csdn.net/ITWANGBOIT/article/details/105428281</text></g></g><g id="minder_node2599" display="none"><g id="node_expander2596" display="none" style="cursor: pointer;"><path id="kity_path_28310" fill="white" stroke="gray" d="M554.5,30932.5A6,6,0,1,1,542.5,30932.5A6,6,0,1,1,554.5,30932.5"></path><path id="kity_path_28311" fill="none" stroke="gray"></path></g><path id="node_outline2597" fill="none" stroke="none" d="M554.5,30923.5h161a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-161a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2597" fill="black"><text id="kity_text_14682" text-rendering="inherit" font-size="12" dy=".8em" y="30924.700000047684" x="554.5">rabbitmq的死信队列是什么？</text></g></g><g id="minder_node2600" display="none"><g id="node_expander2595" display="none" style="cursor: pointer;"><path id="kity_path_28307" fill="white" stroke="gray" d="M570.5,30932.5A6,6,0,1,1,558.5,30932.5A6,6,0,1,1,570.5,30932.5"></path><path id="kity_path_28308" fill="none" stroke="gray"></path></g><path id="node_outline2596" fill="none" stroke="none" d="M570.5,30914.5h663a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-663a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2596" fill="black"><text id="kity_text_14679" text-rendering="inherit" font-size="12" dy=".8em" y="30915.700000047684" x="570.5">1.消息没有任何消费者去消费就变为死信</text><text id="kity_text_14680" text-rendering="inherit" font-size="12" dy=".8em" y="30933.700000047684" x="570.5">消息被拒绝重新消费(basic.reject/basic.nack),并且requeue=false&#xa0; 或者 消息TTL过期&#xa0; 或者 队列达到最大长度 就会变为DXL</text></g></g><g id="minder_node2601" display="none"><g id="node_expander2599" display="none" style="cursor: pointer;"><path id="kity_path_28319" fill="white" stroke="gray" d="M554.5,30940.5A6,6,0,1,1,542.5,30940.5A6,6,0,1,1,554.5,30940.5"></path><path id="kity_path_28320" fill="none" stroke="gray"></path></g><path id="node_outline2600" fill="none" stroke="none" d="M554.5,30931.5h209a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-209a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2600" fill="black"><text id="kity_text_14692" text-rendering="inherit" font-size="12" dy=".8em" y="30932.700000047684" x="554.5">rabbitmq的死信队列怎么实现，怎么用</text></g></g><g id="minder_node2602" display="none"><g id="node_expander2598" display="none" style="cursor: pointer;"><path id="kity_path_28316" fill="white" stroke="gray" d="M570.5,30940.5A6,6,0,1,1,558.5,30940.5A6,6,0,1,1,570.5,30940.5"></path><path id="kity_path_28317" fill="none" stroke="gray"></path></g><path id="node_outline2599" fill="none" stroke="none" d="M570.5,30895.5h1478a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1478a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text2599" fill="black"><text id="kity_text_14686" text-rendering="inherit" font-size="12" dy=".8em" y="30896.700000047684" x="570.5">1.死信队列一般是和TTL一起搭配，DXL主要是 一个消息被Consumer拒收了，并且reject方法的参数里requeue是false。也就是说不会被再次放在队列里，被其他消费者使用</text><text id="kity_text_14687" text-rendering="inherit" font-size="12" dy=".8em" y="30914.700000047684" x="570.5">或者是说是 消息的TTL到了，消息过期了。 队列的长度限制满了。排在前面的消息会被丢弃或者扔到死信路由上</text><text id="kity_text_14688" text-rendering="inherit" font-size="12" dy=".8em" y="30932.700000047684" x="570.5">DXL和普通的队列没有什么区别。主要是通过设置普通队列的属性 让他的消息TTL到了 然后消息通过路由到死信队列，我们不让MQ直接去处理，放到死信队列中 我们再路由到下游的队列中，去消费，可以实现一个延迟队列，比如说 超过一定时间以后&#xa0; 释放业务交易的金额占用，</text><text id="kity_text_14689" text-rendering="inherit" font-size="12" dy=".8em" y="30950.700000047684" x="570.5">我们系统里面有一个客户额度的东西，具体额度多少 是上游去决定的，表示你这个客户的购买额度，然后你客户办理交易，办理了交易，然后因为一些原因 整个流程没有做完，那么这个额度不能去占客户的，</text><text id="kity_text_14690" text-rendering="inherit" font-size="12" dy=".8em" y="30968.700000047684" x="570.5">这个额度是比较严格的，你后续贷款购买东西 都会涉及到额度，流程没有做完 正常情况下 超时 我们交易额度就要去释放，然后这里也是相当于 分布式事务的最终一致性，你业务没有做完 我们需要去释放这个交易和涉及到很多组件的东西，额度也是其中一个 大概流程是这样的</text></g></g><g id="minder_node2603" display="none"><g id="node_expander2597" display="none" style="cursor: pointer;"><path id="kity_path_28313" fill="white" stroke="gray" d="M586.5,30940.5A6,6,0,1,1,574.5,30940.5A6,6,0,1,1,586.5,30940.5"></path><path id="kity_path_28314" fill="none" stroke="gray"></path></g><path id="node_outline2598" fill="none" stroke="none" d="M586.5,30817.5h288a5,5,0,0,1,5,5v127a5,5,0,0,1,-5,5h-288a5,5,0,0,1,-5,-5v-127a5,5,0,0,1,5,-5z"></path><g id="node_text2598" fill="black"><text id="kity_text_14684" text-rendering="inherit" font-size="12" dy=".8em" y="30932.700000047684" x="586.5">https://juejin.cn/post/6844904003000762375</text></g><a id="kity_a_16973" xlink:href="https://gitee.com/xiaobo97/viwmall/blob/master/viwmall-order/src/main/java/com/viw/viwmall/order/config/MyMQConfig.java" target="_blank" xlink:title="https://gitee.com/xiaobo97/viwmall/blob/master/viwmall-order/src/main/java/com/viw/viwmall/order/config/MyMQConfig.java" style="cursor: pointer;"><path id="kity_path_16975" fill="rgba(255, 255, 255, 0)" stroke="none" d="M854.5,30929.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16974" fill="#666" stroke="none" d="M869.114,30945.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V30939.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C864.766,30936.571,866.168,30935.5,867.836,30935.5h1.278c2.116,0,3.834,1.716,3.834,3.834V30941.89C872.948,30944.008,871.23,30945.724,869.114,30945.724zM857.612,30940.612c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S867.265,30941.89,866.558,30941.89H858.89C858.185,30941.89,857.612,30941.319,857.612,30940.612zM855.056,30939.334V30941.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H856.334C854.216,30945.724,852.5,30944.008,852.5,30941.89V30939.334C852.5,30937.216,854.216,30935.5,856.334,30935.5h1.278c1.667,0,3.071,1.071,3.599,2.556H856.334C855.629,30938.056,855.056,30938.627,855.056,30939.334z"></path></a><image id="kity_image_17084" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20210314023434437.png" x="630.5" y="30820.5" width="200" height="104"></image></g><g id="minder_node2604" display="none"><g id="node_expander2601" display="none" style="cursor: pointer;"><path id="kity_path_28325" fill="white" stroke="gray" d="M554.5,30948.5A6,6,0,1,1,542.5,30948.5A6,6,0,1,1,554.5,30948.5"></path><path id="kity_path_28326" fill="none" stroke="gray"></path></g><path id="node_outline2602" fill="none" stroke="none" d="M554.5,30939.5h186a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-186a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2602" fill="black"><text id="kity_text_14697" text-rendering="inherit" font-size="12" dy=".8em" y="30940.700000047684" x="554.5">说说rabbitmq的延迟队列和实现？</text></g></g><g id="minder_node2605" display="none"><g id="node_expander2600" display="none" style="cursor: pointer;"><path id="kity_path_28322" fill="white" stroke="gray" d="M570.5,30948.5A6,6,0,1,1,558.5,30948.5A6,6,0,1,1,570.5,30948.5"></path><path id="kity_path_28323" fill="none" stroke="gray"></path></g><path id="node_outline2601" fill="none" stroke="none" d="M570.5,30930.5h524a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-524a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2601" fill="black"><text id="kity_text_14694" text-rendering="inherit" font-size="12" dy=".8em" y="30931.700000047684" x="570.5">1.和上面一样，我们项目中通过TTL+DXL实现一个延时队列，和分布式事务MQ+最终一致性有关系</text><text id="kity_text_14695" text-rendering="inherit" font-size="12" dy=".8em" y="30949.700000047684" x="570.5">2.流程就是</text></g></g><g id="minder_node2606" display="none"><g id="node_expander2604" display="none" style="cursor: pointer;"><path id="kity_path_28334" fill="white" stroke="gray" d="M554.5,30956.5A6,6,0,1,1,542.5,30956.5A6,6,0,1,1,554.5,30956.5"></path><path id="kity_path_28335" fill="none" stroke="gray"></path></g><path id="node_outline2605" fill="none" stroke="none" d="M554.5,30947.5h139a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-139a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2605" fill="black"><text id="kity_text_14706" text-rendering="inherit" font-size="12" dy=".8em" y="30948.700000047684" x="554.5">说说rabbitmq的消息追踪</text></g></g><g id="minder_node2607" display="none"><g id="node_expander2603" display="none" style="cursor: pointer;"><path id="kity_path_28331" fill="white" stroke="gray" d="M570.5,30956.5A6,6,0,1,1,558.5,30956.5A6,6,0,1,1,570.5,30956.5"></path><path id="kity_path_28332" fill="none" stroke="gray"></path></g><path id="node_outline2604" fill="none" stroke="none" d="M570.5,30929.5h756a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-756a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2604" fill="black"><text id="kity_text_14702" text-rendering="inherit" font-size="12" dy=".8em" y="30930.700000047684" x="570.5">1.使用Trace实现，他是rabbitmq的插件，并且有可视化，Trace是Rabbitmq用于记录每一次发送的消息流入流出情况</text><text id="kity_text_14703" text-rendering="inherit" font-size="12" dy=".8em" y="30948.700000047684" x="570.5">启动后会自动创建系统Exchange：amq.rabbitmq.trace&#xa0; ,每个队列会自动绑定该Exchange，绑定后发送到队列的消息都会记录到Trace日志。</text><text id="kity_text_14704" text-rendering="inherit" font-size="12" dy=".8em" y="30966.700000047684" x="570.5">2.然后他的输出的消息日志格式还有JSON</text></g></g><g id="minder_node2608" display="none"><g id="node_expander2602" display="none" style="cursor: pointer;"><path id="kity_path_28328" fill="white" stroke="gray" d="M586.5,30956.5A6,6,0,1,1,574.5,30956.5A6,6,0,1,1,586.5,30956.5"></path><path id="kity_path_28329" fill="none" stroke="gray"></path></g><path id="node_outline2603" fill="none" stroke="none" d="M586.5,30938.5h363a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-363a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2603" fill="black"><text id="kity_text_14699" text-rendering="inherit" font-size="12" dy=".8em" y="30939.700000047684" x="586.5">1.https://blog.csdn.net/qq_39669058/article/details/102817156</text><text id="kity_text_14700" text-rendering="inherit" font-size="12" dy=".8em" y="30957.700000047684" x="586.5">2.https://blog.csdn.net/it_lihongmin/article/details/71055304</text></g></g><g id="minder_node2609" display="none"><g id="node_expander2615" display="none" style="cursor: pointer;"><path id="kity_path_28367" fill="white" stroke="gray" d="M538.5,30964.5A6,6,0,1,1,526.5,30964.5A6,6,0,1,1,538.5,30964.5"></path><path id="kity_path_28368" fill="none" stroke="gray"></path></g><path id="node_outline2616" fill="none" stroke="none" d="M538.5,30955.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2616" fill="black"><text id="kity_text_14750" text-rendering="inherit" font-size="12" dy=".8em" y="30956.700000047684" x="538.5">集群</text></g></g><g id="minder_node2610" display="none"><g id="node_expander2607" display="none" style="cursor: pointer;"><path id="kity_path_28343" fill="white" stroke="gray" d="M554.5,30940.5A6,6,0,1,1,542.5,30940.5A6,6,0,1,1,554.5,30940.5"></path><path id="kity_path_28344" fill="none" stroke="gray"></path></g><path id="node_outline2608" fill="none" stroke="none" d="M554.5,30931.5h150a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-150a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2608" fill="black"><text id="kity_text_14721" text-rendering="inherit" font-size="12" dy=".8em" y="30932.700000047684" x="554.5">怎么保证rabbitmq高可用？</text></g></g><g id="minder_node2611" display="none"><g id="node_expander2606" display="none" style="cursor: pointer;"><path id="kity_path_28340" fill="white" stroke="gray" d="M570.5,30940.5A6,6,0,1,1,558.5,30940.5A6,6,0,1,1,570.5,30940.5"></path><path id="kity_path_28341" fill="none" stroke="gray"></path></g><path id="node_outline2607" fill="none" stroke="none" d="M570.5,30850.5h976a5,5,0,0,1,5,5v170a5,5,0,0,1,-5,5h-976a5,5,0,0,1,-5,-5v-170a5,5,0,0,1,5,-5z"></path><g id="node_text2607" fill="black"><text id="kity_text_14710" text-rendering="inherit" font-size="12" dy=".8em" y="30851.700000047684" x="570.5">1.普通集群，通过负载均衡器HAProxy ，在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。</text><text id="kity_text_14711" text-rendering="inherit" font-size="12" dy=".8em" y="30869.700000047684" x="570.5">创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）</text><text id="kity_text_14712" text-rendering="inherit" font-size="12" dy=".8em" y="30887.700000047684" x="570.5">消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。</text><text id="kity_text_14713" text-rendering="inherit" font-size="12" dy=".8em" y="30905.700000047684" x="570.5">2.镜像队列才是高可用模式&#xa0; 可以解决 普通单节点的消息的临时不可用问题。镜像模式至少采用3节点，2个磁盘节点和1个内存节点来保证</text><text id="kity_text_14714" text-rendering="inherit" font-size="12" dy=".8em" y="30923.700000047684" x="570.5">这种模式下 每个 RabbitMQ 节点也就是每一个实例 都有这个 queue 的一个完整镜像，包含 queue 的全部数据。</text><text id="kity_text_14715" text-rendering="inherit" font-size="12" dy=".8em" y="30941.700000047684" x="570.5">每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上</text><text id="kity_text_14716" text-rendering="inherit" font-size="12" dy=".8em" y="30959.700000047684" x="570.5">然后还可以指定策略 是同步所有节点 还是指定节点，一般是同步指定的节点，要不然全部的话性能影响大， 后面再一次队列的时侯，就会自动把数据同步到其他节点中</text><text id="kity_text_14717" text-rendering="inherit" font-size="12" dy=".8em" y="30977.700000047684" x="570.5">优点是：保证了mq消息的高可用，一个节点宕机 ，其他节点还有queue完整的数据，别的consumer可以到其它节点上去消费数据</text><text id="kity_text_14718" text-rendering="inherit" font-size="12" dy=".8em" y="30995.700000047684" x="570.5">缺点：性能开销太大，消息需要同步到所有机器上，导致网络带宽压力和消耗很重</text><text id="kity_text_14719" text-rendering="inherit" font-size="12" dy=".8em" y="31013.700000047684" x="570.5">3.采用镜像模式，要根据具体的业务规则定制话处理。如果没那么重要的业务，消息丢了也没关系的场景，又要求必须高的性能的时候，镜像也可以不用设置。</text></g></g><g id="minder_node2612" display="none"><g id="node_expander2609" display="none" style="cursor: pointer;"><path id="kity_path_28349" fill="white" stroke="gray" d="M554.5,30948.5A6,6,0,1,1,542.5,30948.5A6,6,0,1,1,554.5,30948.5"></path><path id="kity_path_28350" fill="none" stroke="gray"></path></g><path id="node_outline2610" fill="none" stroke="none" d="M554.5,30939.5h234a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-234a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2610" fill="black"><text id="kity_text_14730" text-rendering="inherit" font-size="12" dy=".8em" y="30940.700000047684" x="554.5">你们线上rabbitmq的集群是怎么搭建方式的</text></g></g><g id="minder_node2613" display="none"><g id="node_expander2608" display="none" style="cursor: pointer;"><path id="kity_path_28346" fill="white" stroke="gray" d="M570.5,30948.5A6,6,0,1,1,558.5,30948.5A6,6,0,1,1,570.5,30948.5"></path><path id="kity_path_28347" fill="none" stroke="gray"></path></g><path id="node_outline2609" fill="none" stroke="none" d="M570.5,30894.5h1458a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1458a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text2609" fill="black"><text id="kity_text_14723" text-rendering="inherit" font-size="12" dy=".8em" y="30895.700000047684" x="570.5">1.使用策略模板，</text><text id="kity_text_14724" text-rendering="inherit" font-size="12" dy=".8em" y="30913.700000047684" x="570.5">1.1为每个以“xxx.xxx”开头的队列设置所有节点的镜像，并且设置为自动同步模式</text><text id="kity_text_14725" text-rendering="inherit" font-size="12" dy=".8em" y="30931.700000047684" x="570.5">1.2为每个以“xxx.xxx.”开头的队列设置两个节点的镜像，并且设置为自动同步模式</text><text id="kity_text_14726" text-rendering="inherit" font-size="12" dy=".8em" y="30949.700000047684" x="570.5">1.3为每个以“node.”开头的队列分配指定的节点做镜像</text><text id="kity_text_14727" text-rendering="inherit" font-size="12" dy=".8em" y="30967.700000047684" x="570.5">2.控制台</text><text id="kity_text_14728" text-rendering="inherit" font-size="12" dy=".8em" y="30985.700000047684" x="570.5">很简单rabbitmq有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候可以要求数据同步到所有节点的，也可以要求就同步到指定数量的节点，然后你再次创建queue的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</text></g></g><g id="minder_node2614" display="none"><g id="node_expander2611" display="none" style="cursor: pointer;"><path id="kity_path_28355" fill="white" stroke="gray" d="M554.5,30956.5A6,6,0,1,1,542.5,30956.5A6,6,0,1,1,554.5,30956.5"></path><path id="kity_path_28356" fill="none" stroke="gray"></path></g><path id="node_outline2612" fill="none" stroke="none" d="M554.5,30947.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2612" fill="black"><text id="kity_text_14737" text-rendering="inherit" font-size="12" dy=".8em" y="30948.700000047684" x="554.5">高可用集群的使用？</text></g></g><g id="minder_node2615" display="none"><g id="node_expander2610" display="none" style="cursor: pointer;"><path id="kity_path_28352" fill="white" stroke="gray" d="M570.5,30956.5A6,6,0,1,1,558.5,30956.5A6,6,0,1,1,570.5,30956.5"></path><path id="kity_path_28353" fill="none" stroke="gray"></path></g><path id="node_outline2611" fill="none" stroke="none" d="M570.5,30920.5h327a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-327a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text2611" fill="black"><text id="kity_text_14732" text-rendering="inherit" font-size="12" dy=".8em" y="30921.700000047684" x="570.5">1.基于 HAProxy + KeepAlived 搭建 RabbitMQ 高可用集群</text><text id="kity_text_14733" text-rendering="inherit" font-size="12" dy=".8em" y="30939.700000047684" x="570.5">https://juejin.cn/post/6844904039201652744</text><text id="kity_text_14734" text-rendering="inherit" font-size="12" dy=".8em" y="30957.700000047684" x="570.5">2.</text><text id="kity_text_14735" text-rendering="inherit" font-size="12" dy=".8em" y="30975.700000047684" x="570.5">https://juejin.cn/post/6844903646405066760#heading-4</text></g></g><g id="minder_node2616" display="none"><g id="node_expander2614" display="none" style="cursor: pointer;"><path id="kity_path_28364" fill="white" stroke="gray" d="M554.5,30964.5A6,6,0,1,1,542.5,30964.5A6,6,0,1,1,554.5,30964.5"></path><path id="kity_path_28365" fill="none" stroke="gray"></path></g><path id="node_outline2615" fill="none" stroke="none" d="M554.5,30955.5h246a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-246a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2615" fill="black"><text id="kity_text_14748" text-rendering="inherit" font-size="12" dy=".8em" y="30956.700000047684" x="554.5">你们线上rabbitmq的集群有遇到了什么问题吗</text></g></g><g id="minder_node2617" display="none"><g id="node_expander2613" display="none" style="cursor: pointer;"><path id="kity_path_28361" fill="white" stroke="gray" d="M570.5,30964.5A6,6,0,1,1,558.5,30964.5A6,6,0,1,1,570.5,30964.5"></path><path id="kity_path_28362" fill="none" stroke="gray"></path></g><path id="node_outline2614" fill="none" stroke="none" d="M570.5,30919.5h840a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-840a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text2614" fill="black"><text id="kity_text_14742" text-rendering="inherit" font-size="12" dy=".8em" y="30920.700000047684" x="570.5">1.线上没有遇到大问题，但是我知道集群可能重新脑裂问题，</text><text id="kity_text_14743" text-rendering="inherit" font-size="12" dy=".8em" y="30938.700000047684" x="570.5">多机集群中节点与节点之间失联，都认为对方出现故障，而自身裂变为独立的个体，各自为政，那么就出现了抢夺对方的资源，争抢启动，至此就发生了事故。</text><text id="kity_text_14744" text-rendering="inherit" font-size="12" dy=".8em" y="30956.700000047684" x="570.5">手动处理网络分区：挑选一个信任的分区，重启其他分区的节点；</text><text id="kity_text_14745" text-rendering="inherit" font-size="12" dy=".8em" y="30974.700000047684" x="570.5">自动处理网络分区：4种方式</text><text id="kity_text_14746" text-rendering="inherit" font-size="12" dy=".8em" y="30992.700000047684" x="570.5">2.丢失消息，还没有来得及持久化</text></g></g><g id="minder_node2618" display="none"><g id="node_expander2612" display="none" style="cursor: pointer;"><path id="kity_path_28358" fill="white" stroke="gray" d="M586.5,30964.5A6,6,0,1,1,574.5,30964.5A6,6,0,1,1,586.5,30964.5"></path><path id="kity_path_28359" fill="none" stroke="gray"></path></g><path id="node_outline2613" fill="none" stroke="none" d="M586.5,30946.5h374a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-374a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2613" fill="black"><text id="kity_text_14739" text-rendering="inherit" font-size="12" dy=".8em" y="30947.700000047684" x="586.5">https://blog.csdn.net/weixin_43046724/article/details/103496219</text><text id="kity_text_14740" text-rendering="inherit" font-size="12" dy=".8em" y="30965.700000047684" x="586.5">https://blog.csdn.net/hhq163/article/details/92584790</text></g></g><g id="minder_node2619" display="none"><g id="node_expander2618" display="none" style="cursor: pointer;"><path id="kity_path_28376" fill="white" stroke="gray" d="M538.5,30972.5A6,6,0,1,1,526.5,30972.5A6,6,0,1,1,538.5,30972.5"></path><path id="kity_path_28377" fill="none" stroke="gray"></path></g><path id="node_outline2619" fill="none" stroke="none" d="M538.5,30963.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2619" fill="black"><text id="kity_text_14760" text-rendering="inherit" font-size="12" dy=".8em" y="30964.700000047684" x="538.5">场景</text></g></g><g id="minder_node2620" display="none"><g id="node_expander2617" display="none" style="cursor: pointer;"><path id="kity_path_28373" fill="white" stroke="gray" d="M554.5,30972.5A6,6,0,1,1,542.5,30972.5A6,6,0,1,1,554.5,30972.5"></path><path id="kity_path_28374" fill="none" stroke="gray"></path></g><path id="node_outline2618" fill="none" stroke="none" d="M554.5,30963.5h107a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-107a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2618" fill="black"><text id="kity_text_14758" text-rendering="inherit" font-size="12" dy=".8em" y="30964.700000047684" x="554.5">怎么设计一个MQ？</text></g></g><g id="minder_node2621" display="none"><g id="node_expander2616" display="none" style="cursor: pointer;"><path id="kity_path_28370" fill="white" stroke="gray" d="M570.5,30972.5A6,6,0,1,1,558.5,30972.5A6,6,0,1,1,570.5,30972.5"></path><path id="kity_path_28371" fill="none" stroke="gray"></path></g><path id="node_outline2617" fill="none" stroke="none" d="M570.5,30927.5h1451a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1451a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text2617" fill="black"><text id="kity_text_14752" text-rendering="inherit" font-size="12" dy=".8em" y="30928.700000047684" x="570.5">1.</text><text id="kity_text_14753" text-rendering="inherit" font-size="12" dy=".8em" y="30946.700000047684" x="570.5">伸缩性：支持可伸缩性。需要的时候快速扩容，就可以增加吞吐量和容量。broker -&gt; topic -&gt; partition，每个partition放一个机器，就存一部分数据。如果现在资源不够了，给topic增加partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了</text><text id="kity_text_14754" text-rendering="inherit" font-size="12" dy=".8em" y="30964.700000047684" x="570.5">数据保存（落地磁盘）：落磁盘，才能保证别进程挂了数据就丢了。那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的</text><text id="kity_text_14755" text-rendering="inherit" font-size="12" dy=".8em" y="30982.700000047684" x="570.5">可用性：多副本 -&gt; leader &amp; follower -&gt; broker挂了重新选举leader即可对外服务。</text><text id="kity_text_14756" text-rendering="inherit" font-size="12" dy=".8em" y="31000.700000047684" x="570.5">数据丢失：kafka数据零丢失方案</text></g></g><g id="minder_node2622" display="none"><g id="node_expander2622" display="none" style="cursor: pointer;"><path id="kity_path_28388" fill="white" stroke="gray" d="M538.5,30980.5A6,6,0,1,1,526.5,30980.5A6,6,0,1,1,538.5,30980.5"></path><path id="kity_path_28389" fill="none" stroke="gray"></path></g><path id="node_outline2623" fill="none" stroke="none" d="M538.5,30971.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2623" fill="black"><text id="kity_text_14769" text-rendering="inherit" font-size="12" dy=".8em" y="30972.700000047684" x="538.5">问题排查和性能优化</text></g></g><g id="minder_node2623" display="none"><g id="node_expander2621" display="none" style="cursor: pointer;"><path id="kity_path_28385" fill="white" stroke="gray" d="M554.5,30980.5A6,6,0,1,1,542.5,30980.5A6,6,0,1,1,554.5,30980.5"></path><path id="kity_path_28386" fill="none" stroke="gray"></path></g><path id="node_outline2622" fill="none" stroke="none" d="M554.5,30971.5h198a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-198a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2622" fill="black"><text id="kity_text_14767" text-rendering="inherit" font-size="12" dy=".8em" y="30972.700000047684" x="554.5">说说rabbitmq的日志和监控怎么做的</text></g></g><g id="minder_node2624" display="none"><g id="node_expander2620" display="none" style="cursor: pointer;"><path id="kity_path_28382" fill="white" stroke="gray" d="M570.5,30980.5A6,6,0,1,1,558.5,30980.5A6,6,0,1,1,570.5,30980.5"></path><path id="kity_path_28383" fill="none" stroke="gray"></path></g><path id="node_outline2621" fill="none" stroke="none" d="M570.5,30971.5h401a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-401a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2621" fill="black"><text id="kity_text_14765" text-rendering="inherit" font-size="12" dy=".8em" y="30972.700000047684" x="570.5">1.通过绑定监听amq.rabbitmq.log交换机来订阅日志信息来实现更多功能。</text></g></g><g id="minder_node2625" display="none"><g id="node_expander2619" display="none" style="cursor: pointer;"><path id="kity_path_28379" fill="white" stroke="gray" d="M586.5,30980.5A6,6,0,1,1,574.5,30980.5A6,6,0,1,1,586.5,30980.5"></path><path id="kity_path_28380" fill="none" stroke="gray"></path></g><path id="node_outline2620" fill="none" stroke="none" d="M586.5,30962.5h326a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2620" fill="black"><text id="kity_text_14762" text-rendering="inherit" font-size="12" dy=".8em" y="30963.700000047684" x="586.5">https://www.cnblogs.com/wyt007/p/9073316.html</text><text id="kity_text_14763" text-rendering="inherit" font-size="12" dy=".8em" y="30981.700000047684" x="586.5">https://blog.csdn.net/Mrwxxxx/article/details/109494783</text></g></g><g id="minder_node2626" display="none"><g id="node_expander2624" display="none" style="cursor: pointer;"><path id="kity_path_28394" fill="white" stroke="gray" d="M538.5,30988.5A6,6,0,1,1,526.5,30988.5A6,6,0,1,1,538.5,30988.5"></path><path id="kity_path_28395" fill="none" stroke="gray"></path></g><path id="node_outline2625" fill="none" stroke="none" d="M538.5,30979.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2625" fill="black"><text id="kity_text_14786" text-rendering="inherit" font-size="12" dy=".8em" y="30980.700000047684" x="538.5">参考文章</text></g></g><g id="minder_node2627" display="none"><g id="node_expander2623" display="none" style="cursor: pointer;"><path id="kity_path_28391" fill="white" stroke="gray" d="M554.5,30988.5A6,6,0,1,1,542.5,30988.5A6,6,0,1,1,554.5,30988.5"></path><path id="kity_path_28392" fill="none" stroke="gray"></path></g><path id="node_outline2624" fill="none" stroke="none" d="M554.5,30862.5h334a5,5,0,0,1,5,5v242a5,5,0,0,1,-5,5h-334a5,5,0,0,1,-5,-5v-242a5,5,0,0,1,5,-5z"></path><g id="node_text2624" fill="black"><text id="kity_text_14771" text-rendering="inherit" font-size="12" dy=".8em" y="30863.700000047684" x="554.5">https://www.cnblogs.com/hello-/articles/10345021.html</text><text id="kity_text_14772" text-rendering="inherit" font-size="12" dy=".8em" y="30881.700000047684" x="554.5">https://juejin.cn/post/6844903906074427400#heading-11</text><text id="kity_text_14773" text-rendering="inherit" font-size="12" dy=".8em" y="30899.700000047684" x="554.5">https://juejin.cn/post/6844903927696064526</text><text id="kity_text_14774" text-rendering="inherit" font-size="12" dy=".8em" y="30917.700000047684" x="554.5">https://juejin.cn/post/6844903849103196173</text><text id="kity_text_14775" text-rendering="inherit" font-size="12" dy=".8em" y="30935.700000047684" x="554.5">https://juejin.cn/post/6844903906804236301#heading-8</text><text id="kity_text_14776" text-rendering="inherit" font-size="12" dy=".8em" y="30953.700000047684" x="554.5">https://juejin.cn/post/6856610666137157645#heading-5</text><text id="kity_text_14777" text-rendering="inherit" font-size="12" dy=".8em" y="30971.700000047684" x="554.5">https://juejin.cn/post/6933502513954062349#heading-11</text><text id="kity_text_14778" text-rendering="inherit" font-size="12" dy=".8em" y="30989.700000047684" x="554.5">https://juejin.cn/post/6844903951834284045#heading-16</text><text id="kity_text_14779" text-rendering="inherit" font-size="12" dy=".8em" y="31007.700000047684" x="554.5">https://juejin.cn/post/6844904025008128013#heading-3</text><text id="kity_text_14780" text-rendering="inherit" font-size="12" dy=".8em" y="31025.700000047684" x="554.5">https://juejin.cn/post/6844904120671797255#heading-3</text><text id="kity_text_14781" text-rendering="inherit" font-size="12" dy=".8em" y="31043.700000047684" x="554.5">https://juejin.cn/post/6844903847203192839#heading-4</text><text id="kity_text_14782" text-rendering="inherit" font-size="12" dy=".8em" y="31061.700000047684" x="554.5">https://juejin.cn/post/6850418106372882446#heading-21</text><text id="kity_text_14783" text-rendering="inherit" font-size="12" dy=".8em" y="31079.700000047684" x="554.5">https://juejin.cn/post/6844904125935665160#heading-14</text><text id="kity_text_14784" text-rendering="inherit" font-size="12" dy=".8em" y="31097.700000047684" x="554.5">https://juejin.cn/post/6844904138757799949#heading-6</text></g></g><g id="minder_node2628" display="none"><g id="node_expander2640" display="none" style="cursor: pointer;"><path id="kity_path_28442" fill="white" stroke="gray" d="M522.5,30996.5A6,6,0,1,1,510.5,30996.5A6,6,0,1,1,522.5,30996.5"></path><path id="kity_path_28443" fill="none" stroke="gray"></path></g><path id="node_outline2641" fill="none" stroke="none" d="M522.5,30987.5h31a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-31a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2641" fill="black"><text id="kity_text_14818" text-rendering="inherit" font-size="12" dy=".8em" y="30988.700000047684" x="522.5">kfaka</text></g></g><g id="minder_node2629" display="none"><g id="node_expander2630" display="none" style="cursor: pointer;"><path id="kity_path_28412" fill="white" stroke="gray" d="M538.5,30972.5A6,6,0,1,1,526.5,30972.5A6,6,0,1,1,538.5,30972.5"></path><path id="kity_path_28413" fill="none" stroke="gray"></path></g><path id="node_outline2631" fill="none" stroke="none" d="M538.5,30963.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2631" fill="black"><text id="kity_text_14798" text-rendering="inherit" font-size="12" dy=".8em" y="30964.700000047684" x="538.5">基础</text></g></g><g id="minder_node2630" display="none"><g id="node_expander2626" display="none" style="cursor: pointer;"><path id="kity_path_28400" fill="white" stroke="gray" d="M554.5,30948.5A6,6,0,1,1,542.5,30948.5A6,6,0,1,1,554.5,30948.5"></path><path id="kity_path_28401" fill="none" stroke="gray"></path></g><path id="node_outline2627" fill="none" stroke="none" d="M554.5,30939.5h68a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-68a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2627" fill="black"><text id="kity_text_14790" text-rendering="inherit" font-size="12" dy=".8em" y="30940.700000047684" x="554.5">kfaka是什么</text></g></g><g id="minder_node2631" display="none"><g id="node_expander2627" display="none" style="cursor: pointer;"><path id="kity_path_28403" fill="white" stroke="gray" d="M554.5,30956.5A6,6,0,1,1,542.5,30956.5A6,6,0,1,1,554.5,30956.5"></path><path id="kity_path_28404" fill="none" stroke="gray"></path></g><path id="node_outline2628" fill="none" stroke="none" d="M554.5,30947.5h95a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-95a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2628" fill="black"><text id="kity_text_14792" text-rendering="inherit" font-size="12" dy=".8em" y="30948.700000047684" x="554.5">Kafka 的内部结构</text></g></g><g id="minder_node2632" display="none"><g id="node_expander2628" display="none" style="cursor: pointer;"><path id="kity_path_28406" fill="white" stroke="gray" d="M554.5,30964.5A6,6,0,1,1,542.5,30964.5A6,6,0,1,1,554.5,30964.5"></path><path id="kity_path_28407" fill="none" stroke="gray"></path></g><path id="node_outline2629" fill="none" stroke="none" d="M554.5,30955.5h150a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-150a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2629" fill="black"><text id="kity_text_14794" text-rendering="inherit" font-size="12" dy=".8em" y="30956.700000047684" x="554.5">Consumer和Pataion的关系</text></g></g><g id="minder_node2633" display="none"><g id="node_expander2629" display="none" style="cursor: pointer;"><path id="kity_path_28409" fill="white" stroke="gray" d="M554.5,30972.5A6,6,0,1,1,542.5,30972.5A6,6,0,1,1,554.5,30972.5"></path><path id="kity_path_28410" fill="none" stroke="gray"></path></g><path id="node_outline2630" fill="none" stroke="none" d="M554.5,30963.5h103a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-103a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2630" fill="black"><text id="kity_text_14796" text-rendering="inherit" font-size="12" dy=".8em" y="30964.700000047684" x="554.5">kfaka适应什么场景</text></g></g><g id="minder_node2634" display="none"><g id="node_expander2637" display="none" style="cursor: pointer;"><path id="kity_path_28433" fill="white" stroke="gray" d="M538.5,30980.5A6,6,0,1,1,526.5,30980.5A6,6,0,1,1,538.5,30980.5"></path><path id="kity_path_28434" fill="none" stroke="gray"></path></g><path id="node_outline2638" fill="none" stroke="none" d="M538.5,30971.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2638" fill="black"><text id="kity_text_14812" text-rendering="inherit" font-size="12" dy=".8em" y="30972.700000047684" x="538.5">进阶</text></g></g><g id="minder_node2635" display="none"><g id="node_expander2631" display="none" style="cursor: pointer;"><path id="kity_path_28415" fill="white" stroke="gray" d="M554.5,30940.5A6,6,0,1,1,542.5,30940.5A6,6,0,1,1,554.5,30940.5"></path><path id="kity_path_28416" fill="none" stroke="gray"></path></g><path id="node_outline2632" fill="none" stroke="none" d="M554.5,30931.5h119a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-119a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2632" fill="black"><text id="kity_text_14800" text-rendering="inherit" font-size="12" dy=".8em" y="30932.700000047684" x="554.5">Kafka&#xa0;选主怎么做的？</text></g></g><g id="minder_node2636" display="none"><g id="node_expander2632" display="none" style="cursor: pointer;"><path id="kity_path_28418" fill="white" stroke="gray" d="M554.5,30948.5A6,6,0,1,1,542.5,30948.5A6,6,0,1,1,554.5,30948.5"></path><path id="kity_path_28419" fill="none" stroke="gray"></path></g><path id="node_outline2633" fill="none" stroke="none" d="M554.5,30939.5h130a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-130a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2633" fill="black"><text id="kity_text_14802" text-rendering="inherit" font-size="12" dy=".8em" y="30940.700000047684" x="554.5">kafka&#xa0;分区怎么同步的？</text></g></g><g id="minder_node2637" display="none"><g id="node_expander2633" display="none" style="cursor: pointer;"><path id="kity_path_28421" fill="white" stroke="gray" d="M554.5,30956.5A6,6,0,1,1,542.5,30956.5A6,6,0,1,1,554.5,30956.5"></path><path id="kity_path_28422" fill="none" stroke="gray"></path></g><path id="node_outline2634" fill="none" stroke="none" d="M554.5,30947.5h154a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-154a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2634" fill="black"><text id="kity_text_14804" text-rendering="inherit" font-size="12" dy=".8em" y="30948.700000047684" x="554.5">kafka&#xa0;怎么保证不丢消息的？</text></g></g><g id="minder_node2638" display="none"><g id="node_expander2634" display="none" style="cursor: pointer;"><path id="kity_path_28424" fill="white" stroke="gray" d="M554.5,30964.5A6,6,0,1,1,542.5,30964.5A6,6,0,1,1,554.5,30964.5"></path><path id="kity_path_28425" fill="none" stroke="gray"></path></g><path id="node_outline2635" fill="none" stroke="none" d="M554.5,30955.5h199a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-199a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2635" fill="black"><text id="kity_text_14806" text-rendering="inherit" font-size="12" dy=".8em" y="30956.700000047684" x="554.5">kafka&#xa0;为什么可以扛住这么高的qps？</text></g></g><g id="minder_node2639" display="none"><g id="node_expander2635" display="none" style="cursor: pointer;"><path id="kity_path_28427" fill="white" stroke="gray" d="M554.5,30972.5A6,6,0,1,1,542.5,30972.5A6,6,0,1,1,554.5,30972.5"></path><path id="kity_path_28428" fill="none" stroke="gray"></path></g><path id="node_outline2636" fill="none" stroke="none" d="M554.5,30963.5h131a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-131a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2636" fill="black"><text id="kity_text_14808" text-rendering="inherit" font-size="12" dy=".8em" y="30964.700000047684" x="554.5">kafka 如何保证消息唯一</text></g></g><g id="minder_node2640" display="none"><g id="node_expander2636" display="none" style="cursor: pointer;"><path id="kity_path_28430" fill="white" stroke="gray" d="M554.5,30980.5A6,6,0,1,1,542.5,30980.5A6,6,0,1,1,554.5,30980.5"></path><path id="kity_path_28431" fill="none" stroke="gray"></path></g><path id="node_outline2637" fill="none" stroke="none" d="M554.5,30971.5h97a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-97a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2637" fill="black"><text id="kity_text_14810" text-rendering="inherit" font-size="12" dy=".8em" y="30972.700000047684" x="554.5">如何保证顺序消费</text></g></g><g id="minder_node2641" display="none"><g id="node_expander2638" display="none" style="cursor: pointer;"><path id="kity_path_28436" fill="white" stroke="gray" d="M538.5,30988.5A6,6,0,1,1,526.5,30988.5A6,6,0,1,1,538.5,30988.5"></path><path id="kity_path_28437" fill="none" stroke="gray"></path></g><path id="node_outline2639" fill="none" stroke="none" d="M538.5,30979.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2639" fill="black"><text id="kity_text_14814" text-rendering="inherit" font-size="12" dy=".8em" y="30980.700000047684" x="538.5">场景</text></g></g><g id="minder_node2642" display="none"><g id="node_expander2639" display="none" style="cursor: pointer;"><path id="kity_path_28439" fill="white" stroke="gray" d="M538.5,30996.5A6,6,0,1,1,526.5,30996.5A6,6,0,1,1,538.5,30996.5"></path><path id="kity_path_28440" fill="none" stroke="gray"></path></g><path id="node_outline2640" fill="none" stroke="none" d="M538.5,30987.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2640" fill="black"><text id="kity_text_14816" text-rendering="inherit" font-size="12" dy=".8em" y="30988.700000047684" x="538.5">问题排查和优化</text></g></g><g id="minder_node2643"><g id="node_expander2719" style="cursor: pointer;"><path id="kity_path_28679" fill="white" stroke="gray" d="M397.5,31038.5A6,6,0,1,1,385.5,31038.5A6,6,0,1,1,397.5,31038.5"></path><path id="kity_path_28680" fill="none" stroke="gray" d="M387,31038.5L396,31038.5M391.5,31034L391.5,31043"></path></g><path id="node_outline2720" fill="rgb(239, 238, 246)" stroke="rgb(123, 115, 191)" d="M401.5,31025.5h78a3,3,0,0,1,3,3v20a3,3,0,0,1,-3,3h-78a3,3,0,0,1,-3,-3v-20a3,3,0,0,1,3,-3z" stroke-width="1"></path><g id="node_text2720" fill="black"><text id="kity_text_15026" text-rendering="inherit" font-size="14" dy=".8em" y="31029.400000095367" x="418.5">9.linux</text></g></g><g id="minder_node2644" display="none"><g id="node_expander2652" display="none" style="cursor: pointer;"><path id="kity_path_28478" fill="white" stroke="gray" d="M498.5,31006.5A6,6,0,1,1,486.5,31006.5A6,6,0,1,1,498.5,31006.5"></path><path id="kity_path_28479" fill="none" stroke="gray"></path></g><path id="node_outline2653" fill="none" stroke="none" d="M498.5,30997.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2653" fill="black"><text id="kity_text_14847" text-rendering="inherit" font-size="12" dy=".8em" y="30998.700000047684" x="498.5">基础</text></g></g><g id="minder_node2645" display="none"><g id="node_expander2643" display="none" style="cursor: pointer;"><path id="kity_path_28451" fill="white" stroke="gray" d="M514.5,30950.5A6,6,0,1,1,502.5,30950.5A6,6,0,1,1,514.5,30950.5"></path><path id="kity_path_28452" fill="none" stroke="gray"></path></g><path id="node_outline2644" fill="none" stroke="none" d="M514.5,30941.5h113a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-113a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2644" fill="black"><text id="kity_text_14829" text-rendering="inherit" font-size="12" dy=".8em" y="30942.700000047684" x="514.5">你知道哪些linux命令</text></g></g><g id="minder_node2646" display="none"><g id="node_expander2642" display="none" style="cursor: pointer;"><path id="kity_path_28448" fill="white" stroke="gray" d="M530.5,30950.5A6,6,0,1,1,518.5,30950.5A6,6,0,1,1,530.5,30950.5"></path><path id="kity_path_28449" fill="none" stroke="gray"></path></g><path id="node_outline2643" fill="none" stroke="none" d="M530.5,30896.5h489a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-489a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text2643" fill="black"><text id="kity_text_14822" text-rendering="inherit" font-size="12" dy=".8em" y="30897.700000047684" x="530.5">1.排查内存</text><text id="kity_text_14823" text-rendering="inherit" font-size="12" dy=".8em" y="30915.700000047684" x="530.5">top; vmstat;pidstat实时查看 CPU、内存、I/O ; free内存使用情况；</text><text id="kity_text_14824" text-rendering="inherit" font-size="12" dy=".8em" y="30933.700000047684" x="530.5">2.网络</text><text id="kity_text_14825" text-rendering="inherit" font-size="12" dy=".8em" y="30951.700000047684" x="530.5">netstat</text><text id="kity_text_14826" text-rendering="inherit" font-size="12" dy=".8em" y="30969.700000047684" x="530.5">3.文件操作</text><text id="kity_text_14827" text-rendering="inherit" font-size="12" dy=".8em" y="30987.700000047684" x="530.5">cat&#xa0; ； tail日志，输出末尾n行；more 向下翻动参查看文件内容；grep 正则筛选文件的行；</text></g></g><g id="minder_node2647" display="none"><g id="node_expander2644" display="none" style="cursor: pointer;"><path id="kity_path_28454" fill="white" stroke="gray" d="M514.5,30958.5A6,6,0,1,1,502.5,30958.5A6,6,0,1,1,514.5,30958.5"></path><path id="kity_path_28455" fill="none" stroke="gray"></path></g><path id="node_outline2645" fill="none" stroke="none" d="M514.5,30949.5h148a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-148a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2645" fill="black"><text id="kity_text_14831" text-rendering="inherit" font-size="12" dy=".8em" y="30950.700000047684" x="514.5">linux查看系统日志文件命令</text></g></g><g id="minder_node2648" display="none"><g id="node_expander2645" display="none" style="cursor: pointer;"><path id="kity_path_28457" fill="white" stroke="gray" d="M514.5,30966.5A6,6,0,1,1,502.5,30966.5A6,6,0,1,1,514.5,30966.5"></path><path id="kity_path_28458" fill="none" stroke="gray"></path></g><path id="node_outline2646" fill="none" stroke="none" d="M514.5,30957.5h184a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-184a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2646" fill="black"><text id="kity_text_14833" text-rendering="inherit" font-size="12" dy=".8em" y="30958.700000047684" x="514.5">linux的软连接和硬连接是怎么回事</text></g></g><g id="minder_node2649" display="none"><g id="node_expander2646" display="none" style="cursor: pointer;"><path id="kity_path_28460" fill="white" stroke="gray" d="M514.5,30974.5A6,6,0,1,1,502.5,30974.5A6,6,0,1,1,514.5,30974.5"></path><path id="kity_path_28461" fill="none" stroke="gray"></path></g><path id="node_outline2647" fill="none" stroke="none" d="M514.5,30965.5h241a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-241a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2647" fill="black"><text id="kity_text_14835" text-rendering="inherit" font-size="12" dy=".8em" y="30966.700000047684" x="514.5">linux检索日志，匹配每一个请求最大的top10</text></g></g><g id="minder_node2650" display="none"><g id="node_expander2647" display="none" style="cursor: pointer;"><path id="kity_path_28463" fill="white" stroke="gray" d="M514.5,30982.5A6,6,0,1,1,502.5,30982.5A6,6,0,1,1,514.5,30982.5"></path><path id="kity_path_28464" fill="none" stroke="gray"></path></g><path id="node_outline2648" fill="none" stroke="none" d="M514.5,30973.5h131a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-131a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2648" fill="black"><text id="kity_text_14837" text-rendering="inherit" font-size="12" dy=".8em" y="30974.700000047684" x="514.5">查看cpu和内存占用命令</text></g></g><g id="minder_node2651" display="none"><g id="node_expander2648" display="none" style="cursor: pointer;"><path id="kity_path_28466" fill="white" stroke="gray" d="M514.5,30990.5A6,6,0,1,1,502.5,30990.5A6,6,0,1,1,514.5,30990.5"></path><path id="kity_path_28467" fill="none" stroke="gray"></path></g><path id="node_outline2649" fill="none" stroke="none" d="M514.5,30981.5h93a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-93a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2649" fill="black"><text id="kity_text_14839" text-rendering="inherit" font-size="12" dy=".8em" y="30982.700000047684" x="514.5">linux的swap分区</text></g></g><g id="minder_node2652" display="none"><g id="node_expander2650" display="none" style="cursor: pointer;"><path id="kity_path_28472" fill="white" stroke="gray" d="M514.5,30998.5A6,6,0,1,1,502.5,30998.5A6,6,0,1,1,514.5,30998.5"></path><path id="kity_path_28473" fill="none" stroke="gray"></path></g><path id="node_outline2651" fill="none" stroke="none" d="M514.5,30989.5h319a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-319a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2651" fill="black"><text id="kity_text_14843" text-rendering="inherit" font-size="12" dy=".8em" y="30990.700000047684" x="514.5">linux&#xa0;系统里，一个被打开的文件可以被另一个进程删除吗？</text></g></g><g id="minder_node2653" display="none"><g id="node_expander2649" display="none" style="cursor: pointer;"><path id="kity_path_28469" fill="white" stroke="gray" d="M530.5,30998.5A6,6,0,1,1,518.5,30998.5A6,6,0,1,1,530.5,30998.5"></path><path id="kity_path_28470" fill="none" stroke="gray"></path></g><path id="node_outline2650" fill="none" stroke="none" d="M530.5,30989.5h146a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-146a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2650" fill="black"><text id="kity_text_14841" text-rendering="inherit" font-size="12" dy=".8em" y="30990.700000047684" x="530.5">该进程会立即出现读写失败</text></g></g><g id="minder_node2654" display="none"><g id="node_expander2651" display="none" style="cursor: pointer;"><path id="kity_path_28475" fill="white" stroke="gray" d="M514.5,31006.5A6,6,0,1,1,502.5,31006.5A6,6,0,1,1,514.5,31006.5"></path><path id="kity_path_28476" fill="none" stroke="gray"></path></g><path id="node_outline2652" fill="none" stroke="none" d="M514.5,30997.5h158a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-158a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2652" fill="black"><text id="kity_text_14845" text-rendering="inherit" font-size="12" dy=".8em" y="30998.700000047684" x="514.5">一个进程可以创建多少个线程</text></g></g><g id="minder_node2655" display="none"><g id="node_expander2709" display="none" style="cursor: pointer;"><path id="kity_path_28649" fill="white" stroke="gray" d="M498.5,31014.5A6,6,0,1,1,486.5,31014.5A6,6,0,1,1,498.5,31014.5"></path><path id="kity_path_28650" fill="none" stroke="gray"></path></g><path id="node_outline2710" fill="none" stroke="none" d="M498.5,31005.5h36a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-36a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2710" fill="black"><text id="kity_text_15004" text-rendering="inherit" font-size="12" dy=".8em" y="31006.700000047684" x="498.5">网络Io</text></g></g><g id="minder_node2656" display="none"><g id="node_expander2654" display="none" style="cursor: pointer;"><path id="kity_path_28484" fill="white" stroke="gray" d="M514.5,30798.5A6,6,0,1,1,502.5,30798.5A6,6,0,1,1,514.5,30798.5"></path><path id="kity_path_28485" fill="none" stroke="gray"></path></g><path id="node_outline2655" fill="none" stroke="none" d="M514.5,30789.5h135a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-135a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2655" fill="black"><text id="kity_text_14856" text-rendering="inherit" font-size="12" dy=".8em" y="30790.700000047684" x="514.5">知道linux的网络io模型吗</text></g></g><g id="minder_node2657" display="none"><g id="node_expander2653" display="none" style="cursor: pointer;"><path id="kity_path_28481" fill="white" stroke="gray" d="M530.5,30798.5A6,6,0,1,1,518.5,30798.5A6,6,0,1,1,530.5,30798.5"></path><path id="kity_path_28482" fill="none" stroke="gray"></path></g><path id="node_outline2654" fill="none" stroke="none" d="M530.5,30744.5h147a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-147a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text2654" fill="black"><text id="kity_text_14849" text-rendering="inherit" font-size="12" dy=".8em" y="30745.700000047684" x="530.5">1.有五种io模型</text><text id="kity_text_14850" text-rendering="inherit" font-size="12" dy=".8em" y="30763.700000047684" x="530.5">同步阻塞IO(BIO)</text><text id="kity_text_14851" text-rendering="inherit" font-size="12" dy=".8em" y="30781.700000047684" x="530.5">同步非阻塞IO（NIO）</text><text id="kity_text_14852" text-rendering="inherit" font-size="12" dy=".8em" y="30799.700000047684" x="530.5"> IO多路复用（异步阻塞IO）</text><text id="kity_text_14853" text-rendering="inherit" font-size="12" dy=".8em" y="30817.700000047684" x="530.5">信号驱动IO</text><text id="kity_text_14854" text-rendering="inherit" font-size="12" dy=".8em" y="30835.700000047684" x="530.5">异步IO</text></g></g><g id="minder_node2658" display="none"><g id="node_expander2658" display="none" style="cursor: pointer;"><path id="kity_path_28496" fill="white" stroke="gray" d="M514.5,30806.5A6,6,0,1,1,502.5,30806.5A6,6,0,1,1,514.5,30806.5"></path><path id="kity_path_28497" fill="none" stroke="gray"></path></g><path id="node_outline2659" fill="none" stroke="none" d="M514.5,30797.5h33a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-33a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2659" fill="black"><text id="kity_text_14866" text-rendering="inherit" font-size="12" dy=".8em" y="30798.700000047684" x="514.5">BIO？</text></g></g><g id="minder_node2659" display="none"><g id="node_expander2657" display="none" style="cursor: pointer;"><path id="kity_path_28493" fill="white" stroke="gray" d="M530.5,30806.5A6,6,0,1,1,518.5,30806.5A6,6,0,1,1,530.5,30806.5"></path><path id="kity_path_28494" fill="none" stroke="gray"></path></g><path id="node_outline2658" fill="none" stroke="none" d="M530.5,30779.5h961a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-961a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2658" fill="black"><text id="kity_text_14862" text-rendering="inherit" font-size="12" dy=".8em" y="30780.700000047684" x="530.5">1.默认情况下 所有的socket连接的IO操作都是同步阻塞IO</text><text id="kity_text_14863" text-rendering="inherit" font-size="12" dy=".8em" y="30798.700000047684" x="530.5">一开始用户态调用系统IO读取数据，然后就进入阻塞状态。内核在等待数据完整达到之前(网络上等)，内核也要等待，</text><text id="kity_text_14864" text-rendering="inherit" font-size="12" dy=".8em" y="30816.700000047684" x="530.5">达到以后再把数据从到内核缓冲区复制到用户缓冲区(用户态的内存)，然后内核返回结果(如复制给用户缓冲区的字节数)给用户态， 用户线程去处理数据报 这个时侯用户线程阻塞解除</text></g></g><g id="minder_node2660" display="none"><g id="node_expander2655" display="none" style="cursor: pointer;"><path id="kity_path_28487" fill="white" stroke="gray" d="M546.5,30798.5A6,6,0,1,1,534.5,30798.5A6,6,0,1,1,546.5,30798.5"></path><path id="kity_path_28488" fill="none" stroke="gray"></path></g><path id="node_outline2656" fill="none" stroke="none" d="M471.5,30690.5h200a5,5,0,0,1,5,5v107a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-107a5,5,0,0,1,5,-5z"></path><g id="node_text2656" fill="black"><text id="kity_text_14858" text-rendering="inherit" font-size="12" dy=".8em" y="30790.700000047684" x="546.5">分支主题</text></g><image id="kity_image_17085" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210508014010.png" x="471.5" y="30693.5" width="200" height="94"></image></g><g id="minder_node2661" display="none"><g id="node_expander2656" display="none" style="cursor: pointer;"><path id="kity_path_28490" fill="white" stroke="gray" d="M546.5,30806.5A6,6,0,1,1,534.5,30806.5A6,6,0,1,1,546.5,30806.5"></path><path id="kity_path_28491" fill="none" stroke="gray"></path></g><path id="node_outline2657" fill="none" stroke="none" d="M471.5,30687.5h200a5,5,0,0,1,5,5v118a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-118a5,5,0,0,1,5,-5z"></path><g id="node_text2657" fill="black"><text id="kity_text_14860" text-rendering="inherit" font-size="12" dy=".8em" y="30798.700000047684" x="546.5">分支主题</text></g><image id="kity_image_17086" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210508015035.png" x="471.5" y="30690.5" width="200" height="105"></image></g><g id="minder_node2662" display="none"><g id="node_expander2660" display="none" style="cursor: pointer;"><path id="kity_path_28502" fill="white" stroke="gray" d="M514.5,30814.5A6,6,0,1,1,502.5,30814.5A6,6,0,1,1,514.5,30814.5"></path><path id="kity_path_28503" fill="none" stroke="gray"></path></g><path id="node_outline2661" fill="none" stroke="none" d="M514.5,30805.5h81a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-81a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2661" fill="black"><text id="kity_text_14871" text-rendering="inherit" font-size="12" dy=".8em" y="30806.700000047684" x="514.5">BIO的优缺点？</text></g></g><g id="minder_node2663" display="none"><g id="node_expander2659" display="none" style="cursor: pointer;"><path id="kity_path_28499" fill="white" stroke="gray" d="M530.5,30814.5A6,6,0,1,1,518.5,30814.5A6,6,0,1,1,530.5,30814.5"></path><path id="kity_path_28500" fill="none" stroke="gray"></path></g><path id="node_outline2660" fill="none" stroke="none" d="M530.5,30796.5h791a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-791a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2660" fill="black"><text id="kity_text_14868" text-rendering="inherit" font-size="12" dy=".8em" y="30797.700000047684" x="530.5">1.优点：开发简单；在阻塞等待数据期间，用户线程挂起。在阻塞期间，用户线程基本不会占用CPU资源。</text><text id="kity_text_14869" text-rendering="inherit" font-size="12" dy=".8em" y="30815.700000047684" x="530.5">2.缺点：一个线程维护一个连接的IO操作。并发量小没问题。高并发场景，需要大量的线程来维护大量的网络连接，内存、线程切换开销会非常巨大。</text></g></g><g id="minder_node2664" display="none"><g id="node_expander2664" display="none" style="cursor: pointer;"><path id="kity_path_28514" fill="white" stroke="gray" d="M514.5,30822.5A6,6,0,1,1,502.5,30822.5A6,6,0,1,1,514.5,30822.5"></path><path id="kity_path_28515" fill="none" stroke="gray"></path></g><path id="node_outline2665" fill="none" stroke="none" d="M514.5,30813.5h35a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-35a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2665" fill="black"><text id="kity_text_14881" text-rendering="inherit" font-size="12" dy=".8em" y="30814.700000047684" x="514.5">NIO？</text></g></g><g id="minder_node2665" display="none"><g id="node_expander2663" display="none" style="cursor: pointer;"><path id="kity_path_28511" fill="white" stroke="gray" d="M530.5,30822.5A6,6,0,1,1,518.5,30822.5A6,6,0,1,1,530.5,30822.5"></path><path id="kity_path_28512" fill="none" stroke="gray"></path></g><path id="node_outline2664" fill="none" stroke="none" d="M530.5,30795.5h1265a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1265a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2664" fill="black"><text id="kity_text_14877" text-rendering="inherit" font-size="12" dy=".8em" y="30796.700000047684" x="530.5">1.同步非阻塞IO；非阻塞IO要求socket被设置为NONBLOCK</text><text id="kity_text_14878" text-rendering="inherit" font-size="12" dy=".8em" y="30814.700000047684" x="530.5">用户线程在内核还没有准备好完整数据的时候，会不断地去轮询内核数据是否准备好了；这个时候用户线程会立即返回；直到内核数据到达后，用户线程发起系统调用，用户线程阻塞。等待内核把数据从内核缓冲区复制到用户缓冲区 以后；</text><text id="kity_text_14879" text-rendering="inherit" font-size="12" dy=".8em" y="30832.700000047684" x="530.5">内核返回结果给用户态线程。用户线程才解除阻塞。</text></g></g><g id="minder_node2666" display="none"><g id="node_expander2661" display="none" style="cursor: pointer;"><path id="kity_path_28505" fill="white" stroke="gray" d="M546.5,30814.5A6,6,0,1,1,534.5,30814.5A6,6,0,1,1,546.5,30814.5"></path><path id="kity_path_28506" fill="none" stroke="gray"></path></g><path id="node_outline2662" fill="none" stroke="none" d="M471.5,30672.5h200a5,5,0,0,1,5,5v141a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-141a5,5,0,0,1,5,-5z"></path><g id="node_text2662" fill="black"><text id="kity_text_14873" text-rendering="inherit" font-size="12" dy=".8em" y="30806.700000047684" x="546.5">分支主题</text></g><image id="kity_image_17087" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210508015706.png" x="471.5" y="30675.5" width="200" height="128"></image></g><g id="minder_node2667" display="none"><g id="node_expander2662" display="none" style="cursor: pointer;"><path id="kity_path_28508" fill="white" stroke="gray" d="M546.5,30822.5A6,6,0,1,1,534.5,30822.5A6,6,0,1,1,546.5,30822.5"></path><path id="kity_path_28509" fill="none" stroke="gray"></path></g><path id="node_outline2663" fill="none" stroke="none" d="M471.5,30697.5h200a5,5,0,0,1,5,5v124a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-124a5,5,0,0,1,5,-5z"></path><g id="node_text2663" fill="black"><text id="kity_text_14875" text-rendering="inherit" font-size="12" dy=".8em" y="30814.700000047684" x="546.5">分支主题</text></g><image id="kity_image_17088" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210508015736.png" x="471.5" y="30700.5" width="200" height="111"></image></g><g id="minder_node2668" display="none"><g id="node_expander2666" display="none" style="cursor: pointer;"><path id="kity_path_28520" fill="white" stroke="gray" d="M514.5,30830.5A6,6,0,1,1,502.5,30830.5A6,6,0,1,1,514.5,30830.5"></path><path id="kity_path_28521" fill="none" stroke="gray"></path></g><path id="node_outline2667" fill="none" stroke="none" d="M514.5,30821.5h71a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-71a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2667" fill="black"><text id="kity_text_14886" text-rendering="inherit" font-size="12" dy=".8em" y="30822.700000047684" x="514.5">NIO优缺点？</text></g></g><g id="minder_node2669" display="none"><g id="node_expander2665" display="none" style="cursor: pointer;"><path id="kity_path_28517" fill="white" stroke="gray" d="M530.5,30830.5A6,6,0,1,1,518.5,30830.5A6,6,0,1,1,530.5,30830.5"></path><path id="kity_path_28518" fill="none" stroke="gray"></path></g><path id="node_outline2666" fill="none" stroke="none" d="M530.5,30812.5h563a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-563a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2666" fill="black"><text id="kity_text_14883" text-rendering="inherit" font-size="12" dy=".8em" y="30813.700000047684" x="530.5">1.优点：每次发起的IO系统调用，在内核等待数据过程中可以立即返回。用户线程不会阻塞，实时性较好。</text><text id="kity_text_14884" text-rendering="inherit" font-size="12" dy=".8em" y="30831.700000047684" x="530.5">缺点：不断地轮询内核，这将占用大量的CPU时间，效率低下</text></g></g><g id="minder_node2670" display="none"><g id="node_expander2670" display="none" style="cursor: pointer;"><path id="kity_path_28532" fill="white" stroke="gray" d="M514.5,30838.5A6,6,0,1,1,502.5,30838.5A6,6,0,1,1,514.5,30838.5"></path><path id="kity_path_28533" fill="none" stroke="gray"></path></g><path id="node_outline2671" fill="none" stroke="none" d="M514.5,30829.5h84a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-84a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2671" fill="black"><text id="kity_text_14900" text-rendering="inherit" font-size="12" dy=".8em" y="30830.700000047684" x="514.5">说说io多路复用</text></g></g><g id="minder_node2671" display="none"><g id="node_expander2669" display="none" style="cursor: pointer;"><path id="kity_path_28529" fill="white" stroke="gray" d="M530.5,30838.5A6,6,0,1,1,518.5,30838.5A6,6,0,1,1,530.5,30838.5"></path><path id="kity_path_28530" fill="none" stroke="gray"></path></g><path id="node_outline2670" fill="none" stroke="none" d="M530.5,30775.5h1028a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-1028a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text2670" fill="black"><text id="kity_text_14892" text-rendering="inherit" font-size="12" dy=".8em" y="30776.700000047684" x="530.5">1.IO多路复用可以解决NIO的轮询等待问题；多路复用主要是引入了查询IO的就绪状态的系统调用，在linux中就是select/poll/epoll</text><text id="kity_text_14893" text-rendering="inherit" font-size="12" dy=".8em" y="30794.700000047684" x="530.5">一开始把要调用系统的IO操作 socket了解 提前放入select选择器中，给后面开启轮询操作用。通过选择器的查询方法，查询注册过的所有socket连接的就绪状态，内核会返回一个就绪状态列表，</text><text id="kity_text_14894" text-rendering="inherit" font-size="12" dy=".8em" y="30812.700000047684" x="530.5">只要任何一个注册过的socket数据准备好了，也就是说内核缓冲区有数据了，内核就把这个socket放入列表中；相当于是告诉用户线程这个socket连接数据准备好了；</text><text id="kity_text_14895" text-rendering="inherit" font-size="12" dy=".8em" y="30830.700000047684" x="530.5">在这个select查询过程&#xa0; 线程会阻塞。</text><text id="kity_text_14896" text-rendering="inherit" font-size="12" dy=".8em" y="30848.700000047684" x="530.5">用户线程获取到了就绪状态的scoket连接列表以后，根据列表中注册的socket连接去发起系统调用，这个时后用户线程阻塞。直到把前面的内核缓冲区数据复制到用户缓存区。</text><text id="kity_text_14897" text-rendering="inherit" font-size="12" dy=".8em" y="30866.700000047684" x="530.5">复制结束后 内核返回结果。用户线程解除阻塞 处理数据&#xa0;</text><text id="kity_text_14898" text-rendering="inherit" font-size="12" dy=".8em" y="30884.700000047684" x="530.5">2.在多路复用中一个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是内核缓冲区可读/可写），内核能够将就绪的状态返回给应用程序。</text></g></g><g id="minder_node2672" display="none"><g id="node_expander2667" display="none" style="cursor: pointer;"><path id="kity_path_28523" fill="white" stroke="gray" d="M546.5,30830.5A6,6,0,1,1,534.5,30830.5A6,6,0,1,1,546.5,30830.5"></path><path id="kity_path_28524" fill="none" stroke="gray"></path></g><path id="node_outline2668" fill="none" stroke="none" d="M471.5,30687.5h200a5,5,0,0,1,5,5v142a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-142a5,5,0,0,1,5,-5z"></path><g id="node_text2668" fill="black"><text id="kity_text_14888" text-rendering="inherit" font-size="12" dy=".8em" y="30822.700000047684" x="546.5">分支主题</text></g><image id="kity_image_17089" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210508021649.png" x="471.5" y="30690.5" width="200" height="129"></image></g><g id="minder_node2673" display="none"><g id="node_expander2668" display="none" style="cursor: pointer;"><path id="kity_path_28526" fill="white" stroke="gray" d="M546.5,30838.5A6,6,0,1,1,534.5,30838.5A6,6,0,1,1,546.5,30838.5"></path><path id="kity_path_28527" fill="none" stroke="gray"></path></g><path id="node_outline2669" fill="none" stroke="none" d="M505.5,30749.5h200a5,5,0,0,1,5,5v88a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-88a5,5,0,0,1,5,-5z"></path><g id="node_text2669" fill="black"><text id="kity_text_14890" text-rendering="inherit" font-size="12" dy=".8em" y="30830.700000047684" x="546.5">IO多路复用(来自网络)</text></g><image id="kity_image_17090" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210420144946.png" x="505.5" y="30752.5" width="200" height="75" xlink:title="IO多路复用图(来自网络)"></image></g><g id="minder_node2674" display="none"><g id="node_expander2672" display="none" style="cursor: pointer;"><path id="kity_path_28538" fill="white" stroke="gray" d="M514.5,30846.5A6,6,0,1,1,502.5,30846.5A6,6,0,1,1,514.5,30846.5"></path><path id="kity_path_28539" fill="none" stroke="gray"></path></g><path id="node_outline2673" fill="none" stroke="none" d="M514.5,30837.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2673" fill="black"><text id="kity_text_14906" text-rendering="inherit" font-size="12" dy=".8em" y="30838.700000047684" x="514.5">IO多路复用优缺点？</text></g></g><g id="minder_node2675" display="none"><g id="node_expander2671" display="none" style="cursor: pointer;"><path id="kity_path_28535" fill="white" stroke="gray" d="M530.5,30846.5A6,6,0,1,1,518.5,30846.5A6,6,0,1,1,530.5,30846.5"></path><path id="kity_path_28536" fill="none" stroke="gray"></path></g><path id="node_outline2672" fill="none" stroke="none" d="M530.5,30819.5h1216a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1216a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2672" fill="black"><text id="kity_text_14902" text-rendering="inherit" font-size="12" dy=".8em" y="30820.700000047684" x="530.5">1.优点：一个选择器查询线程可以同时处理成千上万个连接（Connection）。系统不必创建大量的线程，也不必维护这些线程，只需要监听查询是否有描述符就绪状态的事件，只要有就通知读写操作，从而大大减小了系统的开销。</text><text id="kity_text_14903" text-rendering="inherit" font-size="12" dy=".8em" y="30838.700000047684" x="530.5">2.缺点：select/poll/epoll系统调用是阻塞式的，属于同步IO。因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的</text><text id="kity_text_14904" text-rendering="inherit" font-size="12" dy=".8em" y="30856.700000047684" x="530.5">多路复用IO也需要轮询。负责select/epoll/poll状态查询调用的线程，需要不断地进行select/epoll轮询，查找出达到IO操作就绪的socket连接。</text></g></g><g id="minder_node2676" display="none"><g id="node_expander2675" display="none" style="cursor: pointer;"><path id="kity_path_28547" fill="white" stroke="gray" d="M514.5,30854.5A6,6,0,1,1,502.5,30854.5A6,6,0,1,1,514.5,30854.5"></path><path id="kity_path_28548" fill="none" stroke="gray"></path></g><path id="node_outline2676" fill="none" stroke="none" d="M514.5,30845.5h79a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-79a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2676" fill="black"><text id="kity_text_14913" text-rendering="inherit" font-size="12" dy=".8em" y="30846.700000047684" x="514.5">异步IO(AIO)？</text></g></g><g id="minder_node2677" display="none"><g id="node_expander2674" display="none" style="cursor: pointer;"><path id="kity_path_28544" fill="white" stroke="gray" d="M530.5,30854.5A6,6,0,1,1,518.5,30854.5A6,6,0,1,1,530.5,30854.5"></path><path id="kity_path_28545" fill="none" stroke="gray"></path></g><path id="node_outline2675" fill="none" stroke="none" d="M530.5,30836.5h1260a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1260a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2675" fill="black"><text id="kity_text_14910" text-rendering="inherit" font-size="12" dy=".8em" y="30837.700000047684" x="530.5">1.AIO可以解决IO多路复用的 内核数据复制到用户缓冲区时的线程阻塞问题，也就是读写事件准备就绪后用户线程调用的线程阻塞</text><text id="kity_text_14911" text-rendering="inherit" font-size="12" dy=".8em" y="30855.700000047684" x="530.5">当用户线程发起一个系统调用，马上就可以去做其它事情了，包括内核的等待数据过程 和 复制到用户缓冲区的过程 用户线程都不阻塞，用户线程可以去做其它事情，而数据完整复制到用户缓冲区时就通知用户线程，直接去IO操作就可以了</text></g></g><g id="minder_node2678" display="none"><g id="node_expander2673" display="none" style="cursor: pointer;"><path id="kity_path_28541" fill="white" stroke="gray" d="M546.5,30854.5A6,6,0,1,1,534.5,30854.5A6,6,0,1,1,546.5,30854.5"></path><path id="kity_path_28542" fill="none" stroke="gray"></path></g><path id="node_outline2674" fill="none" stroke="none" d="M471.5,30693.5h200a5,5,0,0,1,5,5v160a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-160a5,5,0,0,1,5,-5z"></path><g id="node_text2674" fill="black"><text id="kity_text_14908" text-rendering="inherit" font-size="12" dy=".8em" y="30846.700000047684" x="546.5">分支主题</text></g><image id="kity_image_17091" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210508102111.png" x="471.5" y="30696.5" width="200" height="147"></image></g><g id="minder_node2679" display="none"><g id="node_expander2677" display="none" style="cursor: pointer;"><path id="kity_path_28553" fill="white" stroke="gray" d="M514.5,30862.5A6,6,0,1,1,502.5,30862.5A6,6,0,1,1,514.5,30862.5"></path><path id="kity_path_28554" fill="none" stroke="gray"></path></g><path id="node_outline2678" fill="none" stroke="none" d="M514.5,30853.5h71a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-71a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2678" fill="black"><text id="kity_text_14918" text-rendering="inherit" font-size="12" dy=".8em" y="30854.700000047684" x="514.5">AIO的优缺点</text></g></g><g id="minder_node2680" display="none"><g id="node_expander2676" display="none" style="cursor: pointer;"><path id="kity_path_28550" fill="white" stroke="gray" d="M530.5,30862.5A6,6,0,1,1,518.5,30862.5A6,6,0,1,1,530.5,30862.5"></path><path id="kity_path_28551" fill="none" stroke="gray"></path></g><path id="node_outline2677" fill="none" stroke="none" d="M530.5,30844.5h1101a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1101a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2677" fill="black"><text id="kity_text_14915" text-rendering="inherit" font-size="12" dy=".8em" y="30845.700000047684" x="530.5">1.优点：内核等待数据和复制到用户缓冲区数据的两个阶段，用户线程都不阻塞。用户线程需要接收内核的IO操作完成的事件通知(也就是数据复制完成的通知)，或者用户线程注册一个IO操作完成的回调函数。</text><text id="kity_text_14916" text-rendering="inherit" font-size="12" dy=".8em" y="30863.700000047684" x="530.5">缺点：应用程序仅需要进行事件的注册与接收，其余的工作都留给了操作系统，也就是说，需要底层内核提供支持。 异步IO是真正的异步输入输出。linux 2.6的AIO基于epoll</text></g></g><g id="minder_node2681" display="none"><g id="node_expander2679" display="none" style="cursor: pointer;"><path id="kity_path_28559" fill="white" stroke="gray" d="M514.5,30870.5A6,6,0,1,1,502.5,30870.5A6,6,0,1,1,514.5,30870.5"></path><path id="kity_path_28560" fill="none" stroke="gray"></path></g><path id="node_outline2680" fill="none" stroke="none" d="M514.5,30861.5h74a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-74a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2680" fill="black"><text id="kity_text_14922" text-rendering="inherit" font-size="12" dy=".8em" y="30862.700000047684" x="514.5">信号驱动IO？</text></g></g><g id="minder_node2682" display="none"><g id="node_expander2678" display="none" style="cursor: pointer;"><path id="kity_path_28556" fill="white" stroke="gray" d="M530.5,30870.5A6,6,0,1,1,518.5,30870.5A6,6,0,1,1,530.5,30870.5"></path><path id="kity_path_28557" fill="none" stroke="gray"></path></g><path id="node_outline2679" fill="none" stroke="none" d="M530.5,30861.5h95a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-95a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2679" fill="black"><text id="kity_text_14920" text-rendering="inherit" font-size="12" dy=".8em" y="30862.700000047684" x="530.5">也就是上面的AIO</text></g></g><g id="minder_node2683" display="none"><g id="node_expander2681" display="none" style="cursor: pointer;"><path id="kity_path_28565" fill="white" stroke="gray" d="M514.5,30878.5A6,6,0,1,1,502.5,30878.5A6,6,0,1,1,514.5,30878.5"></path><path id="kity_path_28566" fill="none" stroke="gray"></path></g><path id="node_outline2682" fill="none" stroke="none" d="M514.5,30869.5h73a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-73a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2682" fill="black"><text id="kity_text_14927" text-rendering="inherit" font-size="12" dy=".8em" y="30870.700000047684" x="514.5">文件描述符fd</text></g></g><g id="minder_node2684" display="none"><g id="node_expander2680" display="none" style="cursor: pointer;"><path id="kity_path_28562" fill="white" stroke="gray" d="M530.5,30878.5A6,6,0,1,1,518.5,30878.5A6,6,0,1,1,530.5,30878.5"></path><path id="kity_path_28563" fill="none" stroke="gray"></path></g><path id="node_outline2681" fill="none" stroke="none" d="M530.5,30860.5h658a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-658a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2681" fill="black"><text id="kity_text_14924" text-rendering="inherit" font-size="12" dy=".8em" y="30861.700000047684" x="530.5">1.fd是内核为每一个应用程序打开文件和创建文件所创建的索引，指向文件的引用，fd会返回给应用程序此时的文件描述符。</text><text id="kity_text_14925" text-rendering="inherit" font-size="12" dy=".8em" y="30879.700000047684" x="530.5">内核为每一个进程维护一个fd的记录表</text></g></g><g id="minder_node2685" display="none"><g id="node_expander2682" display="none" style="cursor: pointer;"><path id="kity_path_28568" fill="white" stroke="gray" d="M514.5,30886.5A6,6,0,1,1,502.5,30886.5A6,6,0,1,1,514.5,30886.5"></path><path id="kity_path_28569" fill="none" stroke="gray"></path></g><path id="node_outline2683" fill="none" stroke="none" d="M514.5,30877.5h95a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-95a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2683" fill="black"><text id="kity_text_14929" text-rendering="inherit" font-size="12" dy=".8em" y="30878.700000047684" x="514.5">NIO为什么那么快</text></g></g><g id="minder_node2686" display="none"><g id="node_expander2683" display="none" style="cursor: pointer;"><path id="kity_path_28571" fill="white" stroke="gray" d="M514.5,30894.5A6,6,0,1,1,502.5,30894.5A6,6,0,1,1,514.5,30894.5"></path><path id="kity_path_28572" fill="none" stroke="gray"></path></g><path id="node_outline2684" fill="none" stroke="none" d="M514.5,30885.5h84a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-84a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2684" fill="black"><text id="kity_text_14931" text-rendering="inherit" font-size="12" dy=".8em" y="30886.700000047684" x="514.5">多路复用怎么用</text></g></g><g id="minder_node2687" display="none"><g id="node_expander2684" display="none" style="cursor: pointer;"><path id="kity_path_28574" fill="white" stroke="gray" d="M514.5,30902.5A6,6,0,1,1,502.5,30902.5A6,6,0,1,1,514.5,30902.5"></path><path id="kity_path_28575" fill="none" stroke="gray"></path></g><path id="node_outline2685" fill="none" stroke="none" d="M514.5,30893.5h156a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-156a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2685" fill="black"><text id="kity_text_14933" text-rendering="inherit" font-size="12" dy=".8em" y="30894.700000047684" x="514.5">你了解哪些io多路复用的场景</text></g></g><g id="minder_node2688" display="none"><g id="node_expander2686" display="none" style="cursor: pointer;"><path id="kity_path_28580" fill="white" stroke="gray" d="M514.5,30910.5A6,6,0,1,1,502.5,30910.5A6,6,0,1,1,514.5,30910.5"></path><path id="kity_path_28581" fill="none" stroke="gray"></path></g><path id="node_outline2687" fill="none" stroke="none" d="M514.5,30901.5h95a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-95a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2687" fill="black"><text id="kity_text_14939" text-rendering="inherit" font-size="12" dy=".8em" y="30902.700000047684" x="514.5">模型select是什么</text></g></g><g id="minder_node2689" display="none"><g id="node_expander2685" display="none" style="cursor: pointer;"><path id="kity_path_28577" fill="white" stroke="gray" d="M530.5,30910.5A6,6,0,1,1,518.5,30910.5A6,6,0,1,1,530.5,30910.5"></path><path id="kity_path_28578" fill="none" stroke="gray"></path></g><path id="node_outline2686" fill="none" stroke="none" d="M530.5,30883.5h1206a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1206a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2686" fill="black"><text id="kity_text_14935" text-rendering="inherit" font-size="12" dy=".8em" y="30884.700000047684" x="530.5">1.select会监听可读可写和except的fd，也会告诉内核一个可接受的超时时间，然后调用select阻塞，select会返回三个类型的fd就绪个数，把他们放入fdset，可以通过遍历集合找到fd 然后用户线程进行下一步操作(有可读就去读)</text><text id="kity_text_14936" text-rendering="inherit" font-size="12" dy=".8em" y="30902.700000047684" x="530.5">2.缺点：select支持的最大1024的fd；每次调用select需要轮询一遍所有的fd，查看就绪状态，不管哪个Socket是活跃的,都遍历一遍。，开销大效率低；</text><text id="kity_text_14937" text-rendering="inherit" font-size="12" dy=".8em" y="30920.700000047684" x="530.5">每次调用select需要把待监控的fd集合从用户态拷贝到内核态</text></g></g><g id="minder_node2690" display="none"><g id="node_expander2688" display="none" style="cursor: pointer;"><path id="kity_path_28586" fill="white" stroke="gray" d="M514.5,30918.5A6,6,0,1,1,502.5,30918.5A6,6,0,1,1,514.5,30918.5"></path><path id="kity_path_28587" fill="none" stroke="gray"></path></g><path id="node_outline2689" fill="none" stroke="none" d="M514.5,30909.5h59a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-59a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2689" fill="black"><text id="kity_text_14943" text-rendering="inherit" font-size="12" dy=".8em" y="30910.700000047684" x="514.5">poll是什么</text></g></g><g id="minder_node2691" display="none"><g id="node_expander2687" display="none" style="cursor: pointer;"><path id="kity_path_28583" fill="white" stroke="gray" d="M530.5,30918.5A6,6,0,1,1,518.5,30918.5A6,6,0,1,1,530.5,30918.5"></path><path id="kity_path_28584" fill="none" stroke="gray"></path></g><path id="node_outline2688" fill="none" stroke="none" d="M530.5,30909.5h508a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-508a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2688" fill="black"><text id="kity_text_14941" text-rendering="inherit" font-size="12" dy=".8em" y="30910.700000047684" x="530.5">1.select和poll没有什么本质区别，除了没有最大文件描述符限制。原因是它是基于链表来存储的</text></g></g><g id="minder_node2692" display="none"><g id="node_expander2690" display="none" style="cursor: pointer;"><path id="kity_path_28592" fill="white" stroke="gray" d="M514.5,30926.5A6,6,0,1,1,502.5,30926.5A6,6,0,1,1,514.5,30926.5"></path><path id="kity_path_28593" fill="none" stroke="gray"></path></g><path id="node_outline2691" fill="none" stroke="none" d="M514.5,30917.5h66a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-66a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2691" fill="black"><text id="kity_text_14951" text-rendering="inherit" font-size="12" dy=".8em" y="30918.700000047684" x="514.5">epoll是什么</text></g></g><g id="minder_node2693" display="none"><g id="node_expander2689" display="none" style="cursor: pointer;"><path id="kity_path_28589" fill="white" stroke="gray" d="M530.5,30926.5A6,6,0,1,1,518.5,30926.5A6,6,0,1,1,530.5,30926.5"></path><path id="kity_path_28590" fill="none" stroke="gray"></path></g><path id="node_outline2690" fill="none" stroke="none" d="M530.5,30881.5h1115a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1115a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text2690" fill="black"><text id="kity_text_14945" text-rendering="inherit" font-size="12" dy=".8em" y="30882.700000047684" x="530.5">1.epoll是增强版，没有描述符限制，只是说连接数上限很大，1G内存机器上可以打开10万个连接</text><text id="kity_text_14946" text-rendering="inherit" font-size="12" dy=".8em" y="30900.700000047684" x="530.5">epoll使用一个文件描述符管理多个描述符，只需要把描述符copy一次到内核的事件表中(事件表是内核和用户共享的内存)，只有活跃的socket才会主动调用fd的callback，然后被异步的调用并加入到ready队列。</text><text id="kity_text_14947" text-rendering="inherit" font-size="12" dy=".8em" y="30918.700000047684" x="530.5">无须遍历整个被侦听的描述符集合，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。</text><text id="kity_text_14948" text-rendering="inherit" font-size="12" dy=".8em" y="30936.700000047684" x="530.5">优点：消息传递避免内存级拷贝而是共享一块内存，事件驱动（不是轮询）每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到readyList里面，时间复杂度O(1)</text><text id="kity_text_14949" text-rendering="inherit" font-size="12" dy=".8em" y="30954.700000047684" x="530.5">缺点：大多数客户端都很活跃的情况下，系统会把所有的回调函数都唤醒，所以会导致负载较高。既然连接多就直接遍历算了</text></g></g><g id="minder_node2694" display="none"><g id="node_expander2691" display="none" style="cursor: pointer;"><path id="kity_path_28595" fill="white" stroke="gray" d="M514.5,30934.5A6,6,0,1,1,502.5,30934.5A6,6,0,1,1,514.5,30934.5"></path><path id="kity_path_28596" fill="none" stroke="gray"></path></g><path id="node_outline2692" fill="none" stroke="none" d="M514.5,30925.5h101a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-101a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2692" fill="black"><text id="kity_text_14953" text-rendering="inherit" font-size="12" dy=".8em" y="30926.700000047684" x="514.5">epoll是怎么实现的</text></g></g><g id="minder_node2695" display="none"><g id="node_expander2694" display="none" style="cursor: pointer;"><path id="kity_path_28604" fill="white" stroke="gray" d="M514.5,30942.5A6,6,0,1,1,502.5,30942.5A6,6,0,1,1,514.5,30942.5"></path><path id="kity_path_28605" fill="none" stroke="gray"></path></g><path id="node_outline2695" fill="none" stroke="none" d="M514.5,30933.5h130a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-130a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2695" fill="black"><text id="kity_text_14966" text-rendering="inherit" font-size="12" dy=".8em" y="30934.700000047684" x="514.5">select epoll poll 区别？</text></g></g><g id="minder_node2696" display="none"><g id="node_expander2693" display="none" style="cursor: pointer;"><path id="kity_path_28601" fill="white" stroke="gray" d="M530.5,30942.5A6,6,0,1,1,518.5,30942.5A6,6,0,1,1,530.5,30942.5"></path><path id="kity_path_28602" fill="none" stroke="gray"></path></g><path id="node_outline2694" fill="none" stroke="none" d="M530.5,30879.5h977a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-977a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text2694" fill="black"><text id="kity_text_14958" text-rendering="inherit" font-size="12" dy=".8em" y="30880.700000047684" x="530.5">1.			select	poll	epoll</text><text id="kity_text_14959" text-rendering="inherit" font-size="12" dy=".8em" y="30898.700000047684" x="530.5">操作方式：&#xa0; 	&#xa0; 遍历	遍历	&#xa0; 回调</text><text id="kity_text_14960" text-rendering="inherit" font-size="12" dy=".8em" y="30916.700000047684" x="530.5">底层实现：	&#xa0; 数组	链表	哈希表</text><text id="kity_text_14961" text-rendering="inherit" font-size="12" dy=".8em" y="30934.700000047684" x="530.5">IO 效率:	select每次调用都进行线性遍历，时间复杂度为O(n)	poll每次调用都进行线性遍历，时间复杂度为O(n)	</text><text id="kity_text_14962" text-rendering="inherit" font-size="12" dy=".8em" y="30952.700000047684" x="530.5">epoll事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到readyList里面，时间复杂度O(1)</text><text id="kity_text_14963" text-rendering="inherit" font-size="12" dy=".8em" y="30970.700000047684" x="530.5">最大连接数:	&#xa0; 1024	无上限	无上限</text><text id="kity_text_14964" text-rendering="inherit" font-size="12" dy=".8em" y="30988.700000047684" x="530.5">fd 拷贝	每次调用select，都需要把fd集合从用户态拷贝到内核态	每次调用poll，都需要把fd集合从用户态拷贝到内核态	 而调用epoll_ctl时拷贝进内核并保存，之后每次epoll_wait不拷贝</text></g></g><g id="minder_node2697" display="none"><g id="node_expander2692" display="none" style="cursor: pointer;"><path id="kity_path_28598" fill="white" stroke="gray" d="M546.5,30942.5A6,6,0,1,1,534.5,30942.5A6,6,0,1,1,546.5,30942.5"></path><path id="kity_path_28599" fill="none" stroke="gray"></path></g><path id="node_outline2693" fill="none" stroke="none" d="M546.5,30924.5h333a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2693" fill="black"><text id="kity_text_14955" text-rendering="inherit" font-size="12" dy=".8em" y="30925.700000047684" x="546.5">https://juejin.cn/post/6844904115131121671#heading-12</text><text id="kity_text_14956" text-rendering="inherit" font-size="12" dy=".8em" y="30943.700000047684" x="546.5">https://juejin.cn/post/6873718093709836301/#heading-7</text></g></g><g id="minder_node2698" display="none"><g id="node_expander2696" display="none" style="cursor: pointer;"><path id="kity_path_28610" fill="white" stroke="gray" d="M514.5,30950.5A6,6,0,1,1,502.5,30950.5A6,6,0,1,1,514.5,30950.5"></path><path id="kity_path_28611" fill="none" stroke="gray"></path></g><path id="node_outline2697" fill="none" stroke="none" d="M514.5,30941.5h190a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-190a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2697" fill="black"><text id="kity_text_14970" text-rendering="inherit" font-size="12" dy=".8em" y="30942.700000047684" x="514.5">select poll&#xa0; epoll用了什么存储结构</text></g></g><g id="minder_node2699" display="none"><g id="node_expander2695" display="none" style="cursor: pointer;"><path id="kity_path_28607" fill="white" stroke="gray" d="M530.5,30950.5A6,6,0,1,1,518.5,30950.5A6,6,0,1,1,530.5,30950.5"></path><path id="kity_path_28608" fill="none" stroke="gray"></path></g><path id="node_outline2696" fill="none" stroke="none" d="M530.5,30941.5h122a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-122a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2696" fill="black"><text id="kity_text_14968" text-rendering="inherit" font-size="12" dy=".8em" y="30942.700000047684" x="530.5">1.数组 2.链表 3.哈希表</text></g></g><g id="minder_node2700" display="none"><g id="node_expander2698" display="none" style="cursor: pointer;"><path id="kity_path_28616" fill="white" stroke="gray" d="M514.5,30958.5A6,6,0,1,1,502.5,30958.5A6,6,0,1,1,514.5,30958.5"></path><path id="kity_path_28617" fill="none" stroke="gray"></path></g><path id="node_outline2699" fill="none" stroke="none" d="M514.5,30949.5h113a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-113a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2699" fill="black"><text id="kity_text_14976" text-rendering="inherit" font-size="12" dy=".8em" y="30950.700000047684" x="514.5">epoll两种工作模式？</text></g></g><g id="minder_node2701" display="none"><g id="node_expander2697" display="none" style="cursor: pointer;"><path id="kity_path_28613" fill="white" stroke="gray" d="M530.5,30958.5A6,6,0,1,1,518.5,30958.5A6,6,0,1,1,530.5,30958.5"></path><path id="kity_path_28614" fill="none" stroke="gray"></path></g><path id="node_outline2698" fill="none" stroke="none" d="M530.5,30931.5h762a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-762a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2698" fill="black"><text id="kity_text_14972" text-rendering="inherit" font-size="12" dy=".8em" y="30932.700000047684" x="530.5">1.epoll 两种触发模式，LT默认，ET是高速模式</text><text id="kity_text_14973" text-rendering="inherit" font-size="12" dy=".8em" y="30950.700000047684" x="530.5">LT模式 只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作，可以不用立即去处理；下一次调用再次响应去通知</text><text id="kity_text_14974" text-rendering="inherit" font-size="12" dy=".8em" y="30968.700000047684" x="530.5">ET ，它只会提示一次，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</text></g></g><g id="minder_node2702" display="none"><g id="node_expander2701" display="none" style="cursor: pointer;"><path id="kity_path_28625" fill="white" stroke="gray" d="M514.5,30966.5A6,6,0,1,1,502.5,30966.5A6,6,0,1,1,514.5,30966.5"></path><path id="kity_path_28626" fill="none" stroke="gray"></path></g><path id="node_outline2702" fill="none" stroke="none" d="M514.5,30957.5h161a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-161a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2702" fill="black"><text id="kity_text_14984" text-rendering="inherit" font-size="12" dy=".8em" y="30958.700000047684" x="514.5">epoll回调函数是在哪里设置的</text></g></g><g id="minder_node2703" display="none"><g id="node_expander2700" display="none" style="cursor: pointer;"><path id="kity_path_28622" fill="white" stroke="gray" d="M530.5,30966.5A6,6,0,1,1,518.5,30966.5A6,6,0,1,1,530.5,30966.5"></path><path id="kity_path_28623" fill="none" stroke="gray"></path></g><path id="node_outline2701" fill="none" stroke="none" d="M530.5,30939.5h1186a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1186a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2701" fill="black"><text id="kity_text_14980" text-rendering="inherit" font-size="12" dy=".8em" y="30940.700000047684" x="530.5">1.epoll_create是创建一个epoll句柄（告诉内核这个监听的数目一共有多大）；</text><text id="kity_text_14981" text-rendering="inherit" font-size="12" dy=".8em" y="30958.700000047684" x="530.5">epoll_ctl是注册要监听的事件类型(把 socket 增加、删除到内核红黑树)；每次注册新的事件到epoll句柄中时，会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。</text><text id="kity_text_14982" text-rendering="inherit" font-size="12" dy=".8em" y="30976.700000047684" x="530.5">epoll_wait则是等待事件的产生(负责检测可读队列)。为每个fd指定一个callback函数，当事件就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表，</text></g></g><g id="minder_node2704" display="none"><g id="node_expander2699" display="none" style="cursor: pointer;"><path id="kity_path_28619" fill="white" stroke="gray" d="M546.5,30966.5A6,6,0,1,1,534.5,30966.5A6,6,0,1,1,546.5,30966.5"></path><path id="kity_path_28620" fill="none" stroke="gray"></path></g><path id="node_outline2700" fill="none" stroke="none" d="M471.5,30862.5h200a5,5,0,0,1,5,5v103a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-103a5,5,0,0,1,5,-5z"></path><g id="node_text2700" fill="black"><text id="kity_text_14978" text-rendering="inherit" font-size="12" dy=".8em" y="30958.700000047684" x="546.5">分支主题</text></g><image id="kity_image_17092" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210508202041.png" x="471.5" y="30865.5" width="200" height="90"></image></g><g id="minder_node2705" display="none"><g id="node_expander2702" display="none" style="cursor: pointer;"><path id="kity_path_28628" fill="white" stroke="gray" d="M514.5,30974.5A6,6,0,1,1,502.5,30974.5A6,6,0,1,1,514.5,30974.5"></path><path id="kity_path_28629" fill="none" stroke="gray"></path></g><path id="node_outline2703" fill="none" stroke="none" d="M514.5,30965.5h149a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-149a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2703" fill="black"><text id="kity_text_14986" text-rendering="inherit" font-size="12" dy=".8em" y="30966.700000047684" x="514.5">epoll是怎么使用步骤知道吗</text></g></g><g id="minder_node2706" display="none"><g id="node_expander2703" display="none" style="cursor: pointer;"><path id="kity_path_28631" fill="white" stroke="gray" d="M514.5,30982.5A6,6,0,1,1,502.5,30982.5A6,6,0,1,1,514.5,30982.5"></path><path id="kity_path_28632" fill="none" stroke="gray"></path></g><path id="node_outline2704" fill="none" stroke="none" d="M514.5,30973.5h143a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-143a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2704" fill="black"><text id="kity_text_14988" text-rendering="inherit" font-size="12" dy=".8em" y="30974.700000047684" x="514.5">epoll wait干了什么 知道吗</text></g></g><g id="minder_node2707" display="none"><g id="node_expander2704" display="none" style="cursor: pointer;"><path id="kity_path_28634" fill="white" stroke="gray" d="M514.5,30990.5A6,6,0,1,1,502.5,30990.5A6,6,0,1,1,514.5,30990.5"></path><path id="kity_path_28635" fill="none" stroke="gray"></path></g><path id="node_outline2705" fill="none" stroke="none" d="M514.5,30981.5h140a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-140a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2705" fill="black"><text id="kity_text_14990" text-rendering="inherit" font-size="12" dy=".8em" y="30982.700000047684" x="514.5">epoll 多个请求怎么处理？</text></g></g><g id="minder_node2708" display="none"><g id="node_expander2705" display="none" style="cursor: pointer;"><path id="kity_path_28637" fill="white" stroke="gray" d="M514.5,30998.5A6,6,0,1,1,502.5,30998.5A6,6,0,1,1,514.5,30998.5"></path><path id="kity_path_28638" fill="none" stroke="gray"></path></g><path id="node_outline2706" fill="none" stroke="none" d="M514.5,30989.5h180a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-180a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2706" fill="black"><text id="kity_text_14992" text-rendering="inherit" font-size="12" dy=".8em" y="30990.700000047684" x="514.5">fd什么时候可读，什么时候可写？</text></g></g><g id="minder_node2709" display="none"><g id="node_expander2706" display="none" style="cursor: pointer;"><path id="kity_path_28640" fill="white" stroke="gray" d="M514.5,31006.5A6,6,0,1,1,502.5,31006.5A6,6,0,1,1,514.5,31006.5"></path><path id="kity_path_28641" fill="none" stroke="gray"></path></g><path id="node_outline2707" fill="none" stroke="none" d="M514.5,30997.5h353a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-353a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2707" fill="black"><text id="kity_text_14994" text-rendering="inherit" font-size="12" dy=".8em" y="30998.700000047684" x="514.5">epoll模型有没有用到什么队列去等待的，来一个请求处理一个吗？</text></g></g><g id="minder_node2710" display="none"><g id="node_expander2708" display="none" style="cursor: pointer;"><path id="kity_path_28646" fill="white" stroke="gray" d="M514.5,31014.5A6,6,0,1,1,502.5,31014.5A6,6,0,1,1,514.5,31014.5"></path><path id="kity_path_28647" fill="none" stroke="gray"></path></g><path id="node_outline2709" fill="none" stroke="none" d="M514.5,31005.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2709" fill="black"><text id="kity_text_15002" text-rendering="inherit" font-size="12" dy=".8em" y="31006.700000047684" x="514.5">参考文章</text></g></g><g id="minder_node2711" display="none"><g id="node_expander2707" display="none" style="cursor: pointer;"><path id="kity_path_28643" fill="white" stroke="gray" d="M530.5,31014.5A6,6,0,1,1,518.5,31014.5A6,6,0,1,1,530.5,31014.5"></path><path id="kity_path_28644" fill="none" stroke="gray"></path></g><path id="node_outline2708" fill="none" stroke="none" d="M530.5,30969.5h260a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-260a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text2708" fill="black"><text id="kity_text_14996" text-rendering="inherit" font-size="12" dy=".8em" y="30970.700000047684" x="530.5">https://juejin.cn/post/6844904115131121671</text><text id="kity_text_14997" text-rendering="inherit" font-size="12" dy=".8em" y="30988.700000047684" x="530.5">https://juejin.cn/post/6844904200141438984</text><text id="kity_text_14998" text-rendering="inherit" font-size="12" dy=".8em" y="31006.700000047684" x="530.5">https://juejin.cn/post/6844904005391351822</text><text id="kity_text_14999" text-rendering="inherit" font-size="12" dy=".8em" y="31024.700000047684" x="530.5">https://juejin.cn/post/6850037276085321736</text><text id="kity_text_15000" text-rendering="inherit" font-size="12" dy=".8em" y="31042.700000047684" x="530.5">https://juejin.cn/post/6873718093709836301</text></g></g><g id="minder_node2712" display="none"><g id="node_expander2713" display="none" style="cursor: pointer;"><path id="kity_path_28661" fill="white" stroke="gray" d="M498.5,31022.5A6,6,0,1,1,486.5,31022.5A6,6,0,1,1,498.5,31022.5"></path><path id="kity_path_28662" fill="none" stroke="gray"></path></g><path id="node_outline2714" fill="none" stroke="none" d="M498.5,31013.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2714" fill="black"><text id="kity_text_15012" text-rendering="inherit" font-size="12" dy=".8em" y="31014.700000047684" x="498.5">进阶</text></g></g><g id="minder_node2713" display="none"><g id="node_expander2710" display="none" style="cursor: pointer;"><path id="kity_path_28652" fill="white" stroke="gray" d="M514.5,31006.5A6,6,0,1,1,502.5,31006.5A6,6,0,1,1,514.5,31006.5"></path><path id="kity_path_28653" fill="none" stroke="gray"></path></g><path id="node_outline2711" fill="none" stroke="none" d="M514.5,30997.5h114a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-114a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2711" fill="black"><text id="kity_text_15006" text-rendering="inherit" font-size="12" dy=".8em" y="30998.700000047684" x="514.5">linux fork函数知道吗</text></g></g><g id="minder_node2714" display="none"><g id="node_expander2711" display="none" style="cursor: pointer;"><path id="kity_path_28655" fill="white" stroke="gray" d="M514.5,31014.5A6,6,0,1,1,502.5,31014.5A6,6,0,1,1,514.5,31014.5"></path><path id="kity_path_28656" fill="none" stroke="gray"></path></g><path id="node_outline2712" fill="none" stroke="none" d="M514.5,31005.5h248a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-248a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2712" fill="black"><text id="kity_text_15008" text-rendering="inherit" font-size="12" dy=".8em" y="31006.700000047684" x="514.5">linux fork子进程 如果在线程中fork会怎么样？</text></g></g><g id="minder_node2715" display="none"><g id="node_expander2712" display="none" style="cursor: pointer;"><path id="kity_path_28658" fill="white" stroke="gray" d="M514.5,31022.5A6,6,0,1,1,502.5,31022.5A6,6,0,1,1,514.5,31022.5"></path><path id="kity_path_28659" fill="none" stroke="gray"></path></g><path id="node_outline2713" fill="none" stroke="none" d="M514.5,31013.5h495a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-495a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2713" fill="black"><text id="kity_text_15010" text-rendering="inherit" font-size="12" dy=".8em" y="31014.700000047684" x="514.5">上面那个问题，如果总共就4g内存，一个进程有10个线程，在线程中fork，能不能fork出来？</text></g></g><g id="minder_node2716" display="none"><g id="node_expander2716" display="none" style="cursor: pointer;"><path id="kity_path_28670" fill="white" stroke="gray" d="M498.5,31030.5A6,6,0,1,1,486.5,31030.5A6,6,0,1,1,498.5,31030.5"></path><path id="kity_path_28671" fill="none" stroke="gray"></path></g><path id="node_outline2717" fill="none" stroke="none" d="M498.5,31021.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2717" fill="black"><text id="kity_text_15018" text-rendering="inherit" font-size="12" dy=".8em" y="31022.700000047684" x="498.5">监控优化和性能方面</text></g></g><g id="minder_node2717" display="none"><g id="node_expander2714" display="none" style="cursor: pointer;"><path id="kity_path_28664" fill="white" stroke="gray" d="M514.5,31022.5A6,6,0,1,1,502.5,31022.5A6,6,0,1,1,514.5,31022.5"></path><path id="kity_path_28665" fill="none" stroke="gray"></path></g><path id="node_outline2715" fill="none" stroke="none" d="M514.5,31013.5h156a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-156a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2715" fill="black"><text id="kity_text_15014" text-rendering="inherit" font-size="12" dy=".8em" y="31014.700000047684" x="514.5">linux怎么监控cpu运行情况？</text></g></g><g id="minder_node2718" display="none"><g id="node_expander2715" display="none" style="cursor: pointer;"><path id="kity_path_28667" fill="white" stroke="gray" d="M514.5,31030.5A6,6,0,1,1,502.5,31030.5A6,6,0,1,1,514.5,31030.5"></path><path id="kity_path_28668" fill="none" stroke="gray"></path></g><path id="node_outline2716" fill="none" stroke="none" d="M514.5,31021.5h307a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-307a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2716" fill="black"><text id="kity_text_15016" text-rendering="inherit" font-size="12" dy=".8em" y="31022.700000047684" x="514.5">怎么监控端口连接情况？tcp连接情况？占用了多少内存？</text></g></g><g id="minder_node2719" display="none"><g id="node_expander2718" display="none" style="cursor: pointer;"><path id="kity_path_28676" fill="white" stroke="gray" d="M498.5,31038.5A6,6,0,1,1,486.5,31038.5A6,6,0,1,1,498.5,31038.5"></path><path id="kity_path_28677" fill="none" stroke="gray"></path></g><path id="node_outline2719" fill="none" stroke="none" d="M498.5,31029.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2719" fill="black"><text id="kity_text_15024" text-rendering="inherit" font-size="12" dy=".8em" y="31030.700000047684" x="498.5">参考文章</text></g></g><g id="minder_node2720" display="none"><g id="node_expander2717" display="none" style="cursor: pointer;"><path id="kity_path_28673" fill="white" stroke="gray" d="M514.5,31038.5A6,6,0,1,1,502.5,31038.5A6,6,0,1,1,514.5,31038.5"></path><path id="kity_path_28674" fill="none" stroke="gray"></path></g><path id="node_outline2718" fill="none" stroke="none" d="M514.5,31011.5h339a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-339a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2718" fill="black"><text id="kity_text_15020" text-rendering="inherit" font-size="12" dy=".8em" y="31012.700000047684" x="514.5">https://juejin.cn/post/6844904125700784136#heading-1</text><text id="kity_text_15021" text-rendering="inherit" font-size="12" dy=".8em" y="31030.700000047684" x="514.5">https://segmentfault.com/a/1190000012316621</text><text id="kity_text_15022" text-rendering="inherit" font-size="12" dy=".8em" y="31048.700000047684" x="514.5">https://blog.csdn.net/XueyinGuo/article/details/113096416</text></g></g><g id="minder_node2721"><g id="node_expander2763" style="cursor: pointer;"><path id="kity_path_28811" fill="white" stroke="gray" d="M397.5,31080.5A6,6,0,1,1,385.5,31080.5A6,6,0,1,1,397.5,31080.5"></path><path id="kity_path_28812" fill="none" stroke="gray" d="M387,31080.5L396,31080.5M391.5,31076L391.5,31085"></path></g><path id="node_outline2764" fill="rgb(239, 238, 246)" stroke="rgb(123, 115, 191)" d="M401.5,31067.5h111a3,3,0,0,1,3,3v20a3,3,0,0,1,-3,3h-111a3,3,0,0,1,-3,-3v-20a3,3,0,0,1,3,-3z" stroke-width="1"></path><g id="node_text2764" fill="black"><text id="kity_text_15141" text-rendering="inherit" font-size="14" dy=".8em" y="31071.400000095367" x="418.5">10.设计模式</text></g></g><g id="minder_node2722" display="none"><g id="node_expander2723" display="none" style="cursor: pointer;"><path id="kity_path_28691" fill="white" stroke="gray" d="M531.5,31048.5A6,6,0,1,1,519.5,31048.5A6,6,0,1,1,531.5,31048.5"></path><path id="kity_path_28692" fill="none" stroke="gray"></path></g><path id="node_outline2724" fill="none" stroke="none" d="M531.5,31039.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2724" fill="black"><text id="kity_text_15045" text-rendering="inherit" font-size="12" dy=".8em" y="31040.700000047684" x="531.5">基础</text></g></g><g id="minder_node2723" display="none"><g id="node_expander2722" display="none" style="cursor: pointer;"><path id="kity_path_28688" fill="white" stroke="gray" d="M547.5,31048.5A6,6,0,1,1,535.5,31048.5A6,6,0,1,1,547.5,31048.5"></path><path id="kity_path_28689" fill="none" stroke="gray"></path></g><path id="node_outline2723" fill="none" stroke="none" d="M547.5,31039.5h43a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-43a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2723" fill="black"><text id="kity_text_15043" text-rendering="inherit" font-size="12" dy=".8em" y="31040.700000047684" x="547.5">6大原则</text></g></g><g id="minder_node2724" display="none"><g id="node_expander2721" display="none" style="cursor: pointer;"><path id="kity_path_28685" fill="white" stroke="gray" d="M563.5,31048.5A6,6,0,1,1,551.5,31048.5A6,6,0,1,1,563.5,31048.5"></path><path id="kity_path_28686" fill="none" stroke="gray"></path></g><path id="node_outline2722" fill="none" stroke="none" d="M563.5,30940.5h648a5,5,0,0,1,5,5v206a5,5,0,0,1,-5,5h-648a5,5,0,0,1,-5,-5v-206a5,5,0,0,1,5,-5z"></path><g id="node_text2722" fill="black"><text id="kity_text_15030" text-rendering="inherit" font-size="12" dy=".8em" y="30941.700000047684" x="563.5">1.开闭原则</text><text id="kity_text_15031" text-rendering="inherit" font-size="12" dy=".8em" y="30959.700000047684" x="563.5">设计符合开闭原则，方便系统扩展，而且扩展时无须修改现有代码，具备较好的稳定性和延续性；降低了程序的维护成本。</text><text id="kity_text_15032" text-rendering="inherit" font-size="12" dy=".8em" y="30977.700000047684" x="563.5">2.里氏替换原则</text><text id="kity_text_15033" text-rendering="inherit" font-size="12" dy=".8em" y="30995.700000047684" x="563.5">所有引用父类对象的地方能够透明地使用其子类的对象；约束继承在使用上的泛滥。</text><text id="kity_text_15034" text-rendering="inherit" font-size="12" dy=".8em" y="31013.700000047684" x="563.5">3.依赖倒置原则</text><text id="kity_text_15035" text-rendering="inherit" font-size="12" dy=".8em" y="31031.700000047684" x="563.5">抽象不应该依赖于具体类，具体类应当依赖于抽象；面向接口编程；用抽象多久系统框架</text><text id="kity_text_15036" text-rendering="inherit" font-size="12" dy=".8em" y="31049.700000047684" x="563.5">4.单一职责原则</text><text id="kity_text_15037" text-rendering="inherit" font-size="12" dy=".8em" y="31067.700000047684" x="563.5">一个类而言，应该只有一个引起它变化的原因；类与方法的职责划分清晰，</text><text id="kity_text_15038" text-rendering="inherit" font-size="12" dy=".8em" y="31085.700000047684" x="563.5">5.最少知道原则</text><text id="kity_text_15039" text-rendering="inherit" font-size="12" dy=".8em" y="31103.700000047684" x="563.5">降低类与类之间的耦合，减少类与类之间的关联程度</text><text id="kity_text_15040" text-rendering="inherit" font-size="12" dy=".8em" y="31121.700000047684" x="563.5">6.接口分离原则</text><text id="kity_text_15041" text-rendering="inherit" font-size="12" dy=".8em" y="31139.700000047684" x="563.5">接口责任划分明确</text></g></g><g id="minder_node2725" display="none"><g id="node_expander2720" display="none" style="cursor: pointer;"><path id="kity_path_28682" fill="white" stroke="gray" d="M579.5,31048.5A6,6,0,1,1,567.5,31048.5A6,6,0,1,1,579.5,31048.5"></path><path id="kity_path_28683" fill="none" stroke="gray"></path></g><path id="node_outline2721" fill="none" stroke="none" d="M579.5,31039.5h326a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2721" fill="black"><text id="kity_text_15028" text-rendering="inherit" font-size="12" dy=".8em" y="31040.700000047684" x="579.5">https://juejin.cn/post/6844903795017646094#heading-7</text></g></g><g id="minder_node2726" display="none"><g id="node_expander2734" display="none" style="cursor: pointer;"><path id="kity_path_28724" fill="white" stroke="gray" d="M531.5,31056.5A6,6,0,1,1,519.5,31056.5A6,6,0,1,1,531.5,31056.5"></path><path id="kity_path_28725" fill="none" stroke="gray"></path></g><path id="node_outline2735" fill="none" stroke="none" d="M531.5,31047.5h38a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-38a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2735" fill="black"><text id="kity_text_15075" text-rendering="inherit" font-size="12" dy=".8em" y="31048.700000047684" x="531.5">创建型</text></g></g><g id="minder_node2727" display="none"><g id="node_expander2726" display="none" style="cursor: pointer;"><path id="kity_path_28700" fill="white" stroke="gray" d="M547.5,31024.5A6,6,0,1,1,535.5,31024.5A6,6,0,1,1,547.5,31024.5"></path><path id="kity_path_28701" fill="none" stroke="gray"></path></g><path id="node_outline2727" fill="none" stroke="none" d="M547.5,31015.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2727" fill="black"><text id="kity_text_15054" text-rendering="inherit" font-size="12" dy=".8em" y="31016.700000047684" x="547.5">单例模式</text></g></g><g id="minder_node2728" display="none"><g id="node_expander2725" display="none" style="cursor: pointer;"><path id="kity_path_28697" fill="white" stroke="gray" d="M563.5,31024.5A6,6,0,1,1,551.5,31024.5A6,6,0,1,1,563.5,31024.5"></path><path id="kity_path_28698" fill="none" stroke="gray"></path></g><path id="node_outline2726" fill="none" stroke="none" d="M563.5,30988.5h797a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-797a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text2726" fill="black"><text id="kity_text_15049" text-rendering="inherit" font-size="12" dy=".8em" y="30989.700000047684" x="563.5">1.单例模式：提供一个方法 自己负责创建对象，并且这个对象在内存中只有一个，然后提供方法给其它访问</text><text id="kity_text_15050" text-rendering="inherit" font-size="12" dy=".8em" y="31007.700000047684" x="563.5">双重检验锁(volatile+syn同步锁)</text><text id="kity_text_15051" text-rendering="inherit" font-size="12" dy=".8em" y="31025.700000047684" x="563.5">第一重检验：首先判断有没有创建，没创建再加锁；第二重检验：对类实例加锁，再次判断有没有创建，没有就创建实例，主要是解决多线程并发调用&#xa0;</text><text id="kity_text_15052" text-rendering="inherit" font-size="12" dy=".8em" y="31043.700000047684" x="563.5">2.单例模式 如果长时间不利用，可能被回收，那么之前保存的信息 就不在了</text></g></g><g id="minder_node2729" display="none"><g id="node_expander2724" display="none" style="cursor: pointer;"><path id="kity_path_28694" fill="white" stroke="gray" d="M579.5,31024.5A6,6,0,1,1,567.5,31024.5A6,6,0,1,1,579.5,31024.5"></path><path id="kity_path_28695" fill="none" stroke="gray"></path></g><path id="node_outline2725" fill="none" stroke="none" d="M579.5,31013.5h71a5,5,0,0,1,5,5v13a5,5,0,0,1,-5,5h-71a5,5,0,0,1,-5,-5v-13a5,5,0,0,1,5,-5z"></path><g id="node_text2725" fill="black"><text id="kity_text_15047" text-rendering="inherit" font-size="12" dy=".8em" y="31016.700000047684" x="579.5">分支主题</text></g><g id="kity_g_17003" style="cursor: pointer;"><path id="kity_path_17004" fill="none" stroke="none" d="M637,31016h12a2,2,0,0,1,2,2v13a2,2,0,0,1,-2,2h-12a2,2,0,0,1,-2,-2v-13a2,2,0,0,1,2,-2z"></path><path id="kity_path_17005" fill="black" stroke="none" d="M646,31027H640V31026h6L646,31027L646,31027zM646,31025H640V31024h6V31025zM646,31023H640V31022h6V31023zM645.5,31029H639V31020h8v7.5M646,31030l2,-2V31019H638v11"></path></g></g><g id="minder_node2730" display="none"><g id="node_expander2727" display="none" style="cursor: pointer;"><path id="kity_path_28703" fill="white" stroke="gray" d="M547.5,31032.5A6,6,0,1,1,535.5,31032.5A6,6,0,1,1,547.5,31032.5"></path><path id="kity_path_28704" fill="none" stroke="gray"></path></g><path id="node_outline2728" fill="none" stroke="none" d="M547.5,31023.5h62a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-62a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2728" fill="black"><text id="kity_text_15056" text-rendering="inherit" font-size="12" dy=".8em" y="31024.700000047684" x="547.5">建造者模式</text></g></g><g id="minder_node2731" display="none"><g id="node_expander2730" display="none" style="cursor: pointer;"><path id="kity_path_28712" fill="white" stroke="gray" d="M547.5,31040.5A6,6,0,1,1,535.5,31040.5A6,6,0,1,1,547.5,31040.5"></path><path id="kity_path_28713" fill="none" stroke="gray"></path></g><path id="node_outline2731" fill="none" stroke="none" d="M547.5,31031.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2731" fill="black"><text id="kity_text_15067" text-rendering="inherit" font-size="12" dy=".8em" y="31032.700000047684" x="547.5">工厂模式</text></g></g><g id="minder_node2732" display="none"><g id="node_expander2729" display="none" style="cursor: pointer;"><path id="kity_path_28709" fill="white" stroke="gray" d="M563.5,31040.5A6,6,0,1,1,551.5,31040.5A6,6,0,1,1,563.5,31040.5"></path><path id="kity_path_28710" fill="none" stroke="gray"></path></g><path id="node_outline2730" fill="none" stroke="none" d="M563.5,30986.5h887a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-887a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text2730" fill="black"><text id="kity_text_15060" text-rendering="inherit" font-size="12" dy=".8em" y="30987.700000047684" x="563.5">1.简单工厂模式</text><text id="kity_text_15061" text-rendering="inherit" font-size="12" dy=".8em" y="31005.700000047684" x="563.5">专门定义一个工厂类来负责创建其他类的实例。根据创建方法的参数来返回不同类的实例；</text><text id="kity_text_15062" text-rendering="inherit" font-size="12" dy=".8em" y="31023.700000047684" x="563.5">优点：只需传入约定参数，减少系统的耦合。缺点：添加新产品需要修改工厂类；违背开闭原则。产品类型多，工厂逻辑会复杂</text><text id="kity_text_15063" text-rendering="inherit" font-size="12" dy=".8em" y="31041.700000047684" x="563.5">2.工厂方法模式</text><text id="kity_text_15064" text-rendering="inherit" font-size="12" dy=".8em" y="31059.700000047684" x="563.5">工厂父类负责定义创建产品对象的公共接口，不同的工厂子类来创建不同的产品对象。比如说 工厂，下面的代工厂 可口可乐和百事可乐 不同的工厂子类创建不同的产品</text><text id="kity_text_15065" text-rendering="inherit" font-size="12" dy=".8em" y="31077.700000047684" x="563.5">优点：系统中加入新产品时 只需要添加工厂子类和具体产品类，不需要改其它代码；缺点：类的个数将成对增加</text></g></g><g id="minder_node2733" display="none"><g id="node_expander2728" display="none" style="cursor: pointer;"><path id="kity_path_28706" fill="white" stroke="gray" d="M579.5,31040.5A6,6,0,1,1,567.5,31040.5A6,6,0,1,1,579.5,31040.5"></path><path id="kity_path_28707" fill="none" stroke="gray"></path></g><path id="node_outline2729" fill="none" stroke="none" d="M579.5,31031.5h259a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-259a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2729" fill="black"><text id="kity_text_15058" text-rendering="inherit" font-size="12" dy=".8em" y="31032.700000047684" x="579.5">https://juejin.cn/post/6844903961980321800</text></g></g><g id="minder_node2734" display="none"><g id="node_expander2732" display="none" style="cursor: pointer;"><path id="kity_path_28718" fill="white" stroke="gray" d="M547.5,31048.5A6,6,0,1,1,535.5,31048.5A6,6,0,1,1,547.5,31048.5"></path><path id="kity_path_28719" fill="none" stroke="gray"></path></g><path id="node_outline2733" fill="none" stroke="none" d="M547.5,31039.5h74a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-74a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2733" fill="black"><text id="kity_text_15071" text-rendering="inherit" font-size="12" dy=".8em" y="31040.700000047684" x="547.5">抽象工厂模式</text></g></g><g id="minder_node2735" display="none"><g id="node_expander2731" display="none" style="cursor: pointer;"><path id="kity_path_28715" fill="white" stroke="gray" d="M563.5,31048.5A6,6,0,1,1,551.5,31048.5A6,6,0,1,1,563.5,31048.5"></path><path id="kity_path_28716" fill="none" stroke="gray"></path></g><path id="node_outline2732" fill="none" stroke="none" d="M563.5,31039.5h410a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-410a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2732" fill="black"><text id="kity_text_15069" text-rendering="inherit" font-size="12" dy=".8em" y="31040.700000047684" x="563.5">1.对需要生成的类和工厂都进行抽象；同一接口的不同工厂类 生产出不同对象</text></g></g><g id="minder_node2736" display="none"><g id="node_expander2733" display="none" style="cursor: pointer;"><path id="kity_path_28721" fill="white" stroke="gray" d="M547.5,31056.5A6,6,0,1,1,535.5,31056.5A6,6,0,1,1,547.5,31056.5"></path><path id="kity_path_28722" fill="none" stroke="gray"></path></g><path id="node_outline2734" fill="none" stroke="none" d="M547.5,31047.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2734" fill="black"><text id="kity_text_15073" text-rendering="inherit" font-size="12" dy=".8em" y="31048.700000047684" x="547.5">原型模式</text></g></g><g id="minder_node2737" display="none"><g id="node_expander2744" display="none" style="cursor: pointer;"><path id="kity_path_28754" fill="white" stroke="gray" d="M531.5,31064.5A6,6,0,1,1,519.5,31064.5A6,6,0,1,1,531.5,31064.5"></path><path id="kity_path_28755" fill="none" stroke="gray"></path></g><path id="node_outline2745" fill="none" stroke="none" d="M531.5,31055.5h38a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-38a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2745" fill="black"><text id="kity_text_15096" text-rendering="inherit" font-size="12" dy=".8em" y="31056.700000047684" x="531.5">结构型</text></g></g><g id="minder_node2738" display="none"><g id="node_expander2736" display="none" style="cursor: pointer;"><path id="kity_path_28730" fill="white" stroke="gray" d="M547.5,31016.5A6,6,0,1,1,535.5,31016.5A6,6,0,1,1,547.5,31016.5"></path><path id="kity_path_28731" fill="none" stroke="gray"></path></g><path id="node_outline2737" fill="none" stroke="none" d="M547.5,31007.5h62a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-62a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2737" fill="black"><text id="kity_text_15080" text-rendering="inherit" font-size="12" dy=".8em" y="31008.700000047684" x="547.5">适配器模式</text></g></g><g id="minder_node2739" display="none"><g id="node_expander2735" display="none" style="cursor: pointer;"><path id="kity_path_28727" fill="white" stroke="gray" d="M563.5,31016.5A6,6,0,1,1,551.5,31016.5A6,6,0,1,1,563.5,31016.5"></path><path id="kity_path_28728" fill="none" stroke="gray"></path></g><path id="node_outline2736" fill="none" stroke="none" d="M563.5,30998.5h636a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-636a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2736" fill="black"><text id="kity_text_15077" text-rendering="inherit" font-size="12" dy=".8em" y="30999.700000047684" x="563.5">1.将某个类的接口转换成用户期望的另一个接口；使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</text><text id="kity_text_15078" text-rendering="inherit" font-size="12" dy=".8em" y="31017.700000047684" x="563.5">比如说 安卓和苹果手机 手机卡大小不一样，如果加一个卡套， 小的加卡套就可以给大的使用了，相当于在原来卡再包装</text></g></g><g id="minder_node2740" display="none"><g id="node_expander2737" display="none" style="cursor: pointer;"><path id="kity_path_28733" fill="white" stroke="gray" d="M547.5,31024.5A6,6,0,1,1,535.5,31024.5A6,6,0,1,1,547.5,31024.5"></path><path id="kity_path_28734" fill="none" stroke="gray"></path></g><path id="node_outline2738" fill="none" stroke="none" d="M547.5,31015.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2738" fill="black"><text id="kity_text_15082" text-rendering="inherit" font-size="12" dy=".8em" y="31016.700000047684" x="547.5">装饰模式</text></g></g><g id="minder_node2741" display="none"><g id="node_expander2738" display="none" style="cursor: pointer;"><path id="kity_path_28736" fill="white" stroke="gray" d="M547.5,31032.5A6,6,0,1,1,535.5,31032.5A6,6,0,1,1,547.5,31032.5"></path><path id="kity_path_28737" fill="none" stroke="gray"></path></g><path id="node_outline2739" fill="none" stroke="none" d="M547.5,31023.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2739" fill="black"><text id="kity_text_15084" text-rendering="inherit" font-size="12" dy=".8em" y="31024.700000047684" x="547.5">组合模式</text></g></g><g id="minder_node2742" display="none"><g id="node_expander2739" display="none" style="cursor: pointer;"><path id="kity_path_28739" fill="white" stroke="gray" d="M547.5,31040.5A6,6,0,1,1,535.5,31040.5A6,6,0,1,1,547.5,31040.5"></path><path id="kity_path_28740" fill="none" stroke="gray"></path></g><path id="node_outline2740" fill="none" stroke="none" d="M547.5,31031.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2740" fill="black"><text id="kity_text_15086" text-rendering="inherit" font-size="12" dy=".8em" y="31032.700000047684" x="547.5">外观模式</text></g></g><g id="minder_node2743" display="none"><g id="node_expander2740" display="none" style="cursor: pointer;"><path id="kity_path_28742" fill="white" stroke="gray" d="M547.5,31048.5A6,6,0,1,1,535.5,31048.5A6,6,0,1,1,547.5,31048.5"></path><path id="kity_path_28743" fill="none" stroke="gray"></path></g><path id="node_outline2741" fill="none" stroke="none" d="M547.5,31039.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2741" fill="black"><text id="kity_text_15088" text-rendering="inherit" font-size="12" dy=".8em" y="31040.700000047684" x="547.5">享元模式</text></g></g><g id="minder_node2744" display="none"><g id="node_expander2742" display="none" style="cursor: pointer;"><path id="kity_path_28748" fill="white" stroke="gray" d="M547.5,31056.5A6,6,0,1,1,535.5,31056.5A6,6,0,1,1,547.5,31056.5"></path><path id="kity_path_28749" fill="none" stroke="gray"></path></g><path id="node_outline2743" fill="none" stroke="none" d="M547.5,31047.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2743" fill="black"><text id="kity_text_15092" text-rendering="inherit" font-size="12" dy=".8em" y="31048.700000047684" x="547.5">代理模式</text></g></g><g id="minder_node2745" display="none"><g id="node_expander2741" display="none" style="cursor: pointer;"><path id="kity_path_28745" fill="white" stroke="gray" d="M563.5,31056.5A6,6,0,1,1,551.5,31056.5A6,6,0,1,1,563.5,31056.5"></path><path id="kity_path_28746" fill="none" stroke="gray"></path></g><path id="node_outline2742" fill="none" stroke="none" d="M563.5,31047.5h635a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-635a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2742" fill="black"><text id="kity_text_15090" text-rendering="inherit" font-size="12" dy=".8em" y="31048.700000047684" x="563.5">1.为某个对象提供一个代理，并由这个代理对象控制对原对象的访问。通过代理对象可以增强原对象的访问做更多的事情</text></g></g><g id="minder_node2746" display="none"><g id="node_expander2743" display="none" style="cursor: pointer;"><path id="kity_path_28751" fill="white" stroke="gray" d="M547.5,31064.5A6,6,0,1,1,535.5,31064.5A6,6,0,1,1,547.5,31064.5"></path><path id="kity_path_28752" fill="none" stroke="gray"></path></g><path id="node_outline2744" fill="none" stroke="none" d="M547.5,31055.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2744" fill="black"><text id="kity_text_15094" text-rendering="inherit" font-size="12" dy=".8em" y="31056.700000047684" x="547.5">桥接模式</text></g></g><g id="minder_node2747" display="none"><g id="node_expander2760" display="none" style="cursor: pointer;"><path id="kity_path_28802" fill="white" stroke="gray" d="M531.5,31072.5A6,6,0,1,1,519.5,31072.5A6,6,0,1,1,531.5,31072.5"></path><path id="kity_path_28803" fill="none" stroke="gray"></path></g><path id="node_outline2761" fill="none" stroke="none" d="M531.5,31063.5h38a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-38a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2761" fill="black"><text id="kity_text_15133" text-rendering="inherit" font-size="12" dy=".8em" y="31064.700000047684" x="531.5">行为型</text></g></g><g id="minder_node2748" display="none"><g id="node_expander2747" display="none" style="cursor: pointer;"><path id="kity_path_28763" fill="white" stroke="gray" d="M547.5,30992.5A6,6,0,1,1,535.5,30992.5A6,6,0,1,1,547.5,30992.5"></path><path id="kity_path_28764" fill="none" stroke="gray"></path></g><path id="node_outline2748" fill="none" stroke="none" d="M547.5,30983.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2748" fill="black"><text id="kity_text_15103" text-rendering="inherit" font-size="12" dy=".8em" y="30984.700000047684" x="547.5">模板模式</text></g></g><g id="minder_node2749" display="none"><g id="node_expander2746" display="none" style="cursor: pointer;"><path id="kity_path_28760" fill="white" stroke="gray" d="M563.5,30992.5A6,6,0,1,1,551.5,30992.5A6,6,0,1,1,563.5,30992.5"></path><path id="kity_path_28761" fill="none" stroke="gray"></path></g><path id="node_outline2747" fill="none" stroke="none" d="M563.5,30974.5h822a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-822a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2747" fill="black"><text id="kity_text_15100" text-rendering="inherit" font-size="12" dy=".8em" y="30975.700000047684" x="563.5">1.抽象类制作模板实现共同的步骤，让子类根据需要重写抽象类的行为</text><text id="kity_text_15101" text-rendering="inherit" font-size="12" dy=".8em" y="30993.700000047684" x="563.5">优点：使用继承来实现代码复用， 一些方法通用，却在每一个子类都重新写了这一方法；缺点：需要为每一个基本方法的不同实现提供一个子类，系统庞大</text></g></g><g id="minder_node2750" display="none"><g id="node_expander2745" display="none" style="cursor: pointer;"><path id="kity_path_28757" fill="white" stroke="gray" d="M579.5,30992.5A6,6,0,1,1,567.5,30992.5A6,6,0,1,1,579.5,30992.5"></path><path id="kity_path_28758" fill="none" stroke="gray"></path></g><path id="node_outline2746" fill="none" stroke="none" d="M579.5,30983.5h333a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2746" fill="black"><text id="kity_text_15098" text-rendering="inherit" font-size="12" dy=".8em" y="30984.700000047684" x="579.5">https://juejin.cn/post/6844903822297415687#heading-79</text></g></g><g id="minder_node2751" display="none"><g id="node_expander2749" display="none" style="cursor: pointer;"><path id="kity_path_28769" fill="white" stroke="gray" d="M547.5,31000.5A6,6,0,1,1,535.5,31000.5A6,6,0,1,1,547.5,31000.5"></path><path id="kity_path_28770" fill="none" stroke="gray"></path></g><path id="node_outline2750" fill="none" stroke="none" d="M547.5,30991.5h62a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-62a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2750" fill="black"><text id="kity_text_15109" text-rendering="inherit" font-size="12" dy=".8em" y="30992.700000047684" x="547.5">观察者模式</text></g></g><g id="minder_node2752" display="none"><g id="node_expander2748" display="none" style="cursor: pointer;"><path id="kity_path_28766" fill="white" stroke="gray" d="M563.5,31000.5A6,6,0,1,1,551.5,31000.5A6,6,0,1,1,563.5,31000.5"></path><path id="kity_path_28767" fill="none" stroke="gray"></path></g><path id="node_outline2749" fill="none" stroke="none" d="M563.5,30973.5h673a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-673a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2749" fill="black"><text id="kity_text_15105" text-rendering="inherit" font-size="12" dy=".8em" y="30974.700000047684" x="563.5">1.当对象间存在一对多关系时 ；当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。进行广播通知。</text><text id="kity_text_15106" text-rendering="inherit" font-size="12" dy=".8em" y="30992.700000047684" x="563.5">比如：拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。</text><text id="kity_text_15107" text-rendering="inherit" font-size="12" dy=".8em" y="31010.700000047684" x="563.5">优点：观察者和被观察者是抽象耦合的。 缺点：所有的观察者都通知到会花费很多时间。如果循环调用，可能导致系统崩溃。</text></g></g><g id="minder_node2753" display="none"><g id="node_expander2750" display="none" style="cursor: pointer;"><path id="kity_path_28772" fill="white" stroke="gray" d="M547.5,31008.5A6,6,0,1,1,535.5,31008.5A6,6,0,1,1,547.5,31008.5"></path><path id="kity_path_28773" fill="none" stroke="gray"></path></g><path id="node_outline2751" fill="none" stroke="none" d="M547.5,30999.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2751" fill="black"><text id="kity_text_15111" text-rendering="inherit" font-size="12" dy=".8em" y="31000.700000047684" x="547.5">命令模式</text></g></g><g id="minder_node2754" display="none"><g id="node_expander2751" display="none" style="cursor: pointer;"><path id="kity_path_28775" fill="white" stroke="gray" d="M547.5,31016.5A6,6,0,1,1,535.5,31016.5A6,6,0,1,1,547.5,31016.5"></path><path id="kity_path_28776" fill="none" stroke="gray"></path></g><path id="node_outline2752" fill="none" stroke="none" d="M547.5,31007.5h62a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-62a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2752" fill="black"><text id="kity_text_15113" text-rendering="inherit" font-size="12" dy=".8em" y="31008.700000047684" x="547.5">迭代器模式</text></g></g><g id="minder_node2755" display="none"><g id="node_expander2752" display="none" style="cursor: pointer;"><path id="kity_path_28778" fill="white" stroke="gray" d="M547.5,31024.5A6,6,0,1,1,535.5,31024.5A6,6,0,1,1,547.5,31024.5"></path><path id="kity_path_28779" fill="none" stroke="gray"></path></g><path id="node_outline2753" fill="none" stroke="none" d="M547.5,31015.5h61a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-61a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2753" fill="black"><text id="kity_text_15115" text-rendering="inherit" font-size="12" dy=".8em" y="31016.700000047684" x="547.5">中介者模式</text></g></g><g id="minder_node2756" display="none"><g id="node_expander2753" display="none" style="cursor: pointer;"><path id="kity_path_28781" fill="white" stroke="gray" d="M547.5,31032.5A6,6,0,1,1,535.5,31032.5A6,6,0,1,1,547.5,31032.5"></path><path id="kity_path_28782" fill="none" stroke="gray"></path></g><path id="node_outline2754" fill="none" stroke="none" d="M547.5,31023.5h62a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-62a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2754" fill="black"><text id="kity_text_15117" text-rendering="inherit" font-size="12" dy=".8em" y="31024.700000047684" x="547.5">备忘录模式</text></g></g><g id="minder_node2757" display="none"><g id="node_expander2754" display="none" style="cursor: pointer;"><path id="kity_path_28784" fill="white" stroke="gray" d="M547.5,31040.5A6,6,0,1,1,535.5,31040.5A6,6,0,1,1,547.5,31040.5"></path><path id="kity_path_28785" fill="none" stroke="gray"></path></g><path id="node_outline2755" fill="none" stroke="none" d="M547.5,31031.5h62a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-62a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2755" fill="black"><text id="kity_text_15119" text-rendering="inherit" font-size="12" dy=".8em" y="31032.700000047684" x="547.5">解释器模式</text></g></g><g id="minder_node2758" display="none"><g id="node_expander2755" display="none" style="cursor: pointer;"><path id="kity_path_28787" fill="white" stroke="gray" d="M547.5,31048.5A6,6,0,1,1,535.5,31048.5A6,6,0,1,1,547.5,31048.5"></path><path id="kity_path_28788" fill="none" stroke="gray"></path></g><path id="node_outline2756" fill="none" stroke="none" d="M547.5,31039.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2756" fill="black"><text id="kity_text_15121" text-rendering="inherit" font-size="12" dy=".8em" y="31040.700000047684" x="547.5">状态模式</text></g></g><g id="minder_node2759" display="none"><g id="node_expander2757" display="none" style="cursor: pointer;"><path id="kity_path_28793" fill="white" stroke="gray" d="M547.5,31056.5A6,6,0,1,1,535.5,31056.5A6,6,0,1,1,547.5,31056.5"></path><path id="kity_path_28794" fill="none" stroke="gray"></path></g><path id="node_outline2758" fill="none" stroke="none" d="M547.5,31047.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2758" fill="black"><text id="kity_text_15127" text-rendering="inherit" font-size="12" dy=".8em" y="31048.700000047684" x="547.5">策略模式</text></g></g><g id="minder_node2760" display="none"><g id="node_expander2756" display="none" style="cursor: pointer;"><path id="kity_path_28790" fill="white" stroke="gray" d="M563.5,31056.5A6,6,0,1,1,551.5,31056.5A6,6,0,1,1,563.5,31056.5"></path><path id="kity_path_28791" fill="none" stroke="gray"></path></g><path id="node_outline2757" fill="none" stroke="none" d="M563.5,31029.5h657a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-657a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2757" fill="black"><text id="kity_text_15123" text-rendering="inherit" font-size="12" dy=".8em" y="31030.700000047684" x="563.5">1.创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。比如解决 if...else 所带来的复杂和难以维护</text><text id="kity_text_15124" text-rendering="inherit" font-size="12" dy=".8em" y="31048.700000047684" x="563.5">比如：旅行的出游方式，选择骑自行车. 坐汽车，每一种旅行方式都是一个策略。</text><text id="kity_text_15125" text-rendering="inherit" font-size="12" dy=".8em" y="31066.700000047684" x="563.5">优点：扩展性良好；避免使用多重条件判断。。缺点：策略类会增多，所有策略类都需要对外暴露。</text></g></g><g id="minder_node2761" display="none"><g id="node_expander2758" display="none" style="cursor: pointer;"><path id="kity_path_28796" fill="white" stroke="gray" d="M547.5,31064.5A6,6,0,1,1,535.5,31064.5A6,6,0,1,1,547.5,31064.5"></path><path id="kity_path_28797" fill="none" stroke="gray"></path></g><path id="node_outline2759" fill="none" stroke="none" d="M547.5,31055.5h62a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-62a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2759" fill="black"><text id="kity_text_15129" text-rendering="inherit" font-size="12" dy=".8em" y="31056.700000047684" x="547.5">责任链模式</text></g></g><g id="minder_node2762" display="none"><g id="node_expander2759" display="none" style="cursor: pointer;"><path id="kity_path_28799" fill="white" stroke="gray" d="M547.5,31072.5A6,6,0,1,1,535.5,31072.5A6,6,0,1,1,547.5,31072.5"></path><path id="kity_path_28800" fill="none" stroke="gray"></path></g><path id="node_outline2760" fill="none" stroke="none" d="M547.5,31063.5h61a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-61a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2760" fill="black"><text id="kity_text_15131" text-rendering="inherit" font-size="12" dy=".8em" y="31064.700000047684" x="547.5">访问者模式</text></g></g><g id="minder_node2763" display="none"><g id="node_expander2762" display="none" style="cursor: pointer;"><path id="kity_path_28808" fill="white" stroke="gray" d="M531.5,31080.5A6,6,0,1,1,519.5,31080.5A6,6,0,1,1,531.5,31080.5"></path><path id="kity_path_28809" fill="none" stroke="gray"></path></g><path id="node_outline2763" fill="none" stroke="none" d="M531.5,31071.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2763" fill="black"><text id="kity_text_15139" text-rendering="inherit" font-size="12" dy=".8em" y="31072.700000047684" x="531.5">参考文章</text></g></g><g id="minder_node2764" display="none"><g id="node_expander2761" display="none" style="cursor: pointer;"><path id="kity_path_28805" fill="white" stroke="gray" d="M547.5,31080.5A6,6,0,1,1,535.5,31080.5A6,6,0,1,1,547.5,31080.5"></path><path id="kity_path_28806" fill="none" stroke="gray"></path></g><path id="node_outline2762" fill="none" stroke="none" d="M547.5,31053.5h343a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-343a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2762" fill="black"><text id="kity_text_15135" text-rendering="inherit" font-size="12" dy=".8em" y="31054.700000047684" x="547.5">1.https://juejin.cn/post/6844903961980321800#heading-18</text><text id="kity_text_15136" text-rendering="inherit" font-size="12" dy=".8em" y="31072.700000047684" x="547.5">2.https://juejin.cn/post/6844903795017646094#heading-43</text><text id="kity_text_15137" text-rendering="inherit" font-size="12" dy=".8em" y="31090.700000047684" x="547.5">3.https://juejin.cn/post/6844903822297415687#heading-77</text></g></g><g id="minder_node2765"><g id="node_expander2831" style="cursor: pointer;"><path id="kity_path_29015" fill="white" stroke="gray" d="M397.5,31122.5A6,6,0,1,1,385.5,31122.5A6,6,0,1,1,397.5,31122.5"></path><path id="kity_path_29016" fill="none" stroke="gray" d="M387,31122.5L396,31122.5M391.5,31118L391.5,31127"></path></g><path id="node_outline2832" fill="rgb(239, 238, 246)" stroke="rgb(123, 115, 191)" d="M401.5,31109.5h92a3,3,0,0,1,3,3v20a3,3,0,0,1,-3,3h-92a3,3,0,0,1,-3,-3v-20a3,3,0,0,1,3,-3z" stroke-width="1"></path><g id="node_text2832" fill="black"><text id="kity_text_15318" text-rendering="inherit" font-size="14" dy=".8em" y="31113.400000095367" x="418.5">11.nginx</text></g></g><g id="minder_node2766" display="none"><g id="node_expander2807" display="none" style="cursor: pointer;"><path id="kity_path_28943" fill="white" stroke="gray" d="M512.5,31090.5A6,6,0,1,1,500.5,31090.5A6,6,0,1,1,512.5,31090.5"></path><path id="kity_path_28944" fill="none" stroke="gray"></path></g><path id="node_outline2808" fill="none" stroke="none" d="M512.5,31081.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2808" fill="black"><text id="kity_text_15255" text-rendering="inherit" font-size="12" dy=".8em" y="31082.700000047684" x="512.5">基础</text></g></g><g id="minder_node2767" display="none"><g id="node_expander2764" display="none" style="cursor: pointer;"><path id="kity_path_28814" fill="white" stroke="gray" d="M528.5,30946.5A6,6,0,1,1,516.5,30946.5A6,6,0,1,1,528.5,30946.5"></path><path id="kity_path_28815" fill="none" stroke="gray"></path></g><path id="node_outline2765" fill="none" stroke="none" d="M528.5,30937.5h58a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-58a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2765" fill="black"><text id="kity_text_15143" text-rendering="inherit" font-size="12" dy=".8em" y="30938.700000047684" x="528.5">说说nginx</text></g></g><g id="minder_node2768" display="none"><g id="node_expander2766" display="none" style="cursor: pointer;"><path id="kity_path_28820" fill="white" stroke="gray" d="M528.5,30954.5A6,6,0,1,1,516.5,30954.5A6,6,0,1,1,528.5,30954.5"></path><path id="kity_path_28821" fill="none" stroke="gray"></path></g><path id="node_outline2767" fill="none" stroke="none" d="M528.5,30945.5h184a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-184a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2767" fill="black"><text id="kity_text_15149" text-rendering="inherit" font-size="12" dy=".8em" y="30946.700000047684" x="528.5">nginx和tomcat有什么区别 知道吗</text></g></g><g id="minder_node2769" display="none"><g id="node_expander2765" display="none" style="cursor: pointer;"><path id="kity_path_28817" fill="white" stroke="gray" d="M544.5,30954.5A6,6,0,1,1,532.5,30954.5A6,6,0,1,1,544.5,30954.5"></path><path id="kity_path_28818" fill="none" stroke="gray"></path></g><path id="node_outline2766" fill="none" stroke="none" d="M544.5,30927.5h731a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-731a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2766" fill="black"><text id="kity_text_15145" text-rendering="inherit" font-size="12" dy=".8em" y="30928.700000047684" x="544.5">1.nginx 主要是做http server，比如说做反向代理，客户端请求nginx nginx去请求应用服务器（tomcat）， 然后nginx把结果再返回</text><text id="kity_text_15146" text-rendering="inherit" font-size="12" dy=".8em" y="30946.700000047684" x="544.5">2.tomcat是做应用服务器，首先要有支持的语言 比如说java的应用可以在上面跑，而 python 就不可以</text><text id="kity_text_15147" text-rendering="inherit" font-size="12" dy=".8em" y="30964.700000047684" x="544.5">3.一般nginx和tomcat 来做动静分离，tomcat来处理动态请求，nginx的并发能力比较强，一般可以nginx + cdn网络分担高并发集群压力</text></g></g><g id="minder_node2770" display="none"><g id="node_expander2769" display="none" style="cursor: pointer;"><path id="kity_path_28829" fill="white" stroke="gray" d="M528.5,30962.5A6,6,0,1,1,516.5,30962.5A6,6,0,1,1,528.5,30962.5"></path><path id="kity_path_28830" fill="none" stroke="gray"></path></g><path id="node_outline2770" fill="none" stroke="none" d="M528.5,30953.5h128a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-128a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2770" fill="black"><text id="kity_text_15159" text-rendering="inherit" font-size="12" dy=".8em" y="30954.700000047684" x="528.5">nginx有什么优点知道吗</text></g></g><g id="minder_node2771" display="none"><g id="node_expander2768" display="none" style="cursor: pointer;"><path id="kity_path_28826" fill="white" stroke="gray" d="M544.5,30962.5A6,6,0,1,1,532.5,30962.5A6,6,0,1,1,544.5,30962.5"></path><path id="kity_path_28827" fill="none" stroke="gray"></path></g><path id="node_outline2769" fill="none" stroke="none" d="M544.5,30917.5h843a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-843a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text2769" fill="black"><text id="kity_text_15153" text-rendering="inherit" font-size="12" dy=".8em" y="30918.700000047684" x="544.5">1.配置简单，配置文件模块化，扩展好。</text><text id="kity_text_15154" text-rendering="inherit" font-size="12" dy=".8em" y="30936.700000047684" x="544.5">2.高可靠性：用于反向代理，5个9 宕机率。每个worker进程相对独立，master进程在一个worder进程出错时可以快速”拉起“新的workder子进程提供服务。</text><text id="kity_text_15155" text-rendering="inherit" font-size="12" dy=".8em" y="30954.700000047684" x="544.5">3.低内存消耗 ，10000个非活跃的HTTP Keep-Alive连接在Nginx中仅消耗2.5MB的内存</text><text id="kity_text_15156" text-rendering="inherit" font-size="12" dy=".8em" y="30972.700000047684" x="544.5">4.单机支持10万以上的并发连接</text><text id="kity_text_15157" text-rendering="inherit" font-size="12" dy=".8em" y="30990.700000047684" x="544.5">5.源代码开发，节省宽带：支持GZIP压缩，可以添加浏览器本地缓存</text></g></g><g id="minder_node2772" display="none"><g id="node_expander2767" display="none" style="cursor: pointer;"><path id="kity_path_28823" fill="white" stroke="gray" d="M560.5,30962.5A6,6,0,1,1,548.5,30962.5A6,6,0,1,1,560.5,30962.5"></path><path id="kity_path_28824" fill="none" stroke="gray"></path></g><path id="node_outline2768" fill="none" stroke="none" d="M560.5,30953.5h326a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2768" fill="black"><text id="kity_text_15151" text-rendering="inherit" font-size="12" dy=".8em" y="30954.700000047684" x="560.5">https://juejin.cn/post/6844904125784653837#heading-1</text></g></g><g id="minder_node2773" display="none"><g id="node_expander2771" display="none" style="cursor: pointer;"><path id="kity_path_28835" fill="white" stroke="gray" d="M528.5,30970.5A6,6,0,1,1,516.5,30970.5A6,6,0,1,1,528.5,30970.5"></path><path id="kity_path_28836" fill="none" stroke="gray"></path></g><path id="node_outline2772" fill="none" stroke="none" d="M528.5,30961.5h130a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-130a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2772" fill="black"><text id="kity_text_15164" text-rendering="inherit" font-size="12" dy=".8em" y="30962.700000047684" x="528.5">用nginx可以来解决什么</text></g></g><g id="minder_node2774" display="none"><g id="node_expander2770" display="none" style="cursor: pointer;"><path id="kity_path_28832" fill="white" stroke="gray" d="M544.5,30970.5A6,6,0,1,1,532.5,30970.5A6,6,0,1,1,544.5,30970.5"></path><path id="kity_path_28833" fill="none" stroke="gray"></path></g><path id="node_outline2771" fill="none" stroke="none" d="M544.5,30952.5h179a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-179a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2771" fill="black"><text id="kity_text_15161" text-rendering="inherit" font-size="12" dy=".8em" y="30953.700000047684" x="544.5">1.反向代理，L7负载均衡</text><text id="kity_text_15162" text-rendering="inherit" font-size="12" dy=".8em" y="30971.700000047684" x="544.5">2.流控，过滤器，http静态服务器</text></g></g><g id="minder_node2775" display="none"><g id="node_expander2774" display="none" style="cursor: pointer;"><path id="kity_path_28844" fill="white" stroke="gray" d="M528.5,30978.5A6,6,0,1,1,516.5,30978.5A6,6,0,1,1,528.5,30978.5"></path><path id="kity_path_28845" fill="none" stroke="gray"></path></g><path id="node_outline2775" fill="none" stroke="none" d="M528.5,30960.5h181a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-181a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2775" fill="black"><text id="kity_text_15171" text-rendering="inherit" font-size="12" dy=".8em" y="30961.700000047684" x="528.5">nginx是怎么处理一个https请求的</text><text id="kity_text_15172" text-rendering="inherit" font-size="12" dy=".8em" y="30979.700000047684" x="528.5">(https怎么访问http)</text></g></g><g id="minder_node2776" display="none"><g id="node_expander2773" display="none" style="cursor: pointer;"><path id="kity_path_28841" fill="white" stroke="gray" d="M544.5,30978.5A6,6,0,1,1,532.5,30978.5A6,6,0,1,1,544.5,30978.5"></path><path id="kity_path_28842" fill="none" stroke="gray"></path></g><path id="node_outline2774" fill="none" stroke="none" d="M544.5,30960.5h1015a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1015a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2774" fill="black"><text id="kity_text_15168" text-rendering="inherit" font-size="12" dy=".8em" y="30961.700000047684" x="544.5">1.https 443端口 http 80端口，首先会根据host去匹配，如果匹配到了 就去匹配的项目上请求，如果没有匹配，就去默认的服务请求，也就是 server下的default_server;默认是它的默认服务。</text><text id="kity_text_15169" text-rendering="inherit" font-size="12" dy=".8em" y="30979.700000047684" x="544.5">2.https来的时侯也是这样，如果我们是要把http请求重定向为https 通过server中重定向就可以实现，</text></g></g><g id="minder_node2777" display="none"><g id="node_expander2772" display="none" style="cursor: pointer;"><path id="kity_path_28838" fill="white" stroke="gray" d="M560.5,30978.5A6,6,0,1,1,548.5,30978.5A6,6,0,1,1,560.5,30978.5"></path><path id="kity_path_28839" fill="none" stroke="gray"></path></g><path id="node_outline2773" fill="none" stroke="none" d="M560.5,30969.5h354a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-354a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2773" fill="black"><text id="kity_text_15166" text-rendering="inherit" font-size="12" dy=".8em" y="30970.700000047684" x="560.5">https://www.cnblogs.com/howtobuildjenkins/p/6904997.html</text></g></g><g id="minder_node2778" display="none"><g id="node_expander2777" display="none" style="cursor: pointer;"><path id="kity_path_28853" fill="white" stroke="gray" d="M528.5,30986.5A6,6,0,1,1,516.5,30986.5A6,6,0,1,1,528.5,30986.5"></path><path id="kity_path_28854" fill="none" stroke="gray"></path></g><path id="node_outline2778" fill="none" stroke="none" d="M528.5,30977.5h140a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-140a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2778" fill="black"><text id="kity_text_15183" text-rendering="inherit" font-size="12" dy=".8em" y="30978.700000047684" x="528.5">nginx是怎么处理请求的？</text></g></g><g id="minder_node2779" display="none"><g id="node_expander2776" display="none" style="cursor: pointer;"><path id="kity_path_28850" fill="white" stroke="gray" d="M544.5,30986.5A6,6,0,1,1,532.5,30986.5A6,6,0,1,1,544.5,30986.5"></path><path id="kity_path_28851" fill="none" stroke="gray"></path></g><path id="node_outline2777" fill="none" stroke="none" d="M544.5,30932.5h896a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-896a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text2777" fill="black"><text id="kity_text_15176" text-rendering="inherit" font-size="12" dy=".8em" y="30933.700000047684" x="544.5">1.首先匹配server中的listen模块 和 server_name模块，再匹配 location，location就是实际地址，然后后面可能就是网关了&#xa0;</text><text id="kity_text_15177" text-rendering="inherit" font-size="12" dy=".8em" y="30951.700000047684" x="544.5">2.多进程机制和异步机制</text><text id="kity_text_15178" text-rendering="inherit" font-size="12" dy=".8em" y="30969.700000047684" x="544.5">多进程机制：主进程生成一个子进程出来和客户端建立连接处理请求，直到连接断开，子进程也就结束。</text><text id="kity_text_15179" text-rendering="inherit" font-size="12" dy=".8em" y="30987.700000047684" x="544.5">3.异步非阻塞机制：每个worker使用异步非阻塞方式，可以处理多个客户端请求。</text><text id="kity_text_15180" text-rendering="inherit" font-size="12" dy=".8em" y="31005.700000047684" x="544.5">（1）当某个工作进程接收到客户端的请求后，调用IO进行处理，如果不能立即得到结果，就去处理其他请求，而客户端在此期间也无需等待响应，可以去处理其他事情。</text><text id="kity_text_15181" text-rendering="inherit" font-size="12" dy=".8em" y="31023.700000047684" x="544.5">（2）当IO返回时，就会通知此工作进程；该进程得到通知，暂时挂起，当前处理的事物去响应客户端请求。</text></g></g><g id="minder_node2780" display="none"><g id="node_expander2775" display="none" style="cursor: pointer;"><path id="kity_path_28847" fill="white" stroke="gray" d="M560.5,30986.5A6,6,0,1,1,548.5,30986.5A6,6,0,1,1,560.5,30986.5"></path><path id="kity_path_28848" fill="none" stroke="gray"></path></g><path id="node_outline2776" fill="none" stroke="none" d="M560.5,30977.5h326a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2776" fill="black"><text id="kity_text_15174" text-rendering="inherit" font-size="12" dy=".8em" y="30978.700000047684" x="560.5">https://juejin.cn/post/6844904125784653837#heading-3</text></g></g><g id="minder_node2781" display="none"><g id="node_expander2780" display="none" style="cursor: pointer;"><path id="kity_path_28862" fill="white" stroke="gray" d="M528.5,30994.5A6,6,0,1,1,516.5,30994.5A6,6,0,1,1,528.5,30994.5"></path><path id="kity_path_28863" fill="none" stroke="gray"></path></g><path id="node_outline2781" fill="none" stroke="none" d="M528.5,30985.5h182a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-182a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2781" fill="black"><text id="kity_text_15190" text-rendering="inherit" font-size="12" dy=".8em" y="30986.700000047684" x="528.5">什么是正向代理，什么是反向代理</text></g></g><g id="minder_node2782" display="none"><g id="node_expander2779" display="none" style="cursor: pointer;"><path id="kity_path_28859" fill="white" stroke="gray" d="M544.5,30994.5A6,6,0,1,1,532.5,30994.5A6,6,0,1,1,544.5,30994.5"></path><path id="kity_path_28860" fill="none" stroke="gray"></path></g><path id="node_outline2780" fill="none" stroke="none" d="M544.5,30976.5h708a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-708a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2780" fill="black"><text id="kity_text_15187" text-rendering="inherit" font-size="12" dy=".8em" y="30977.700000047684" x="544.5">1.正向代理，发生在客户端，我作为服务端 不知道谁访问我，相当于你翻墙一样&#xa0;</text><text id="kity_text_15188" text-rendering="inherit" font-size="12" dy=".8em" y="30995.700000047684" x="544.5">2.反向代理，发生在服务端，我作为客户端，我不知道访问了谁，相当于 你访问www.baidu.com 一样，你不知道你访问哪一台server</text></g></g><g id="minder_node2783" display="none"><g id="node_expander2778" display="none" style="cursor: pointer;"><path id="kity_path_28856" fill="white" stroke="gray" d="M560.5,30994.5A6,6,0,1,1,548.5,30994.5A6,6,0,1,1,560.5,30994.5"></path><path id="kity_path_28857" fill="none" stroke="gray"></path></g><path id="node_outline2779" fill="none" stroke="none" d="M506.5,30780.5h158a5,5,0,0,1,5,5v213a5,5,0,0,1,-5,5h-158a5,5,0,0,1,-5,-5v-213a5,5,0,0,1,5,-5z"></path><g id="node_text2779" fill="black"><text id="kity_text_15185" text-rendering="inherit" font-size="12" dy=".8em" y="30986.700000047684" x="560.5">分支主题</text></g><image id="kity_image_17093" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/ec6879c3311a3b83a13b81645cf0849.jpg" x="506.5" y="30783.5" width="158" height="200"></image></g><g id="minder_node2784" display="none"><g id="node_expander2782" display="none" style="cursor: pointer;"><path id="kity_path_28868" fill="white" stroke="gray" d="M528.5,31002.5A6,6,0,1,1,516.5,31002.5A6,6,0,1,1,528.5,31002.5"></path><path id="kity_path_28869" fill="none" stroke="gray"></path></g><path id="node_outline2783" fill="none" stroke="none" d="M528.5,30993.5h182a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-182a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2783" fill="black"><text id="kity_text_15194" text-rendering="inherit" font-size="12" dy=".8em" y="30994.700000047684" x="528.5">使用反向代理服务器的优点有什么</text></g></g><g id="minder_node2785" display="none"><g id="node_expander2781" display="none" style="cursor: pointer;"><path id="kity_path_28865" fill="white" stroke="gray" d="M544.5,31002.5A6,6,0,1,1,532.5,31002.5A6,6,0,1,1,544.5,31002.5"></path><path id="kity_path_28866" fill="none" stroke="gray"></path></g><path id="node_outline2782" fill="none" stroke="none" d="M544.5,30993.5h670a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-670a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2782" fill="black"><text id="kity_text_15192" text-rendering="inherit" font-size="12" dy=".8em" y="30994.700000047684" x="544.5">1.可以隐藏源服务器的存在和特征。客户端的请求来都是交给我们代理服务器来处理，客户端是不知道我们后续具体怎么处理。</text></g></g><g id="minder_node2786" display="none"><g id="node_expander2784" display="none" style="cursor: pointer;"><path id="kity_path_28874" fill="white" stroke="gray" d="M528.5,31010.5A6,6,0,1,1,516.5,31010.5A6,6,0,1,1,528.5,31010.5"></path><path id="kity_path_28875" fill="none" stroke="gray"></path></g><path id="node_outline2785" fill="none" stroke="none" d="M528.5,31001.5h311a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-311a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2785" fill="black"><text id="kity_text_15199" text-rendering="inherit" font-size="12" dy=".8em" y="31002.700000047684" x="528.5">在Nginx中，如何用未定义的服务器名称来阻止处理请求？</text></g></g><g id="minder_node2787" display="none"><g id="node_expander2783" display="none" style="cursor: pointer;"><path id="kity_path_28871" fill="white" stroke="gray" d="M544.5,31010.5A6,6,0,1,1,532.5,31010.5A6,6,0,1,1,544.5,31010.5"></path><path id="kity_path_28872" fill="none" stroke="gray"></path></g><path id="node_outline2784" fill="none" stroke="none" d="M544.5,30992.5h761a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-761a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2784" fill="black"><text id="kity_text_15196" text-rendering="inherit" font-size="12" dy=".8em" y="30993.700000047684" x="544.5">1.服务器名称保留为一个空字符串，它将在没有“主机”头字段的情况下匹配请求，而一个特殊的Nginx的非标准代码444返回，从而终止连接。</text><text id="kity_text_15197" text-rendering="inherit" font-size="12" dy=".8em" y="31011.700000047684" x="544.5">2.Server {    listen 80;    server_name "";    return 444;}</text></g></g><g id="minder_node2788" display="none"><g id="node_expander2786" display="none" style="cursor: pointer;"><path id="kity_path_28880" fill="white" stroke="gray" d="M528.5,31018.5A6,6,0,1,1,516.5,31018.5A6,6,0,1,1,528.5,31018.5"></path><path id="kity_path_28881" fill="none" stroke="gray"></path></g><path id="node_outline2787" fill="none" stroke="none" d="M528.5,31009.5h110a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-110a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2787" fill="black"><text id="kity_text_15208" text-rendering="inherit" font-size="12" dy=".8em" y="31010.700000047684" x="528.5">负载均衡策略有哪些</text></g></g><g id="minder_node2789" display="none"><g id="node_expander2785" display="none" style="cursor: pointer;"><path id="kity_path_28877" fill="white" stroke="gray" d="M544.5,31018.5A6,6,0,1,1,532.5,31018.5A6,6,0,1,1,544.5,31018.5"></path><path id="kity_path_28878" fill="none" stroke="gray"></path></g><path id="node_outline2786" fill="none" stroke="none" d="M544.5,30964.5h710a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-710a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text2786" fill="black"><text id="kity_text_15201" text-rendering="inherit" font-size="12" dy=".8em" y="30965.700000047684" x="544.5">轮询，权重，最小连接时间，ip绑定；</text><text id="kity_text_15202" text-rendering="inherit" font-size="12" dy=".8em" y="30983.700000047684" x="544.5">1.默认轮询；在upstream 中配置。如果后端某个服务器宕机，能自动剔除故障系统。</text><text id="kity_text_15203" text-rendering="inherit" font-size="12" dy=".8em" y="31001.700000047684" x="544.5">2.权重；权重大的访问概率越高，主要用于后端每台服务器性能不均衡的情况下</text><text id="kity_text_15204" text-rendering="inherit" font-size="12" dy=".8em" y="31019.700000047684" x="544.5">3.ip_hash( IP绑定)；请求按访问的ip hash后分配，可以解决同一个IP的访客固定访问一台后端服务器，还可以解决动态页面的session</text><text id="kity_text_15205" text-rendering="inherit" font-size="12" dy=".8em" y="31037.700000047684" x="544.5">4.fair(插件-智能算法) 根据页面大小和加载时间长短智能地进行负载均衡，响应时间短的优先分配。</text><text id="kity_text_15206" text-rendering="inherit" font-size="12" dy=".8em" y="31055.700000047684" x="544.5">5.url_hash(插件)；根据访问url的hash结果来分配请求，使每个url定向到同一个后端服务器</text></g></g><g id="minder_node2790" display="none"><g id="node_expander2788" display="none" style="cursor: pointer;"><path id="kity_path_28886" fill="white" stroke="gray" d="M528.5,31026.5A6,6,0,1,1,516.5,31026.5A6,6,0,1,1,528.5,31026.5"></path><path id="kity_path_28887" fill="none" stroke="gray"></path></g><path id="node_outline2789" fill="none" stroke="none" d="M528.5,31017.5h173a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-173a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2789" fill="black"><text id="kity_text_15212" text-rendering="inherit" font-size="12" dy=".8em" y="31018.700000047684" x="528.5">负载均衡有哪些算法实现 知道吗</text></g></g><g id="minder_node2791" display="none"><g id="node_expander2787" display="none" style="cursor: pointer;"><path id="kity_path_28883" fill="white" stroke="gray" d="M544.5,31026.5A6,6,0,1,1,532.5,31026.5A6,6,0,1,1,544.5,31026.5"></path><path id="kity_path_28884" fill="none" stroke="gray"></path></g><path id="node_outline2788" fill="none" stroke="none" d="M544.5,31017.5h34a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-34a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2788" fill="black"><text id="kity_text_15210" text-rendering="inherit" font-size="12" dy=".8em" y="31018.700000047684" x="544.5">1.同上</text></g></g><g id="minder_node2792" display="none"><g id="node_expander2790" display="none" style="cursor: pointer;"><path id="kity_path_28892" fill="white" stroke="gray" d="M528.5,31034.5A6,6,0,1,1,516.5,31034.5A6,6,0,1,1,528.5,31034.5"></path><path id="kity_path_28893" fill="none" stroke="gray"></path></g><path id="node_outline2791" fill="none" stroke="none" d="M528.5,31025.5h213a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-213a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2791" fill="black"><text id="kity_text_15216" text-rendering="inherit" font-size="12" dy=".8em" y="31026.700000047684" x="528.5">你们是怎么使用负载均衡的(方面和场景)</text></g></g><g id="minder_node2793" display="none"><g id="node_expander2789" display="none" style="cursor: pointer;"><path id="kity_path_28889" fill="white" stroke="gray" d="M544.5,31034.5A6,6,0,1,1,532.5,31034.5A6,6,0,1,1,544.5,31034.5"></path><path id="kity_path_28890" fill="none" stroke="gray"></path></g><path id="node_outline2790" fill="none" stroke="none" d="M544.5,31025.5h1030a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1030a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2790" fill="black"><text id="kity_text_15214" text-rendering="inherit" font-size="12" dy=".8em" y="31026.700000047684" x="544.5">1.为了避免服务器崩溃，大家会通过负载均衡的方式来分担服务器压力。将对台服务器组成一个集群，当用户访问时，先访问到一个转发服务器，再由转发服务器将访问分发到压力更小的服务器。</text></g></g><g id="minder_node2794" display="none"><g id="node_expander2793" display="none" style="cursor: pointer;"><path id="kity_path_28901" fill="white" stroke="gray" d="M528.5,31042.5A6,6,0,1,1,516.5,31042.5A6,6,0,1,1,528.5,31042.5"></path><path id="kity_path_28902" fill="none" stroke="gray"></path></g><path id="node_outline2794" fill="none" stroke="none" d="M528.5,31033.5h141a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-141a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2794" fill="black"><text id="kity_text_15222" text-rendering="inherit" font-size="12" dy=".8em" y="31034.700000047684" x="528.5">知道nginx负载均衡配置吗</text></g></g><g id="minder_node2795" display="none"><g id="node_expander2792" display="none" style="cursor: pointer;"><path id="kity_path_28898" fill="white" stroke="gray" d="M544.5,31042.5A6,6,0,1,1,532.5,31042.5A6,6,0,1,1,544.5,31042.5"></path><path id="kity_path_28899" fill="none" stroke="gray"></path></g><path id="node_outline2793" fill="none" stroke="none" d="M544.5,31033.5h124a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-124a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2793" fill="black"><text id="kity_text_15220" text-rendering="inherit" font-size="12" dy=".8em" y="31034.700000047684" x="544.5">1.1upstream 模块配置</text></g></g><g id="minder_node2796" display="none"><g id="node_expander2791" display="none" style="cursor: pointer;"><path id="kity_path_28895" fill="white" stroke="gray" d="M560.5,31042.5A6,6,0,1,1,548.5,31042.5A6,6,0,1,1,560.5,31042.5"></path><path id="kity_path_28896" fill="none" stroke="gray"></path></g><path id="node_outline2792" fill="none" stroke="none" d="M560.5,31031.5h46a5,5,0,0,1,5,5v13a5,5,0,0,1,-5,5h-46a5,5,0,0,1,-5,-5v-13a5,5,0,0,1,5,-5z"></path><g id="node_text2792" fill="black"><text id="kity_text_15218" text-rendering="inherit" font-size="12" dy=".8em" y="31034.700000047684" x="560.5">配置</text></g><g id="kity_g_17006" style="cursor: pointer;"><path id="kity_path_17007" fill="none" stroke="none" d="M593,31034h12a2,2,0,0,1,2,2v13a2,2,0,0,1,-2,2h-12a2,2,0,0,1,-2,-2v-13a2,2,0,0,1,2,-2z"></path><path id="kity_path_17008" fill="black" stroke="none" d="M602,31045H596V31044h6L602,31045L602,31045zM602,31043H596V31042h6V31043zM602,31041H596V31040h6V31041zM601.5,31047H595V31038h8v7.5M602,31048l2,-2V31037H594v11"></path></g></g><g id="minder_node2797" display="none"><g id="node_expander2794" display="none" style="cursor: pointer;"><path id="kity_path_28904" fill="white" stroke="gray" d="M528.5,31050.5A6,6,0,1,1,516.5,31050.5A6,6,0,1,1,528.5,31050.5"></path><path id="kity_path_28905" fill="none" stroke="gray"></path></g><path id="node_outline2795" fill="none" stroke="none" d="M528.5,31041.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2795" fill="black"><text id="kity_text_15224" text-rendering="inherit" font-size="12" dy=".8em" y="31042.700000047684" x="528.5">轮询和随机的缺点；</text></g></g><g id="minder_node2798" display="none"><g id="node_expander2797" display="none" style="cursor: pointer;"><path id="kity_path_28913" fill="white" stroke="gray" d="M528.5,31058.5A6,6,0,1,1,516.5,31058.5A6,6,0,1,1,528.5,31058.5"></path><path id="kity_path_28914" fill="none" stroke="gray"></path></g><path id="node_outline2798" fill="none" stroke="none" d="M528.5,31049.5h251a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-251a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2798" fill="black"><text id="kity_text_15232" text-rendering="inherit" font-size="12" dy=".8em" y="31050.700000047684" x="528.5">说说nginx的三大模块,handle,filter,upstream?</text></g></g><g id="minder_node2799" display="none"><g id="node_expander2796" display="none" style="cursor: pointer;"><path id="kity_path_28910" fill="white" stroke="gray" d="M544.5,31058.5A6,6,0,1,1,532.5,31058.5A6,6,0,1,1,544.5,31058.5"></path><path id="kity_path_28911" fill="none" stroke="gray"></path></g><path id="node_outline2797" fill="none" stroke="none" d="M544.5,31031.5h709a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-709a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2797" fill="black"><text id="kity_text_15228" text-rendering="inherit" font-size="12" dy=".8em" y="31032.700000047684" x="544.5">1.handler;接受来自客户端的请求并产生输出的模块；处理结果一般 处理成功，处理失败（处理的时候发生了错误）或者是拒绝去处理</text><text id="kity_text_15229" text-rendering="inherit" font-size="12" dy=".8em" y="31050.700000047684" x="544.5">2.upstream模块，将使nginx跨越单机的限制，完成网络数据的接收、处理和转发。</text><text id="kity_text_15230" text-rendering="inherit" font-size="12" dy=".8em" y="31068.700000047684" x="544.5">3.filter；过滤响应头和内容的模块；它的处理时间在获取回复内容之后，向用户发送响应之前；过滤和修改HTTP回复的头部和主体</text></g></g><g id="minder_node2800" display="none"><g id="node_expander2795" display="none" style="cursor: pointer;"><path id="kity_path_28907" fill="white" stroke="gray" d="M560.5,31058.5A6,6,0,1,1,548.5,31058.5A6,6,0,1,1,560.5,31058.5"></path><path id="kity_path_28908" fill="none" stroke="gray"></path></g><path id="node_outline2796" fill="none" stroke="none" d="M560.5,31049.5h279a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-279a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2796" fill="black"><text id="kity_text_15226" text-rendering="inherit" font-size="12" dy=".8em" y="31050.700000047684" x="560.5">http://tengine.taobao.org/book/chapter_05.html</text></g></g><g id="minder_node2801" display="none"><g id="node_expander2800" display="none" style="cursor: pointer;"><path id="kity_path_28922" fill="white" stroke="gray" d="M528.5,31066.5A6,6,0,1,1,516.5,31066.5A6,6,0,1,1,528.5,31066.5"></path><path id="kity_path_28923" fill="none" stroke="gray"></path></g><path id="node_outline2801" fill="none" stroke="none" d="M528.5,31057.5h264a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-264a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2801" fill="black"><text id="kity_text_15239" text-rendering="inherit" font-size="12" dy=".8em" y="31058.700000047684" x="528.5">来了一个请求 nginx 的master和worker谁去处理</text></g></g><g id="minder_node2802" display="none"><g id="node_expander2799" display="none" style="cursor: pointer;"><path id="kity_path_28919" fill="white" stroke="gray" d="M544.5,31066.5A6,6,0,1,1,532.5,31066.5A6,6,0,1,1,544.5,31066.5"></path><path id="kity_path_28920" fill="none" stroke="gray"></path></g><path id="node_outline2800" fill="none" stroke="none" d="M544.5,31048.5h288a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-288a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2800" fill="black"><text id="kity_text_15236" text-rendering="inherit" font-size="12" dy=".8em" y="31049.700000047684" x="544.5">1.master"进程只能有一个,而"worker"进程可以有多个</text><text id="kity_text_15237" text-rendering="inherit" font-size="12" dy=".8em" y="31067.700000047684" x="544.5">master 接受 转发给work去处理</text></g></g><g id="minder_node2803" display="none"><g id="node_expander2798" display="none" style="cursor: pointer;"><path id="kity_path_28916" fill="white" stroke="gray" d="M560.5,31066.5A6,6,0,1,1,548.5,31066.5A6,6,0,1,1,560.5,31066.5"></path><path id="kity_path_28917" fill="none" stroke="gray"></path></g><path id="node_outline2799" fill="none" stroke="none" d="M560.5,31057.5h335a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-335a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2799" fill="black"><text id="kity_text_15234" text-rendering="inherit" font-size="12" dy=".8em" y="31058.700000047684" x="560.5">https://blog.csdn.net/yrx420909/article/details/104513013</text></g></g><g id="minder_node2804" display="none"><g id="node_expander2802" display="none" style="cursor: pointer;"><path id="kity_path_28928" fill="white" stroke="gray" d="M528.5,31074.5A6,6,0,1,1,516.5,31074.5A6,6,0,1,1,528.5,31074.5"></path><path id="kity_path_28929" fill="none" stroke="gray"></path></g><path id="node_outline2803" fill="none" stroke="none" d="M528.5,31065.5h125a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-125a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2803" fill="black"><text id="kity_text_15243" text-rendering="inherit" font-size="12" dy=".8em" y="31066.700000047684" x="528.5">一个请求占几个worker</text></g></g><g id="minder_node2805" display="none"><g id="node_expander2801" display="none" style="cursor: pointer;"><path id="kity_path_28925" fill="white" stroke="gray" d="M544.5,31074.5A6,6,0,1,1,532.5,31074.5A6,6,0,1,1,544.5,31074.5"></path><path id="kity_path_28926" fill="none" stroke="gray"></path></g><path id="node_outline2802" fill="none" stroke="none" d="M544.5,31065.5h73a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-73a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2802" fill="black"><text id="kity_text_15241" text-rendering="inherit" font-size="12" dy=".8em" y="31066.700000047684" x="544.5">1.2个或者4个</text></g></g><g id="minder_node2806" display="none"><g id="node_expander2804" display="none" style="cursor: pointer;"><path id="kity_path_28934" fill="white" stroke="gray" d="M528.5,31082.5A6,6,0,1,1,516.5,31082.5A6,6,0,1,1,528.5,31082.5"></path><path id="kity_path_28935" fill="none" stroke="gray"></path></g><path id="node_outline2805" fill="none" stroke="none" d="M528.5,31073.5h169a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-169a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2805" fill="black"><text id="kity_text_15248" text-rendering="inherit" font-size="12" dy=".8em" y="31074.700000047684" x="528.5">四层负载和7层负载有什么区别?</text></g></g><g id="minder_node2807" display="none"><g id="node_expander2803" display="none" style="cursor: pointer;"><path id="kity_path_28931" fill="white" stroke="gray" d="M544.5,31082.5A6,6,0,1,1,532.5,31082.5A6,6,0,1,1,544.5,31082.5"></path><path id="kity_path_28932" fill="none" stroke="gray"></path></g><path id="node_outline2804" fill="none" stroke="none" d="M544.5,31064.5h653a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-653a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2804" fill="black"><text id="kity_text_15245" text-rendering="inherit" font-size="12" dy=".8em" y="31065.700000047684" x="544.5">1.四层负载均衡是基于IP+端口的负载均衡，也就是基于tcp层面 通过 虚拟ip+port接收请求,再转发到对应的真实机器。</text><text id="kity_text_15246" text-rendering="inherit" font-size="12" dy=".8em" y="31083.700000047684" x="544.5">七层负载均衡是基于URL等应用层信息的负载均衡，基于http层面。虚拟的url或主机名接收请求,再转向相应的处理服务器。</text></g></g><g id="minder_node2808" display="none"><g id="node_expander2806" display="none" style="cursor: pointer;"><path id="kity_path_28940" fill="white" stroke="gray" d="M528.5,31090.5A6,6,0,1,1,516.5,31090.5A6,6,0,1,1,528.5,31090.5"></path><path id="kity_path_28941" fill="none" stroke="gray"></path></g><path id="node_outline2807" fill="none" stroke="none" d="M528.5,31081.5h117a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-117a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2807" fill="black"><text id="kity_text_15253" text-rendering="inherit" font-size="12" dy=".8em" y="31082.700000047684" x="528.5">nginx怎么做代理缓存</text></g></g><g id="minder_node2809" display="none"><g id="node_expander2805" display="none" style="cursor: pointer;"><path id="kity_path_28937" fill="white" stroke="gray" d="M544.5,31090.5A6,6,0,1,1,532.5,31090.5A6,6,0,1,1,544.5,31090.5"></path><path id="kity_path_28938" fill="none" stroke="gray"></path></g><path id="node_outline2806" fill="none" stroke="none" d="M544.5,31072.5h760a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-760a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2806" fill="black"><text id="kity_text_15250" text-rendering="inherit" font-size="12" dy=".8em" y="31073.700000047684" x="544.5">1.http模块下 proxy_cache_path&#xa0; 置缓存的路径和配置，http下的server中 proxy_cache 来开启内容缓存</text><text id="kity_text_15251" text-rendering="inherit" font-size="12" dy=".8em" y="31091.700000047684" x="544.5">2.在配置中设置缓存最大时间，上限， 通过level来设置分层，指定缓存在本地的路径；还有一个共享内存区域，不检索磁盘快速响应是否命中；</text></g></g><g id="minder_node2810" display="none"><g id="node_expander2824" display="none" style="cursor: pointer;"><path id="kity_path_28994" fill="white" stroke="gray" d="M512.5,31098.5A6,6,0,1,1,500.5,31098.5A6,6,0,1,1,512.5,31098.5"></path><path id="kity_path_28995" fill="none" stroke="gray"></path></g><path id="node_outline2825" fill="none" stroke="none" d="M512.5,31089.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2825" fill="black"><text id="kity_text_15298" text-rendering="inherit" font-size="12" dy=".8em" y="31090.700000047684" x="512.5">进阶</text></g></g><g id="minder_node2811" display="none"><g id="node_expander2808" display="none" style="cursor: pointer;"><path id="kity_path_28946" fill="white" stroke="gray" d="M528.5,31050.5A6,6,0,1,1,516.5,31050.5A6,6,0,1,1,528.5,31050.5"></path><path id="kity_path_28947" fill="none" stroke="gray"></path></g><path id="node_outline2809" fill="none" stroke="none" d="M528.5,31041.5h180a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-180a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2809" fill="black"><text id="kity_text_15257" text-rendering="inherit" font-size="12" dy=".8em" y="31042.700000047684" x="528.5">怎么通过不同于80端口启动nginx</text></g></g><g id="minder_node2812" display="none"><g id="node_expander2810" display="none" style="cursor: pointer;"><path id="kity_path_28952" fill="white" stroke="gray" d="M528.5,31058.5A6,6,0,1,1,516.5,31058.5A6,6,0,1,1,528.5,31058.5"></path><path id="kity_path_28953" fill="none" stroke="gray"></path></g><path id="node_outline2811" fill="none" stroke="none" d="M528.5,31049.5h142a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-142a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2811" fill="black"><text id="kity_text_15265" text-rendering="inherit" font-size="12" dy=".8em" y="31050.700000047684" x="528.5">知道nginx限流吗，怎么做</text></g></g><g id="minder_node2813" display="none"><g id="node_expander2809" display="none" style="cursor: pointer;"><path id="kity_path_28949" fill="white" stroke="gray" d="M544.5,31058.5A6,6,0,1,1,532.5,31058.5A6,6,0,1,1,544.5,31058.5"></path><path id="kity_path_28950" fill="none" stroke="gray"></path></g><path id="node_outline2810" fill="none" stroke="none" d="M544.5,31013.5h1122a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1122a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text2810" fill="black"><text id="kity_text_15259" text-rendering="inherit" font-size="12" dy=".8em" y="31014.700000047684" x="544.5">nginx限流有三种，正常限制访问频率；限制突发访问频率；限制并发连接数；都是基于漏桶算法</text><text id="kity_text_15260" text-rendering="inherit" font-size="12" dy=".8em" y="31032.700000047684" x="544.5">1.</text><text id="kity_text_15261" text-rendering="inherit" font-size="12" dy=".8em" y="31050.700000047684" x="544.5">(1)在nginx.conf配置文件中可以使用limit_req_zone命令及limit_req命令限制单个IP的请求处理频率。限制一个用户发送的请求，我Nginx多久接收一个请求。</text><text id="kity_text_15262" text-rendering="inherit" font-size="12" dy=".8em" y="31068.700000047684" x="544.5">(2)通过burst参数结合nodelay参数可以解决流量突发的问题；对于一个用户的请求会立即处理前几个，多余的就慢慢来处理，没有其他用户的请求我就处理你的，有其他的请求的话我Nginx就漏掉不接受你的请求</text><text id="kity_text_15263" text-rendering="inherit" font-size="12" dy=".8em" y="31086.700000047684" x="544.5">(3)通过ngx_http_limit_conn_module模块提供了限制并发连接数的功能；可以配置了单个IP同时并发连接数最和整个虚拟服务器同时最大并发连接数</text></g></g><g id="minder_node2814" display="none"><g id="node_expander2812" display="none" style="cursor: pointer;"><path id="kity_path_28958" fill="white" stroke="gray" d="M528.5,31066.5A6,6,0,1,1,516.5,31066.5A6,6,0,1,1,528.5,31066.5"></path><path id="kity_path_28959" fill="none" stroke="gray"></path></g><path id="node_outline2813" fill="none" stroke="none" d="M528.5,31057.5h142a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-142a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2813" fill="black"><text id="kity_text_15270" text-rendering="inherit" font-size="12" dy=".8em" y="31058.700000047684" x="528.5">知道nginx缓存吗，怎么做</text></g></g><g id="minder_node2815" display="none"><g id="node_expander2811" display="none" style="cursor: pointer;"><path id="kity_path_28955" fill="white" stroke="gray" d="M544.5,31066.5A6,6,0,1,1,532.5,31066.5A6,6,0,1,1,544.5,31066.5"></path><path id="kity_path_28956" fill="none" stroke="gray"></path></g><path id="node_outline2812" fill="none" stroke="none" d="M544.5,31048.5h600a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-600a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2812" fill="black"><text id="kity_text_15267" text-rendering="inherit" font-size="12" dy=".8em" y="31049.700000047684" x="544.5">静态的资源只走静态资源服务器，动态的走动态的服务器；代理服务器nginx就可以直接处理图片，js，css等文件</text><text id="kity_text_15268" text-rendering="inherit" font-size="12" dy=".8em" y="31067.700000047684" x="544.5">1.在location中 只需要指定路径对应的目录。 比如说 location&#xa0; /image/ 正则匹配</text></g></g><g id="minder_node2816" display="none"><g id="node_expander2815" display="none" style="cursor: pointer;"><path id="kity_path_28967" fill="white" stroke="gray" d="M528.5,31074.5A6,6,0,1,1,516.5,31074.5A6,6,0,1,1,528.5,31074.5"></path><path id="kity_path_28968" fill="none" stroke="gray"></path></g><path id="node_outline2816" fill="none" stroke="none" d="M528.5,31065.5h117a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-117a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2816" fill="black"><text id="kity_text_15276" text-rendering="inherit" font-size="12" dy=".8em" y="31066.700000047684" x="528.5">知道nginx黑名单吗，</text></g></g><g id="minder_node2817" display="none"><g id="node_expander2814" display="none" style="cursor: pointer;"><path id="kity_path_28964" fill="white" stroke="gray" d="M544.5,31074.5A6,6,0,1,1,532.5,31074.5A6,6,0,1,1,544.5,31074.5"></path><path id="kity_path_28965" fill="none" stroke="gray"></path></g><path id="node_outline2815" fill="none" stroke="none" d="M544.5,31065.5h516a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-516a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2815" fill="black"><text id="kity_text_15274" text-rendering="inherit" font-size="12" dy=".8em" y="31066.700000047684" x="544.5">1.在黑名单配置文件中 屏蔽p访问 deny是单个ip访问 all是屏蔽所有 然后让 nginx去加载配置文件</text></g></g><g id="minder_node2818" display="none"><g id="node_expander2813" display="none" style="cursor: pointer;"><path id="kity_path_28961" fill="white" stroke="gray" d="M560.5,31074.5A6,6,0,1,1,548.5,31074.5A6,6,0,1,1,560.5,31074.5"></path><path id="kity_path_28962" fill="none" stroke="gray"></path></g><path id="node_outline2814" fill="none" stroke="none" d="M560.5,31065.5h353a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-353a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2814" fill="black"><text id="kity_text_15272" text-rendering="inherit" font-size="12" dy=".8em" y="31066.700000047684" x="560.5">https://blog.csdn.net/qq_42492606/article/details/107184761</text></g></g><g id="minder_node2819" display="none"><g id="node_expander2818" display="none" style="cursor: pointer;"><path id="kity_path_28976" fill="white" stroke="gray" d="M528.5,31082.5A6,6,0,1,1,516.5,31082.5A6,6,0,1,1,528.5,31082.5"></path><path id="kity_path_28977" fill="none" stroke="gray"></path></g><path id="node_outline2819" fill="none" stroke="none" d="M528.5,31073.5h230a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-230a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2819" fill="black"><text id="kity_text_15284" text-rendering="inherit" font-size="12" dy=".8em" y="31074.700000047684" x="528.5">Nginx 工作模型？以及为什么性能这么高？</text></g></g><g id="minder_node2820" display="none"><g id="node_expander2817" display="none" style="cursor: pointer;"><path id="kity_path_28973" fill="white" stroke="gray" d="M544.5,31082.5A6,6,0,1,1,532.5,31082.5A6,6,0,1,1,544.5,31082.5"></path><path id="kity_path_28974" fill="none" stroke="gray"></path></g><path id="node_outline2818" fill="none" stroke="none" d="M544.5,31064.5h606a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-606a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2818" fill="black"><text id="kity_text_15281" text-rendering="inherit" font-size="12" dy=".8em" y="31065.700000047684" x="544.5">1.在events模块中配置 use epoll&#xa0; epoll是多路复用io， 和 配置&#xa0; 单个后台 worker process 进程的最大并发链接数</text><text id="kity_text_15282" text-rendering="inherit" font-size="12" dy=".8em" y="31083.700000047684" x="544.5">2.因为他的事件处理机制：异步非阻塞事件处理机制：运用了epoll模型，提供了一个队列，排队解决</text></g></g><g id="minder_node2821" display="none"><g id="node_expander2816" display="none" style="cursor: pointer;"><path id="kity_path_28970" fill="white" stroke="gray" d="M560.5,31082.5A6,6,0,1,1,548.5,31082.5A6,6,0,1,1,560.5,31082.5"></path><path id="kity_path_28971" fill="none" stroke="gray"></path></g><path id="node_outline2817" fill="none" stroke="none" d="M560.5,31064.5h326a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2817" fill="black"><text id="kity_text_15278" text-rendering="inherit" font-size="12" dy=".8em" y="31065.700000047684" x="560.5">https://juejin.cn/post/6844904182923837454#heading-3</text><text id="kity_text_15279" text-rendering="inherit" font-size="12" dy=".8em" y="31083.700000047684" x="560.5">https://juejin.cn/post/6844904125784653837#heading-2</text></g></g><g id="minder_node2822" display="none"><g id="node_expander2821" display="none" style="cursor: pointer;"><path id="kity_path_28985" fill="white" stroke="gray" d="M528.5,31090.5A6,6,0,1,1,516.5,31090.5A6,6,0,1,1,528.5,31090.5"></path><path id="kity_path_28986" fill="none" stroke="gray"></path></g><path id="node_outline2822" fill="none" stroke="none" d="M528.5,31081.5h135a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-135a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2822" fill="black"><text id="kity_text_15291" text-rendering="inherit" font-size="12" dy=".8em" y="31082.700000047684" x="528.5">Nginx 是如何来解决跨域</text></g></g><g id="minder_node2823" display="none"><g id="node_expander2820" display="none" style="cursor: pointer;"><path id="kity_path_28982" fill="white" stroke="gray" d="M544.5,31090.5A6,6,0,1,1,532.5,31090.5A6,6,0,1,1,544.5,31090.5"></path><path id="kity_path_28983" fill="none" stroke="gray"></path></g><path id="node_outline2821" fill="none" stroke="none" d="M544.5,31072.5h531a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-531a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2821" fill="black"><text id="kity_text_15288" text-rendering="inherit" font-size="12" dy=".8em" y="31073.700000047684" x="544.5">1.使用Nginx转发请求。把跨域的接口写成调本域的接口，然后将这些接口转发到真正的请求地址。</text><text id="kity_text_15289" text-rendering="inherit" font-size="12" dy=".8em" y="31091.700000047684" x="544.5">2.比如 a的请求 b导致 跨域，在server_name 配置a&#xa0; location模块里面 配置 proxy_pass b 就可以了</text></g></g><g id="minder_node2824" display="none"><g id="node_expander2819" display="none" style="cursor: pointer;"><path id="kity_path_28979" fill="white" stroke="gray" d="M560.5,31090.5A6,6,0,1,1,548.5,31090.5A6,6,0,1,1,560.5,31090.5"></path><path id="kity_path_28980" fill="none" stroke="gray"></path></g><path id="node_outline2820" fill="none" stroke="none" d="M560.5,31081.5h333a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2820" fill="black"><text id="kity_text_15286" text-rendering="inherit" font-size="12" dy=".8em" y="31082.700000047684" x="560.5">https://juejin.cn/post/6844904144235413512#heading-18</text></g></g><g id="minder_node2825" display="none"><g id="node_expander2823" display="none" style="cursor: pointer;"><path id="kity_path_28991" fill="white" stroke="gray" d="M528.5,31098.5A6,6,0,1,1,516.5,31098.5A6,6,0,1,1,528.5,31098.5"></path><path id="kity_path_28992" fill="none" stroke="gray"></path></g><path id="node_outline2824" fill="none" stroke="none" d="M528.5,31089.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2824" fill="black"><text id="kity_text_15296" text-rendering="inherit" font-size="12" dy=".8em" y="31090.700000047684" x="528.5">怎么开启gzip压缩？优缺点？</text></g></g><g id="minder_node2826" display="none"><g id="node_expander2822" display="none" style="cursor: pointer;"><path id="kity_path_28988" fill="white" stroke="gray" d="M544.5,31098.5A6,6,0,1,1,532.5,31098.5A6,6,0,1,1,544.5,31098.5"></path><path id="kity_path_28989" fill="none" stroke="gray"></path></g><path id="node_outline2823" fill="none" stroke="none" d="M544.5,31080.5h551a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-551a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2823" fill="black"><text id="kity_text_15293" text-rendering="inherit" font-size="12" dy=".8em" y="31081.700000047684" x="544.5">1.在location中 开启gzip 和配置多大才压缩，可以压缩js&#xa0; html css 等静态资源，http基本都是文本传输</text><text id="kity_text_15294" text-rendering="inherit" font-size="12" dy=".8em" y="31099.700000047684" x="544.5">2.压缩是可以节省带宽，提高传输效率；但是在服务器上进行压缩，会消耗服务器资源</text></g></g><g id="minder_node2827" display="none"><g id="node_expander2827" display="none" style="cursor: pointer;"><path id="kity_path_29003" fill="white" stroke="gray" d="M512.5,31106.5A6,6,0,1,1,500.5,31106.5A6,6,0,1,1,512.5,31106.5"></path><path id="kity_path_29004" fill="none" stroke="gray"></path></g><path id="node_outline2828" fill="none" stroke="none" d="M512.5,31097.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2828" fill="black"><text id="kity_text_15304" text-rendering="inherit" font-size="12" dy=".8em" y="31098.700000047684" x="512.5">场景</text></g></g><g id="minder_node2828" display="none"><g id="node_expander2826" display="none" style="cursor: pointer;"><path id="kity_path_29000" fill="white" stroke="gray" d="M528.5,31106.5A6,6,0,1,1,516.5,31106.5A6,6,0,1,1,528.5,31106.5"></path><path id="kity_path_29001" fill="none" stroke="gray"></path></g><path id="node_outline2827" fill="none" stroke="none" d="M528.5,31097.5h197a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-197a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2827" fill="black"><text id="kity_text_15302" text-rendering="inherit" font-size="12" dy=".8em" y="31098.700000047684" x="528.5">生产中如何设置worker进程的数量？</text></g></g><g id="minder_node2829" display="none"><g id="node_expander2825" display="none" style="cursor: pointer;"><path id="kity_path_28997" fill="white" stroke="gray" d="M544.5,31106.5A6,6,0,1,1,532.5,31106.5A6,6,0,1,1,544.5,31106.5"></path><path id="kity_path_28998" fill="none" stroke="gray"></path></g><path id="node_outline2826" fill="none" stroke="none" d="M544.5,31097.5h92a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-92a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2826" fill="black"><text id="kity_text_15300" text-rendering="inherit" font-size="12" dy=".8em" y="31098.700000047684" x="544.5">1.和cpu保持一致</text></g></g><g id="minder_node2830" display="none"><g id="node_expander2828" display="none" style="cursor: pointer;"><path id="kity_path_29006" fill="white" stroke="gray" d="M512.5,31114.5A6,6,0,1,1,500.5,31114.5A6,6,0,1,1,512.5,31114.5"></path><path id="kity_path_29007" fill="none" stroke="gray"></path></g><path id="node_outline2829" fill="none" stroke="none" d="M512.5,31105.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2829" fill="black"><text id="kity_text_15306" text-rendering="inherit" font-size="12" dy=".8em" y="31106.700000047684" x="512.5">问题排查和优化解决</text></g></g><g id="minder_node2831" display="none"><g id="node_expander2830" display="none" style="cursor: pointer;"><path id="kity_path_29012" fill="white" stroke="gray" d="M512.5,31122.5A6,6,0,1,1,500.5,31122.5A6,6,0,1,1,512.5,31122.5"></path><path id="kity_path_29013" fill="none" stroke="gray"></path></g><path id="node_outline2831" fill="none" stroke="none" d="M512.5,31113.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2831" fill="black"><text id="kity_text_15316" text-rendering="inherit" font-size="12" dy=".8em" y="31114.700000047684" x="512.5">参考文章</text></g></g><g id="minder_node2832" display="none"><g id="node_expander2829" display="none" style="cursor: pointer;"><path id="kity_path_29009" fill="white" stroke="gray" d="M528.5,31122.5A6,6,0,1,1,516.5,31122.5A6,6,0,1,1,528.5,31122.5"></path><path id="kity_path_29010" fill="none" stroke="gray"></path></g><path id="node_outline2830" fill="none" stroke="none" d="M528.5,31059.5h347a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-347a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text2830" fill="black"><text id="kity_text_15308" text-rendering="inherit" font-size="12" dy=".8em" y="31060.700000047684" x="528.5">https://juejin.cn/post/6844904125784653837#heading-25</text><text id="kity_text_15309" text-rendering="inherit" font-size="12" dy=".8em" y="31078.700000047684" x="528.5">https://juejin.cn/post/6896745769584459784#heading-3</text><text id="kity_text_15310" text-rendering="inherit" font-size="12" dy=".8em" y="31096.700000047684" x="528.5">https://juejin.cn/post/6844904182923837454#heading-15</text><text id="kity_text_15311" text-rendering="inherit" font-size="12" dy=".8em" y="31114.700000047684" x="528.5">https://juejin.cn/post/6844903619465068551#heading-2</text><text id="kity_text_15312" text-rendering="inherit" font-size="12" dy=".8em" y="31132.700000047684" x="528.5">https://juejin.cn/post/6844904144235413512#heading-18</text><text id="kity_text_15313" text-rendering="inherit" font-size="12" dy=".8em" y="31150.700000047684" x="528.5">https://blog.csdn.net/u012068483/article/details/104442706</text><text id="kity_text_15314" text-rendering="inherit" font-size="12" dy=".8em" y="31168.700000047684" x="528.5">https://blog.csdn.net/u012068483/article/details/104442706</text></g></g><g id="minder_node2833"><g id="node_expander2838" style="cursor: pointer;"><path id="kity_path_29036" fill="white" stroke="gray" d="M317.5,15346.5A6,6,0,1,1,305.5,15346.5A6,6,0,1,1,317.5,15346.5"></path><path id="kity_path_29037" fill="none" stroke="gray" d="M307,15346.5L316,15346.5M311.5,15342L311.5,15351"></path></g><path id="node_outline2839" fill="rgb(239, 238, 246)" stroke="rgb(123, 115, 191)" d="M201.5,15333.5h100a3,3,0,0,1,3,3v20a3,3,0,0,1,-3,3h-100a3,3,0,0,1,-3,-3v-20a3,3,0,0,1,3,-3z" stroke-width="1"></path><g id="node_text2839" fill="black"><text id="kity_text_15332" text-rendering="inherit" font-size="14" dy=".8em" y="15337.400000095367" x="218.5">12.docker</text></g></g><g id="minder_node2834" display="none"><g id="node_expander2834" display="none" style="cursor: pointer;"><path id="kity_path_29024" fill="white" stroke="gray" d="M194.5,15322.5A6,6,0,1,1,182.5,15322.5A6,6,0,1,1,194.5,15322.5"></path><path id="kity_path_29025" fill="none" stroke="gray"></path></g><path id="node_outline2835" fill="none" stroke="none" d="M182.5,15313.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2835" fill="black"><text id="kity_text_15324" text-rendering="inherit" font-size="12" dy=".8em" y="15314.700000047684" x="182.5">基础</text></g></g><g id="minder_node2835" display="none"><g id="node_expander2833" display="none" style="cursor: pointer;"><path id="kity_path_29021" fill="white" stroke="gray" d="M178.5,15322.5A6,6,0,1,1,166.5,15322.5A6,6,0,1,1,178.5,15322.5"></path><path id="kity_path_29022" fill="none" stroke="gray"></path></g><path id="node_outline2834" fill="none" stroke="none" d="M166.5,15313.5h75a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-75a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2834" fill="black"><text id="kity_text_15322" text-rendering="inherit" font-size="12" dy=".8em" y="15314.700000047684" x="166.5">了解docker吗</text></g></g><g id="minder_node2836" display="none"><g id="node_expander2832" display="none" style="cursor: pointer;"><path id="kity_path_29018" fill="white" stroke="gray" d="M162.5,15322.5A6,6,0,1,1,150.5,15322.5A6,6,0,1,1,162.5,15322.5"></path><path id="kity_path_29019" fill="none" stroke="gray"></path></g><path id="node_outline2833" fill="none" stroke="none" d="M150.5,15313.5h354a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-354a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2833" fill="black"><text id="kity_text_15320" text-rendering="inherit" font-size="12" dy=".8em" y="15314.700000047684" x="150.5">https://blog.csdn.net/qq_40574571/article/details/108034804</text></g></g><g id="minder_node2837" display="none"><g id="node_expander2835" display="none" style="cursor: pointer;"><path id="kity_path_29027" fill="white" stroke="gray" d="M194.5,15330.5A6,6,0,1,1,182.5,15330.5A6,6,0,1,1,194.5,15330.5"></path><path id="kity_path_29028" fill="none" stroke="gray"></path></g><path id="node_outline2836" fill="none" stroke="none" d="M182.5,15321.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2836" fill="black"><text id="kity_text_15326" text-rendering="inherit" font-size="12" dy=".8em" y="15322.700000047684" x="182.5">进阶</text></g></g><g id="minder_node2838" display="none"><g id="node_expander2836" display="none" style="cursor: pointer;"><path id="kity_path_29030" fill="white" stroke="gray" d="M194.5,15338.5A6,6,0,1,1,182.5,15338.5A6,6,0,1,1,194.5,15338.5"></path><path id="kity_path_29031" fill="none" stroke="gray"></path></g><path id="node_outline2837" fill="none" stroke="none" d="M182.5,15329.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2837" fill="black"><text id="kity_text_15328" text-rendering="inherit" font-size="12" dy=".8em" y="15330.700000047684" x="182.5">场景</text></g></g><g id="minder_node2839" display="none"><g id="node_expander2837" display="none" style="cursor: pointer;"><path id="kity_path_29033" fill="white" stroke="gray" d="M194.5,15346.5A6,6,0,1,1,182.5,15346.5A6,6,0,1,1,194.5,15346.5"></path><path id="kity_path_29034" fill="none" stroke="gray"></path></g><path id="node_outline2838" fill="none" stroke="none" d="M182.5,15337.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2838" fill="black"><text id="kity_text_15330" text-rendering="inherit" font-size="12" dy=".8em" y="15338.700000047684" x="182.5">问题排查和相关优化</text></g></g><g id="minder_node2840"><g id="node_expander2851" style="cursor: pointer;"><path id="kity_path_29075" fill="white" stroke="gray" d="M317.5,15388.5A6,6,0,1,1,305.5,15388.5A6,6,0,1,1,317.5,15388.5"></path><path id="kity_path_29076" fill="none" stroke="gray" d="M307,15388.5L316,15388.5M311.5,15384L311.5,15393"></path></g><path id="node_outline2852" fill="rgb(239, 238, 246)" stroke="rgb(123, 115, 191)" d="M203.5,15375.5h98a3,3,0,0,1,3,3v20a3,3,0,0,1,-3,3h-98a3,3,0,0,1,-3,-3v-20a3,3,0,0,1,3,-3z" stroke-width="1"></path><g id="node_text2852" fill="black"><text id="kity_text_15358" text-rendering="inherit" font-size="14" dy=".8em" y="15379.400000095367" x="220.5">13.dubbo</text></g></g><g id="minder_node2841" display="none"><g id="node_expander2843" display="none" style="cursor: pointer;"><path id="kity_path_29051" fill="white" stroke="gray" d="M196.5,15364.5A6,6,0,1,1,184.5,15364.5A6,6,0,1,1,196.5,15364.5"></path><path id="kity_path_29052" fill="none" stroke="gray"></path></g><path id="node_outline2844" fill="none" stroke="none" d="M184.5,15355.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2844" fill="black"><text id="kity_text_15342" text-rendering="inherit" font-size="12" dy=".8em" y="15356.700000047684" x="184.5">基础</text></g></g><g id="minder_node2842" display="none"><g id="node_expander2839" display="none" style="cursor: pointer;"><path id="kity_path_29039" fill="white" stroke="gray" d="M180.5,15340.5A6,6,0,1,1,168.5,15340.5A6,6,0,1,1,180.5,15340.5"></path><path id="kity_path_29040" fill="none" stroke="gray"></path></g><path id="node_outline2840" fill="none" stroke="none" d="M168.5,15331.5h98a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-98a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2840" fill="black"><text id="kity_text_15334" text-rendering="inherit" font-size="12" dy=".8em" y="15332.700000047684" x="168.5">dubbo有了解过吗</text></g></g><g id="minder_node2843" display="none"><g id="node_expander2840" display="none" style="cursor: pointer;"><path id="kity_path_29042" fill="white" stroke="gray" d="M180.5,15348.5A6,6,0,1,1,168.5,15348.5A6,6,0,1,1,180.5,15348.5"></path><path id="kity_path_29043" fill="none" stroke="gray"></path></g><path id="node_outline2841" fill="none" stroke="none" d="M168.5,15339.5h184a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-184a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2841" fill="black"><text id="kity_text_15336" text-rendering="inherit" font-size="12" dy=".8em" y="15340.700000047684" x="168.5">dubbo的spi和jdk的spi有什么区别</text></g></g><g id="minder_node2844" display="none"><g id="node_expander2841" display="none" style="cursor: pointer;"><path id="kity_path_29045" fill="white" stroke="gray" d="M180.5,15356.5A6,6,0,1,1,168.5,15356.5A6,6,0,1,1,180.5,15356.5"></path><path id="kity_path_29046" fill="none" stroke="gray"></path></g><path id="node_outline2842" fill="none" stroke="none" d="M168.5,15347.5h159a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-159a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2842" fill="black"><text id="kity_text_15338" text-rendering="inherit" font-size="12" dy=".8em" y="15348.700000047684" x="168.5">dubbo的负载均衡方式有哪些</text></g></g><g id="minder_node2845" display="none"><g id="node_expander2842" display="none" style="cursor: pointer;"><path id="kity_path_29048" fill="white" stroke="gray" d="M180.5,15364.5A6,6,0,1,1,168.5,15364.5A6,6,0,1,1,180.5,15364.5"></path><path id="kity_path_29049" fill="none" stroke="gray"></path></g><path id="node_outline2843" fill="none" stroke="none" d="M168.5,15355.5h158a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-158a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2843" fill="black"><text id="kity_text_15340" text-rendering="inherit" font-size="12" dy=".8em" y="15356.700000047684" x="168.5">dubbo的负载均衡怎么实现的</text></g></g><g id="minder_node2846" display="none"><g id="node_expander2846" display="none" style="cursor: pointer;"><path id="kity_path_29060" fill="white" stroke="gray" d="M196.5,15372.5A6,6,0,1,1,184.5,15372.5A6,6,0,1,1,196.5,15372.5"></path><path id="kity_path_29061" fill="none" stroke="gray"></path></g><path id="node_outline2847" fill="none" stroke="none" d="M184.5,15363.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2847" fill="black"><text id="kity_text_15348" text-rendering="inherit" font-size="12" dy=".8em" y="15364.700000047684" x="184.5">进阶</text></g></g><g id="minder_node2847" display="none"><g id="node_expander2844" display="none" style="cursor: pointer;"><path id="kity_path_29054" fill="white" stroke="gray" d="M180.5,15364.5A6,6,0,1,1,168.5,15364.5A6,6,0,1,1,180.5,15364.5"></path><path id="kity_path_29055" fill="none" stroke="gray"></path></g><path id="node_outline2845" fill="none" stroke="none" d="M168.5,15355.5h158a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-158a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2845" fill="black"><text id="kity_text_15344" text-rendering="inherit" font-size="12" dy=".8em" y="15356.700000047684" x="168.5">dubbo的服务暴露过程知道吗</text></g></g><g id="minder_node2848" display="none"><g id="node_expander2845" display="none" style="cursor: pointer;"><path id="kity_path_29057" fill="white" stroke="gray" d="M180.5,15372.5A6,6,0,1,1,168.5,15372.5A6,6,0,1,1,180.5,15372.5"></path><path id="kity_path_29058" fill="none" stroke="gray"></path></g><path id="node_outline2846" fill="none" stroke="none" d="M168.5,15363.5h122a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-122a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2846" fill="black"><text id="kity_text_15346" text-rendering="inherit" font-size="12" dy=".8em" y="15364.700000047684" x="168.5">dubbo调用链路了解吗</text></g></g><g id="minder_node2849" display="none"><g id="node_expander2849" display="none" style="cursor: pointer;"><path id="kity_path_29069" fill="white" stroke="gray" d="M196.5,15380.5A6,6,0,1,1,184.5,15380.5A6,6,0,1,1,196.5,15380.5"></path><path id="kity_path_29070" fill="none" stroke="gray"></path></g><path id="node_outline2850" fill="none" stroke="none" d="M184.5,15371.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2850" fill="black"><text id="kity_text_15354" text-rendering="inherit" font-size="12" dy=".8em" y="15372.700000047684" x="184.5">场景</text></g></g><g id="minder_node2850" display="none"><g id="node_expander2847" display="none" style="cursor: pointer;"><path id="kity_path_29063" fill="white" stroke="gray" d="M180.5,15372.5A6,6,0,1,1,168.5,15372.5A6,6,0,1,1,180.5,15372.5"></path><path id="kity_path_29064" fill="none" stroke="gray"></path></g><path id="node_outline2848" fill="none" stroke="none" d="M168.5,15363.5h159a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-159a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2848" fill="black"><text id="kity_text_15350" text-rendering="inherit" font-size="12" dy=".8em" y="15364.700000047684" x="168.5">dubbo为什么支持这么多协议</text></g></g><g id="minder_node2851" display="none"><g id="node_expander2848" display="none" style="cursor: pointer;"><path id="kity_path_29066" fill="white" stroke="gray" d="M180.5,15380.5A6,6,0,1,1,168.5,15380.5A6,6,0,1,1,180.5,15380.5"></path><path id="kity_path_29067" fill="none" stroke="gray"></path></g><path id="node_outline2849" fill="none" stroke="none" d="M168.5,15371.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2849" fill="black"><text id="kity_text_15352" text-rendering="inherit" font-size="12" dy=".8em" y="15372.700000047684" x="168.5">知道这些协议的使用场景吗</text></g></g><g id="minder_node2852" display="none"><g id="node_expander2850" display="none" style="cursor: pointer;"><path id="kity_path_29072" fill="white" stroke="gray" d="M196.5,15388.5A6,6,0,1,1,184.5,15388.5A6,6,0,1,1,196.5,15388.5"></path><path id="kity_path_29073" fill="none" stroke="gray"></path></g><path id="node_outline2851" fill="none" stroke="none" d="M184.5,15379.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2851" fill="black"><text id="kity_text_15356" text-rendering="inherit" font-size="12" dy=".8em" y="15380.700000047684" x="184.5">问题排查和优化分析</text></g></g><g id="minder_node2853"><g id="node_expander2860" style="cursor: pointer;"><path id="kity_path_29102" fill="white" stroke="gray" d="M317.5,15430.5A6,6,0,1,1,305.5,15430.5A6,6,0,1,1,317.5,15430.5"></path><path id="kity_path_29103" fill="none" stroke="gray" d="M307,15430.5L316,15430.5M311.5,15426L311.5,15435"></path></g><path id="node_outline2861" fill="rgb(239, 238, 246)" stroke="rgb(123, 115, 191)" d="M199.5,15417.5h102a3,3,0,0,1,3,3v20a3,3,0,0,1,-3,3h-102a3,3,0,0,1,-3,-3v-20a3,3,0,0,1,3,-3z" stroke-width="1"></path><g id="node_text2861" fill="black"><text id="kity_text_15388" text-rendering="inherit" font-size="14" dy=".8em" y="15421.400000095367" x="216.5">14.tomcat</text></g></g><g id="minder_node2854" display="none"><g id="node_expander2853" display="none" style="cursor: pointer;"><path id="kity_path_29081" fill="white" stroke="gray" d="M192.5,15406.5A6,6,0,1,1,180.5,15406.5A6,6,0,1,1,192.5,15406.5"></path><path id="kity_path_29082" fill="none" stroke="gray"></path></g><path id="node_outline2854" fill="none" stroke="none" d="M180.5,15397.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2854" fill="black"><text id="kity_text_15362" text-rendering="inherit" font-size="12" dy=".8em" y="15398.700000047684" x="180.5">基础</text></g></g><g id="minder_node2855" display="none"><g id="node_expander2852" display="none" style="cursor: pointer;"><path id="kity_path_29078" fill="white" stroke="gray" d="M176.5,15406.5A6,6,0,1,1,164.5,15406.5A6,6,0,1,1,176.5,15406.5"></path><path id="kity_path_29079" fill="none" stroke="gray"></path></g><path id="node_outline2853" fill="none" stroke="none" d="M164.5,15397.5h149a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-149a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2853" fill="black"><text id="kity_text_15360" text-rendering="inherit" font-size="12" dy=".8em" y="15398.700000047684" x="164.5">tomcat的类加载加载了解吗</text></g></g><g id="minder_node2856" display="none"><g id="node_expander2854" display="none" style="cursor: pointer;"><path id="kity_path_29084" fill="white" stroke="gray" d="M192.5,15414.5A6,6,0,1,1,180.5,15414.5A6,6,0,1,1,192.5,15414.5"></path><path id="kity_path_29085" fill="none" stroke="gray"></path></g><path id="node_outline2855" fill="none" stroke="none" d="M180.5,15405.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2855" fill="black"><text id="kity_text_15364" text-rendering="inherit" font-size="12" dy=".8em" y="15406.700000047684" x="180.5">进阶</text></g></g><g id="minder_node2857" display="none"><g id="node_expander2855" display="none" style="cursor: pointer;"><path id="kity_path_29087" fill="white" stroke="gray" d="M192.5,15422.5A6,6,0,1,1,180.5,15422.5A6,6,0,1,1,192.5,15422.5"></path><path id="kity_path_29088" fill="none" stroke="gray"></path></g><path id="node_outline2856" fill="none" stroke="none" d="M180.5,15413.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2856" fill="black"><text id="kity_text_15366" text-rendering="inherit" font-size="12" dy=".8em" y="15414.700000047684" x="180.5">场景</text></g></g><g id="minder_node2858" display="none"><g id="node_expander2859" display="none" style="cursor: pointer;"><path id="kity_path_29099" fill="white" stroke="gray" d="M192.5,15430.5A6,6,0,1,1,180.5,15430.5A6,6,0,1,1,192.5,15430.5"></path><path id="kity_path_29100" fill="none" stroke="gray"></path></g><path id="node_outline2860" fill="none" stroke="none" d="M180.5,15421.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2860" fill="black"><text id="kity_text_15386" text-rendering="inherit" font-size="12" dy=".8em" y="15422.700000047684" x="180.5">问题排查和优化解决</text></g></g><g id="minder_node2859" display="none"><g id="node_expander2858" display="none" style="cursor: pointer;"><path id="kity_path_29096" fill="white" stroke="gray" d="M176.5,15430.5A6,6,0,1,1,164.5,15430.5A6,6,0,1,1,176.5,15430.5"></path><path id="kity_path_29097" fill="none" stroke="gray"></path></g><path id="node_outline2859" fill="none" stroke="none" d="M164.5,15421.5h146a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-146a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2859" fill="black"><text id="kity_text_15384" text-rendering="inherit" font-size="12" dy=".8em" y="15422.700000047684" x="164.5">Tomcat并发重要参数调优?</text></g></g><g id="minder_node2860" display="none"><g id="node_expander2857" display="none" style="cursor: pointer;"><path id="kity_path_29093" fill="white" stroke="gray" d="M160.5,15430.5A6,6,0,1,1,148.5,15430.5A6,6,0,1,1,160.5,15430.5"></path><path id="kity_path_29094" fill="none" stroke="gray"></path></g><path id="node_outline2858" fill="none" stroke="none" d="M148.5,15313.5h945a5,5,0,0,1,5,5v224a5,5,0,0,1,-5,5h-945a5,5,0,0,1,-5,-5v-224a5,5,0,0,1,5,-5z"></path><g id="node_text2858" fill="black"><text id="kity_text_15370" text-rendering="inherit" font-size="12" dy=".8em" y="15314.700000047684" x="148.5">1.并发配置，如maxThreads接收客户端请求的最大线程数，默认是200，一般默认是1000，也是linux中可以设置最大的值。</text><text id="kity_text_15371" text-rendering="inherit" font-size="12" dy=".8em" y="15332.700000047684" x="148.5">maxConnections同一时间，tomcat能够接受的最大连接数 Java NIO模式，maxConnections 默认值是10000。</text><text id="kity_text_15372" text-rendering="inherit" font-size="12" dy=".8em" y="15350.700000047684" x="148.5">acceptCount 请求就会被拒绝上限，一般是和maxThreads</text><text id="kity_text_15373" text-rendering="inherit" font-size="12" dy=".8em" y="15368.700000047684" x="148.5">2.线程配置</text><text id="kity_text_15374" text-rendering="inherit" font-size="12" dy=".8em" y="15386.700000047684" x="148.5">minSpareThreads -- 一直处于活跃状态的线程数</text><text id="kity_text_15375" text-rendering="inherit" font-size="12" dy=".8em" y="15404.700000047684" x="148.5">maxIdleTime -- 线程的空闲时间，在超过空闲时间时这些线程则会被销毁</text><text id="kity_text_15376" text-rendering="inherit" font-size="12" dy=".8em" y="15422.700000047684" x="148.5">threadPriority -- 线程池中线程的优先级，默认为5</text><text id="kity_text_15377" text-rendering="inherit" font-size="12" dy=".8em" y="15440.700000047684" x="148.5">3.JVM配置</text><text id="kity_text_15378" text-rendering="inherit" font-size="12" dy=".8em" y="15458.700000047684" x="148.5">-XX:+UseG1GC 首先，要指定JVM使用的垃圾回收器。-Xmx 设置堆的最大值，一般为操作系统的2/3大小。</text><text id="kity_text_15379" text-rendering="inherit" font-size="12" dy=".8em" y="15476.700000047684" x="148.5">-Xms 设置堆的初始值，一般设置成和Xmx一样的大小来避免动态扩容。-Xmn 年轻代大小，默认新生代占堆大小的1/3。高并发快消亡场景可适当加大这个区域，G1不需要设置。</text><text id="kity_text_15380" text-rendering="inherit" font-size="12" dy=".8em" y="15494.700000047684" x="148.5">-XX:ReservedCodeCacheSize 设置JIT编译后的代码存放区大小。-Xss 设置栈的大小，默认为1M，已经足够用了。</text><text id="kity_text_15381" text-rendering="inherit" font-size="12" dy=".8em" y="15512.700000047684" x="148.5">-XX:+AlwaysPreTouch 启动时就把参数里说好了的内存全部初始化，启动时间会慢一些，但运行速度会增加。</text><text id="kity_text_15382" text-rendering="inherit" font-size="12" dy=".8em" y="15530.700000047684" x="148.5">-XX:MaxTenuringThreshold 这个值在CMS下默认为6(jvm默认是cms，不指定gc默认是6，指定使用cms 默认15)，G1下默认为15。</text></g></g><g id="minder_node2861" display="none"><g id="node_expander2856" display="none" style="cursor: pointer;"><path id="kity_path_29090" fill="white" stroke="gray" d="M144.5,15430.5A6,6,0,1,1,132.5,15430.5A6,6,0,1,1,144.5,15430.5"></path><path id="kity_path_29091" fill="none" stroke="gray"></path></g><path id="node_outline2857" fill="none" stroke="none" d="M132.5,15421.5h304a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-304a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2857" fill="black"><text id="kity_text_15368" text-rendering="inherit" font-size="12" dy=".8em" y="15422.700000047684" x="132.5">http://blog.itpub.net/69955379/viewspace-2768572/</text></g></g><g id="minder_node2862"><g id="node_expander2903" style="cursor: pointer;"><path id="kity_path_29231" fill="white" stroke="gray" d="M317.5,15472.5A6,6,0,1,1,305.5,15472.5A6,6,0,1,1,317.5,15472.5"></path><path id="kity_path_29232" fill="none" stroke="gray" d="M307,15472.5L316,15472.5M311.5,15468L311.5,15477"></path></g><path id="node_outline2904" fill="rgb(239, 238, 246)" stroke="rgb(123, 115, 191)" d="M218.5,15459.5h83a3,3,0,0,1,3,3v20a3,3,0,0,1,-3,3h-83a3,3,0,0,1,-3,-3v-20a3,3,0,0,1,3,-3z" stroke-width="1"></path><g id="node_text2904" fill="black"><text id="kity_text_15479" text-rendering="inherit" font-size="14" dy=".8em" y="15463.400000095367" x="235.5">15.搜索</text></g></g><g id="minder_node2863" display="none"><g id="node_expander2878" display="none" style="cursor: pointer;"><path id="kity_path_29156" fill="white" stroke="gray" d="M211.5,15464.5A6,6,0,1,1,199.5,15464.5A6,6,0,1,1,211.5,15464.5"></path><path id="kity_path_29157" fill="none" stroke="gray"></path></g><path id="node_outline2879" fill="none" stroke="none" d="M199.5,15455.5h14a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-14a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2879" fill="black"><text id="kity_text_15429" text-rendering="inherit" font-size="12" dy=".8em" y="15456.700000047684" x="199.5">ES</text></g></g><g id="minder_node2864" display="none"><g id="node_expander2871" display="none" style="cursor: pointer;"><path id="kity_path_29135" fill="white" stroke="gray" d="M195.5,15432.5A6,6,0,1,1,183.5,15432.5A6,6,0,1,1,195.5,15432.5"></path><path id="kity_path_29136" fill="none" stroke="gray"></path></g><path id="node_outline2872" fill="none" stroke="none" d="M183.5,15423.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2872" fill="black"><text id="kity_text_15415" text-rendering="inherit" font-size="12" dy=".8em" y="15424.700000047684" x="183.5">基础</text></g></g><g id="minder_node2865" display="none"><g id="node_expander2862" display="none" style="cursor: pointer;"><path id="kity_path_29108" fill="white" stroke="gray" d="M179.5,15392.5A6,6,0,1,1,167.5,15392.5A6,6,0,1,1,179.5,15392.5"></path><path id="kity_path_29109" fill="none" stroke="gray"></path></g><path id="node_outline2863" fill="none" stroke="none" d="M167.5,15383.5h183a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-183a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2863" fill="black"><text id="kity_text_15392" text-rendering="inherit" font-size="12" dy=".8em" y="15384.700000047684" x="167.5">es怎么聚合计算?怎么做range查询</text></g></g><g id="minder_node2866" display="none"><g id="node_expander2861" display="none" style="cursor: pointer;"><path id="kity_path_29105" fill="white" stroke="gray" d="M163.5,15392.5A6,6,0,1,1,151.5,15392.5A6,6,0,1,1,163.5,15392.5"></path><path id="kity_path_29106" fill="none" stroke="gray"></path></g><path id="node_outline2862" fill="none" stroke="none" d="M151.5,15383.5h38a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-38a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2862" fill="black"><text id="kity_text_15390" text-rendering="inherit" font-size="12" dy=".8em" y="15384.700000047684" x="151.5">1.aggs</text></g></g><g id="minder_node2867" display="none"><g id="node_expander2863" display="none" style="cursor: pointer;"><path id="kity_path_29111" fill="white" stroke="gray" d="M179.5,15400.5A6,6,0,1,1,167.5,15400.5A6,6,0,1,1,179.5,15400.5"></path><path id="kity_path_29112" fill="none" stroke="gray"></path></g><path id="node_outline2864" fill="none" stroke="none" d="M167.5,15391.5h61a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-61a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2864" fill="black"><text id="kity_text_15394" text-rendering="inherit" font-size="12" dy=".8em" y="15392.700000047684" x="167.5">分词原理？</text></g></g><g id="minder_node2868" display="none"><g id="node_expander2864" display="none" style="cursor: pointer;"><path id="kity_path_29114" fill="white" stroke="gray" d="M179.5,15408.5A6,6,0,1,1,167.5,15408.5A6,6,0,1,1,179.5,15408.5"></path><path id="kity_path_29115" fill="none" stroke="gray"></path></g><path id="node_outline2865" fill="none" stroke="none" d="M167.5,15399.5h97a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-97a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2865" fill="black"><text id="kity_text_15396" text-rendering="inherit" font-size="12" dy=".8em" y="15400.700000047684" x="167.5">怎么自定义分词？</text></g></g><g id="minder_node2869" display="none"><g id="node_expander2866" display="none" style="cursor: pointer;"><path id="kity_path_29120" fill="white" stroke="gray" d="M179.5,15416.5A6,6,0,1,1,167.5,15416.5A6,6,0,1,1,179.5,15416.5"></path><path id="kity_path_29121" fill="none" stroke="gray"></path></g><path id="node_outline2867" fill="none" stroke="none" d="M167.5,15407.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2867" fill="black"><text id="kity_text_15403" text-rendering="inherit" font-size="12" dy=".8em" y="15408.700000047684" x="167.5">查询</text></g></g><g id="minder_node2870" display="none"><g id="node_expander2865" display="none" style="cursor: pointer;"><path id="kity_path_29117" fill="white" stroke="gray" d="M163.5,15416.5A6,6,0,1,1,151.5,15416.5A6,6,0,1,1,163.5,15416.5"></path><path id="kity_path_29118" fill="none" stroke="gray"></path></g><path id="node_outline2866" fill="none" stroke="none" d="M151.5,15380.5h245a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-245a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text2866" fill="black"><text id="kity_text_15398" text-rendering="inherit" font-size="12" dy=".8em" y="15381.700000047684" x="151.5">1.range范围查询</text><text id="kity_text_15399" text-rendering="inherit" font-size="12" dy=".8em" y="15399.700000047684" x="151.5">2._search 编写DSL做字段搜索</text><text id="kity_text_15400" text-rendering="inherit" font-size="12" dy=".8em" y="15417.700000047684" x="151.5">3.filtered 做过滤搜索</text><text id="kity_text_15401" text-rendering="inherit" font-size="12" dy=".8em" y="15435.700000047684" x="151.5">4.match做全文检索 全字段&#xa0; 多字段&#xa0; 分词匹配</text></g></g><g id="minder_node2871" display="none"><g id="node_expander2868" display="none" style="cursor: pointer;"><path id="kity_path_29126" fill="white" stroke="gray" d="M179.5,15424.5A6,6,0,1,1,167.5,15424.5A6,6,0,1,1,179.5,15424.5"></path><path id="kity_path_29127" fill="none" stroke="gray"></path></g><path id="node_outline2869" fill="none" stroke="none" d="M167.5,15415.5h223a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-223a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2869" fill="black"><text id="kity_text_15407" text-rendering="inherit" font-size="12" dy=".8em" y="15416.700000047684" x="167.5">ES如何深分页？from + size过大怎么办？</text></g></g><g id="minder_node2872" display="none"><g id="node_expander2867" display="none" style="cursor: pointer;"><path id="kity_path_29123" fill="white" stroke="gray" d="M163.5,15424.5A6,6,0,1,1,151.5,15424.5A6,6,0,1,1,163.5,15424.5"></path><path id="kity_path_29124" fill="none" stroke="gray"></path></g><path id="node_outline2868" fill="none" stroke="none" d="M151.5,15415.5h203a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-203a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2868" fill="black"><text id="kity_text_15405" text-rendering="inherit" font-size="12" dy=".8em" y="15416.700000047684" x="151.5">（from + size有限制，过大用scroll）</text></g></g><g id="minder_node2873" display="none"><g id="node_expander2870" display="none" style="cursor: pointer;"><path id="kity_path_29132" fill="white" stroke="gray" d="M179.5,15432.5A6,6,0,1,1,167.5,15432.5A6,6,0,1,1,179.5,15432.5"></path><path id="kity_path_29133" fill="none" stroke="gray"></path></g><path id="node_outline2871" fill="none" stroke="none" d="M167.5,15423.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2871" fill="black"><text id="kity_text_15413" text-rendering="inherit" font-size="12" dy=".8em" y="15424.700000047684" x="167.5">solr 和es的区别</text></g></g><g id="minder_node2874" display="none"><g id="node_expander2869" display="none" style="cursor: pointer;"><path id="kity_path_29129" fill="white" stroke="gray" d="M163.5,15432.5A6,6,0,1,1,151.5,15432.5A6,6,0,1,1,163.5,15432.5"></path><path id="kity_path_29130" fill="none" stroke="gray"></path></g><path id="node_outline2870" fill="none" stroke="none" d="M151.5,15405.5h579a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-579a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2870" fill="black"><text id="kity_text_15409" text-rendering="inherit" font-size="12" dy=".8em" y="15406.700000047684" x="151.5">1.Solr 支持更多格式的数据，而 Elasticsearch 仅支持 json 文件格式；</text><text id="kity_text_15410" text-rendering="inherit" font-size="12" dy=".8em" y="15424.700000047684" x="151.5">2.Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用 时效率明显低于 Elasticsearch。&#xa0;</text><text id="kity_text_15411" text-rendering="inherit" font-size="12" dy=".8em" y="15442.700000047684" x="151.5">3.Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级 功能多有第三方插件提供；</text></g></g><g id="minder_node2875" display="none"><g id="node_expander2872" display="none" style="cursor: pointer;"><path id="kity_path_29138" fill="white" stroke="gray" d="M195.5,15440.5A6,6,0,1,1,183.5,15440.5A6,6,0,1,1,195.5,15440.5"></path><path id="kity_path_29139" fill="none" stroke="gray"></path></g><path id="node_outline2873" fill="none" stroke="none" d="M183.5,15431.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2873" fill="black"><text id="kity_text_15417" text-rendering="inherit" font-size="12" dy=".8em" y="15432.700000047684" x="183.5">进阶</text></g></g><g id="minder_node2876" display="none"><g id="node_expander2873" display="none" style="cursor: pointer;"><path id="kity_path_29141" fill="white" stroke="gray" d="M195.5,15448.5A6,6,0,1,1,183.5,15448.5A6,6,0,1,1,195.5,15448.5"></path><path id="kity_path_29142" fill="none" stroke="gray"></path></g><path id="node_outline2874" fill="none" stroke="none" d="M183.5,15439.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2874" fill="black"><text id="kity_text_15419" text-rendering="inherit" font-size="12" dy=".8em" y="15440.700000047684" x="183.5">场景</text></g></g><g id="minder_node2877" display="none"><g id="node_expander2874" display="none" style="cursor: pointer;"><path id="kity_path_29144" fill="white" stroke="gray" d="M195.5,15456.5A6,6,0,1,1,183.5,15456.5A6,6,0,1,1,195.5,15456.5"></path><path id="kity_path_29145" fill="none" stroke="gray"></path></g><path id="node_outline2875" fill="none" stroke="none" d="M183.5,15447.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2875" fill="black"><text id="kity_text_15421" text-rendering="inherit" font-size="12" dy=".8em" y="15448.700000047684" x="183.5">集群</text></g></g><g id="minder_node2878" display="none"><g id="node_expander2877" display="none" style="cursor: pointer;"><path id="kity_path_29153" fill="white" stroke="gray" d="M195.5,15464.5A6,6,0,1,1,183.5,15464.5A6,6,0,1,1,195.5,15464.5"></path><path id="kity_path_29154" fill="none" stroke="gray"></path></g><path id="node_outline2878" fill="none" stroke="none" d="M183.5,15455.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2878" fill="black"><text id="kity_text_15427" text-rendering="inherit" font-size="12" dy=".8em" y="15456.700000047684" x="183.5">问题解决和优化</text></g></g><g id="minder_node2879" display="none"><g id="node_expander2875" display="none" style="cursor: pointer;"><path id="kity_path_29147" fill="white" stroke="gray" d="M179.5,15456.5A6,6,0,1,1,167.5,15456.5A6,6,0,1,1,179.5,15456.5"></path><path id="kity_path_29148" fill="none" stroke="gray"></path></g><path id="node_outline2876" fill="none" stroke="none" d="M167.5,15447.5h98a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-98a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2876" fill="black"><text id="kity_text_15423" text-rendering="inherit" font-size="12" dy=".8em" y="15448.700000047684" x="167.5">ES脑裂问题的原因</text></g></g><g id="minder_node2880" display="none"><g id="node_expander2876" display="none" style="cursor: pointer;"><path id="kity_path_29150" fill="white" stroke="gray" d="M179.5,15464.5A6,6,0,1,1,167.5,15464.5A6,6,0,1,1,179.5,15464.5"></path><path id="kity_path_29151" fill="none" stroke="gray"></path></g><path id="node_outline2877" fill="none" stroke="none" d="M167.5,15455.5h123a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-123a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2877" fill="black"><text id="kity_text_15425" text-rendering="inherit" font-size="12" dy=".8em" y="15456.700000047684" x="167.5">ES脑裂问题的解决方案</text></g></g><g id="minder_node2881" display="none"><g id="node_expander2902" display="none" style="cursor: pointer;"><path id="kity_path_29228" fill="white" stroke="gray" d="M211.5,15472.5A6,6,0,1,1,199.5,15472.5A6,6,0,1,1,211.5,15472.5"></path><path id="kity_path_29229" fill="none" stroke="gray"></path></g><path id="node_outline2903" fill="none" stroke="none" d="M199.5,15463.5h21a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-21a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2903" fill="black"><text id="kity_text_15477" text-rendering="inherit" font-size="12" dy=".8em" y="15464.700000047684" x="199.5">solr</text></g></g><g id="minder_node2882" display="none"><g id="node_expander2889" display="none" style="cursor: pointer;"><path id="kity_path_29189" fill="white" stroke="gray" d="M195.5,15448.5A6,6,0,1,1,183.5,15448.5A6,6,0,1,1,195.5,15448.5"></path><path id="kity_path_29190" fill="none" stroke="gray"></path></g><path id="node_outline2890" fill="none" stroke="none" d="M183.5,15439.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2890" fill="black"><text id="kity_text_15451" text-rendering="inherit" font-size="12" dy=".8em" y="15440.700000047684" x="183.5">基础</text></g></g><g id="minder_node2883" display="none"><g id="node_expander2879" display="none" style="cursor: pointer;"><path id="kity_path_29159" fill="white" stroke="gray" d="M179.5,15400.5A6,6,0,1,1,167.5,15400.5A6,6,0,1,1,179.5,15400.5"></path><path id="kity_path_29160" fill="none" stroke="gray"></path></g><path id="node_outline2880" fill="none" stroke="none" d="M167.5,15391.5h58a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-58a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2880" fill="black"><text id="kity_text_15431" text-rendering="inherit" font-size="12" dy=".8em" y="15392.700000047684" x="167.5">solr是什么</text></g></g><g id="minder_node2884" display="none"><g id="node_expander2880" display="none" style="cursor: pointer;"><path id="kity_path_29162" fill="white" stroke="gray" d="M179.5,15408.5A6,6,0,1,1,167.5,15408.5A6,6,0,1,1,179.5,15408.5"></path><path id="kity_path_29163" fill="none" stroke="gray"></path></g><path id="node_outline2881" fill="none" stroke="none" d="M167.5,15399.5h105a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-105a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2881" fill="black"><text id="kity_text_15433" text-rendering="inherit" font-size="12" dy=".8em" y="15400.700000047684" x="167.5">为什么你们使用solr</text></g></g><g id="minder_node2885" display="none"><g id="node_expander2882" display="none" style="cursor: pointer;"><path id="kity_path_29168" fill="white" stroke="gray" d="M179.5,15416.5A6,6,0,1,1,167.5,15416.5A6,6,0,1,1,179.5,15416.5"></path><path id="kity_path_29169" fill="none" stroke="gray"></path></g><path id="node_outline2883" fill="none" stroke="none" d="M167.5,15407.5h142a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-142a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2883" fill="black"><text id="kity_text_15437" text-rendering="inherit" font-size="12" dy=".8em" y="15408.700000047684" x="167.5">solr的底层存储结构是什么</text></g></g><g id="minder_node2886" display="none"><g id="node_expander2881" display="none" style="cursor: pointer;"><path id="kity_path_29165" fill="white" stroke="gray" d="M163.5,15416.5A6,6,0,1,1,151.5,15416.5A6,6,0,1,1,163.5,15416.5"></path><path id="kity_path_29166" fill="none" stroke="gray"></path></g><path id="node_outline2882" fill="none" stroke="none" d="M151.5,15407.5h57a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-57a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2882" fill="black"><text id="kity_text_15435" text-rendering="inherit" font-size="12" dy=".8em" y="15408.700000047684" x="151.5">FTS状态机</text></g></g><g id="minder_node2887" display="none"><g id="node_expander2883" display="none" style="cursor: pointer;"><path id="kity_path_29171" fill="white" stroke="gray" d="M179.5,15424.5A6,6,0,1,1,167.5,15424.5A6,6,0,1,1,179.5,15424.5"></path><path id="kity_path_29172" fill="none" stroke="gray"></path></g><path id="node_outline2884" fill="none" stroke="none" d="M167.5,15415.5h117a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-117a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2884" fill="black"><text id="kity_text_15439" text-rendering="inherit" font-size="12" dy=".8em" y="15416.700000047684" x="167.5">solr为什么检索那么快</text></g></g><g id="minder_node2888" display="none"><g id="node_expander2885" display="none" style="cursor: pointer;"><path id="kity_path_29177" fill="white" stroke="gray" d="M179.5,15432.5A6,6,0,1,1,167.5,15432.5A6,6,0,1,1,179.5,15432.5"></path><path id="kity_path_29178" fill="none" stroke="gray"></path></g><path id="node_outline2886" fill="none" stroke="none" d="M167.5,15423.5h142a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-142a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2886" fill="black"><text id="kity_text_15443" text-rendering="inherit" font-size="12" dy=".8em" y="15424.700000047684" x="167.5">solr使用的是什么搜索算法</text></g></g><g id="minder_node2889" display="none"><g id="node_expander2884" display="none" style="cursor: pointer;"><path id="kity_path_29174" fill="white" stroke="gray" d="M163.5,15432.5A6,6,0,1,1,151.5,15432.5A6,6,0,1,1,163.5,15432.5"></path><path id="kity_path_29175" fill="none" stroke="gray"></path></g><path id="node_outline2885" fill="none" stroke="none" d="M151.5,15423.5h74a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-74a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2885" fill="black"><text id="kity_text_15441" text-rendering="inherit" font-size="12" dy=".8em" y="15424.700000047684" x="151.5">倒排索引算法</text></g></g><g id="minder_node2890" display="none"><g id="node_expander2887" display="none" style="cursor: pointer;"><path id="kity_path_29183" fill="white" stroke="gray" d="M179.5,15440.5A6,6,0,1,1,167.5,15440.5A6,6,0,1,1,179.5,15440.5"></path><path id="kity_path_29184" fill="none" stroke="gray"></path></g><path id="node_outline2888" fill="none" stroke="none" d="M167.5,15431.5h110a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-110a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2888" fill="black"><text id="kity_text_15447" text-rendering="inherit" font-size="12" dy=".8em" y="15432.700000047684" x="167.5">说一下倒排索引算法</text></g></g><g id="minder_node2891" display="none"><g id="node_expander2886" display="none" style="cursor: pointer;"><path id="kity_path_29180" fill="white" stroke="gray" d="M163.5,15440.5A6,6,0,1,1,151.5,15440.5A6,6,0,1,1,163.5,15440.5"></path><path id="kity_path_29181" fill="none" stroke="gray"></path></g><path id="node_outline2887" fill="none" stroke="none" d="M151.5,15431.5h1370a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1370a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2887" fill="black"><text id="kity_text_15445" text-rendering="inherit" font-size="12" dy=".8em" y="15432.700000047684" x="151.5">1.查询之前先提取文档内容组成文档，把文档切分词组成目录（索引），具体怎么切分 可以自定义使用IK词库。这是一种时间换空间的思想。用组成的索引文件，然后让我们去查询的时侯，分析我们查询的关键字和哪个文档索引最匹配，提高查询准确率和速度</text></g></g><g id="minder_node2892" display="none"><g id="node_expander2888" display="none" style="cursor: pointer;"><path id="kity_path_29186" fill="white" stroke="gray" d="M179.5,15448.5A6,6,0,1,1,167.5,15448.5A6,6,0,1,1,179.5,15448.5"></path><path id="kity_path_29187" fill="none" stroke="gray"></path></g><path id="node_outline2889" fill="none" stroke="none" d="M167.5,15439.5h179a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-179a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2889" fill="black"><text id="kity_text_15449" text-rendering="inherit" font-size="12" dy=".8em" y="15440.700000047684" x="167.5">说一下solr查询和创建索引的流程</text></g></g><g id="minder_node2893" display="none"><g id="node_expander2894" display="none" style="cursor: pointer;"><path id="kity_path_29204" fill="white" stroke="gray" d="M195.5,15456.5A6,6,0,1,1,183.5,15456.5A6,6,0,1,1,195.5,15456.5"></path><path id="kity_path_29205" fill="none" stroke="gray"></path></g><path id="node_outline2895" fill="none" stroke="none" d="M183.5,15447.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2895" fill="black"><text id="kity_text_15461" text-rendering="inherit" font-size="12" dy=".8em" y="15448.700000047684" x="183.5">进阶</text></g></g><g id="minder_node2894" display="none"><g id="node_expander2890" display="none" style="cursor: pointer;"><path id="kity_path_29192" fill="white" stroke="gray" d="M179.5,15432.5A6,6,0,1,1,167.5,15432.5A6,6,0,1,1,179.5,15432.5"></path><path id="kity_path_29193" fill="none" stroke="gray"></path></g><path id="node_outline2891" fill="none" stroke="none" d="M167.5,15423.5h106a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-106a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2891" fill="black"><text id="kity_text_15453" text-rendering="inherit" font-size="12" dy=".8em" y="15424.700000047684" x="167.5">为什么使用solr集群</text></g></g><g id="minder_node2895" display="none"><g id="node_expander2891" display="none" style="cursor: pointer;"><path id="kity_path_29195" fill="white" stroke="gray" d="M179.5,15440.5A6,6,0,1,1,167.5,15440.5A6,6,0,1,1,179.5,15440.5"></path><path id="kity_path_29196" fill="none" stroke="gray"></path></g><path id="node_outline2892" fill="none" stroke="none" d="M167.5,15431.5h181a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-181a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2892" fill="black"><text id="kity_text_15455" text-rendering="inherit" font-size="12" dy=".8em" y="15432.700000047684" x="167.5">来的请求是怎么打在每一个片上的</text></g></g><g id="minder_node2896" display="none"><g id="node_expander2892" display="none" style="cursor: pointer;"><path id="kity_path_29198" fill="white" stroke="gray" d="M179.5,15448.5A6,6,0,1,1,167.5,15448.5A6,6,0,1,1,179.5,15448.5"></path><path id="kity_path_29199" fill="none" stroke="gray"></path></g><path id="node_outline2893" fill="none" stroke="none" d="M167.5,15439.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2893" fill="black"><text id="kity_text_15457" text-rendering="inherit" font-size="12" dy=".8em" y="15440.700000047684" x="167.5">怎么实现全量数据导入</text></g></g><g id="minder_node2897" display="none"><g id="node_expander2893" display="none" style="cursor: pointer;"><path id="kity_path_29201" fill="white" stroke="gray" d="M179.5,15456.5A6,6,0,1,1,167.5,15456.5A6,6,0,1,1,179.5,15456.5"></path><path id="kity_path_29202" fill="none" stroke="gray"></path></g><path id="node_outline2894" fill="none" stroke="none" d="M167.5,15447.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2894" fill="black"><text id="kity_text_15459" text-rendering="inherit" font-size="12" dy=".8em" y="15448.700000047684" x="167.5">怎么实现增量数据导入</text></g></g><g id="minder_node2898" display="none"><g id="node_expander2899" display="none" style="cursor: pointer;"><path id="kity_path_29219" fill="white" stroke="gray" d="M195.5,15464.5A6,6,0,1,1,183.5,15464.5A6,6,0,1,1,195.5,15464.5"></path><path id="kity_path_29220" fill="none" stroke="gray"></path></g><path id="node_outline2900" fill="none" stroke="none" d="M183.5,15455.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2900" fill="black"><text id="kity_text_15471" text-rendering="inherit" font-size="12" dy=".8em" y="15456.700000047684" x="183.5">场景</text></g></g><g id="minder_node2899" display="none"><g id="node_expander2896" display="none" style="cursor: pointer;"><path id="kity_path_29210" fill="white" stroke="gray" d="M179.5,15456.5A6,6,0,1,1,167.5,15456.5A6,6,0,1,1,179.5,15456.5"></path><path id="kity_path_29211" fill="none" stroke="gray"></path></g><path id="node_outline2897" fill="none" stroke="none" d="M167.5,15447.5h193a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-193a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2897" fill="black"><text id="kity_text_15465" text-rendering="inherit" font-size="12" dy=".8em" y="15448.700000047684" x="167.5">如果id的数量大，还是放map里面吗</text></g></g><g id="minder_node2900" display="none"><g id="node_expander2895" display="none" style="cursor: pointer;"><path id="kity_path_29207" fill="white" stroke="gray" d="M163.5,15456.5A6,6,0,1,1,151.5,15456.5A6,6,0,1,1,163.5,15456.5"></path><path id="kity_path_29208" fill="none" stroke="gray"></path></g><path id="node_outline2896" fill="none" stroke="none" d="M151.5,15447.5h62a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-62a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2896" fill="black"><text id="kity_text_15463" text-rendering="inherit" font-size="12" dy=".8em" y="15448.700000047684" x="151.5">使用字典树</text></g></g><g id="minder_node2901" display="none"><g id="node_expander2898" display="none" style="cursor: pointer;"><path id="kity_path_29216" fill="white" stroke="gray" d="M179.5,15464.5A6,6,0,1,1,167.5,15464.5A6,6,0,1,1,179.5,15464.5"></path><path id="kity_path_29217" fill="none" stroke="gray"></path></g><path id="node_outline2899" fill="none" stroke="none" d="M167.5,15455.5h74a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-74a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2899" fill="black"><text id="kity_text_15469" text-rendering="inherit" font-size="12" dy=".8em" y="15456.700000047684" x="167.5">什么是字典树</text></g></g><g id="minder_node2902" display="none"><g id="node_expander2897" display="none" style="cursor: pointer;"><path id="kity_path_29213" fill="white" stroke="gray" d="M163.5,15464.5A6,6,0,1,1,151.5,15464.5A6,6,0,1,1,163.5,15464.5"></path><path id="kity_path_29214" fill="none" stroke="gray"></path></g><path id="node_outline2898" fill="none" stroke="none" d="M151.5,15455.5h522a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-522a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2898" fill="black"><text id="kity_text_15467" text-rendering="inherit" font-size="12" dy=".8em" y="15456.700000047684" x="151.5">把词变成树，遍历树的每一个叶子节点，组成词，如果是一个词 就返回true，如果不是就返回false</text></g></g><g id="minder_node2903" display="none"><g id="node_expander2901" display="none" style="cursor: pointer;"><path id="kity_path_29225" fill="white" stroke="gray" d="M195.5,15472.5A6,6,0,1,1,183.5,15472.5A6,6,0,1,1,195.5,15472.5"></path><path id="kity_path_29226" fill="none" stroke="gray"></path></g><path id="node_outline2902" fill="none" stroke="none" d="M183.5,15463.5h86a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-86a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2902" fill="black"><text id="kity_text_15475" text-rendering="inherit" font-size="12" dy=".8em" y="15464.700000047684" x="183.5">优化和问题排查</text></g></g><g id="minder_node2904" display="none"><g id="node_expander2900" display="none" style="cursor: pointer;"><path id="kity_path_29222" fill="white" stroke="gray" d="M179.5,15472.5A6,6,0,1,1,167.5,15472.5A6,6,0,1,1,179.5,15472.5"></path><path id="kity_path_29223" fill="none" stroke="gray"></path></g><path id="node_outline2901" fill="none" stroke="none" d="M167.5,15463.5h110a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-110a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2901" fill="black"><text id="kity_text_15473" text-rendering="inherit" font-size="12" dy=".8em" y="15464.700000047684" x="167.5">有没有遇到什么问题</text></g></g><g id="minder_node2905"><g id="node_expander2936" style="cursor: pointer;"><path id="kity_path_29330" fill="white" stroke="gray" d="M317.5,15514.5A6,6,0,1,1,305.5,15514.5A6,6,0,1,1,317.5,15514.5"></path><path id="kity_path_29331" fill="none" stroke="gray" d="M307,15514.5L316,15514.5M311.5,15510L311.5,15519"></path></g><path id="node_outline2937" fill="rgb(239, 238, 246)" stroke="rgb(123, 115, 191)" d="M212.5,15501.5h89a3,3,0,0,1,3,3v20a3,3,0,0,1,-3,3h-89a3,3,0,0,1,-3,-3v-20a3,3,0,0,1,3,-3z" stroke-width="1"></path><g id="node_text2937" fill="black"><text id="kity_text_15572" text-rendering="inherit" font-size="14" dy=".8em" y="15505.400000095367" x="229.5">16.netty</text></g></g><g id="minder_node2906" display="none"><g id="node_expander2906" display="none" style="cursor: pointer;"><path id="kity_path_29240" fill="white" stroke="gray" d="M205.5,15474.5A6,6,0,1,1,193.5,15474.5A6,6,0,1,1,205.5,15474.5"></path><path id="kity_path_29241" fill="none" stroke="gray"></path></g><path id="node_outline2907" fill="none" stroke="none" d="M193.5,15465.5h23a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-23a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2907" fill="black"><text id="kity_text_15485" text-rendering="inherit" font-size="12" dy=".8em" y="15466.700000047684" x="193.5">NIO</text></g></g><g id="minder_node2907" display="none"><g id="node_expander2904" display="none" style="cursor: pointer;"><path id="kity_path_29234" fill="white" stroke="gray" d="M189.5,15466.5A6,6,0,1,1,177.5,15466.5A6,6,0,1,1,189.5,15466.5"></path><path id="kity_path_29235" fill="none" stroke="gray"></path></g><path id="node_outline2905" fill="none" stroke="none" d="M177.5,15457.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2905" fill="black"><text id="kity_text_15481" text-rendering="inherit" font-size="12" dy=".8em" y="15458.700000047684" x="177.5">基础</text></g></g><g id="minder_node2908" display="none"><g id="node_expander2905" display="none" style="cursor: pointer;"><path id="kity_path_29237" fill="white" stroke="gray" d="M189.5,15474.5A6,6,0,1,1,177.5,15474.5A6,6,0,1,1,189.5,15474.5"></path><path id="kity_path_29238" fill="none" stroke="gray"></path></g><path id="node_outline2906" fill="none" stroke="none" d="M177.5,15465.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2906" fill="black"><text id="kity_text_15483" text-rendering="inherit" font-size="12" dy=".8em" y="15466.700000047684" x="177.5">参考文章</text></g></g><g id="minder_node2909" display="none"><g id="node_expander2912" display="none" style="cursor: pointer;"><path id="kity_path_29258" fill="white" stroke="gray" d="M205.5,15482.5A6,6,0,1,1,193.5,15482.5A6,6,0,1,1,205.5,15482.5"></path><path id="kity_path_29259" fill="none" stroke="gray"></path></g><path id="node_outline2913" fill="none" stroke="none" d="M193.5,15473.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2913" fill="black"><text id="kity_text_15502" text-rendering="inherit" font-size="12" dy=".8em" y="15474.700000047684" x="193.5">基础</text></g></g><g id="minder_node2910" display="none"><g id="node_expander2908" display="none" style="cursor: pointer;"><path id="kity_path_29246" fill="white" stroke="gray" d="M189.5,15466.5A6,6,0,1,1,177.5,15466.5A6,6,0,1,1,189.5,15466.5"></path><path id="kity_path_29247" fill="none" stroke="gray"></path></g><path id="node_outline2909" fill="none" stroke="none" d="M177.5,15457.5h128a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-128a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2909" fill="black"><text id="kity_text_15491" text-rendering="inherit" font-size="12" dy=".8em" y="15458.700000047684" x="177.5">知道netty吗，简单说说</text></g></g><g id="minder_node2911" display="none"><g id="node_expander2907" display="none" style="cursor: pointer;"><path id="kity_path_29243" fill="white" stroke="gray" d="M173.5,15466.5A6,6,0,1,1,161.5,15466.5A6,6,0,1,1,173.5,15466.5"></path><path id="kity_path_29244" fill="none" stroke="gray"></path></g><path id="node_outline2908" fill="none" stroke="none" d="M161.5,15439.5h661a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-661a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2908" fill="black"><text id="kity_text_15487" text-rendering="inherit" font-size="12" dy=".8em" y="15440.700000047684" x="161.5">1.Netty是基于NIO的加强版的通信框架，他对NIO复杂的API进行再封装，解决NIO的BUG，比如epoll的空轮询，</text><text id="kity_text_15488" text-rendering="inherit" font-size="12" dy=".8em" y="15458.700000047684" x="161.5">提供高度可定制的线程模型。具备更高的性能和更大的吞吐量，使用零拷贝技术最小化不必要的内存复制，减少资源的消耗。</text><text id="kity_text_15489" text-rendering="inherit" font-size="12" dy=".8em" y="15476.700000047684" x="161.5">支持多种主流协议(支持 TCP、UDP、HTTP、WebSocket 等协议)；预置多种编解码功能，支持用户开发私有协议。</text></g></g><g id="minder_node2912" display="none"><g id="node_expander2910" display="none" style="cursor: pointer;"><path id="kity_path_29252" fill="white" stroke="gray" d="M189.5,15474.5A6,6,0,1,1,177.5,15474.5A6,6,0,1,1,189.5,15474.5"></path><path id="kity_path_29253" fill="none" stroke="gray"></path></g><path id="node_outline2911" fill="none" stroke="none" d="M177.5,15465.5h96a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-96a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2911" fill="black"><text id="kity_text_15498" text-rendering="inherit" font-size="12" dy=".8em" y="15466.700000047684" x="177.5">Netty 的各大组件</text></g></g><g id="minder_node2913" display="none"><g id="node_expander2909" display="none" style="cursor: pointer;"><path id="kity_path_29249" fill="white" stroke="gray" d="M173.5,15474.5A6,6,0,1,1,161.5,15474.5A6,6,0,1,1,173.5,15474.5"></path><path id="kity_path_29250" fill="none" stroke="gray"></path></g><path id="node_outline2910" fill="none" stroke="none" d="M161.5,15438.5h564a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-564a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text2910" fill="black"><text id="kity_text_15493" text-rendering="inherit" font-size="12" dy=".8em" y="15439.700000047684" x="161.5">1.Handler 组件 ChannelHandler 主要用来处理各种IO事件，并给下一个handler处理，形成一个责任链，</text><text id="kity_text_15494" text-rendering="inherit" font-size="12" dy=".8em" y="15457.700000047684" x="161.5">2.Pipeline 组件</text><text id="kity_text_15495" text-rendering="inherit" font-size="12" dy=".8em" y="15475.700000047684" x="161.5">3.EventLoopGroup 组件</text><text id="kity_text_15496" text-rendering="inherit" font-size="12" dy=".8em" y="15493.700000047684" x="161.5">4.ChannelFuture异步事件监听组件</text></g></g><g id="minder_node2914" display="none"><g id="node_expander2911" display="none" style="cursor: pointer;"><path id="kity_path_29255" fill="white" stroke="gray" d="M189.5,15482.5A6,6,0,1,1,177.5,15482.5A6,6,0,1,1,189.5,15482.5"></path><path id="kity_path_29256" fill="none" stroke="gray"></path></g><path id="node_outline2912" fill="none" stroke="none" d="M177.5,15473.5h114a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-114a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2912" fill="black"><text id="kity_text_15500" text-rendering="inherit" font-size="12" dy=".8em" y="15474.700000047684" x="177.5">netty为什么效率高？</text></g></g><g id="minder_node2915" display="none"><g id="node_expander2922" display="none" style="cursor: pointer;"><path id="kity_path_29288" fill="white" stroke="gray" d="M205.5,15490.5A6,6,0,1,1,193.5,15490.5A6,6,0,1,1,205.5,15490.5"></path><path id="kity_path_29289" fill="none" stroke="gray"></path></g><path id="node_outline2923" fill="none" stroke="none" d="M193.5,15481.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2923" fill="black"><text id="kity_text_15535" text-rendering="inherit" font-size="12" dy=".8em" y="15482.700000047684" x="193.5">进阶</text></g></g><g id="minder_node2916" display="none"><g id="node_expander2917" display="none" style="cursor: pointer;"><path id="kity_path_29273" fill="white" stroke="gray" d="M189.5,15474.5A6,6,0,1,1,177.5,15474.5A6,6,0,1,1,189.5,15474.5"></path><path id="kity_path_29274" fill="none" stroke="gray"></path></g><path id="node_outline2918" fill="none" stroke="none" d="M177.5,15465.5h127a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-127a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2918" fill="black"><text id="kity_text_15525" text-rendering="inherit" font-size="12" dy=".8em" y="15466.700000047684" x="177.5">知道netty的线程模型吗</text></g></g><g id="minder_node2917" display="none"><g id="node_expander2916" display="none" style="cursor: pointer;"><path id="kity_path_29270" fill="white" stroke="gray" d="M173.5,15474.5A6,6,0,1,1,161.5,15474.5A6,6,0,1,1,173.5,15474.5"></path><path id="kity_path_29271" fill="none" stroke="gray"></path></g><path id="node_outline2917" fill="none" stroke="none" d="M161.5,15348.5h1064a5,5,0,0,1,5,5v242a5,5,0,0,1,-5,5h-1064a5,5,0,0,1,-5,-5v-242a5,5,0,0,1,5,-5z"></path><g id="node_text2917" fill="black"><text id="kity_text_15510" text-rendering="inherit" font-size="12" dy=".8em" y="15349.700000047684" x="161.5">1.单 Reactor 单线程模式</text><text id="kity_text_15511" text-rendering="inherit" font-size="12" dy=".8em" y="15367.700000047684" x="161.5">reactor通过select监听客户端请求事件，收到事件之后通过dispactch分发，如果是创建连接的请求就给Acceptor调用accept处理，如果是不是就给Handler处理完成read业务处理 到send的完整流程，</text><text id="kity_text_15512" text-rendering="inherit" font-size="12" dy=".8em" y="15385.700000047684" x="161.5">优点：没有多线程、进程通信、竞争的问题，一个线程完成所有的事件响应和业务处理</text><text id="kity_text_15513" text-rendering="inherit" font-size="12" dy=".8em" y="15403.700000047684" x="161.5">缺点：单线程处理容易导致性能瓶颈，可靠性问题线程停止导致不可用，</text><text id="kity_text_15514" text-rendering="inherit" font-size="12" dy=".8em" y="15421.700000047684" x="161.5">场景：客户端的数量有限，业务处理非常快速</text><text id="kity_text_15515" text-rendering="inherit" font-size="12" dy=".8em" y="15439.700000047684" x="161.5">2.单 Reactor 多线程模式</text><text id="kity_text_15516" text-rendering="inherit" font-size="12" dy=".8em" y="15457.700000047684" x="161.5">Reactor通过seelct去监听客户端请求，收到后通过dispactor分发，</text><text id="kity_text_15517" text-rendering="inherit" font-size="12" dy=".8em" y="15475.700000047684" x="161.5">如果是创建连接就给Acceptor处理，如果不是就给Handler处理，但是Handler只响应，业务处理通过调用Worker线程池去分配线程处理，处理完把结果返回给Handler，然后Handler响应结果。</text><text id="kity_text_15518" text-rendering="inherit" font-size="12" dy=".8em" y="15493.700000047684" x="161.5">优点：充分利用多核 cpu，缺点是多线程数据共享和控制比较复杂，Reactor 处理所有的事件的监听和响应，在单线程中运行，面对高并发场景还是容易出现性能瓶颈。</text><text id="kity_text_15519" text-rendering="inherit" font-size="12" dy=".8em" y="15511.700000047684" x="161.5">3.主从 Reactor 多线程模式(一个主可以有多个从)&#xa0; 解决单Reactor面对高并发性能瓶颈的缺陷，</text><text id="kity_text_15520" text-rendering="inherit" font-size="12" dy=".8em" y="15529.700000047684" x="161.5">主从 Reactor 多线程模式让 Reactor 在多个线程中运行分成 MainReactor 线程与 SubReactor 线程</text><text id="kity_text_15521" text-rendering="inherit" font-size="12" dy=".8em" y="15547.700000047684" x="161.5">主Reactor 只负责监听客户端连接请求，然后给Accept处理,和客户端建立连接之后将连接交由 从Reactor 监听后面的 IO 事件；</text><text id="kity_text_15522" text-rendering="inherit" font-size="12" dy=".8em" y="15565.700000047684" x="161.5">从把这些连接放入自己的队列去监听，然后创建Handler去处理这些连接的事件；Handler负责从连接read数据 给Worker线程池分配线程去处理，并接受处理结果 把响应send给客户端</text><text id="kity_text_15523" text-rendering="inherit" font-size="12" dy=".8em" y="15583.700000047684" x="161.5">优点：职责明确(主只需要接收新连接，从完成后续的业务处理；并且主把连接给从，从不需要响应) 缺点：复杂</text></g></g><g id="minder_node2918" display="none"><g id="node_expander2913" display="none" style="cursor: pointer;"><path id="kity_path_29261" fill="white" stroke="gray" d="M157.5,15458.5A6,6,0,1,1,145.5,15458.5A6,6,0,1,1,157.5,15458.5"></path><path id="kity_path_29262" fill="none" stroke="gray"></path></g><path id="node_outline2914" fill="none" stroke="none" d="M70.5,15312.5h200a5,5,0,0,1,5,5v145a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-145a5,5,0,0,1,5,-5z"></path><g id="node_text2914" fill="black"><text id="kity_text_15504" text-rendering="inherit" font-size="12" dy=".8em" y="15450.700000047684" x="145.5">分支主题</text></g><image id="kity_image_17094" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210509001636.png" x="70.5" y="15315.5" width="200" height="132"></image></g><g id="minder_node2919" display="none"><g id="node_expander2914" display="none" style="cursor: pointer;"><path id="kity_path_29264" fill="white" stroke="gray" d="M157.5,15466.5A6,6,0,1,1,145.5,15466.5A6,6,0,1,1,157.5,15466.5"></path><path id="kity_path_29265" fill="none" stroke="gray"></path></g><path id="node_outline2915" fill="none" stroke="none" d="M70.5,15260.5h200a5,5,0,0,1,5,5v205a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-205a5,5,0,0,1,5,-5z"></path><g id="node_text2915" fill="black"><text id="kity_text_15506" text-rendering="inherit" font-size="12" dy=".8em" y="15458.700000047684" x="145.5">分支主题</text></g><image id="kity_image_17095" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210509001713.png" x="70.5" y="15263.5" width="200" height="192"></image></g><g id="minder_node2920" display="none"><g id="node_expander2915" display="none" style="cursor: pointer;"><path id="kity_path_29267" fill="white" stroke="gray" d="M157.5,15474.5A6,6,0,1,1,145.5,15474.5A6,6,0,1,1,157.5,15474.5"></path><path id="kity_path_29268" fill="none" stroke="gray"></path></g><path id="node_outline2916" fill="none" stroke="none" d="M74.5,15260.5h192a5,5,0,0,1,5,5v213a5,5,0,0,1,-5,5h-192a5,5,0,0,1,-5,-5v-213a5,5,0,0,1,5,-5z"></path><g id="node_text2916" fill="black"><text id="kity_text_15508" text-rendering="inherit" font-size="12" dy=".8em" y="15466.700000047684" x="145.5">分支主题</text></g><image id="kity_image_17096" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210509001741.png" x="74.5" y="15263.5" width="192" height="200"></image></g><g id="minder_node2921" display="none"><g id="node_expander2920" display="none" style="cursor: pointer;"><path id="kity_path_29282" fill="white" stroke="gray" d="M189.5,15482.5A6,6,0,1,1,177.5,15482.5A6,6,0,1,1,189.5,15482.5"></path><path id="kity_path_29283" fill="none" stroke="gray"></path></g><path id="node_outline2921" fill="none" stroke="none" d="M177.5,15473.5h164a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-164a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2921" fill="black"><text id="kity_text_15531" text-rendering="inherit" font-size="12" dy=".8em" y="15474.700000047684" x="177.5">简单说说netty的内部执行流程</text></g></g><g id="minder_node2922" display="none"><g id="node_expander2919" display="none" style="cursor: pointer;"><path id="kity_path_29279" fill="white" stroke="gray" d="M173.5,15482.5A6,6,0,1,1,161.5,15482.5A6,6,0,1,1,173.5,15482.5"></path><path id="kity_path_29280" fill="none" stroke="gray"></path></g><path id="node_outline2920" fill="none" stroke="none" d="M161.5,15473.5h901a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-901a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2920" fill="black"><text id="kity_text_15529" text-rendering="inherit" font-size="12" dy=".8em" y="15474.700000047684" x="161.5">数据在基于 Netty 的服务器或客户端中的处理流程是：读取数据--&gt;解码数据--&gt;处理数据--&gt;编码数据--&gt;发送数据。其中的每个过程都用得到 ChannelHandler 责任链。</text></g></g><g id="minder_node2923" display="none"><g id="node_expander2918" display="none" style="cursor: pointer;"><path id="kity_path_29276" fill="white" stroke="gray" d="M157.5,15482.5A6,6,0,1,1,145.5,15482.5A6,6,0,1,1,157.5,15482.5"></path><path id="kity_path_29277" fill="none" stroke="gray"></path></g><path id="node_outline2919" fill="none" stroke="none" d="M70.5,15326.5h200a5,5,0,0,1,5,5v155a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-155a5,5,0,0,1,5,-5z"></path><g id="node_text2919" fill="black"><text id="kity_text_15527" text-rendering="inherit" font-size="12" dy=".8em" y="15474.700000047684" x="145.5">分支主题</text></g><image id="kity_image_17097" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210509004249.png" x="70.5" y="15329.5" width="200" height="142"></image></g><g id="minder_node2924" display="none"><g id="node_expander2921" display="none" style="cursor: pointer;"><path id="kity_path_29285" fill="white" stroke="gray" d="M189.5,15490.5A6,6,0,1,1,177.5,15490.5A6,6,0,1,1,189.5,15490.5"></path><path id="kity_path_29286" fill="none" stroke="gray"></path></g><path id="node_outline2922" fill="none" stroke="none" d="M177.5,15481.5h91a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-91a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2922" fill="black"><text id="kity_text_15533" text-rendering="inherit" font-size="12" dy=".8em" y="15482.700000047684" x="177.5">netty的重连实现</text></g></g><g id="minder_node2925" display="none"><g id="node_expander2929" display="none" style="cursor: pointer;"><path id="kity_path_29309" fill="white" stroke="gray" d="M205.5,15498.5A6,6,0,1,1,193.5,15498.5A6,6,0,1,1,205.5,15498.5"></path><path id="kity_path_29310" fill="none" stroke="gray"></path></g><path id="node_outline2930" fill="none" stroke="none" d="M193.5,15489.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2930" fill="black"><text id="kity_text_15551" text-rendering="inherit" font-size="12" dy=".8em" y="15490.700000047684" x="193.5">场景</text></g></g><g id="minder_node2926" display="none"><g id="node_expander2923" display="none" style="cursor: pointer;"><path id="kity_path_29291" fill="white" stroke="gray" d="M189.5,15474.5A6,6,0,1,1,177.5,15474.5A6,6,0,1,1,189.5,15474.5"></path><path id="kity_path_29292" fill="none" stroke="gray"></path></g><path id="node_outline2924" fill="none" stroke="none" d="M177.5,15465.5h90a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-90a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2924" fill="black"><text id="kity_text_15537" text-rendering="inherit" font-size="12" dy=".8em" y="15466.700000047684" x="177.5">为什么现在netty</text></g></g><g id="minder_node2927" display="none"><g id="node_expander2924" display="none" style="cursor: pointer;"><path id="kity_path_29294" fill="white" stroke="gray" d="M189.5,15482.5A6,6,0,1,1,177.5,15482.5A6,6,0,1,1,189.5,15482.5"></path><path id="kity_path_29295" fill="none" stroke="gray"></path></g><path id="node_outline2925" fill="none" stroke="none" d="M177.5,15473.5h140a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-140a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2925" fill="black"><text id="kity_text_15539" text-rendering="inherit" font-size="12" dy=".8em" y="15474.700000047684" x="177.5">项目中netty主要是用在哪</text></g></g><g id="minder_node2928" display="none"><g id="node_expander2927" display="none" style="cursor: pointer;"><path id="kity_path_29303" fill="white" stroke="gray" d="M189.5,15490.5A6,6,0,1,1,177.5,15490.5A6,6,0,1,1,189.5,15490.5"></path><path id="kity_path_29304" fill="none" stroke="gray"></path></g><path id="node_outline2928" fill="none" stroke="none" d="M177.5,15481.5h63a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-63a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2928" fill="black"><text id="kity_text_15547" text-rendering="inherit" font-size="12" dy=".8em" y="15482.700000047684" x="177.5">linux零拷贝</text></g></g><g id="minder_node2929" display="none"><g id="node_expander2926" display="none" style="cursor: pointer;"><path id="kity_path_29300" fill="white" stroke="gray" d="M173.5,15490.5A6,6,0,1,1,161.5,15490.5A6,6,0,1,1,173.5,15490.5"></path><path id="kity_path_29301" fill="none" stroke="gray"></path></g><path id="node_outline2927" fill="none" stroke="none" d="M161.5,15463.5h1038a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1038a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2927" fill="black"><text id="kity_text_15543" text-rendering="inherit" font-size="12" dy=".8em" y="15464.700000047684" x="161.5">1.linux2.4 操作系统层面从磁盘拷贝数据到内核缓冲区，底层网卡直接从内核缓冲区读取数据发送，不经过socket缓冲区。在用户空间内存中的数据拷贝为0，经历一次用户内核切换，两次数据拷贝</text><text id="kity_text_15544" text-rendering="inherit" font-size="12" dy=".8em" y="15482.700000047684" x="161.5">零拷贝适合小文件传输，因为占内核缓冲区</text><text id="kity_text_15545" text-rendering="inherit" font-size="12" dy=".8em" y="15500.700000047684" x="161.5">2.在linux中函数是sendFile&#xa0; java中是transderTo</text></g></g><g id="minder_node2930" display="none"><g id="node_expander2925" display="none" style="cursor: pointer;"><path id="kity_path_29297" fill="white" stroke="gray" d="M157.5,15490.5A6,6,0,1,1,145.5,15490.5A6,6,0,1,1,157.5,15490.5"></path><path id="kity_path_29298" fill="none" stroke="gray"></path></g><path id="node_outline2926" fill="none" stroke="none" d="M70.5,15396.5h200a5,5,0,0,1,5,5v93a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-93a5,5,0,0,1,5,-5z"></path><g id="node_text2926" fill="black"><text id="kity_text_15541" text-rendering="inherit" font-size="12" dy=".8em" y="15482.700000047684" x="145.5">分支主题</text></g><image id="kity_image_17098" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/image-20210508221842632.png" x="70.5" y="15399.5" width="200" height="80"></image></g><g id="minder_node2931" display="none"><g id="node_expander2928" display="none" style="cursor: pointer;"><path id="kity_path_29306" fill="white" stroke="gray" d="M189.5,15498.5A6,6,0,1,1,177.5,15498.5A6,6,0,1,1,189.5,15498.5"></path><path id="kity_path_29307" fill="none" stroke="gray"></path></g><path id="node_outline2929" fill="none" stroke="none" d="M177.5,15489.5h140a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-140a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2929" fill="black"><text id="kity_text_15549" text-rendering="inherit" font-size="12" dy=".8em" y="15490.700000047684" x="177.5">说说netty的零拷贝的实现</text></g></g><g id="minder_node2932" display="none"><g id="node_expander2933" display="none" style="cursor: pointer;"><path id="kity_path_29321" fill="white" stroke="gray" d="M205.5,15506.5A6,6,0,1,1,193.5,15506.5A6,6,0,1,1,205.5,15506.5"></path><path id="kity_path_29322" fill="none" stroke="gray"></path></g><path id="node_outline2934" fill="none" stroke="none" d="M193.5,15497.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2934" fill="black"><text id="kity_text_15561" text-rendering="inherit" font-size="12" dy=".8em" y="15498.700000047684" x="193.5">问题排查和优化</text></g></g><g id="minder_node2933" display="none"><g id="node_expander2932" display="none" style="cursor: pointer;"><path id="kity_path_29318" fill="white" stroke="gray" d="M189.5,15506.5A6,6,0,1,1,177.5,15506.5A6,6,0,1,1,189.5,15506.5"></path><path id="kity_path_29319" fill="none" stroke="gray"></path></g><path id="node_outline2933" fill="none" stroke="none" d="M177.5,15497.5h206a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-206a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2933" fill="black"><text id="kity_text_15559" text-rendering="inherit" font-size="12" dy=".8em" y="15498.700000047684" x="177.5">TCP 粘包/拆包的原因及netty解决方法</text></g></g><g id="minder_node2934" display="none"><g id="node_expander2931" display="none" style="cursor: pointer;"><path id="kity_path_29315" fill="white" stroke="gray" d="M173.5,15506.5A6,6,0,1,1,161.5,15506.5A6,6,0,1,1,173.5,15506.5"></path><path id="kity_path_29316" fill="none" stroke="gray"></path></g><path id="node_outline2932" fill="none" stroke="none" d="M161.5,15479.5h1101a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1101a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2932" fill="black"><text id="kity_text_15555" text-rendering="inherit" font-size="12" dy=".8em" y="15480.700000047684" x="161.5">1.客户端在发送数据包的时候，每个包都固定长度，比如1024个字节大小，如果客户端发送的数据长度不足1024个字节，则通过补充空格的方式补全到指定长度；Netty提供的FixedLengthFrameDecoder</text><text id="kity_text_15556" text-rendering="inherit" font-size="12" dy=".8em" y="15498.700000047684" x="161.5">2.将消息分为头部和消息体，在头部中保存有当前整个消息的长度，只有在读取到足够长度的消息之后才算是读到了一个完整的消息；Netyy提供了LengthFieldBasedFrameDecoder与LengthFieldPrepender</text><text id="kity_text_15557" text-rendering="inherit" font-size="12" dy=".8em" y="15516.700000047684" x="161.5">3.使用开源的 高效的序列化框架Google Protocol 来进行编解码 任何定义自己的&#xa0; 然后在netty中 添加 显式指定解码器需要解码成什么类型。</text></g></g><g id="minder_node2935" display="none"><g id="node_expander2930" display="none" style="cursor: pointer;"><path id="kity_path_29312" fill="white" stroke="gray" d="M157.5,15506.5A6,6,0,1,1,145.5,15506.5A6,6,0,1,1,157.5,15506.5"></path><path id="kity_path_29313" fill="none" stroke="gray"></path></g><path id="node_outline2931" fill="none" stroke="none" d="M145.5,15497.5h326a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2931" fill="black"><text id="kity_text_15553" text-rendering="inherit" font-size="12" dy=".8em" y="15498.700000047684" x="145.5">https://juejin.cn/post/6844903651652141070#heading-2</text></g></g><g id="minder_node2936" display="none"><g id="node_expander2935" display="none" style="cursor: pointer;"><path id="kity_path_29327" fill="white" stroke="gray" d="M205.5,15514.5A6,6,0,1,1,193.5,15514.5A6,6,0,1,1,205.5,15514.5"></path><path id="kity_path_29328" fill="none" stroke="gray"></path></g><path id="node_outline2936" fill="none" stroke="none" d="M193.5,15505.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2936" fill="black"><text id="kity_text_15570" text-rendering="inherit" font-size="12" dy=".8em" y="15506.700000047684" x="193.5">参考文章</text></g></g><g id="minder_node2937" display="none"><g id="node_expander2934" display="none" style="cursor: pointer;"><path id="kity_path_29324" fill="white" stroke="gray" d="M189.5,15514.5A6,6,0,1,1,177.5,15514.5A6,6,0,1,1,189.5,15514.5"></path><path id="kity_path_29325" fill="none" stroke="gray"></path></g><path id="node_outline2935" fill="none" stroke="none" d="M177.5,15460.5h334a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-334a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text2935" fill="black"><text id="kity_text_15563" text-rendering="inherit" font-size="12" dy=".8em" y="15461.700000047684" x="177.5">https://juejin.cn/post/6919486248599945224#heading-6</text><text id="kity_text_15564" text-rendering="inherit" font-size="12" dy=".8em" y="15479.700000047684" x="177.5">https://juejin.cn/post/6919486634710794254#heading-2</text><text id="kity_text_15565" text-rendering="inherit" font-size="12" dy=".8em" y="15497.700000047684" x="177.5">https://juejin.cn/post/6844904000496599054#heading-14</text><text id="kity_text_15566" text-rendering="inherit" font-size="12" dy=".8em" y="15515.700000047684" x="177.5">https://juejin.cn/post/6844903792442343438#heading-7</text><text id="kity_text_15567" text-rendering="inherit" font-size="12" dy=".8em" y="15533.700000047684" x="177.5">https://juejin.cn/post/6844903957127495687</text><text id="kity_text_15568" text-rendering="inherit" font-size="12" dy=".8em" y="15551.700000047684" x="177.5">https://juejin.cn/post/6859923833038569486#heading-23</text></g></g><g id="minder_node2938"><g id="node_expander2987" style="cursor: pointer;"><path id="kity_path_29483" fill="white" stroke="gray" d="M317.5,15556.5A6,6,0,1,1,305.5,15556.5A6,6,0,1,1,317.5,15556.5"></path><path id="kity_path_29484" fill="none" stroke="gray" d="M307,15556.5L316,15556.5M311.5,15552L311.5,15561"></path></g><path id="node_outline2988" fill="rgb(239, 238, 246)" stroke="rgb(123, 115, 191)" d="M176.5,15543.5h125a3,3,0,0,1,3,3v20a3,3,0,0,1,-3,3h-125a3,3,0,0,1,-3,-3v-20a3,3,0,0,1,3,-3z" stroke-width="1"></path><g id="node_text2988" fill="black"><text id="kity_text_15743" text-rendering="inherit" font-size="14" dy=".8em" y="15547.400000095367" x="193.5">17.zookeeper</text></g></g><g id="minder_node2939" display="none"><g id="node_expander2940" display="none" style="cursor: pointer;"><path id="kity_path_29342" fill="white" stroke="gray" d="M169.5,15524.5A6,6,0,1,1,157.5,15524.5A6,6,0,1,1,169.5,15524.5"></path><path id="kity_path_29343" fill="none" stroke="gray"></path></g><path id="node_outline2941" fill="none" stroke="none" d="M157.5,15515.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2941" fill="black"><text id="kity_text_15584" text-rendering="inherit" font-size="12" dy=".8em" y="15516.700000047684" x="157.5">基础</text></g></g><g id="minder_node2940" display="none"><g id="node_expander2937" display="none" style="cursor: pointer;"><path id="kity_path_29333" fill="white" stroke="gray" d="M153.5,15516.5A6,6,0,1,1,141.5,15516.5A6,6,0,1,1,153.5,15516.5"></path><path id="kity_path_29334" fill="none" stroke="gray"></path></g><path id="node_outline2938" fill="none" stroke="none" d="M141.5,15507.5h98a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-98a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2938" fill="black"><text id="kity_text_15574" text-rendering="inherit" font-size="12" dy=".8em" y="15508.700000047684" x="141.5">zookeeper是什么</text></g></g><g id="minder_node2941" display="none"><g id="node_expander2939" display="none" style="cursor: pointer;"><path id="kity_path_29339" fill="white" stroke="gray" d="M153.5,15524.5A6,6,0,1,1,141.5,15524.5A6,6,0,1,1,153.5,15524.5"></path><path id="kity_path_29340" fill="none" stroke="gray"></path></g><path id="node_outline2940" fill="none" stroke="none" d="M141.5,15515.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2940" fill="black"><text id="kity_text_15582" text-rendering="inherit" font-size="12" dy=".8em" y="15516.700000047684" x="141.5">zookeeper的数据结构</text></g></g><g id="minder_node2942" display="none"><g id="node_expander2938" display="none" style="cursor: pointer;"><path id="kity_path_29336" fill="white" stroke="gray" d="M137.5,15524.5A6,6,0,1,1,125.5,15524.5A6,6,0,1,1,137.5,15524.5"></path><path id="kity_path_29337" fill="none" stroke="gray"></path></g><path id="node_outline2939" fill="none" stroke="none" d="M125.5,15479.5h945a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-945a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text2939" fill="black"><text id="kity_text_15576" text-rendering="inherit" font-size="12" dy=".8em" y="15480.700000047684" x="125.5">1.ZK的数据结构是znode和文件系统目录差不多，能够自由的增加、删除znode，在一个znode下增加、删除子znode，并且znode是可以存储数据的。默认有四种类型的znode：</text><text id="kity_text_15577" text-rendering="inherit" font-size="12" dy=".8em" y="15498.700000047684" x="125.5">持久化目录节点 PERSISTENT：客户端与zookeeper断开连接后，该节点依旧存在。除非手动删除，</text><text id="kity_text_15578" text-rendering="inherit" font-size="12" dy=".8em" y="15516.700000047684" x="125.5">临时目录节点 EPHEMERAL：客户端与zookeeper断开连接后，该节点被删除。</text><text id="kity_text_15579" text-rendering="inherit" font-size="12" dy=".8em" y="15534.700000047684" x="125.5">持久顺序节点：和持久节点差不多，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</text><text id="kity_text_15580" text-rendering="inherit" font-size="12" dy=".8em" y="15552.700000047684" x="125.5">临时顺序节点&#xa0; 和临时节点特性差不多 增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</text></g></g><g id="minder_node2943" display="none"><g id="node_expander2975" display="none" style="cursor: pointer;"><path id="kity_path_29447" fill="white" stroke="gray" d="M169.5,15532.5A6,6,0,1,1,157.5,15532.5A6,6,0,1,1,169.5,15532.5"></path><path id="kity_path_29448" fill="none" stroke="gray"></path></g><path id="node_outline2976" fill="none" stroke="none" d="M157.5,15523.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2976" fill="black"><text id="kity_text_15713" text-rendering="inherit" font-size="12" dy=".8em" y="15524.700000047684" x="157.5">进阶</text></g></g><g id="minder_node2944" display="none"><g id="node_expander2943" display="none" style="cursor: pointer;"><path id="kity_path_29351" fill="white" stroke="gray" d="M153.5,15396.5A6,6,0,1,1,141.5,15396.5A6,6,0,1,1,153.5,15396.5"></path><path id="kity_path_29352" fill="none" stroke="gray"></path></g><path id="node_outline2944" fill="none" stroke="none" d="M141.5,15387.5h148a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-148a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2944" fill="black"><text id="kity_text_15603" text-rendering="inherit" font-size="12" dy=".8em" y="15388.700000047684" x="141.5">ZK怎么实现分布式锁知道吗</text></g></g><g id="minder_node2945" display="none"><g id="node_expander2942" display="none" style="cursor: pointer;"><path id="kity_path_29348" fill="white" stroke="gray" d="M137.5,15396.5A6,6,0,1,1,125.5,15396.5A6,6,0,1,1,137.5,15396.5"></path><path id="kity_path_29349" fill="none" stroke="gray"></path></g><path id="node_outline2943" fill="none" stroke="none" d="M125.5,15288.5h739a5,5,0,0,1,5,5v206a5,5,0,0,1,-5,5h-739a5,5,0,0,1,-5,-5v-206a5,5,0,0,1,5,-5z"></path><g id="node_text2943" fill="black"><text id="kity_text_15590" text-rendering="inherit" font-size="12" dy=".8em" y="15289.700000047684" x="125.5">1.acuire加锁</text><text id="kity_text_15591" text-rendering="inherit" font-size="12" dy=".8em" y="15307.700000047684" x="125.5">以某个资源为目录，然后这个目录下面的节点就是我们需要获取锁的客户端，未获取到锁的客户端注册需要注册Watcher到上一个客户端。&#xa0;&#xa0;</text><text id="kity_text_15592" text-rendering="inherit" font-size="12" dy=".8em" y="15325.700000047684" x="125.5">如 加锁的目录/lock。lock 下面的/resource_name是我们锁定的资源 再下面节点是按照我们加锁的顺序排列。</text><text id="kity_text_15593" text-rendering="inherit" font-size="12" dy=".8em" y="15343.700000047684" x="125.5">在zookeeper指定节点（locks）下创建临时顺序节点node_n</text><text id="kity_text_15594" text-rendering="inherit" font-size="12" dy=".8em" y="15361.700000047684" x="125.5">获取locks下所有子节点children</text><text id="kity_text_15595" text-rendering="inherit" font-size="12" dy=".8em" y="15379.700000047684" x="125.5">对子节点按节点自增序号从小到大排序判断本节点是不是第一个子节点，</text><text id="kity_text_15596" text-rendering="inherit" font-size="12" dy=".8em" y="15397.700000047684" x="125.5">若是，则获取锁；若不是 证明前面已经有人获取到锁了，则监听比该节点小的那个节点的删除事件</text><text id="kity_text_15597" text-rendering="inherit" font-size="12" dy=".8em" y="15415.700000047684" x="125.5">若监听事件生效，则重新获取节点所有字节点进行判断，直到获取到锁</text><text id="kity_text_15598" text-rendering="inherit" font-size="12" dy=".8em" y="15433.700000047684" x="125.5">2.release解锁</text><text id="kity_text_15599" text-rendering="inherit" font-size="12" dy=".8em" y="15451.700000047684" x="125.5">首先进行可重入锁的判定:如果有可重入锁只需要次数减1即可，</text><text id="kity_text_15600" text-rendering="inherit" font-size="12" dy=".8em" y="15469.700000047684" x="125.5">如果-1后为0就删除当前节点。然后删除threadDataMap里面的可重入锁的数据。</text><text id="kity_text_15601" text-rendering="inherit" font-size="12" dy=".8em" y="15487.700000047684" x="125.5">如果不为0就直接返回</text></g></g><g id="minder_node2946" display="none"><g id="node_expander2941" display="none" style="cursor: pointer;"><path id="kity_path_29345" fill="white" stroke="gray" d="M121.5,15396.5A6,6,0,1,1,109.5,15396.5A6,6,0,1,1,121.5,15396.5"></path><path id="kity_path_29346" fill="none" stroke="gray"></path></g><path id="node_outline2942" fill="none" stroke="none" d="M109.5,15369.5h333a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2942" fill="black"><text id="kity_text_15586" text-rendering="inherit" font-size="12" dy=".8em" y="15370.700000047684" x="109.5">https://juejin.cn/post/6844903612913549326</text><text id="kity_text_15587" text-rendering="inherit" font-size="12" dy=".8em" y="15388.700000047684" x="109.5">https://juejin.cn/post/6844903688088059912#heading-12</text><text id="kity_text_15588" text-rendering="inherit" font-size="12" dy=".8em" y="15406.700000047684" x="109.5">https://juejin.cn/post/6844904110995537927#heading-15</text></g></g><g id="minder_node2947" display="none"><g id="node_expander2945" display="none" style="cursor: pointer;"><path id="kity_path_29357" fill="white" stroke="gray" d="M153.5,15404.5A6,6,0,1,1,141.5,15404.5A6,6,0,1,1,153.5,15404.5"></path><path id="kity_path_29358" fill="none" stroke="gray"></path></g><path id="node_outline2946" fill="none" stroke="none" d="M141.5,15395.5h204a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-204a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2946" fill="black"><text id="kity_text_15613" text-rendering="inherit" font-size="12" dy=".8em" y="15396.700000047684" x="141.5">继续同上， 加锁 解锁 锁超时，优缺点</text></g></g><g id="minder_node2948" display="none"><g id="node_expander2944" display="none" style="cursor: pointer;"><path id="kity_path_29354" fill="white" stroke="gray" d="M137.5,15404.5A6,6,0,1,1,125.5,15404.5A6,6,0,1,1,137.5,15404.5"></path><path id="kity_path_29355" fill="none" stroke="gray"></path></g><path id="node_outline2945" fill="none" stroke="none" d="M125.5,15341.5h937a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-937a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text2945" fill="black"><text id="kity_text_15605" text-rendering="inherit" font-size="12" dy=".8em" y="15342.700000047684" x="125.5">1.加锁解锁如上</text><text id="kity_text_15606" text-rendering="inherit" font-size="12" dy=".8em" y="15360.700000047684" x="125.5">2.锁超时</text><text id="kity_text_15607" text-rendering="inherit" font-size="12" dy=".8em" y="15378.700000047684" x="125.5">Zookeeper不需要配置锁超时，由于我们设置节点是临时节点，我们的每个机器维护着一个ZK的session，通过这个session，ZK可以判断机器是否宕机。</text><text id="kity_text_15608" text-rendering="inherit" font-size="12" dy=".8em" y="15396.700000047684" x="125.5">如果我们的机器挂掉的话，那么这个临时节点对应的就会被删除，所以我们不需要关心锁超时。</text><text id="kity_text_15609" text-rendering="inherit" font-size="12" dy=".8em" y="15414.700000047684" x="125.5">3.优缺点：&#xa0;</text><text id="kity_text_15610" text-rendering="inherit" font-size="12" dy=".8em" y="15432.700000047684" x="125.5">ZK不需要关心锁超时的问题，有现成的第三方jar包，而且支持读写锁，利用节点的前缀区分读锁还是写锁，其次ZK获取锁会按照加锁的顺序。对于高可用利用ZK集群进行保证。</text><text id="kity_text_15611" text-rendering="inherit" font-size="12" dy=".8em" y="15450.700000047684" x="125.5">ZK需要额外维护，增加维护成本，而且现在ali有篇文章说并不推荐ZK做注册中心。强一致性性能可能并不是其它的实现</text></g></g><g id="minder_node2949" display="none"><g id="node_expander2947" display="none" style="cursor: pointer;"><path id="kity_path_29363" fill="white" stroke="gray" d="M153.5,15412.5A6,6,0,1,1,141.5,15412.5A6,6,0,1,1,153.5,15412.5"></path><path id="kity_path_29364" fill="none" stroke="gray"></path></g><path id="node_outline2948" fill="none" stroke="none" d="M141.5,15403.5h149a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-149a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2948" fill="black"><text id="kity_text_15619" text-rendering="inherit" font-size="12" dy=".8em" y="15404.700000047684" x="141.5">说说zookeeper的选举机制&#xa0;</text></g></g><g id="minder_node2950" display="none"><g id="node_expander2946" display="none" style="cursor: pointer;"><path id="kity_path_29360" fill="white" stroke="gray" d="M137.5,15412.5A6,6,0,1,1,125.5,15412.5A6,6,0,1,1,137.5,15412.5"></path><path id="kity_path_29361" fill="none" stroke="gray"></path></g><path id="node_outline2947" fill="none" stroke="none" d="M125.5,15385.5h716a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-716a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2947" fill="black"><text id="kity_text_15615" text-rendering="inherit" font-size="12" dy=".8em" y="15386.700000047684" x="125.5">1.投票必须在同一轮次中进行，如果Follower服务选举轮次不同，不采纳。</text><text id="kity_text_15616" text-rendering="inherit" font-size="12" dy=".8em" y="15404.700000047684" x="125.5">2.数据最新的节点优先成为Leader，数据的新旧使用事务ID判定，事务ID越大认为节点数据约接近Leader的数据，自然应该成为Leader</text><text id="kity_text_15617" text-rendering="inherit" font-size="12" dy=".8em" y="15422.700000047684" x="125.5">3.事务ID一样，再使用server.id做比较。server.id是节点在集群中唯一的id，myid文件中配置。</text></g></g><g id="minder_node2951" display="none"><g id="node_expander2951" display="none" style="cursor: pointer;"><path id="kity_path_29375" fill="white" stroke="gray" d="M153.5,15420.5A6,6,0,1,1,141.5,15420.5A6,6,0,1,1,153.5,15420.5"></path><path id="kity_path_29376" fill="none" stroke="gray"></path></g><path id="node_outline2952" fill="none" stroke="none" d="M141.5,15411.5h61a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-61a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2952" fill="black"><text id="kity_text_15641" text-rendering="inherit" font-size="12" dy=".8em" y="15412.700000047684" x="141.5">选举过程？</text></g></g><g id="minder_node2952" display="none"><g id="node_expander2950" display="none" style="cursor: pointer;"><path id="kity_path_29372" fill="white" stroke="gray" d="M137.5,15420.5A6,6,0,1,1,125.5,15420.5A6,6,0,1,1,137.5,15420.5"></path><path id="kity_path_29373" fill="none" stroke="gray"></path></g><path id="node_outline2951" fill="none" stroke="none" d="M125.5,15303.5h1179a5,5,0,0,1,5,5v224a5,5,0,0,1,-5,5h-1179a5,5,0,0,1,-5,-5v-224a5,5,0,0,1,5,-5z"></path><g id="node_text2951" fill="black"><text id="kity_text_15627" text-rendering="inherit" font-size="12" dy=".8em" y="15304.700000047684" x="125.5">1.选举涉及的三个角色也是三种状态 Lead（事务唯一调度和处理者）&#xa0; follower（处理非事务请求，转发事务请求给 Leader，参与选举投票）&#xa0;&#xa0;</text><text id="kity_text_15628" text-rendering="inherit" font-size="12" dy=".8em" y="15322.700000047684" x="125.5">observer(观察者，处理非事务请求，事务请求转Leader，不参与投票，来提高集群事务处理能力的) 还有一种状态； LOOKING：无leader时 寻找Leader的状态。</text><text id="kity_text_15629" text-rendering="inherit" font-size="12" dy=".8em" y="15340.700000047684" x="125.5">2.投票的原则就是 有新选新，先选事务id大的，再选id大的，目到是保持数据最全；</text><text id="kity_text_15630" text-rendering="inherit" font-size="12" dy=".8em" y="15358.700000047684" x="125.5">3.启动时Leader选举</text><text id="kity_text_15631" text-rendering="inherit" font-size="12" dy=".8em" y="15376.700000047684" x="125.5">每一机器都给自己一票；主要服务器ID的值，值越大选举权重越大；投票数过半，选举结束。</text><text id="kity_text_15632" text-rendering="inherit" font-size="12" dy=".8em" y="15394.700000047684" x="125.5">(1)一开始 前面的节点都是选自己，但不够半数，下一轮继续；直到有大id的加入以后 并且够半 再发起一轮投票，其它加点选他为leader，此时其它已启动的server为follow；</text><text id="kity_text_15633" text-rendering="inherit" font-size="12" dy=".8em" y="15412.700000047684" x="125.5">后续节点继续启动，然后开启新的一轮投票都选自己，但因为leader follow 已经出来了，半数原则 选自己也没用，之前的leader还是leader；只到最后一个节点加入投完票以后，leader还是之前的leader，其它的都是foller</text><text id="kity_text_15634" text-rendering="inherit" font-size="12" dy=".8em" y="15430.700000047684" x="125.5">4.运行时Leader选举-一开始走ZAB恢复模式，新Leader选出前会暂停对外服务</text><text id="kity_text_15635" text-rendering="inherit" font-size="12" dy=".8em" y="15448.700000047684" x="125.5">一开始server都投自己，投票信息是id和事务id；然后每一个节点广播自己的投票信息，推举自己为Leader；</text><text id="kity_text_15636" text-rendering="inherit" font-size="12" dy=".8em" y="15466.700000047684" x="125.5">其它节点收到消息以后&#xa0; 把自己的和收到的比较(ZXID大者胜出，ZXID相同，则ID大者胜出) ；</text><text id="kity_text_15637" text-rendering="inherit" font-size="12" dy=".8em" y="15484.700000047684" x="125.5">然后统计投票，超过半数的节点收到同样的投票信息，就可以确定leader，注意epoch(zxid高16位表示leader周期，低16表示事务id)的增加跟同步；</text><text id="kity_text_15638" text-rendering="inherit" font-size="12" dy=".8em" y="15502.700000047684" x="125.5">然后节点从looking状态变follow 或者leader，然后follow连接上并和leader比较自己最后的zxid，要么回滚 要么和leader同步，保持事务一致；</text><text id="kity_text_15639" text-rendering="inherit" font-size="12" dy=".8em" y="15520.700000047684" x="125.5">然后集群恢复到广播模式，开始接受客户端的写请求。</text></g></g><g id="minder_node2953" display="none"><g id="node_expander2948" display="none" style="cursor: pointer;"><path id="kity_path_29366" fill="white" stroke="gray" d="M121.5,15412.5A6,6,0,1,1,109.5,15412.5A6,6,0,1,1,121.5,15412.5"></path><path id="kity_path_29367" fill="none" stroke="gray"></path></g><path id="node_outline2949" fill="none" stroke="none" d="M109.5,15385.5h333a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2949" fill="black"><text id="kity_text_15621" text-rendering="inherit" font-size="12" dy=".8em" y="15386.700000047684" x="109.5">https://juejin.cn/post/6844903825023696903</text><text id="kity_text_15622" text-rendering="inherit" font-size="12" dy=".8em" y="15404.700000047684" x="109.5">https://juejin.cn/post/6844904200409726989#heading-29</text><text id="kity_text_15623" text-rendering="inherit" font-size="12" dy=".8em" y="15422.700000047684" x="109.5">https://juejin.cn/post/6919487002417037319#heading-16</text></g></g><g id="minder_node2954" display="none"><g id="node_expander2949" display="none" style="cursor: pointer;"><path id="kity_path_29369" fill="white" stroke="gray" d="M121.5,15420.5A6,6,0,1,1,109.5,15420.5A6,6,0,1,1,121.5,15420.5"></path><path id="kity_path_29370" fill="none" stroke="gray"></path></g><path id="node_outline2950" fill="none" stroke="none" d="M38.5,15206.5h193a5,5,0,0,1,5,5v213a5,5,0,0,1,-5,5h-193a5,5,0,0,1,-5,-5v-213a5,5,0,0,1,5,-5z"></path><g id="node_text2950" fill="black"><text id="kity_text_15625" text-rendering="inherit" font-size="12" dy=".8em" y="15412.700000047684" x="109.5">分支主题</text></g><image id="kity_image_17099" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210509095751.png" x="38.5" y="15209.5" width="193" height="200"></image></g><g id="minder_node2955" display="none"><g id="node_expander2953" display="none" style="cursor: pointer;"><path id="kity_path_29381" fill="white" stroke="gray" d="M153.5,15428.5A6,6,0,1,1,141.5,15428.5A6,6,0,1,1,153.5,15428.5"></path><path id="kity_path_29382" fill="none" stroke="gray"></path></g><path id="node_outline2954" fill="none" stroke="none" d="M141.5,15419.5h146a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-146a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2954" fill="black"><text id="kity_text_15646" text-rendering="inherit" font-size="12" dy=".8em" y="15420.700000047684" x="141.5">zookeeper的选举算法说说</text></g></g><g id="minder_node2956" display="none"><g id="node_expander2952" display="none" style="cursor: pointer;"><path id="kity_path_29378" fill="white" stroke="gray" d="M137.5,15428.5A6,6,0,1,1,125.5,15428.5A6,6,0,1,1,137.5,15428.5"></path><path id="kity_path_29379" fill="none" stroke="gray"></path></g><path id="node_outline2953" fill="none" stroke="none" d="M125.5,15410.5h277a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-277a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2953" fill="black"><text id="kity_text_15643" text-rendering="inherit" font-size="12" dy=".8em" y="15411.700000047684" x="125.5">1.集群刚启动以server id 大为准</text><text id="kity_text_15644" text-rendering="inherit" font-size="12" dy=".8em" y="15429.700000047684" x="125.5">2.集群运行崩溃恢复已 zxid大为准，相同就server id</text></g></g><g id="minder_node2957" display="none"><g id="node_expander2956" display="none" style="cursor: pointer;"><path id="kity_path_29390" fill="white" stroke="gray" d="M153.5,15436.5A6,6,0,1,1,141.5,15436.5A6,6,0,1,1,153.5,15436.5"></path><path id="kity_path_29391" fill="none" stroke="gray"></path></g><path id="node_outline2957" fill="none" stroke="none" d="M141.5,15427.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2957" fill="black"><text id="kity_text_15657" text-rendering="inherit" font-size="12" dy=".8em" y="15428.700000047684" x="141.5">数据同步过程？</text></g></g><g id="minder_node2958" display="none"><g id="node_expander2955" display="none" style="cursor: pointer;"><path id="kity_path_29387" fill="white" stroke="gray" d="M137.5,15436.5A6,6,0,1,1,125.5,15436.5A6,6,0,1,1,137.5,15436.5"></path><path id="kity_path_29388" fill="none" stroke="gray"></path></g><path id="node_outline2956" fill="none" stroke="none" d="M125.5,15382.5h1111a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1111a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text2956" fill="black"><text id="kity_text_15650" text-rendering="inherit" font-size="12" dy=".8em" y="15383.700000047684" x="125.5">1.完成 Leader 选举之后，Follower 和 Observer 向Leader 服务器进行注册完成以后。进入数据同步环节。</text><text id="kity_text_15651" text-rendering="inherit" font-size="12" dy=".8em" y="15401.700000047684" x="125.5">整体流程就是： 1.向leader注册；2.数据同步；3.同步确认</text><text id="kity_text_15652" text-rendering="inherit" font-size="12" dy=".8em" y="15419.700000047684" x="125.5">新Leader把本地快照加载到内存，并通过日志应用快照之后的所有事务，确保Leader数据库和日志是最新的；</text><text id="kity_text_15653" text-rendering="inherit" font-size="12" dy=".8em" y="15437.700000047684" x="125.5">Follower和Observer把自身的ZXID和Leader的ZXID进行比较，确定每个节点的同步策略(是全量还是差异化同步，还是说flow有lead没有的，flow先回滚再差异化同步)；根据策略 Leader把数据同步到各节点；</text><text id="kity_text_15654" text-rendering="inherit" font-size="12" dy=".8em" y="15455.700000047684" x="125.5">每个节点同步结束后，Leader向节点发送NEWLEADER指令；同步完成的Follower节点返回ACK；当Leader收到过半ACK时，认为同步完成；</text><text id="kity_text_15655" text-rendering="inherit" font-size="12" dy=".8em" y="15473.700000047684" x="125.5">Leader向Follower节点发送UPTODATE指令，通知集群同步完成，开始对外服务。</text></g></g><g id="minder_node2959" display="none"><g id="node_expander2954" display="none" style="cursor: pointer;"><path id="kity_path_29384" fill="white" stroke="gray" d="M121.5,15436.5A6,6,0,1,1,109.5,15436.5A6,6,0,1,1,121.5,15436.5"></path><path id="kity_path_29385" fill="none" stroke="gray"></path></g><path id="node_outline2955" fill="none" stroke="none" d="M109.5,15427.5h333a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2955" fill="black"><text id="kity_text_15648" text-rendering="inherit" font-size="12" dy=".8em" y="15428.700000047684" x="109.5">https://juejin.cn/post/6844904200409726989#heading-30</text></g></g><g id="minder_node2960" display="none"><g id="node_expander2958" display="none" style="cursor: pointer;"><path id="kity_path_29396" fill="white" stroke="gray" d="M153.5,15444.5A6,6,0,1,1,141.5,15444.5A6,6,0,1,1,153.5,15444.5"></path><path id="kity_path_29397" fill="none" stroke="gray"></path></g><path id="node_outline2959" fill="none" stroke="none" d="M141.5,15435.5h111a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-111a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2959" fill="black"><text id="kity_text_15666" text-rendering="inherit" font-size="12" dy=".8em" y="15436.700000047684" x="141.5">ZK的ZAB协议了解吗</text></g></g><g id="minder_node2961" display="none"><g id="node_expander2957" display="none" style="cursor: pointer;"><path id="kity_path_29393" fill="white" stroke="gray" d="M137.5,15444.5A6,6,0,1,1,125.5,15444.5A6,6,0,1,1,137.5,15444.5"></path><path id="kity_path_29394" fill="none" stroke="gray"></path></g><path id="node_outline2958" fill="none" stroke="none" d="M125.5,15390.5h1258a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-1258a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text2958" fill="black"><text id="kity_text_15659" text-rendering="inherit" font-size="12" dy=".8em" y="15391.700000047684" x="125.5">1.ZK 能够保证数据一致性主要依赖于 ZAB 协议的消息广播，崩溃恢复和数据同步三个过程。ZAB 协议包括两种基本的模式：崩溃恢复和消息广播。</text><text id="kity_text_15660" text-rendering="inherit" font-size="12" dy=".8em" y="15409.700000047684" x="125.5">2.当 ZK 集群刚刚启动或者 Leader 服务器宕机、重启或者网络故障导致不存在过半的服务器与 Leader 服务器保持正常通信时，所有节点进入崩溃恢复模式；</text><text id="kity_text_15661" text-rendering="inherit" font-size="12" dy=".8em" y="15427.700000047684" x="125.5">首先选举产生新的 Leader 服务器，然后集群中 Follower 服务器开始与新的 Leader 服务器进行数据同步，当集群中超过半数机器与该 Leader服务器完成数据同步之后，退出恢复模式；</text><text id="kity_text_15662" text-rendering="inherit" font-size="12" dy=".8em" y="15445.700000047684" x="125.5">进入消息广播模式(相当于一个2PC来完成事务的顺序一致性)，Leader 服务器开始接收客户端的事务请求生成事物提案来进行事务请求处理。</text><text id="kity_text_15663" text-rendering="inherit" font-size="12" dy=".8em" y="15463.700000047684" x="125.5">这个处理过程主要是 为写请求生成一个新事务并有一个zxid，然后通过leader与每一个flow之间的FIFO队列 传给flow，flow收到以后先持久化，完成再返回ack通过queue给leader；只要收到过半的flow ack&#xa0; leader就发送commit命令 ；</text><text id="kity_text_15664" text-rendering="inherit" font-size="12" dy=".8em" y="15481.700000047684" x="125.5">flow收到commit 先看这个事务的zxid是不是把历史队列中所有任务的zxid要小，如果小就commit ,如果大就等待 让小的先提交(保持顺序性)</text></g></g><g id="minder_node2962" display="none"><g id="node_expander2960" display="none" style="cursor: pointer;"><path id="kity_path_29402" fill="white" stroke="gray" d="M153.5,15452.5A6,6,0,1,1,141.5,15452.5A6,6,0,1,1,153.5,15452.5"></path><path id="kity_path_29403" fill="none" stroke="gray"></path></g><path id="node_outline2961" fill="none" stroke="none" d="M141.5,15443.5h60a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-60a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2961" fill="black"><text id="kity_text_15674" text-rendering="inherit" font-size="12" dy=".8em" y="15444.700000047684" x="141.5">ZAB的特点</text></g></g><g id="minder_node2963" display="none"><g id="node_expander2959" display="none" style="cursor: pointer;"><path id="kity_path_29399" fill="white" stroke="gray" d="M137.5,15452.5A6,6,0,1,1,125.5,15452.5A6,6,0,1,1,137.5,15452.5"></path><path id="kity_path_29400" fill="none" stroke="gray"></path></g><path id="node_outline2960" fill="none" stroke="none" d="M125.5,15407.5h818a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-818a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text2960" fill="black"><text id="kity_text_15668" text-rendering="inherit" font-size="12" dy=".8em" y="15408.700000047684" x="125.5">1.zab的特点就是 ：一致性(如果一个事务 A 被一个server提交了，那么它最终一定会被所有的server提交)</text><text id="kity_text_15669" text-rendering="inherit" font-size="12" dy=".8em" y="15426.700000047684" x="125.5">全局有序: 有一台server先执行A再执行B，那么可以保证所有server上A始终都被在B之前执行;如果发送者在事务A提交之后再发送B,那么B必将在A之后执行</text><text id="kity_text_15670" text-rendering="inherit" font-size="12" dy=".8em" y="15444.700000047684" x="125.5">高可用：只要大多数（法定数量）节点启动，系统就行正常运行</text><text id="kity_text_15671" text-rendering="inherit" font-size="12" dy=".8em" y="15462.700000047684" x="125.5">可恢复：当节点下线后重启，它必须保证能恢复到当前正在执行的事务</text><text id="kity_text_15672" text-rendering="inherit" font-size="12" dy=".8em" y="15480.700000047684" x="125.5">丢弃那些只在 Leader 提出/复制，但没有提交的事务。</text></g></g><g id="minder_node2964" display="none"><g id="node_expander2961" display="none" style="cursor: pointer;"><path id="kity_path_29405" fill="white" stroke="gray" d="M153.5,15460.5A6,6,0,1,1,141.5,15460.5A6,6,0,1,1,153.5,15460.5"></path><path id="kity_path_29406" fill="none" stroke="gray"></path></g><path id="node_outline2962" fill="none" stroke="none" d="M141.5,15451.5h86a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-86a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2962" fill="black"><text id="kity_text_15676" text-rendering="inherit" font-size="12" dy=".8em" y="15452.700000047684" x="141.5">说说数据一致性</text></g></g><g id="minder_node2965" display="none"><g id="node_expander2962" display="none" style="cursor: pointer;"><path id="kity_path_29408" fill="white" stroke="gray" d="M153.5,15468.5A6,6,0,1,1,141.5,15468.5A6,6,0,1,1,153.5,15468.5"></path><path id="kity_path_29409" fill="none" stroke="gray"></path></g><path id="node_outline2963" fill="none" stroke="none" d="M141.5,15459.5h62a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-62a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2963" fill="black"><text id="kity_text_15678" text-rendering="inherit" font-size="12" dy=".8em" y="15460.700000047684" x="141.5">顺序一致性</text></g></g><g id="minder_node2966" display="none"><g id="node_expander2963" display="none" style="cursor: pointer;"><path id="kity_path_29411" fill="white" stroke="gray" d="M153.5,15476.5A6,6,0,1,1,141.5,15476.5A6,6,0,1,1,153.5,15476.5"></path><path id="kity_path_29412" fill="none" stroke="gray"></path></g><path id="node_outline2964" fill="none" stroke="none" d="M141.5,15467.5h62a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-62a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2964" fill="black"><text id="kity_text_15680" text-rendering="inherit" font-size="12" dy=".8em" y="15468.700000047684" x="141.5">最终一致性</text></g></g><g id="minder_node2967" display="none"><g id="node_expander2966" display="none" style="cursor: pointer;"><path id="kity_path_29420" fill="white" stroke="gray" d="M153.5,15484.5A6,6,0,1,1,141.5,15484.5A6,6,0,1,1,153.5,15484.5"></path><path id="kity_path_29421" fill="none" stroke="gray"></path></g><path id="node_outline2967" fill="none" stroke="none" d="M141.5,15475.5h101a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-101a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2967" fill="black"><text id="kity_text_15688" text-rendering="inherit" font-size="12" dy=".8em" y="15476.700000047684" x="141.5">知道ZK的监听器吧</text></g></g><g id="minder_node2968" display="none"><g id="node_expander2965" display="none" style="cursor: pointer;"><path id="kity_path_29417" fill="white" stroke="gray" d="M137.5,15484.5A6,6,0,1,1,125.5,15484.5A6,6,0,1,1,137.5,15484.5"></path><path id="kity_path_29418" fill="none" stroke="gray"></path></g><path id="node_outline2966" fill="none" stroke="none" d="M125.5,15457.5h1224a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1224a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text2966" fill="black"><text id="kity_text_15684" text-rendering="inherit" font-size="12" dy=".8em" y="15458.700000047684" x="125.5">1. 给Znode 注册绑定一个 Watcher 监听事件。当服务端的一些指定事件触发了这个 Watcher，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，然后客户端根据 Watcher 通知状态和事件类型做出业务上的改变。</text><text id="kity_text_15685" text-rendering="inherit" font-size="12" dy=".8em" y="15476.700000047684" x="125.5">工作机制为&#xa0; 客户端(服务提供者)注册watcher&#xa0; 然后服务端(服务消费者)处理 然后客户端回调&#xa0;</text><text id="kity_text_15686" text-rendering="inherit" font-size="12" dy=".8em" y="15494.700000047684" x="125.5">2.可以监听节点数据变更、节点删除、子节点状态变更等事件，通过这个事件机制，可以基于 Zookeeper 实现分布式锁、集群管理等功能。</text></g></g><g id="minder_node2969" display="none"><g id="node_expander2964" display="none" style="cursor: pointer;"><path id="kity_path_29414" fill="white" stroke="gray" d="M121.5,15484.5A6,6,0,1,1,109.5,15484.5A6,6,0,1,1,121.5,15484.5"></path><path id="kity_path_29415" fill="none" stroke="gray"></path></g><path id="node_outline2965" fill="none" stroke="none" d="M34.5,15412.5h200a5,5,0,0,1,5,5v71a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-71a5,5,0,0,1,5,-5z"></path><g id="node_text2965" fill="black"><text id="kity_text_15682" text-rendering="inherit" font-size="12" dy=".8em" y="15476.700000047684" x="109.5">分支主题</text></g><image id="kity_image_17100" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210511021951.png" x="34.5" y="15415.5" width="200" height="58"></image></g><g id="minder_node2970" display="none"><g id="node_expander2968" display="none" style="cursor: pointer;"><path id="kity_path_29426" fill="white" stroke="gray" d="M153.5,15492.5A6,6,0,1,1,141.5,15492.5A6,6,0,1,1,153.5,15492.5"></path><path id="kity_path_29427" fill="none" stroke="gray"></path></g><path id="node_outline2969" fill="none" stroke="none" d="M141.5,15483.5h96a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-96a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2969" fill="black"><text id="kity_text_15696" text-rendering="inherit" font-size="12" dy=".8em" y="15484.700000047684" x="141.5">watch有哪些特性</text></g></g><g id="minder_node2971" display="none"><g id="node_expander2967" display="none" style="cursor: pointer;"><path id="kity_path_29423" fill="white" stroke="gray" d="M137.5,15492.5A6,6,0,1,1,125.5,15492.5A6,6,0,1,1,137.5,15492.5"></path><path id="kity_path_29424" fill="none" stroke="gray"></path></g><path id="node_outline2968" fill="none" stroke="none" d="M125.5,15447.5h881a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-881a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text2968" fill="black"><text id="kity_text_15690" text-rendering="inherit" font-size="12" dy=".8em" y="15448.700000047684" x="125.5">1.一次性：watcher是一次性 触发就被移除，再次使用需要注册。监听的客户端很多情况下，一些频繁更新的节点变化都需要不断地通知所有消费者 给服务器太大压力;</text><text id="kity_text_15691" text-rendering="inherit" font-size="12" dy=".8em" y="15466.700000047684" x="125.5">如果还要继续监听这个节点，就需要我们在客户端的监听回调中，再次对节点的监听watch事件设置为True。否则客户端只能接收到一次该节点的变更通知。</text><text id="kity_text_15692" text-rendering="inherit" font-size="12" dy=".8em" y="15484.700000047684" x="125.5">客户端顺序回调：回调串行同步的过程</text><text id="kity_text_15693" text-rendering="inherit" font-size="12" dy=".8em" y="15502.700000047684" x="125.5">轻量：watch通知比较简单，只告诉发送了事情，不会告诉你发生了什么内容</text><text id="kity_text_15694" text-rendering="inherit" font-size="12" dy=".8em" y="15520.700000047684" x="125.5">可能会丢，如果挂了，需要重新注册，之前的会丢</text></g></g><g id="minder_node2972" display="none"><g id="node_expander2970" display="none" style="cursor: pointer;"><path id="kity_path_29432" fill="white" stroke="gray" d="M153.5,15500.5A6,6,0,1,1,141.5,15500.5A6,6,0,1,1,153.5,15500.5"></path><path id="kity_path_29433" fill="none" stroke="gray"></path></g><path id="node_outline2971" fill="none" stroke="none" d="M141.5,15491.5h113a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-113a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2971" fill="black"><text id="kity_text_15703" text-rendering="inherit" font-size="12" dy=".8em" y="15492.700000047684" x="141.5">说说ZK的监听器原理</text></g></g><g id="minder_node2973" display="none"><g id="node_expander2969" display="none" style="cursor: pointer;"><path id="kity_path_29429" fill="white" stroke="gray" d="M137.5,15500.5A6,6,0,1,1,125.5,15500.5A6,6,0,1,1,137.5,15500.5"></path><path id="kity_path_29430" fill="none" stroke="gray"></path></g><path id="node_outline2970" fill="none" stroke="none" d="M125.5,15464.5h1242a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1242a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text2970" fill="black"><text id="kity_text_15698" text-rendering="inherit" font-size="12" dy=".8em" y="15465.700000047684" x="125.5">watch一般有&#xa0; 基于 znode的 watch 触发条件 get set exists create 和&#xa0; 基于znode的孩子节点 的watch&#xa0; 触发条件有 getChildren&#xa0; create</text><text id="kity_text_15699" text-rendering="inherit" font-size="12" dy=".8em" y="15483.700000047684" x="125.5">1.主线程中创建Zookeeper客户端，会创建两个线程，一个负责网络连接通信(connet)，一个负责监听(listener)。</text><text id="kity_text_15700" text-rendering="inherit" font-size="12" dy=".8em" y="15501.700000047684" x="125.5">通过connect线程将注册的监听事件发送给Zookeeper服务端；在Zookeeper服务端的注册监听器列表中将注册的监听事件添加到WatcherManager 列表中；Zookeeper监听到有数据或路径变化，就会将这个消息发送给listener线程。</text><text id="kity_text_15701" text-rendering="inherit" font-size="12" dy=".8em" y="15519.700000047684" x="125.5">listener线程内部调用了process()方法来触发Watcher；然后客户端回调，接收事件通知然后处理</text></g></g><g id="minder_node2974" display="none"><g id="node_expander2971" display="none" style="cursor: pointer;"><path id="kity_path_29435" fill="white" stroke="gray" d="M153.5,15508.5A6,6,0,1,1,141.5,15508.5A6,6,0,1,1,153.5,15508.5"></path><path id="kity_path_29436" fill="none" stroke="gray"></path></g><path id="node_outline2972" fill="none" stroke="none" d="M141.5,15499.5h76a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-76a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2972" fill="black"><text id="kity_text_15705" text-rendering="inherit" font-size="12" dy=".8em" y="15500.700000047684" x="141.5">ZK怎么加节点</text></g></g><g id="minder_node2975" display="none"><g id="node_expander2972" display="none" style="cursor: pointer;"><path id="kity_path_29438" fill="white" stroke="gray" d="M153.5,15516.5A6,6,0,1,1,141.5,15516.5A6,6,0,1,1,153.5,15516.5"></path><path id="kity_path_29439" fill="none" stroke="gray"></path></g><path id="node_outline2973" fill="none" stroke="none" d="M141.5,15507.5h122a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-122a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2973" fill="black"><text id="kity_text_15707" text-rendering="inherit" font-size="12" dy=".8em" y="15508.700000047684" x="141.5">ZK的paxos原理了解吗</text></g></g><g id="minder_node2976" display="none"><g id="node_expander2973" display="none" style="cursor: pointer;"><path id="kity_path_29441" fill="white" stroke="gray" d="M153.5,15524.5A6,6,0,1,1,141.5,15524.5A6,6,0,1,1,153.5,15524.5"></path><path id="kity_path_29442" fill="none" stroke="gray"></path></g><path id="node_outline2974" fill="none" stroke="none" d="M141.5,15515.5h108a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-108a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2974" fill="black"><text id="kity_text_15709" text-rendering="inherit" font-size="12" dy=".8em" y="15516.700000047684" x="141.5">ZK的raft协议了解吗</text></g></g><g id="minder_node2977" display="none"><g id="node_expander2974" display="none" style="cursor: pointer;"><path id="kity_path_29444" fill="white" stroke="gray" d="M153.5,15532.5A6,6,0,1,1,141.5,15532.5A6,6,0,1,1,153.5,15532.5"></path><path id="kity_path_29445" fill="none" stroke="gray"></path></g><path id="node_outline2975" fill="none" stroke="none" d="M141.5,15523.5h116a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-116a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2975" fill="black"><text id="kity_text_15711" text-rendering="inherit" font-size="12" dy=".8em" y="15524.700000047684" x="141.5">了解raft算法的流程吗</text></g></g><g id="minder_node2978" display="none"><g id="node_expander2979" display="none" style="cursor: pointer;"><path id="kity_path_29459" fill="white" stroke="gray" d="M169.5,15540.5A6,6,0,1,1,157.5,15540.5A6,6,0,1,1,169.5,15540.5"></path><path id="kity_path_29460" fill="none" stroke="gray"></path></g><path id="node_outline2980" fill="none" stroke="none" d="M157.5,15531.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2980" fill="black"><text id="kity_text_15721" text-rendering="inherit" font-size="12" dy=".8em" y="15532.700000047684" x="157.5">集群架构</text></g></g><g id="minder_node2979" display="none"><g id="node_expander2978" display="none" style="cursor: pointer;"><path id="kity_path_29456" fill="white" stroke="gray" d="M153.5,15540.5A6,6,0,1,1,141.5,15540.5A6,6,0,1,1,153.5,15540.5"></path><path id="kity_path_29457" fill="none" stroke="gray"></path></g><path id="node_outline2979" fill="none" stroke="none" d="M141.5,15531.5h197a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-197a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2979" fill="black"><text id="kity_text_15719" text-rendering="inherit" font-size="12" dy=".8em" y="15532.700000047684" x="141.5">ZooKeeper的脑裂的出现和解决方案</text></g></g><g id="minder_node2980" display="none"><g id="node_expander2977" display="none" style="cursor: pointer;"><path id="kity_path_29453" fill="white" stroke="gray" d="M137.5,15540.5A6,6,0,1,1,125.5,15540.5A6,6,0,1,1,137.5,15540.5"></path><path id="kity_path_29454" fill="none" stroke="gray"></path></g><path id="node_outline2978" fill="none" stroke="none" d="M125.5,15531.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2978" fill="black"><text id="kity_text_15717" text-rendering="inherit" font-size="12" dy=".8em" y="15532.700000047684" x="125.5">分支主题</text></g></g><g id="minder_node2981" display="none"><g id="node_expander2976" display="none" style="cursor: pointer;"><path id="kity_path_29450" fill="white" stroke="gray" d="M121.5,15540.5A6,6,0,1,1,109.5,15540.5A6,6,0,1,1,121.5,15540.5"></path><path id="kity_path_29451" fill="none" stroke="gray"></path></g><path id="node_outline2977" fill="none" stroke="none" d="M109.5,15531.5h296a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-296a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2977" fill="black"><text id="kity_text_15715" text-rendering="inherit" font-size="12" dy=".8em" y="15532.700000047684" x="109.5">https://www.cnblogs.com/sweet6/p/10574574.html</text></g></g><g id="minder_node2982" display="none"><g id="node_expander2984" display="none" style="cursor: pointer;"><path id="kity_path_29474" fill="white" stroke="gray" d="M169.5,15548.5A6,6,0,1,1,157.5,15548.5A6,6,0,1,1,169.5,15548.5"></path><path id="kity_path_29475" fill="none" stroke="gray"></path></g><path id="node_outline2985" fill="none" stroke="none" d="M157.5,15539.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2985" fill="black"><text id="kity_text_15731" text-rendering="inherit" font-size="12" dy=".8em" y="15540.700000047684" x="157.5">场景</text></g></g><g id="minder_node2983" display="none"><g id="node_expander2981" display="none" style="cursor: pointer;"><path id="kity_path_29465" fill="white" stroke="gray" d="M153.5,15532.5A6,6,0,1,1,141.5,15532.5A6,6,0,1,1,153.5,15532.5"></path><path id="kity_path_29466" fill="none" stroke="gray"></path></g><path id="node_outline2982" fill="none" stroke="none" d="M141.5,15523.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2982" fill="black"><text id="kity_text_15725" text-rendering="inherit" font-size="12" dy=".8em" y="15524.700000047684" x="141.5">知道zookeeper的应用场景吗</text></g></g><g id="minder_node2984" display="none"><g id="node_expander2980" display="none" style="cursor: pointer;"><path id="kity_path_29462" fill="white" stroke="gray" d="M137.5,15532.5A6,6,0,1,1,125.5,15532.5A6,6,0,1,1,137.5,15532.5"></path><path id="kity_path_29463" fill="none" stroke="gray"></path></g><path id="node_outline2981" fill="none" stroke="none" d="M125.5,15523.5h303a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-303a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2981" fill="black"><text id="kity_text_15723" text-rendering="inherit" font-size="12" dy=".8em" y="15524.700000047684" x="125.5">1.分布式锁，配置管理，分布式注册中心，数据发布/订阅</text></g></g><g id="minder_node2985" display="none"><g id="node_expander2982" display="none" style="cursor: pointer;"><path id="kity_path_29468" fill="white" stroke="gray" d="M153.5,15540.5A6,6,0,1,1,141.5,15540.5A6,6,0,1,1,153.5,15540.5"></path><path id="kity_path_29469" fill="none" stroke="gray"></path></g><path id="node_outline2983" fill="none" stroke="none" d="M141.5,15531.5h193a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-193a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2983" fill="black"><text id="kity_text_15727" text-rendering="inherit" font-size="12" dy=".8em" y="15532.700000047684" x="141.5">zk除了做注册中心还有什么使用场景</text></g></g><g id="minder_node2986" display="none"><g id="node_expander2983" display="none" style="cursor: pointer;"><path id="kity_path_29471" fill="white" stroke="gray" d="M153.5,15548.5A6,6,0,1,1,141.5,15548.5A6,6,0,1,1,153.5,15548.5"></path><path id="kity_path_29472" fill="none" stroke="gray"></path></g><path id="node_outline2984" fill="none" stroke="none" d="M141.5,15539.5h136a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-136a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2984" fill="black"><text id="kity_text_15729" text-rendering="inherit" font-size="12" dy=".8em" y="15540.700000047684" x="141.5">ZK的节点宕机如何处理？</text></g></g><g id="minder_node2987" display="none"><g id="node_expander2986" display="none" style="cursor: pointer;"><path id="kity_path_29480" fill="white" stroke="gray" d="M169.5,15556.5A6,6,0,1,1,157.5,15556.5A6,6,0,1,1,169.5,15556.5"></path><path id="kity_path_29481" fill="none" stroke="gray"></path></g><path id="node_outline2987" fill="none" stroke="none" d="M157.5,15547.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2987" fill="black"><text id="kity_text_15741" text-rendering="inherit" font-size="12" dy=".8em" y="15548.700000047684" x="157.5">参考文章</text></g></g><g id="minder_node2988" display="none"><g id="node_expander2985" display="none" style="cursor: pointer;"><path id="kity_path_29477" fill="white" stroke="gray" d="M153.5,15556.5A6,6,0,1,1,141.5,15556.5A6,6,0,1,1,153.5,15556.5"></path><path id="kity_path_29478" fill="none" stroke="gray"></path></g><path id="node_outline2986" fill="none" stroke="none" d="M141.5,15493.5h333a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text2986" fill="black"><text id="kity_text_15733" text-rendering="inherit" font-size="12" dy=".8em" y="15494.700000047684" x="141.5">https://juejin.cn/post/6844903976719106056#heading-2</text><text id="kity_text_15734" text-rendering="inherit" font-size="12" dy=".8em" y="15512.700000047684" x="141.5">https://juejin.cn/post/6844904110995537927#heading-10</text><text id="kity_text_15735" text-rendering="inherit" font-size="12" dy=".8em" y="15530.700000047684" x="141.5">https://juejin.cn/post/6844904047309225991#heading-8</text><text id="kity_text_15736" text-rendering="inherit" font-size="12" dy=".8em" y="15548.700000047684" x="141.5">https://juejin.cn/post/6844903984814096398#heading-8</text><text id="kity_text_15737" text-rendering="inherit" font-size="12" dy=".8em" y="15566.700000047684" x="141.5">https://juejin.cn/post/6844904200409726989#heading-12</text><text id="kity_text_15738" text-rendering="inherit" font-size="12" dy=".8em" y="15584.700000047684" x="141.5">https://juejin.cn/post/6919487002417037319#heading-5</text><text id="kity_text_15739" text-rendering="inherit" font-size="12" dy=".8em" y="15602.700000047684" x="141.5">https://juejin.cn/post/6844904127076499464#heading-8</text></g></g><g id="minder_node2989"><g id="node_expander3215" style="cursor: pointer;"><path id="kity_path_30167" fill="white" stroke="gray" d="M317.5,15598.5A6,6,0,1,1,305.5,15598.5A6,6,0,1,1,317.5,15598.5"></path><path id="kity_path_30168" fill="none" stroke="gray" d="M307,15598.5L316,15598.5M311.5,15594L311.5,15603"></path></g><path id="node_outline3216" fill="rgb(239, 238, 246)" stroke="rgb(123, 115, 191)" d="M150.5,15585.5h151a3,3,0,0,1,3,3v20a3,3,0,0,1,-3,3h-151a3,3,0,0,1,-3,-3v-20a3,3,0,0,1,3,-3z" stroke-width="1"></path><g id="node_text3216" fill="black"><text id="kity_text_16383" text-rendering="inherit" font-size="14" dy=".8em" y="15589.400000095367" x="167.5">18.微服务&amp;分布式</text></g></g><g id="minder_node2990" display="none"><g id="node_expander3194" display="none" style="cursor: pointer;"><path id="kity_path_30104" fill="white" stroke="gray" d="M143.5,15574.5A6,6,0,1,1,131.5,15574.5A6,6,0,1,1,143.5,15574.5"></path><path id="kity_path_30105" fill="none" stroke="gray"></path></g><path id="node_outline3195" fill="none" stroke="none" d="M131.5,15565.5h129a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-129a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3195" fill="black"><text id="kity_text_16335" text-rendering="inherit" font-size="12" dy=".8em" y="15566.700000047684" x="131.5">springcloud微服务相关</text></g></g><g id="minder_node2991" display="none"><g id="node_expander3009" display="none" style="cursor: pointer;"><path id="kity_path_29549" fill="white" stroke="gray" d="M127.5,15454.5A6,6,0,1,1,115.5,15454.5A6,6,0,1,1,127.5,15454.5"></path><path id="kity_path_29550" fill="none" stroke="gray"></path></g><path id="node_outline3010" fill="none" stroke="none" d="M115.5,15445.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3010" fill="black"><text id="kity_text_15791" text-rendering="inherit" font-size="12" dy=".8em" y="15446.700000047684" x="115.5">基础</text></g></g><g id="minder_node2992" display="none"><g id="node_expander2989" display="none" style="cursor: pointer;"><path id="kity_path_29489" fill="white" stroke="gray" d="M111.5,15446.5A6,6,0,1,1,99.5,15446.5A6,6,0,1,1,111.5,15446.5"></path><path id="kity_path_29490" fill="none" stroke="gray"></path></g><path id="node_outline2990" fill="none" stroke="none" d="M99.5,15437.5h167a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-167a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2990" fill="black"><text id="kity_text_15747" text-rendering="inherit" font-size="12" dy=".8em" y="15438.700000047684" x="99.5">SpringCould都用了那些组件？</text></g></g><g id="minder_node2993" display="none"><g id="node_expander2988" display="none" style="cursor: pointer;"><path id="kity_path_29486" fill="white" stroke="gray" d="M95.5,15446.5A6,6,0,1,1,83.5,15446.5A6,6,0,1,1,95.5,15446.5"></path><path id="kity_path_29487" fill="none" stroke="gray"></path></g><path id="node_outline2989" fill="none" stroke="none" d="M83.5,15437.5h914a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-914a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2989" fill="black"><text id="kity_text_15745" text-rendering="inherit" font-size="12" dy=".8em" y="15438.700000047684" x="83.5">1.1.config配置中心，openfeign远程调用，gateway网关，Hystrix断路器，nacos注册中心,ribbon负载平衡sentinel熔断降级， sleuth+zipkin服务追踪，seata分布式事务</text></g></g><g id="minder_node2994" display="none"><g id="node_expander3008" display="none" style="cursor: pointer;"><path id="kity_path_29546" fill="white" stroke="gray" d="M111.5,15454.5A6,6,0,1,1,99.5,15454.5A6,6,0,1,1,111.5,15454.5"></path><path id="kity_path_29547" fill="none" stroke="gray"></path></g><path id="node_outline3009" fill="none" stroke="none" d="M99.5,15445.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3009" fill="black"><text id="kity_text_15789" text-rendering="inherit" font-size="12" dy=".8em" y="15446.700000047684" x="99.5">基础</text></g></g><g id="minder_node2995" display="none"><g id="node_expander2991" display="none" style="cursor: pointer;"><path id="kity_path_29495" fill="white" stroke="gray" d="M95.5,15390.5A6,6,0,1,1,83.5,15390.5A6,6,0,1,1,95.5,15390.5"></path><path id="kity_path_29496" fill="none" stroke="gray"></path></g><path id="node_outline2992" fill="none" stroke="none" d="M83.5,15381.5h98a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-98a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2992" fill="black"><text id="kity_text_15751" text-rendering="inherit" font-size="12" dy=".8em" y="15382.700000047684" x="83.5">说说什么是微服务</text></g></g><g id="minder_node2996" display="none"><g id="node_expander2990" display="none" style="cursor: pointer;"><path id="kity_path_29492" fill="white" stroke="gray" d="M79.5,15390.5A6,6,0,1,1,67.5,15390.5A6,6,0,1,1,79.5,15390.5"></path><path id="kity_path_29493" fill="none" stroke="gray"></path></g><path id="node_outline2991" fill="none" stroke="none" d="M67.5,15381.5h1264a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1264a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2991" fill="black"><text id="kity_text_15749" text-rendering="inherit" font-size="12" dy=".8em" y="15382.700000047684" x="67.5">1.每种服务都围绕着具体的业务进行构建只做⼀件事，是⼀种松耦合的能够被独⽴开发和部署的可独⽴扩展、升级和可替换的服务风格，服务之间相互协调配合。通常是基于HTTP的RESTful API来做服务通信 比如说spring cloud  openfeign</text></g></g><g id="minder_node2997" display="none"><g id="node_expander2993" display="none" style="cursor: pointer;"><path id="kity_path_29501" fill="white" stroke="gray" d="M95.5,15398.5A6,6,0,1,1,83.5,15398.5A6,6,0,1,1,95.5,15398.5"></path><path id="kity_path_29502" fill="none" stroke="gray"></path></g><path id="node_outline2994" fill="none" stroke="none" d="M83.5,15389.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2994" fill="black"><text id="kity_text_15756" text-rendering="inherit" font-size="12" dy=".8em" y="15390.700000047684" x="83.5">SOA和微服务的区别？</text></g></g><g id="minder_node2998" display="none"><g id="node_expander2992" display="none" style="cursor: pointer;"><path id="kity_path_29498" fill="white" stroke="gray" d="M79.5,15398.5A6,6,0,1,1,67.5,15398.5A6,6,0,1,1,79.5,15398.5"></path><path id="kity_path_29499" fill="none" stroke="gray"></path></g><path id="node_outline2993" fill="none" stroke="none" d="M67.5,15380.5h570a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-570a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2993" fill="black"><text id="kity_text_15753" text-rendering="inherit" font-size="12" dy=".8em" y="15381.700000047684" x="67.5">1.soa的意思是面向服务架构，他的思想是单个系统相对独立，通过网络进行相互通信并对外提供整体服务</text><text id="kity_text_15754" text-rendering="inherit" font-size="12" dy=".8em" y="15399.700000047684" x="67.5">微服务的理念是soa的升华，他是彻底的组件化和服务化，将soa中的单个系统拆成多个提供单一服务的组件</text></g></g><g id="minder_node2999" display="none"><g id="node_expander2996" display="none" style="cursor: pointer;"><path id="kity_path_29510" fill="white" stroke="gray" d="M95.5,15406.5A6,6,0,1,1,83.5,15406.5A6,6,0,1,1,95.5,15406.5"></path><path id="kity_path_29511" fill="none" stroke="gray"></path></g><path id="node_outline2997" fill="none" stroke="none" d="M83.5,15397.5h151a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-151a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2997" fill="black"><text id="kity_text_15762" text-rendering="inherit" font-size="12" dy=".8em" y="15398.700000047684" x="83.5">你怎么理解的restful风格api</text></g></g><g id="minder_node3000" display="none"><g id="node_expander2995" display="none" style="cursor: pointer;"><path id="kity_path_29507" fill="white" stroke="gray" d="M79.5,15406.5A6,6,0,1,1,67.5,15406.5A6,6,0,1,1,79.5,15406.5"></path><path id="kity_path_29508" fill="none" stroke="gray"></path></g><path id="node_outline2996" fill="none" stroke="none" d="M67.5,15397.5h1156a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1156a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2996" fill="black"><text id="kity_text_15760" text-rendering="inherit" font-size="12" dy=".8em" y="15398.700000047684" x="67.5">1.restful是一种实现方式是一种架构规范，比如说可以是rpc底层通信的一种方式。restful 通过让 有意义的url表示资源 合适的http的操作方法表示行为， post get delete put 返回的状态码表示结果，他可读性比较好，</text></g></g><g id="minder_node3001" display="none"><g id="node_expander2994" display="none" style="cursor: pointer;"><path id="kity_path_29504" fill="white" stroke="gray" d="M63.5,15406.5A6,6,0,1,1,51.5,15406.5A6,6,0,1,1,63.5,15406.5"></path><path id="kity_path_29505" fill="none" stroke="gray"></path></g><path id="node_outline2995" fill="none" stroke="none" d="M51.5,15397.5h256a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-256a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2995" fill="black"><text id="kity_text_15758" text-rendering="inherit" font-size="12" dy=".8em" y="15398.700000047684" x="51.5">https://insights.thoughtworks.cn/api-restful/</text></g></g><g id="minder_node3002" display="none"><g id="node_expander2997" display="none" style="cursor: pointer;"><path id="kity_path_29513" fill="white" stroke="gray" d="M95.5,15414.5A6,6,0,1,1,83.5,15414.5A6,6,0,1,1,95.5,15414.5"></path><path id="kity_path_29514" fill="none" stroke="gray"></path></g><path id="node_outline2998" fill="none" stroke="none" d="M83.5,15405.5h110a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-110a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text2998" fill="black"><text id="kity_text_15764" text-rendering="inherit" font-size="12" dy=".8em" y="15406.700000047684" x="83.5">微服务的优缺点说说</text></g></g><g id="minder_node3003" display="none"><g id="node_expander2999" display="none" style="cursor: pointer;"><path id="kity_path_29519" fill="white" stroke="gray" d="M95.5,15422.5A6,6,0,1,1,83.5,15422.5A6,6,0,1,1,95.5,15422.5"></path><path id="kity_path_29520" fill="none" stroke="gray"></path></g><path id="node_outline3000" fill="none" stroke="none" d="M83.5,15413.5h69a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-69a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3000" fill="black"><text id="kity_text_15769" text-rendering="inherit" font-size="12" dy=".8em" y="15414.700000047684" x="83.5">cap理论说说</text></g></g><g id="minder_node3004" display="none"><g id="node_expander2998" display="none" style="cursor: pointer;"><path id="kity_path_29516" fill="white" stroke="gray" d="M79.5,15422.5A6,6,0,1,1,67.5,15422.5A6,6,0,1,1,79.5,15422.5"></path><path id="kity_path_29517" fill="none" stroke="gray"></path></g><path id="node_outline2999" fill="none" stroke="none" d="M67.5,15404.5h1523a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1523a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text2999" fill="black"><text id="kity_text_15766" text-rendering="inherit" font-size="12" dy=".8em" y="15405.700000047684" x="67.5">1.CAP理论，是分布式系统会存在一个C(一致性：数据在多个副本之间能够保持强一致)-A(可用性：提供的服务必须一直处于可用的状态)-P(分区容错性：除非整个网络环境都发生了故障，否则对外提供满足一致性和可用性的服务)。一般P 是我们必须要实现的，然后C和A是我们去选择的。</text><text id="kity_text_15767" text-rendering="inherit" font-size="12" dy=".8em" y="15423.700000047684" x="67.5">2.SpringCloud满足的是AP，也就是可以和容错。ZK和dubbo满足的是CP也就是ZK是强一致性，牺牲了高可用</text></g></g><g id="minder_node3005" display="none"><g id="node_expander3001" display="none" style="cursor: pointer;"><path id="kity_path_29525" fill="white" stroke="gray" d="M95.5,15430.5A6,6,0,1,1,83.5,15430.5A6,6,0,1,1,95.5,15430.5"></path><path id="kity_path_29526" fill="none" stroke="gray"></path></g><path id="node_outline3002" fill="none" stroke="none" d="M83.5,15421.5h182a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-182a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3002" fill="black"><text id="kity_text_15773" text-rendering="inherit" font-size="12" dy=".8em" y="15422.700000047684" x="83.5">一致性，可用性，分区容错性说说</text></g></g><g id="minder_node3006" display="none"><g id="node_expander3000" display="none" style="cursor: pointer;"><path id="kity_path_29522" fill="white" stroke="gray" d="M79.5,15430.5A6,6,0,1,1,67.5,15430.5A6,6,0,1,1,79.5,15430.5"></path><path id="kity_path_29523" fill="none" stroke="gray"></path></g><path id="node_outline3001" fill="none" stroke="none" d="M67.5,15421.5h34a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-34a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3001" fill="black"><text id="kity_text_15771" text-rendering="inherit" font-size="12" dy=".8em" y="15422.700000047684" x="67.5">1.同上</text></g></g><g id="minder_node3007" display="none"><g id="node_expander3003" display="none" style="cursor: pointer;"><path id="kity_path_29531" fill="white" stroke="gray" d="M95.5,15438.5A6,6,0,1,1,83.5,15438.5A6,6,0,1,1,95.5,15438.5"></path><path id="kity_path_29532" fill="none" stroke="gray"></path></g><path id="node_outline3004" fill="none" stroke="none" d="M83.5,15429.5h158a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-158a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3004" fill="black"><text id="kity_text_15777" text-rendering="inherit" font-size="12" dy=".8em" y="15430.700000047684" x="83.5">springCloud和ZK满足了什么</text></g></g><g id="minder_node3008" display="none"><g id="node_expander3002" display="none" style="cursor: pointer;"><path id="kity_path_29528" fill="white" stroke="gray" d="M79.5,15438.5A6,6,0,1,1,67.5,15438.5A6,6,0,1,1,79.5,15438.5"></path><path id="kity_path_29529" fill="none" stroke="gray"></path></g><path id="node_outline3003" fill="none" stroke="none" d="M67.5,15429.5h34a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-34a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3003" fill="black"><text id="kity_text_15775" text-rendering="inherit" font-size="12" dy=".8em" y="15430.700000047684" x="67.5">1.同上</text></g></g><g id="minder_node3009" display="none"><g id="node_expander3005" display="none" style="cursor: pointer;"><path id="kity_path_29537" fill="white" stroke="gray" d="M95.5,15446.5A6,6,0,1,1,83.5,15446.5A6,6,0,1,1,95.5,15446.5"></path><path id="kity_path_29538" fill="none" stroke="gray"></path></g><path id="node_outline3006" fill="none" stroke="none" d="M83.5,15437.5h144a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-144a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3006" fill="black"><text id="kity_text_15782" text-rendering="inherit" font-size="12" dy=".8em" y="15438.700000047684" x="83.5">为什么CAP不能同时满足？</text></g></g><g id="minder_node3010" display="none"><g id="node_expander3004" display="none" style="cursor: pointer;"><path id="kity_path_29534" fill="white" stroke="gray" d="M79.5,15446.5A6,6,0,1,1,67.5,15446.5A6,6,0,1,1,79.5,15446.5"></path><path id="kity_path_29535" fill="none" stroke="gray"></path></g><path id="node_outline3005" fill="none" stroke="none" d="M67.5,15428.5h1214a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1214a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text3005" fill="black"><text id="kity_text_15779" text-rendering="inherit" font-size="12" dy=".8em" y="15429.700000047684" x="67.5">1.比如说集群两个节点A和B，首先满足一致性，就是说AB数据一致，满足可用性。认为无论用户访问A还是B，都可以获得正确的结果。满足分区容错性的时候，认为无论A还是B宕机或者是两者的通信中断，都不影响系统的运行。</text><text id="kity_text_15780" text-rendering="inherit" font-size="12" dy=".8em" y="15447.700000047684" x="67.5">2.当出现A和B网络断开，A修改数据成功，而B不知道这个请求，没有修改成功，还是老数据。要么返回错误数据，要么等待网络回复，数据重新恢复。</text></g></g><g id="minder_node3011" display="none"><g id="node_expander3007" display="none" style="cursor: pointer;"><path id="kity_path_29543" fill="white" stroke="gray" d="M95.5,15454.5A6,6,0,1,1,83.5,15454.5A6,6,0,1,1,95.5,15454.5"></path><path id="kity_path_29544" fill="none" stroke="gray"></path></g><path id="node_outline3008" fill="none" stroke="none" d="M83.5,15445.5h107a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-107a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3008" fill="black"><text id="kity_text_15787" text-rendering="inherit" font-size="12" dy=".8em" y="15446.700000047684" x="83.5">兄弟 BASE理论说说</text></g></g><g id="minder_node3012" display="none"><g id="node_expander3006" display="none" style="cursor: pointer;"><path id="kity_path_29540" fill="white" stroke="gray" d="M79.5,15454.5A6,6,0,1,1,67.5,15454.5A6,6,0,1,1,79.5,15454.5"></path><path id="kity_path_29541" fill="none" stroke="gray"></path></g><path id="node_outline3007" fill="none" stroke="none" d="M67.5,15436.5h1413a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1413a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text3007" fill="black"><text id="kity_text_15784" text-rendering="inherit" font-size="12" dy=".8em" y="15437.700000047684" x="67.5">1.BASE主要是在CAP的扩展.即使无法做到强一致性（CAP 的一致性就是强一致性），但可 以采用适当的采取弱一致性，即最终一致性。主要是&#xa0;</text><text id="kity_text_15785" text-rendering="inherit" font-size="12" dy=".8em" y="15455.700000047684" x="67.5">(1)出现故障，允许损失部分可用性。但是要基本可用。(2)软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。允许不同副本同步的延时就是软状态的体现。(3)最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。</text></g></g><g id="minder_node3013" display="none"><g id="node_expander3040" display="none" style="cursor: pointer;"><path id="kity_path_29642" fill="white" stroke="gray" d="M127.5,15462.5A6,6,0,1,1,115.5,15462.5A6,6,0,1,1,127.5,15462.5"></path><path id="kity_path_29643" fill="none" stroke="gray"></path></g><path id="node_outline3041" fill="none" stroke="none" d="M115.5,15453.5h86a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-86a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3041" fill="black"><text id="kity_text_15875" text-rendering="inherit" font-size="12" dy=".8em" y="15454.700000047684" x="115.5">服务注册和发现</text></g></g><g id="minder_node3014" display="none"><g id="node_expander3011" display="none" style="cursor: pointer;"><path id="kity_path_29555" fill="white" stroke="gray" d="M111.5,15374.5A6,6,0,1,1,99.5,15374.5A6,6,0,1,1,111.5,15374.5"></path><path id="kity_path_29556" fill="none" stroke="gray"></path></g><path id="node_outline3012" fill="none" stroke="none" d="M99.5,15365.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3012" fill="black"><text id="kity_text_15795" text-rendering="inherit" font-size="12" dy=".8em" y="15366.700000047684" x="99.5">服务注册和发现是什么？</text></g></g><g id="minder_node3015" display="none"><g id="node_expander3010" display="none" style="cursor: pointer;"><path id="kity_path_29552" fill="white" stroke="gray" d="M95.5,15374.5A6,6,0,1,1,83.5,15374.5A6,6,0,1,1,95.5,15374.5"></path><path id="kity_path_29553" fill="none" stroke="gray"></path></g><path id="node_outline3011" fill="none" stroke="none" d="M83.5,15365.5h1270a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1270a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3011" fill="black"><text id="kity_text_15793" text-rendering="inherit" font-size="12" dy=".8em" y="15366.700000047684" x="83.5">1.一般微服务下 随着服务开发和部署配置比较多，而我们一般配置属性都是在配置文件中，添加修改这些属性比较复杂，而且不能一直手动去更新。比如说我们可以通过所有服务都在 Eureka 服务器上注册并通过调用 Eureka 服务器完成查找</text></g></g><g id="minder_node3016" display="none"><g id="node_expander3013" display="none" style="cursor: pointer;"><path id="kity_path_29561" fill="white" stroke="gray" d="M111.5,15382.5A6,6,0,1,1,99.5,15382.5A6,6,0,1,1,111.5,15382.5"></path><path id="kity_path_29562" fill="none" stroke="gray"></path></g><path id="node_outline3014" fill="none" stroke="none" d="M99.5,15373.5h88a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-88a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3014" fill="black"><text id="kity_text_15799" text-rendering="inherit" font-size="12" dy=".8em" y="15374.700000047684" x="99.5">说一下eureka？</text></g></g><g id="minder_node3017" display="none"><g id="node_expander3012" display="none" style="cursor: pointer;"><path id="kity_path_29558" fill="white" stroke="gray" d="M95.5,15382.5A6,6,0,1,1,83.5,15382.5A6,6,0,1,1,95.5,15382.5"></path><path id="kity_path_29559" fill="none" stroke="gray"></path></g><path id="node_outline3013" fill="none" stroke="none" d="M83.5,15373.5h1066a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1066a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3013" fill="black"><text id="kity_text_15797" text-rendering="inherit" font-size="12" dy=".8em" y="15374.700000047684" x="83.5">1.1.Eureka是之前SpringCloud的服务注册中心功能服务器，系统中的其他服务使用Eureka的客户端将其连接到Eureka Service中，并且保持心跳，通过Eureka Service来监控各个微服务是否运行正常。</text></g></g><g id="minder_node3018" display="none"><g id="node_expander3016" display="none" style="cursor: pointer;"><path id="kity_path_29570" fill="white" stroke="gray" d="M111.5,15390.5A6,6,0,1,1,99.5,15390.5A6,6,0,1,1,111.5,15390.5"></path><path id="kity_path_29571" fill="none" stroke="gray"></path></g><path id="node_outline3017" fill="none" stroke="none" d="M99.5,15381.5h159a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-159a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3017" fill="black"><text id="kity_text_15811" text-rendering="inherit" font-size="12" dy=".8em" y="15382.700000047684" x="99.5">eureka服务注册与发现原理？</text></g></g><g id="minder_node3019" display="none"><g id="node_expander3015" display="none" style="cursor: pointer;"><path id="kity_path_29567" fill="white" stroke="gray" d="M95.5,15390.5A6,6,0,1,1,83.5,15390.5A6,6,0,1,1,95.5,15390.5"></path><path id="kity_path_29568" fill="none" stroke="gray"></path></g><path id="node_outline3016" fill="none" stroke="none" d="M83.5,15336.5h956a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-956a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text3016" fill="black"><text id="kity_text_15804" text-rendering="inherit" font-size="12" dy=".8em" y="15337.700000047684" x="83.5">1.eureka，设计原则是遵循AP原则。分服务提供，服务消费，注册中心。流程分为服务续约，服务注销，服务移除，服务同步</text><text id="kity_text_15805" text-rendering="inherit" font-size="12" dy=".8em" y="15355.700000047684" x="83.5">服务提供会向注册中心发起Register请求，注册服务，通过给注册中心心跳表明服务状态，通过cancel请求进行服务注销。</text><text id="kity_text_15806" text-rendering="inherit" font-size="12" dy=".8em" y="15373.700000047684" x="83.5">服务消费通过从注册中心拉去服务注册信息，然后调用。注册中心 通过从其他节点拉取服务注册信息，通过定时任务清理坏的服务，如果是多节点 请求会同步到其他注册中心节点。</text><text id="kity_text_15807" text-rendering="inherit" font-size="12" dy=".8em" y="15391.700000047684" x="83.5">2.每30s发送⼼跳检测重新进⾏续约，如果客户端不能多次更新续约，它将在90s内从服务器注册中⼼移除。</text><text id="kity_text_15808" text-rendering="inherit" font-size="12" dy=".8em" y="15409.700000047684" x="83.5">注册信息和更新会被复制到其他Eureka 节点，来⾃任何区域的客户端可以查找到注册中⼼信息，每30s发⽣⼀次复制来定位他们的服务，并进⾏远程调⽤。</text><text id="kity_text_15809" text-rendering="inherit" font-size="12" dy=".8em" y="15427.700000047684" x="83.5">客户端还可以缓存⼀些服务实例信息，所以即使Eureka全挂掉，客户端也是可以定位到服务地址的。</text></g></g><g id="minder_node3020" display="none"><g id="node_expander3014" display="none" style="cursor: pointer;"><path id="kity_path_29564" fill="white" stroke="gray" d="M79.5,15390.5A6,6,0,1,1,67.5,15390.5A6,6,0,1,1,79.5,15390.5"></path><path id="kity_path_29565" fill="none" stroke="gray"></path></g><path id="node_outline3015" fill="none" stroke="none" d="M67.5,15372.5h333a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text3015" fill="black"><text id="kity_text_15801" text-rendering="inherit" font-size="12" dy=".8em" y="15373.700000047684" x="67.5">https://juejin.cn/post/6844903759886155783#heading-22</text><text id="kity_text_15802" text-rendering="inherit" font-size="12" dy=".8em" y="15391.700000047684" x="67.5">https://juejin.cn/post/6844904020272742413#heading-8</text></g></g><g id="minder_node3021" display="none"><g id="node_expander3018" display="none" style="cursor: pointer;"><path id="kity_path_29576" fill="white" stroke="gray" d="M111.5,15398.5A6,6,0,1,1,99.5,15398.5A6,6,0,1,1,111.5,15398.5"></path><path id="kity_path_29577" fill="none" stroke="gray"></path></g><path id="node_outline3019" fill="none" stroke="none" d="M99.5,15389.5h75a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-75a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3019" fill="black"><text id="kity_text_15815" text-rendering="inherit" font-size="12" dy=".8em" y="15390.700000047684" x="99.5">eureka的缺点</text></g></g><g id="minder_node3022" display="none"><g id="node_expander3017" display="none" style="cursor: pointer;"><path id="kity_path_29573" fill="white" stroke="gray" d="M95.5,15398.5A6,6,0,1,1,83.5,15398.5A6,6,0,1,1,95.5,15398.5"></path><path id="kity_path_29574" fill="none" stroke="gray"></path></g><path id="node_outline3018" fill="none" stroke="none" d="M83.5,15389.5h799a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-799a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3018" fill="black"><text id="kity_text_15813" text-rendering="inherit" font-size="12" dy=".8em" y="15390.700000047684" x="83.5">1.时效性的缺点。某个服务不可⽤时，各个Eureka Client不能及时的知道，需要1~3个⼼跳周期才能感知。不过可以通过Hystrix来容错和降级 做弥补。</text></g></g><g id="minder_node3023" display="none"><g id="node_expander3021" display="none" style="cursor: pointer;"><path id="kity_path_29585" fill="white" stroke="gray" d="M111.5,15406.5A6,6,0,1,1,99.5,15406.5A6,6,0,1,1,111.5,15406.5"></path><path id="kity_path_29586" fill="none" stroke="gray"></path></g><path id="node_outline3022" fill="none" stroke="none" d="M99.5,15397.5h99a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-99a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3022" fill="black"><text id="kity_text_15823" text-rendering="inherit" font-size="12" dy=".8em" y="15398.700000047684" x="99.5">eureka缓存机制？</text></g></g><g id="minder_node3024" display="none"><g id="node_expander3020" display="none" style="cursor: pointer;"><path id="kity_path_29582" fill="white" stroke="gray" d="M95.5,15406.5A6,6,0,1,1,83.5,15406.5A6,6,0,1,1,95.5,15406.5"></path><path id="kity_path_29583" fill="none" stroke="gray"></path></g><path id="node_outline3021" fill="none" stroke="none" d="M83.5,15379.5h1311a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1311a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text3021" fill="black"><text id="kity_text_15819" text-rendering="inherit" font-size="12" dy=".8em" y="15380.700000047684" x="83.5">1.eureka缓存机制：设置了⼀个每30秒执⾏⼀次的定时任务，定时去服务端获取注册信息。获取之后，存⼊本地内存。</text><text id="kity_text_15820" text-rendering="inherit" font-size="12" dy=".8em" y="15398.700000047684" x="83.5">二层缓存，都是map实现。第⼀层缓存(readOnlyCacheMap) 本质ConcurrentHashMap，供客户端获取注册信息时使⽤，其缓存更新，依赖于定时器的更新。定时更新时间间隔，默认为30秒。</text><text id="kity_text_15821" text-rendering="inherit" font-size="12" dy=".8em" y="15416.700000047684" x="83.5">第⼆层缓存(readWriteCacheMap)，存放的是最终的缓存， 当服务下线，过期，注册，状态变更，都会来清除这个缓存⾥⾯的数据。加载缓存时 有就直接返回，没有就通过缓存加载器去加载，然后返回并放到这个缓存中。默认缓存过期时间是 180</text></g></g><g id="minder_node3025" display="none"><g id="node_expander3019" display="none" style="cursor: pointer;"><path id="kity_path_29579" fill="white" stroke="gray" d="M79.5,15406.5A6,6,0,1,1,67.5,15406.5A6,6,0,1,1,79.5,15406.5"></path><path id="kity_path_29580" fill="none" stroke="gray"></path></g><path id="node_outline3020" fill="none" stroke="none" d="M67.5,15397.5h333a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3020" fill="black"><text id="kity_text_15817" text-rendering="inherit" font-size="12" dy=".8em" y="15398.700000047684" x="67.5">https://juejin.cn/post/6844904113134665736#heading-27</text></g></g><g id="minder_node3026" display="none"><g id="node_expander3023" display="none" style="cursor: pointer;"><path id="kity_path_29591" fill="white" stroke="gray" d="M111.5,15414.5A6,6,0,1,1,99.5,15414.5A6,6,0,1,1,111.5,15414.5"></path><path id="kity_path_29592" fill="none" stroke="gray"></path></g><path id="node_outline3024" fill="none" stroke="none" d="M99.5,15405.5h123a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-123a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3024" fill="black"><text id="kity_text_15827" text-rendering="inherit" font-size="12" dy=".8em" y="15406.700000047684" x="99.5">eureka自我保护机制？</text></g></g><g id="minder_node3027" display="none"><g id="node_expander3022" display="none" style="cursor: pointer;"><path id="kity_path_29588" fill="white" stroke="gray" d="M95.5,15414.5A6,6,0,1,1,83.5,15414.5A6,6,0,1,1,95.5,15414.5"></path><path id="kity_path_29589" fill="none" stroke="gray"></path></g><path id="node_outline3023" fill="none" stroke="none" d="M83.5,15405.5h1400a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1400a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3023" fill="black"><text id="kity_text_15825" text-rendering="inherit" font-size="12" dy=".8em" y="15406.700000047684" x="83.5">1.默认情况下，当Eureka Server 点在短时间内丢失了过多实例的连接时（比如网络故障或频繁启动关闭客户端）节点会进入自我保护模式，也就是一段时间内没有收到某一个服务的心跳后，保护注册信息，不再删除注册数据，故障恢复时，自动退出自我保护模式。</text></g></g><g id="minder_node3028" display="none"><g id="node_expander3025" display="none" style="cursor: pointer;"><path id="kity_path_29597" fill="white" stroke="gray" d="M111.5,15422.5A6,6,0,1,1,99.5,15422.5A6,6,0,1,1,111.5,15422.5"></path><path id="kity_path_29598" fill="none" stroke="gray"></path></g><path id="node_outline3026" fill="none" stroke="none" d="M99.5,15413.5h159a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-159a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3026" fill="black"><text id="kity_text_15834" text-rendering="inherit" font-size="12" dy=".8em" y="15414.700000047684" x="99.5">eureka和zookeeper的区别？</text></g></g><g id="minder_node3029" display="none"><g id="node_expander3024" display="none" style="cursor: pointer;"><path id="kity_path_29594" fill="white" stroke="gray" d="M95.5,15422.5A6,6,0,1,1,83.5,15422.5A6,6,0,1,1,95.5,15422.5"></path><path id="kity_path_29595" fill="none" stroke="gray"></path></g><path id="node_outline3025" fill="none" stroke="none" d="M83.5,15386.5h721a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-721a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text3025" fill="black"><text id="kity_text_15829" text-rendering="inherit" font-size="12" dy=".8em" y="15387.700000047684" x="83.5">1.ZK是CP策略，eureka是AP策略</text><text id="kity_text_15830" text-rendering="inherit" font-size="12" dy=".8em" y="15405.700000047684" x="83.5">2.eureka节点之间是平等关系，挂了一个不允许注册中心整体使用，只要还有一台就可以，可能数据不是最新的，是因为自我保护机制。</text><text id="kity_text_15831" text-rendering="inherit" font-size="12" dy=".8em" y="15423.700000047684" x="83.5">ZK是主从节点关系。节点服务挂了就要选举 在选举期间注册服务瘫痪,虽然服务最终会恢复,但是选举期间不可用的。</text><text id="kity_text_15832" text-rendering="inherit" font-size="12" dy=".8em" y="15441.700000047684" x="83.5">3.Eureka可以很好的应对因网络故障</text></g></g><g id="minder_node3030" display="none"><g id="node_expander3027" display="none" style="cursor: pointer;"><path id="kity_path_29603" fill="white" stroke="gray" d="M111.5,15430.5A6,6,0,1,1,99.5,15430.5A6,6,0,1,1,111.5,15430.5"></path><path id="kity_path_29604" fill="none" stroke="gray"></path></g><path id="node_outline3028" fill="none" stroke="none" d="M99.5,15421.5h189a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-189a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3028" fill="black"><text id="kity_text_15840" text-rendering="inherit" font-size="12" dy=".8em" y="15422.700000047684" x="99.5">nacos是怎么做的服务注册和发现？</text></g></g><g id="minder_node3031" display="none"><g id="node_expander3026" display="none" style="cursor: pointer;"><path id="kity_path_29600" fill="white" stroke="gray" d="M95.5,15430.5A6,6,0,1,1,83.5,15430.5A6,6,0,1,1,95.5,15430.5"></path><path id="kity_path_29601" fill="none" stroke="gray"></path></g><path id="node_outline3027" fill="none" stroke="none" d="M83.5,15403.5h1460a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1460a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text3027" fill="black"><text id="kity_text_15836" text-rendering="inherit" font-size="12" dy=".8em" y="15404.700000047684" x="83.5">1.注册：服务启动时通过提供方的ip+端口 通知给注册中心也就是nacos，注册中心通过维护 serviceHolder去处理每一个服务，在注册的同时添加一个心跳任务，一开始默认是5s，然后根据结果15s没有结果就认为是不健康的，30s没有就移除，后面就需要重新注册这个节点。</text><text id="kity_text_15837" text-rendering="inherit" font-size="12" dy=".8em" y="15422.700000047684" x="83.5">发现：服务注册到注册中心后，消费者就可以订阅这个服务，nacos的订阅通过轮训(订阅的节点主动定时获取服务端节点的信息，然后再本地去做一个比对，如果有改变就会做一些更新)和推送(订阅的节点发生更新的时候会主动向订阅方进行推送)来实现,</text><text id="kity_text_15838" text-rendering="inherit" font-size="12" dy=".8em" y="15440.700000047684" x="83.5">这个过程会提交一个监听器，监听信息变更让消费者更新本地的服务实例列表，保证服务可用。消费者订阅了服务，那么会在本地基于内存维护一个服务信息列表，之后进行服务调用是直接从本地列表获取对应的服务实例进行调用，否则去主从中心获取服务实例。</text></g></g><g id="minder_node3032" display="none"><g id="node_expander3030" display="none" style="cursor: pointer;"><path id="kity_path_29612" fill="white" stroke="gray" d="M111.5,15438.5A6,6,0,1,1,99.5,15438.5A6,6,0,1,1,111.5,15438.5"></path><path id="kity_path_29613" fill="none" stroke="gray"></path></g><path id="node_outline3031" fill="none" stroke="none" d="M99.5,15429.5h129a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-129a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3031" fill="black"><text id="kity_text_15847" text-rendering="inherit" font-size="12" dy=".8em" y="15430.700000047684" x="99.5">nacos怎么做服务调用？</text></g></g><g id="minder_node3033" display="none"><g id="node_expander3029" display="none" style="cursor: pointer;"><path id="kity_path_29609" fill="white" stroke="gray" d="M95.5,15438.5A6,6,0,1,1,83.5,15438.5A6,6,0,1,1,95.5,15438.5"></path><path id="kity_path_29610" fill="none" stroke="gray"></path></g><path id="node_outline3030" fill="none" stroke="none" d="M83.5,15420.5h995a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-995a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text3030" fill="black"><text id="kity_text_15844" text-rendering="inherit" font-size="12" dy=".8em" y="15421.700000047684" x="83.5">1.主要是通过feign+ribbon进行配合调用的。feign提供http请求的封装以及调用，ribbon提供负载均衡。负载均衡有很多中实现方式，包括轮询法，随机方法法，对请求ip做hash后取模。</text><text id="kity_text_15845" text-rendering="inherit" font-size="12" dy=".8em" y="15439.700000047684" x="83.5">Nacos 的客户端在获取到服务的完整实例列表后，会在客户端进行负载均衡算法来获取一个可用的实例，默认使用的是随机获取的方式。</text></g></g><g id="minder_node3034" display="none"><g id="node_expander3028" display="none" style="cursor: pointer;"><path id="kity_path_29606" fill="white" stroke="gray" d="M79.5,15438.5A6,6,0,1,1,67.5,15438.5A6,6,0,1,1,79.5,15438.5"></path><path id="kity_path_29607" fill="none" stroke="gray"></path></g><path id="node_outline3029" fill="none" stroke="none" d="M-7.5,15339.5h200a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text3029" fill="black"><text id="kity_text_15842" text-rendering="inherit" font-size="12" dy=".8em" y="15430.700000047684" x="67.5">调用流程</text></g><image id="kity_image_17101" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210420230315.png" x="-7.5" y="15342.5" width="200" height="85"></image></g><g id="minder_node3035" display="none"><g id="node_expander3033" display="none" style="cursor: pointer;"><path id="kity_path_29621" fill="white" stroke="gray" d="M111.5,15446.5A6,6,0,1,1,99.5,15446.5A6,6,0,1,1,111.5,15446.5"></path><path id="kity_path_29622" fill="none" stroke="gray"></path></g><path id="node_outline3034" fill="none" stroke="none" d="M99.5,15437.5h141a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-141a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3034" fill="black"><text id="kity_text_15854" text-rendering="inherit" font-size="12" dy=".8em" y="15438.700000047684" x="99.5">nacos做配置中心？原理？</text></g></g><g id="minder_node3036" display="none"><g id="node_expander3032" display="none" style="cursor: pointer;"><path id="kity_path_29618" fill="white" stroke="gray" d="M95.5,15446.5A6,6,0,1,1,83.5,15446.5A6,6,0,1,1,95.5,15446.5"></path><path id="kity_path_29619" fill="none" stroke="gray"></path></g><path id="node_outline3033" fill="none" stroke="none" d="M83.5,15428.5h1389a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1389a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text3033" fill="black"><text id="kity_text_15851" text-rendering="inherit" font-size="12" dy=".8em" y="15429.700000047684" x="83.5">1.nacos做配置中心，可以做配置的增删改查的热更新。本质是提供了一系列的crud的访问接口使应用可以完成配置的增删改查的操作。而对于让客户端能感知配置变化 主要是通过拉模式。</text><text id="kity_text_15852" text-rendering="inherit" font-size="12" dy=".8em" y="15447.700000047684" x="83.5">客户端主动从服务端定时拉取配置，如果有变化则进行替换。如果没有变化则开启定时任务，延迟29.5s执行，同时把当前客户端的连接请求放入队列。这种的好处就是保证了客户端的配置能及时变化更新，也减少了轮询给服务端带来的压力。比eurake好的地方。</text></g></g><g id="minder_node3037" display="none"><g id="node_expander3031" display="none" style="cursor: pointer;"><path id="kity_path_29615" fill="white" stroke="gray" d="M79.5,15446.5A6,6,0,1,1,67.5,15446.5A6,6,0,1,1,79.5,15446.5"></path><path id="kity_path_29616" fill="none" stroke="gray"></path></g><path id="node_outline3032" fill="none" stroke="none" d="M67.5,15437.5h327a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-327a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3032" fill="black"><text id="kity_text_15849" text-rendering="inherit" font-size="12" dy=".8em" y="15438.700000047684" x="67.5">https://juejin.cn/post/6925724354151972871#heading-4</text></g></g><g id="minder_node3038" display="none"><g id="node_expander3035" display="none" style="cursor: pointer;"><path id="kity_path_29627" fill="white" stroke="gray" d="M111.5,15454.5A6,6,0,1,1,99.5,15454.5A6,6,0,1,1,111.5,15454.5"></path><path id="kity_path_29628" fill="none" stroke="gray"></path></g><path id="node_outline3036" fill="none" stroke="none" d="M99.5,15445.5h178a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-178a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3036" fill="black"><text id="kity_text_15859" text-rendering="inherit" font-size="12" dy=".8em" y="15446.700000047684" x="99.5">线上nacos是怎么做的？可用性？</text></g></g><g id="minder_node3039" display="none"><g id="node_expander3034" display="none" style="cursor: pointer;"><path id="kity_path_29624" fill="white" stroke="gray" d="M95.5,15454.5A6,6,0,1,1,83.5,15454.5A6,6,0,1,1,95.5,15454.5"></path><path id="kity_path_29625" fill="none" stroke="gray"></path></g><path id="node_outline3035" fill="none" stroke="none" d="M83.5,15436.5h910a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-910a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text3035" fill="black"><text id="kity_text_15856" text-rendering="inherit" font-size="12" dy=".8em" y="15437.700000047684" x="83.5">1.启动多个默认配置下的Nacos节点，数据存储是存在一致性问题的。Nacos采用了集中式存储的方式来支持集群化部署，目前只要支持MySQL的存储。使用的是raft算法。</text><text id="kity_text_15857" text-rendering="inherit" font-size="12" dy=".8em" y="15455.700000047684" x="83.5">2.创建集群也比较简单。三个节点。修改cluster.conf即可，然后启动节点就可以创建nacos集群。然后也可以在nacos上做nginx的负载均衡到三个节点</text></g></g><g id="minder_node3040" display="none"><g id="node_expander3039" display="none" style="cursor: pointer;"><path id="kity_path_29639" fill="white" stroke="gray" d="M111.5,15462.5A6,6,0,1,1,99.5,15462.5A6,6,0,1,1,111.5,15462.5"></path><path id="kity_path_29640" fill="none" stroke="gray"></path></g><path id="node_outline3040" fill="none" stroke="none" d="M99.5,15453.5h267a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-267a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3040" fill="black"><text id="kity_text_15873" text-rendering="inherit" font-size="12" dy=".8em" y="15454.700000047684" x="99.5">为什么现在nacos做，而没有选择ZK或者是eureka</text></g></g><g id="minder_node3041" display="none"><g id="node_expander3038" display="none" style="cursor: pointer;"><path id="kity_path_29636" fill="white" stroke="gray" d="M95.5,15462.5A6,6,0,1,1,83.5,15462.5A6,6,0,1,1,95.5,15462.5"></path><path id="kity_path_29637" fill="none" stroke="gray"></path></g><path id="node_outline3039" fill="none" stroke="none" d="M83.5,15417.5h1396a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1396a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text3039" fill="black"><text id="kity_text_15867" text-rendering="inherit" font-size="12" dy=".8em" y="15418.700000047684" x="83.5">1.1.ZK和eureka,nacos三个都可以做注册中心，eureka和nacos可以看成是AP的实现原则，ZK是CP的实现原则，也就是强一致性。但是现在用ZK的API比较难用，需要熟悉他的很多异常，以及对这些异常到底做什么处理。而且性能不是很好，无法水平扩展，</text><text id="kity_text_15868" text-rendering="inherit" font-size="12" dy=".8em" y="15436.700000047684" x="83.5">注册中心理论上来说只需要知道此时此刻在注册中心上，有哪些服务和实例进行了注册，但是ZK会持续的记录事务日志。</text><text id="kity_text_15869" text-rendering="inherit" font-size="12" dy=".8em" y="15454.700000047684" x="83.5">而nacos性能压测比较好，多节点集群下运行持续稳定，差不多3节点查询实例缩TPS可以到13000+，而且他的配置中心发布与监听时间差，在100ms内基本都能监听到配置的更改。nacos所有的实例默认是临时节点，会使用AP协议，如果不是临时节点就会走CP。</text><text id="kity_text_15870" text-rendering="inherit" font-size="12" dy=".8em" y="15472.700000047684" x="83.5">其实注册中心更需要的是AP 追求最终一致性，而不是CP。而且我看Alibaba有的文章也说为什么越来越不推荐你使用ZK做注册中心，大概原因也是我上面说的哪些。而且ZK同机房不可连通 会不可用。</text><text id="kity_text_15871" text-rendering="inherit" font-size="12" dy=".8em" y="15490.700000047684" x="83.5">2.而nacos和eureka比较下来。最主要是eureka 2.0闭源，其次是客户端更新服务信息通过简单的轮询机制，当服务数量巨大时，服务器压力过大。而且nacos国产 文档又比较好，方便上手，还是ali的，热度正高。</text></g></g><g id="minder_node3042" display="none"><g id="node_expander3036" display="none" style="cursor: pointer;"><path id="kity_path_29630" fill="white" stroke="gray" d="M79.5,15454.5A6,6,0,1,1,67.5,15454.5A6,6,0,1,1,79.5,15454.5"></path><path id="kity_path_29631" fill="none" stroke="gray"></path></g><path id="node_outline3037" fill="none" stroke="none" d="M-11.5,15297.5h200a5,5,0,0,1,5,5v156a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-156a5,5,0,0,1,5,-5z"></path><g id="node_text3037" fill="black"><text id="kity_text_15861" text-rendering="inherit" font-size="12" dy=".8em" y="15446.700000047684" x="67.5">ZK问题</text></g><image id="kity_image_17102" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210420232556.png" x="-11.5" y="15300.5" width="200" height="143"></image></g><g id="minder_node3043" display="none"><g id="node_expander3037" display="none" style="cursor: pointer;"><path id="kity_path_29633" fill="white" stroke="gray" d="M79.5,15462.5A6,6,0,1,1,67.5,15462.5A6,6,0,1,1,79.5,15462.5"></path><path id="kity_path_29634" fill="none" stroke="gray"></path></g><path id="node_outline3038" fill="none" stroke="none" d="M67.5,15435.5h327a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-327a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text3038" fill="black"><text id="kity_text_15863" text-rendering="inherit" font-size="12" dy=".8em" y="15436.700000047684" x="67.5">https://juejin.cn/post/6844904196785831943#heading-9</text><text id="kity_text_15864" text-rendering="inherit" font-size="12" dy=".8em" y="15454.700000047684" x="67.5">https://juejin.cn/post/6921885895264223239#heading-5</text><text id="kity_text_15865" text-rendering="inherit" font-size="12" dy=".8em" y="15472.700000047684" x="67.5">https://juejin.cn/post/6924236224462848008#heading-4</text></g></g><g id="minder_node3044" display="none"><g id="node_expander3045" display="none" style="cursor: pointer;"><path id="kity_path_29657" fill="white" stroke="gray" d="M127.5,15470.5A6,6,0,1,1,115.5,15470.5A6,6,0,1,1,127.5,15470.5"></path><path id="kity_path_29658" fill="none" stroke="gray"></path></g><path id="node_outline3046" fill="none" stroke="none" d="M115.5,15461.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3046" fill="black"><text id="kity_text_15886" text-rendering="inherit" font-size="12" dy=".8em" y="15462.700000047684" x="115.5">配置中心</text></g></g><g id="minder_node3045" display="none"><g id="node_expander3042" display="none" style="cursor: pointer;"><path id="kity_path_29648" fill="white" stroke="gray" d="M111.5,15462.5A6,6,0,1,1,99.5,15462.5A6,6,0,1,1,111.5,15462.5"></path><path id="kity_path_29649" fill="none" stroke="gray"></path></g><path id="node_outline3043" fill="none" stroke="none" d="M99.5,15453.5h178a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-178a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3043" fill="black"><text id="kity_text_15879" text-rendering="inherit" font-size="12" dy=".8em" y="15454.700000047684" x="99.5">除了nacos，还知道哪些配置中心</text></g></g><g id="minder_node3046" display="none"><g id="node_expander3041" display="none" style="cursor: pointer;"><path id="kity_path_29645" fill="white" stroke="gray" d="M95.5,15462.5A6,6,0,1,1,83.5,15462.5A6,6,0,1,1,95.5,15462.5"></path><path id="kity_path_29646" fill="none" stroke="gray"></path></g><path id="node_outline3042" fill="none" stroke="none" d="M83.5,15453.5h66a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-66a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3042" fill="black"><text id="kity_text_15877" text-rendering="inherit" font-size="12" dy=".8em" y="15454.700000047684" x="83.5">1.Apollo,ZK</text></g></g><g id="minder_node3047" display="none"><g id="node_expander3044" display="none" style="cursor: pointer;"><path id="kity_path_29654" fill="white" stroke="gray" d="M111.5,15470.5A6,6,0,1,1,99.5,15470.5A6,6,0,1,1,111.5,15470.5"></path><path id="kity_path_29655" fill="none" stroke="gray"></path></g><path id="node_outline3045" fill="none" stroke="none" d="M99.5,15461.5h114a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-114a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3045" fill="black"><text id="kity_text_15884" text-rendering="inherit" font-size="12" dy=".8em" y="15462.700000047684" x="99.5">springcloud config?</text></g></g><g id="minder_node3048" display="none"><g id="node_expander3043" display="none" style="cursor: pointer;"><path id="kity_path_29651" fill="white" stroke="gray" d="M95.5,15470.5A6,6,0,1,1,83.5,15470.5A6,6,0,1,1,95.5,15470.5"></path><path id="kity_path_29652" fill="none" stroke="gray"></path></g><path id="node_outline3044" fill="none" stroke="none" d="M83.5,15452.5h994a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-994a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text3044" fill="black"><text id="kity_text_15881" text-rendering="inherit" font-size="12" dy=".8em" y="15453.700000047684" x="83.5">1.为分布式系统中的外部配置提供服务器和客户端支持，方便过来配置文件，nacos支持动态配置使用@RefreshScope， Spring Cloud Config分为Config Server和Config Client两部分。</text><text id="kity_text_15882" text-rendering="inherit" font-size="12" dy=".8em" y="15471.700000047684" x="83.5">Config Server负责读取配置文件，并且暴露Http API接口，Config Client通过调用Config Server的接口来读取配置文件。</text></g></g><g id="minder_node3049" display="none"><g id="node_expander3083" display="none" style="cursor: pointer;"><path id="kity_path_29771" fill="white" stroke="gray" d="M127.5,15478.5A6,6,0,1,1,115.5,15478.5A6,6,0,1,1,127.5,15478.5"></path><path id="kity_path_29772" fill="none" stroke="gray"></path></g><path id="node_outline3084" fill="none" stroke="none" d="M115.5,15469.5h74a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-74a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3084" fill="black"><text id="kity_text_16026" text-rendering="inherit" font-size="12" dy=".8em" y="15470.700000047684" x="115.5">熔断降级限流</text></g></g><g id="minder_node3050" display="none"><g id="node_expander3047" display="none" style="cursor: pointer;"><path id="kity_path_29663" fill="white" stroke="gray" d="M111.5,15350.5A6,6,0,1,1,99.5,15350.5A6,6,0,1,1,111.5,15350.5"></path><path id="kity_path_29664" fill="none" stroke="gray"></path></g><path id="node_outline3048" fill="none" stroke="none" d="M99.5,15341.5h195a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-195a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3048" fill="black"><text id="kity_text_15894" text-rendering="inherit" font-size="12" dy=".8em" y="15342.700000047684" x="99.5">说一下hystrix？状态？有哪些功能？</text></g></g><g id="minder_node3051" display="none"><g id="node_expander3046" display="none" style="cursor: pointer;"><path id="kity_path_29660" fill="white" stroke="gray" d="M95.5,15350.5A6,6,0,1,1,83.5,15350.5A6,6,0,1,1,95.5,15350.5"></path><path id="kity_path_29661" fill="none" stroke="gray"></path></g><path id="node_outline3047" fill="none" stroke="none" d="M83.5,15305.5h1361a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1361a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text3047" fill="black"><text id="kity_text_15888" text-rendering="inherit" font-size="12" dy=".8em" y="15306.700000047684" x="83.5">1.当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待被调用者的响应 当更多的服务请求到这些资源导致更多的请求等待，发生系统不可用效应）。Hystrix可以解决我们整个系统中某一个服务出现不可用的而导致服务雪崩的情况。</text><text id="kity_text_15889" text-rendering="inherit" font-size="12" dy=".8em" y="15324.700000047684" x="83.5">2.Hystrix熔断有三状态，(1)打开状态：一段时间内 达到一定的次数无法调用 并且多次监测没有恢复的迹象 断路器完全打开 那么下次请求就不会请求到该服务</text><text id="kity_text_15890" text-rendering="inherit" font-size="12" dy=".8em" y="15342.700000047684" x="83.5">(2)半开状态：时间内 有恢复迹象 断路器会将部分请求发给该服务，正常调用时 断路器关闭(3)关闭状态：当服务一直处于正常状态 能正常调用</text><text id="kity_text_15891" text-rendering="inherit" font-size="12" dy=".8em" y="15360.700000047684" x="83.5">3.服务降级：接口调用失败就调用本地的方法返回一个空。服务熔断：接口调用失败就会进入调用接口提前定义好的一个熔断的方法，返回错误信息</text><text id="kity_text_15892" text-rendering="inherit" font-size="12" dy=".8em" y="15378.700000047684" x="83.5">服务隔离：隔离服务之间相互影响。服务监控：在服务发生调用时,会将每秒请求数、成功请求数等运行指标记录下来。</text></g></g><g id="minder_node3052" display="none"><g id="node_expander3049" display="none" style="cursor: pointer;"><path id="kity_path_29669" fill="white" stroke="gray" d="M111.5,15358.5A6,6,0,1,1,99.5,15358.5A6,6,0,1,1,111.5,15358.5"></path><path id="kity_path_29670" fill="none" stroke="gray"></path></g><path id="node_outline3050" fill="none" stroke="none" d="M99.5,15349.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3050" fill="black"><text id="kity_text_15898" text-rendering="inherit" font-size="12" dy=".8em" y="15350.700000047684" x="99.5">熔断机制是什么？怎么实现？</text></g></g><g id="minder_node3053" display="none"><g id="node_expander3048" display="none" style="cursor: pointer;"><path id="kity_path_29666" fill="white" stroke="gray" d="M95.5,15358.5A6,6,0,1,1,83.5,15358.5A6,6,0,1,1,95.5,15358.5"></path><path id="kity_path_29667" fill="none" stroke="gray"></path></g><path id="node_outline3049" fill="none" stroke="none" d="M83.5,15349.5h307a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-307a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3049" fill="black"><text id="kity_text_15896" text-rendering="inherit" font-size="12" dy=".8em" y="15350.700000047684" x="83.5">https://blog.csdn.net/varyall/article/details/99722594</text></g></g><g id="minder_node3054" display="none"><g id="node_expander3050" display="none" style="cursor: pointer;"><path id="kity_path_29672" fill="white" stroke="gray" d="M111.5,15366.5A6,6,0,1,1,99.5,15366.5A6,6,0,1,1,111.5,15366.5"></path><path id="kity_path_29673" fill="none" stroke="gray"></path></g><path id="node_outline3051" fill="none" stroke="none" d="M99.5,15357.5h63a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-63a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3051" fill="black"><text id="kity_text_15900" text-rendering="inherit" font-size="12" dy=".8em" y="15358.700000047684" x="99.5">hystrix原理</text></g></g><g id="minder_node3055" display="none"><g id="node_expander3052" display="none" style="cursor: pointer;"><path id="kity_path_29678" fill="white" stroke="gray" d="M111.5,15374.5A6,6,0,1,1,99.5,15374.5A6,6,0,1,1,111.5,15374.5"></path><path id="kity_path_29679" fill="none" stroke="gray"></path></g><path id="node_outline3053" fill="none" stroke="none" d="M99.5,15365.5h173a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-173a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3053" fill="black"><text id="kity_text_15906" text-rendering="inherit" font-size="12" dy=".8em" y="15366.700000047684" x="99.5">什么场景用到断路器（Hystrix）</text></g></g><g id="minder_node3056" display="none"><g id="node_expander3051" display="none" style="cursor: pointer;"><path id="kity_path_29675" fill="white" stroke="gray" d="M95.5,15374.5A6,6,0,1,1,83.5,15374.5A6,6,0,1,1,95.5,15374.5"></path><path id="kity_path_29676" fill="none" stroke="gray"></path></g><path id="node_outline3052" fill="none" stroke="none" d="M83.5,15347.5h1541a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1541a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text3052" fill="black"><text id="kity_text_15902" text-rendering="inherit" font-size="12" dy=".8em" y="15348.700000047684" x="83.5">1.比如说 我们有个在xxx模块 xx的时侯 大量请求进来 的场景，那么我们其实到这一步已经 对于这个业务场景是需要去做接口服务一个熔断和延迟处理的，那么一方面是做熔断处理 可能让他重新确认一下，或者给他个提示，或者错误页面等等，前面通过一些本地限流的策略 然后做延迟处理，</text><text id="kity_text_15903" text-rendering="inherit" font-size="12" dy=".8em" y="15366.700000047684" x="83.5">但是我们这些请求并不是瞬时的，当然就算是瞬时的，那么对于一些请求可以的话我们是可以给他返回缓存的数据，等等，这里瞬时来的我们这个场景没有遇到，处理的不是很好，</text><text id="kity_text_15904" text-rendering="inherit" font-size="12" dy=".8em" y="15384.700000047684" x="83.5">如果重新设计的话 那么我可能会做一些降级处理，引导用户 或者是做进一步流控，或者流量错峰，队列来做削峰等等操作。让核心关键流程不受影响，而对于非核心可能做其他处理之类的</text></g></g><g id="minder_node3057" display="none"><g id="node_expander3054" display="none" style="cursor: pointer;"><path id="kity_path_29684" fill="white" stroke="gray" d="M111.5,15382.5A6,6,0,1,1,99.5,15382.5A6,6,0,1,1,111.5,15382.5"></path><path id="kity_path_29685" fill="none" stroke="gray"></path></g><path id="node_outline3055" fill="none" stroke="none" d="M99.5,15373.5h160a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-160a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3055" fill="black"><text id="kity_text_15914" text-rendering="inherit" font-size="12" dy=".8em" y="15374.700000047684" x="99.5">Hystrix熔断降级是怎么实现的</text></g></g><g id="minder_node3058" display="none"><g id="node_expander3053" display="none" style="cursor: pointer;"><path id="kity_path_29681" fill="white" stroke="gray" d="M95.5,15382.5A6,6,0,1,1,83.5,15382.5A6,6,0,1,1,95.5,15382.5"></path><path id="kity_path_29682" fill="none" stroke="gray"></path></g><path id="node_outline3054" fill="none" stroke="none" d="M83.5,15337.5h1219a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-1219a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text3054" fill="black"><text id="kity_text_15908" text-rendering="inherit" font-size="12" dy=".8em" y="15338.700000047684" x="83.5">熔断和降级都需要去配置文件开启</text><text id="kity_text_15909" text-rendering="inherit" font-size="12" dy=".8em" y="15356.700000047684" x="83.5">1.那么我们在服务中一般是开启熔断降级服务的注接，@EnableHystrix。但是一般会用到openfeign 拥有负载均衡和服务容错功能。我们通过feign的远程调用 的FeignClient注解的fallback 属性，然后来写我们的具体的处理逻辑。</text><text id="kity_text_15910" text-rendering="inherit" font-size="12" dy=".8em" y="15374.700000047684" x="83.5">那服务降级：当客户端请求服务器端的时候，防止客户端一直等待，不会处理业务逻辑代码，直接返回一个友好的提示给客户端。</text><text id="kity_text_15911" text-rendering="inherit" font-size="12" dy=".8em" y="15392.700000047684" x="83.5">服务熔断是在服务降级的基础上更直接的一种保护方式，当在一个统计时间范围内的请求失败数量达到设定值或当前的请求错误率达到设定的错误率阈值时开启断路，之后的请求直接走fallback方法，在设定时间后尝试恢复。</text><text id="kity_text_15912" text-rendering="inherit" font-size="12" dy=".8em" y="15410.700000047684" x="83.5">2.Hystrix实现服务降级的功能是通过重写HystrixCommand中的getFallback()方法，当Hystrix的run方法或construct执行发生错误时转而执行getFallback()方法。</text></g></g><g id="minder_node3059" display="none"><g id="node_expander3056" display="none" style="cursor: pointer;"><path id="kity_path_29690" fill="white" stroke="gray" d="M111.5,15390.5A6,6,0,1,1,99.5,15390.5A6,6,0,1,1,111.5,15390.5"></path><path id="kity_path_29691" fill="none" stroke="gray"></path></g><path id="node_outline3057" fill="none" stroke="none" d="M99.5,15381.5h112a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-112a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3057" fill="black"><text id="kity_text_15920" text-rendering="inherit" font-size="12" dy=".8em" y="15382.700000047684" x="99.5">Hystrix的相关注解？</text></g></g><g id="minder_node3060" display="none"><g id="node_expander3055" display="none" style="cursor: pointer;"><path id="kity_path_29687" fill="white" stroke="gray" d="M95.5,15390.5A6,6,0,1,1,83.5,15390.5A6,6,0,1,1,95.5,15390.5"></path><path id="kity_path_29688" fill="none" stroke="gray"></path></g><path id="node_outline3056" fill="none" stroke="none" d="M83.5,15363.5h744a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-744a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text3056" fill="black"><text id="kity_text_15916" text-rendering="inherit" font-size="12" dy=".8em" y="15364.700000047684" x="83.5">熔断</text><text id="kity_text_15917" text-rendering="inherit" font-size="12" dy=".8em" y="15382.700000047684" x="83.5">1.@EnableHystrix开启熔断</text><text id="kity_text_15918" text-rendering="inherit" font-size="12" dy=".8em" y="15400.700000047684" x="83.5">2.@HystrixComman声明一个失败回滚处理函数XXX，当被注解的方法执行超时（默认是 0毫秒），就会执行fallback函数，返回错误提示。</text></g></g><g id="minder_node3061" display="none"><g id="node_expander3059" display="none" style="cursor: pointer;"><path id="kity_path_29699" fill="white" stroke="gray" d="M111.5,15398.5A6,6,0,1,1,99.5,15398.5A6,6,0,1,1,111.5,15398.5"></path><path id="kity_path_29700" fill="none" stroke="gray"></path></g><path id="node_outline3060" fill="none" stroke="none" d="M99.5,15389.5h134a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-134a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3060" fill="black"><text id="kity_text_15936" text-rendering="inherit" font-size="12" dy=".8em" y="15390.700000047684" x="99.5">hystrix怎么做的服务隔离</text></g></g><g id="minder_node3062" display="none"><g id="node_expander3058" display="none" style="cursor: pointer;"><path id="kity_path_29696" fill="white" stroke="gray" d="M95.5,15398.5A6,6,0,1,1,83.5,15398.5A6,6,0,1,1,95.5,15398.5"></path><path id="kity_path_29697" fill="none" stroke="gray"></path></g><path id="node_outline3059" fill="none" stroke="none" d="M83.5,15308.5h1101a5,5,0,0,1,5,5v170a5,5,0,0,1,-5,5h-1101a5,5,0,0,1,-5,-5v-170a5,5,0,0,1,5,-5z"></path><g id="node_text3059" fill="black"><text id="kity_text_15925" text-rendering="inherit" font-size="12" dy=".8em" y="15309.700000047684" x="83.5">1.Hystrix为每一个隔离的服务开启一个独立的线程池，线程隔离或信号隔离的目的是为不同的服务分配一定的资源，当自己的资源用完，直接返回失败而不是占用别人的资源。防止依赖扩散</text><text id="kity_text_15926" text-rendering="inherit" font-size="12" dy=".8em" y="15327.700000047684" x="83.5">服务隔离有线程池和信号量两种实现方式，一般使用线程池方式。两个区别在于 信号量执行依赖代码的线程依然是请求线程</text><text id="kity_text_15927" text-rendering="inherit" font-size="12" dy=".8em" y="15345.700000047684" x="83.5">2.信号量：记录当前有多少个线程在运行，当请求进来时先判断计数 器的数值；若超过设置的最大线程个数则拒绝该请求，若不超过则通行，这时候计数器+1，请求返回成功后计数器-1；</text><text id="kity_text_15928" text-rendering="inherit" font-size="12" dy=".8em" y="15363.700000047684" x="83.5">通过 继承 HystrixCommand类 来实现，然后做属性分组 然后设置 SemaphoreMaxConcurrentRequests，如果是50 就是最大处理50个请求，结束还回去，并编写当前服务不可用follback方法</text><text id="kity_text_15929" text-rendering="inherit" font-size="12" dy=".8em" y="15381.700000047684" x="83.5">场景： 内部调用或者中间件（redis）；可以 降低线程隔离的上下文切换开销； 并发需求不大 因为 主因为如果并发需求较大，相应的信号量的数量就要设置得够大，而Tomcat 线程与处理线程为同一个线程，</text><text id="kity_text_15930" text-rendering="inherit" font-size="12" dy=".8em" y="15399.700000047684" x="83.5">那么这个依赖调用就会占用过多的 Tomcat 线程资源，有可能会影响到其他服务的接收。</text><text id="kity_text_15931" text-rendering="inherit" font-size="12" dy=".8em" y="15417.700000047684" x="83.5">3.线程池</text><text id="kity_text_15932" text-rendering="inherit" font-size="12" dy=".8em" y="15435.700000047684" x="83.5">继承MyHystrixCommand类 通过andThreadPoolPropertiesDefaults配置线程池的一些参数，并编写当前服务不可用follback方法</text><text id="kity_text_15933" text-rendering="inherit" font-size="12" dy=".8em" y="15453.700000047684" x="83.5">场景：使用线程池隔离可以完全隔离第三方应用，解决timeout问题，请求线程可以快速放回继续接受新的请求；再次可用时，线程池将清理并可立即恢复，不需长时间的恢复。适用并发量大</text><text id="kity_text_15934" text-rendering="inherit" font-size="12" dy=".8em" y="15471.700000047684" x="83.5">但是增加了调度，上下文切换，计算的开销。</text></g></g><g id="minder_node3063" display="none"><g id="node_expander3057" display="none" style="cursor: pointer;"><path id="kity_path_29693" fill="white" stroke="gray" d="M79.5,15398.5A6,6,0,1,1,67.5,15398.5A6,6,0,1,1,79.5,15398.5"></path><path id="kity_path_29694" fill="none" stroke="gray"></path></g><path id="node_outline3058" fill="none" stroke="none" d="M67.5,15380.5h310a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-310a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text3058" fill="black"><text id="kity_text_15922" text-rendering="inherit" font-size="12" dy=".8em" y="15381.700000047684" x="67.5">https://blog.csdn.net/selt791/article/details/94061940</text><text id="kity_text_15923" text-rendering="inherit" font-size="12" dy=".8em" y="15399.700000047684" x="67.5">http://c.biancheng.net/view/5389.html</text></g></g><g id="minder_node3064" display="none"><g id="node_expander3062" display="none" style="cursor: pointer;"><path id="kity_path_29708" fill="white" stroke="gray" d="M111.5,15406.5A6,6,0,1,1,99.5,15406.5A6,6,0,1,1,111.5,15406.5"></path><path id="kity_path_29709" fill="none" stroke="gray"></path></g><path id="node_outline3063" fill="none" stroke="none" d="M99.5,15397.5h111a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-111a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3063" fill="black"><text id="kity_text_15945" text-rendering="inherit" font-size="12" dy=".8em" y="15398.700000047684" x="99.5">hystrix怎么做的限流</text></g></g><g id="minder_node3065" display="none"><g id="node_expander3061" display="none" style="cursor: pointer;"><path id="kity_path_29705" fill="white" stroke="gray" d="M95.5,15406.5A6,6,0,1,1,83.5,15406.5A6,6,0,1,1,95.5,15406.5"></path><path id="kity_path_29706" fill="none" stroke="gray"></path></g><path id="node_outline3062" fill="none" stroke="none" d="M83.5,15388.5h654a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-654a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text3062" fill="black"><text id="kity_text_15942" text-rendering="inherit" font-size="12" dy=".8em" y="15389.700000047684" x="83.5">1.第一种 就是 直接编写 服务线程池隔离 设置并发请求处理参数 来实现限流 和fallback的降级</text><text id="kity_text_15943" text-rendering="inherit" font-size="12" dy=".8em" y="15407.700000047684" x="83.5">2.通过application.properties来实现 设置服务线程池大小，核心线程大小，阻塞队列拒绝大小，设置 接口超时时间 就限流&#xa0;</text></g></g><g id="minder_node3066" display="none"><g id="node_expander3060" display="none" style="cursor: pointer;"><path id="kity_path_29702" fill="white" stroke="gray" d="M79.5,15406.5A6,6,0,1,1,67.5,15406.5A6,6,0,1,1,79.5,15406.5"></path><path id="kity_path_29703" fill="none" stroke="gray"></path></g><path id="node_outline3061" fill="none" stroke="none" d="M67.5,15379.5h336a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-336a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text3061" fill="black"><text id="kity_text_15938" text-rendering="inherit" font-size="12" dy=".8em" y="15380.700000047684" x="67.5">https://blog.csdn.net/Anbang713/article/details/85916559</text><text id="kity_text_15939" text-rendering="inherit" font-size="12" dy=".8em" y="15398.700000047684" x="67.5">https://blog.csdn.net/varyall/article/details/99722594</text><text id="kity_text_15940" text-rendering="inherit" font-size="12" dy=".8em" y="15416.700000047684" x="67.5">https://blog.csdn.net/varyall/article/details/99722594</text></g></g><g id="minder_node3067" display="none"><g id="node_expander3065" display="none" style="cursor: pointer;"><path id="kity_path_29717" fill="white" stroke="gray" d="M111.5,15414.5A6,6,0,1,1,99.5,15414.5A6,6,0,1,1,111.5,15414.5"></path><path id="kity_path_29718" fill="none" stroke="gray"></path></g><path id="node_outline3066" fill="none" stroke="none" d="M99.5,15405.5h174a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-174a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3066" fill="black"><text id="kity_text_15956" text-rendering="inherit" font-size="12" dy=".8em" y="15406.700000047684" x="99.5">项目中 hystrix有遇到什么问题？</text></g></g><g id="minder_node3068" display="none"><g id="node_expander3064" display="none" style="cursor: pointer;"><path id="kity_path_29714" fill="white" stroke="gray" d="M95.5,15414.5A6,6,0,1,1,83.5,15414.5A6,6,0,1,1,95.5,15414.5"></path><path id="kity_path_29715" fill="none" stroke="gray"></path></g><path id="node_outline3065" fill="none" stroke="none" d="M83.5,15360.5h709a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-709a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text3065" fill="black"><text id="kity_text_15949" text-rendering="inherit" font-size="12" dy=".8em" y="15361.700000047684" x="83.5">1.超时：确保Hystrix超时时间配置为⻓于配置的Ribbon超时时间。</text><text id="kity_text_15950" text-rendering="inherit" font-size="12" dy=".8em" y="15379.700000047684" x="83.5">使用Feign调用接口分两层，ribbon的调用和hystrix的调用，所以ribbon的超时时间和Hystrix的超时时间的结合就是Feign的超时时间</text><text id="kity_text_15951" text-rendering="inherit" font-size="12" dy=".8em" y="15397.700000047684" x="83.5">因为ribbon的重试机制和Feign的重试机制有冲突，所以源码中默认关闭Feign的重试机制</text><text id="kity_text_15952" text-rendering="inherit" font-size="12" dy=".8em" y="15415.700000047684" x="83.5">如果不配置ribbon的重试次数，默认会重试一次</text><text id="kity_text_15953" text-rendering="inherit" font-size="12" dy=".8em" y="15433.700000047684" x="83.5">默认情况下,GET方式请求无论是连接异常还是读取异常,都会进行重试</text><text id="kity_text_15954" text-rendering="inherit" font-size="12" dy=".8em" y="15451.700000047684" x="83.5">非GET方式请求,只有连接异常时,才会进行重试</text></g></g><g id="minder_node3069" display="none"><g id="node_expander3063" display="none" style="cursor: pointer;"><path id="kity_path_29711" fill="white" stroke="gray" d="M79.5,15414.5A6,6,0,1,1,67.5,15414.5A6,6,0,1,1,79.5,15414.5"></path><path id="kity_path_29712" fill="none" stroke="gray"></path></g><path id="node_outline3064" fill="none" stroke="none" d="M67.5,15405.5h335a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-335a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3064" fill="black"><text id="kity_text_15947" text-rendering="inherit" font-size="12" dy=".8em" y="15406.700000047684" x="67.5">https://blog.csdn.net/east123321/article/details/82385816</text></g></g><g id="minder_node3070" display="none"><g id="node_expander3066" display="none" style="cursor: pointer;"><path id="kity_path_29720" fill="white" stroke="gray" d="M111.5,15422.5A6,6,0,1,1,99.5,15422.5A6,6,0,1,1,111.5,15422.5"></path><path id="kity_path_29721" fill="none" stroke="gray"></path></g><path id="node_outline3067" fill="none" stroke="none" d="M99.5,15413.5h87a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-87a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3067" fill="black"><text id="kity_text_15958" text-rendering="inherit" font-size="12" dy=".8em" y="15414.700000047684" x="99.5">hystrix如何优化</text></g></g><g id="minder_node3071" display="none"><g id="node_expander3069" display="none" style="cursor: pointer;"><path id="kity_path_29729" fill="white" stroke="gray" d="M111.5,15430.5A6,6,0,1,1,99.5,15430.5A6,6,0,1,1,111.5,15430.5"></path><path id="kity_path_29730" fill="none" stroke="gray"></path></g><path id="node_outline3070" fill="none" stroke="none" d="M99.5,15421.5h147a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-147a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3070" fill="black"><text id="kity_text_15972" text-rendering="inherit" font-size="12" dy=".8em" y="15422.700000047684" x="99.5">sentinel?项目中怎么用的？</text></g></g><g id="minder_node3072" display="none"><g id="node_expander3068" display="none" style="cursor: pointer;"><path id="kity_path_29726" fill="white" stroke="gray" d="M95.5,15430.5A6,6,0,1,1,83.5,15430.5A6,6,0,1,1,95.5,15430.5"></path><path id="kity_path_29727" fill="none" stroke="gray"></path></g><path id="node_outline3069" fill="none" stroke="none" d="M83.5,15367.5h854a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-854a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text3069" fill="black"><text id="kity_text_15964" text-rendering="inherit" font-size="12" dy=".8em" y="15368.700000047684" x="83.5">1.我们项目引入的是sentinel来做全服务流控，实时状态监控，对一些并发模块请求做熔断降级。</text><text id="kity_text_15965" text-rendering="inherit" font-size="12" dy=".8em" y="15386.700000047684" x="83.5">在他的配置台可以指定规则，指定资源。对于熔断保护，通过SentinelResource注解标记资源 实现feign接口的callback 作为本地熔断方法的保护措施。</text><text id="kity_text_15966" text-rendering="inherit" font-size="12" dy=".8em" y="15404.700000047684" x="83.5">指定降级策略 和流控处理&#xa0; 可以通过并发数 和异常率等来指定，然后对统一资源不同数据做不同上限处理。比如说我们的大用户 大业务。</text><text id="kity_text_15967" text-rendering="inherit" font-size="12" dy=".8em" y="15422.700000047684" x="83.5">可以对指定资源做 限流/降级/系统保护后 返回前端的处理，我们对可以流控后的调用如果缓存数据可用 并且影响不大 就给他返回缓存数据，或者就是做降级处理</text><text id="kity_text_15968" text-rendering="inherit" font-size="12" dy=".8em" y="15440.700000047684" x="83.5">(在网关层也可以做流控 通过QPS和线程数对api做流控，需要响应式编程 不熟悉就别说了)。</text><text id="kity_text_15969" text-rendering="inherit" font-size="12" dy=".8em" y="15458.700000047684" x="83.5">2.也是ali的产品 文档 生态比较友好， 适配各种框架。不必全手工添加熔断保护性代码。</text><text id="kity_text_15970" text-rendering="inherit" font-size="12" dy=".8em" y="15476.700000047684" x="83.5">3.做我们项目的 年终 会有大请求，通过10000左右的QPS，查询为主，这个是没问题，然后做了流控，</text></g></g><g id="minder_node3073" display="none"><g id="node_expander3067" display="none" style="cursor: pointer;"><path id="kity_path_29723" fill="white" stroke="gray" d="M79.5,15430.5A6,6,0,1,1,67.5,15430.5A6,6,0,1,1,79.5,15430.5"></path><path id="kity_path_29724" fill="none" stroke="gray"></path></g><path id="node_outline3068" fill="none" stroke="none" d="M67.5,15403.5h391a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-391a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text3068" fill="black"><text id="kity_text_15960" text-rendering="inherit" font-size="12" dy=".8em" y="15404.700000047684" x="67.5">https://gitee.com/xiaobo97/viwmall#sentinel</text><text id="kity_text_15961" text-rendering="inherit" font-size="12" dy=".8em" y="15422.700000047684" x="67.5">https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D</text><text id="kity_text_15962" text-rendering="inherit" font-size="12" dy=".8em" y="15440.700000047684" x="67.5">https://juejin.cn/post/6844903749706579975#heading-0</text></g></g><g id="minder_node3074" display="none"><g id="node_expander3071" display="none" style="cursor: pointer;"><path id="kity_path_29735" fill="white" stroke="gray" d="M111.5,15438.5A6,6,0,1,1,99.5,15438.5A6,6,0,1,1,111.5,15438.5"></path><path id="kity_path_29736" fill="none" stroke="gray"></path></g><path id="node_outline3072" fill="none" stroke="none" d="M99.5,15429.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3072" fill="black"><text id="kity_text_15976" text-rendering="inherit" font-size="12" dy=".8em" y="15430.700000047684" x="99.5">用在什么方面？</text></g></g><g id="minder_node3075" display="none"><g id="node_expander3070" display="none" style="cursor: pointer;"><path id="kity_path_29732" fill="white" stroke="gray" d="M95.5,15438.5A6,6,0,1,1,83.5,15438.5A6,6,0,1,1,95.5,15438.5"></path><path id="kity_path_29733" fill="none" stroke="gray"></path></g><path id="node_outline3071" fill="none" stroke="none" d="M83.5,15429.5h34a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-34a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3071" fill="black"><text id="kity_text_15974" text-rendering="inherit" font-size="12" dy=".8em" y="15430.700000047684" x="83.5">1.同上</text></g></g><g id="minder_node3076" display="none"><g id="node_expander3074" display="none" style="cursor: pointer;"><path id="kity_path_29744" fill="white" stroke="gray" d="M111.5,15446.5A6,6,0,1,1,99.5,15446.5A6,6,0,1,1,111.5,15446.5"></path><path id="kity_path_29745" fill="none" stroke="gray"></path></g><path id="node_outline3075" fill="none" stroke="none" d="M99.5,15437.5h96a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-96a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3075" fill="black"><text id="kity_text_15998" text-rendering="inherit" font-size="12" dy=".8em" y="15438.700000047684" x="99.5">限流的算法知道吗</text></g></g><g id="minder_node3077" display="none"><g id="node_expander3073" display="none" style="cursor: pointer;"><path id="kity_path_29741" fill="white" stroke="gray" d="M95.5,15446.5A6,6,0,1,1,83.5,15446.5A6,6,0,1,1,95.5,15446.5"></path><path id="kity_path_29742" fill="none" stroke="gray"></path></g><path id="node_outline3074" fill="none" stroke="none" d="M83.5,15311.5h1410a5,5,0,0,1,5,5v260a5,5,0,0,1,-5,5h-1410a5,5,0,0,1,-5,-5v-260a5,5,0,0,1,5,-5z"></path><g id="node_text3074" fill="black"><text id="kity_text_15982" text-rendering="inherit" font-size="12" dy=".8em" y="15312.700000047684" x="83.5">1.</text><text id="kity_text_15983" text-rendering="inherit" font-size="12" dy=".8em" y="15330.700000047684" x="83.5">(1)令牌算法&#xa0; 核心思想是 以某种恒定的速度生成令牌，并存入令牌桶中，而每个请求需要先获取令牌才能执行，如果没有获取到令牌的请求可以选择等待或者放弃执行。可以使用guava RateLimiter来实现 参数是每秒产生令牌数。</text><text id="kity_text_15984" text-rendering="inherit" font-size="12" dy=".8em" y="15348.700000047684" x="83.5">通过 tryAcquire() 方法也可以设置超时时间，未超过最大等待时间会阻塞等待获取令牌，如果超过了最大等待时间，还没有可用的令牌就会返回 false。</text><text id="kity_text_15985" text-rendering="inherit" font-size="12" dy=".8em" y="15366.700000047684" x="83.5">优点：令牌满了可以满足突然的大请求；属于单机的限流。如果是分布式下 需要考虑令牌桶的存储和令牌补充，可以用redis存储，但是补充不是很友好，有且只有一个服务去补充，可能挂了。</text><text id="kity_text_15986" text-rendering="inherit" font-size="12" dy=".8em" y="15384.700000047684" x="83.5">(2)漏桶算法&#xa0; 核心是 无论请求有多少，它都是以均匀的速度慢慢流出的。当流入大于流出时，漏斗会慢慢变满，当漏斗满了之后就会丢弃新来的请求;当流入速度小于流出时，漏斗永远不会被装满，并且可以一直流出。</text><text id="kity_text_15987" text-rendering="inherit" font-size="12" dy=".8em" y="15402.700000047684" x="83.5">通过一个FIFO的有界队列实现，大小a,如果请求堆积满了队列，就会触发丢弃策略。假设允许的请求速率为r次每秒，那么这个队列中的请求，就会以这个速率进行消费。通过redis-cell可以实现。需要考虑的是 如何消费，后进来的请求延迟怎么处理。</text><text id="kity_text_15988" text-rendering="inherit" font-size="12" dy=".8em" y="15420.700000047684" x="83.5">(3)时间窗口算法</text><text id="kity_text_15989" text-rendering="inherit" font-size="12" dy=".8em" y="15438.700000047684" x="83.5">将时间切分成若干个时间片，每个时间片内固定处理若干个请求。比如说60s 内最大100个请求，60s 分多个时间片，那么当前时间片请求加上之前的是否超过100，会先计算当前集合内请求数量是否大于设定的最大请求数。大于则执行限流拒绝策略，否则正常执行。</text><text id="kity_text_15990" text-rendering="inherit" font-size="12" dy=".8em" y="15456.700000047684" x="83.5">例如限制 1 秒内最多 100 个请求。假设 0.99 秒的时候 100 个请求到了，之后 1.01 秒的时候又有 100 个请求到了，这样的话其实在 0.99 秒 ~ 1.01 秒这一段时间内有 200 个请求，并不是严格意义上的每一秒都只处理 100 个请求,</text><text id="kity_text_15991" text-rendering="inherit" font-size="12" dy=".8em" y="15474.700000047684" x="83.5">可以通过 redis的zset来实现，key-限流的id标识 score-请求的时间 ，每一次请求来先清空之前的窗口访问量，然后统计现在窗口和最大访问量对比 大于就限流，否则就处理请求；</text><text id="kity_text_15992" text-rendering="inherit" font-size="12" dy=".8em" y="15492.700000047684" x="83.5">缺点：执行非原子操作，先判断后增加，中间空隙可穿插其他业务逻辑的执行，最终导致结果不准确。</text><text id="kity_text_15993" text-rendering="inherit" font-size="12" dy=".8em" y="15510.700000047684" x="83.5">(4)滑动日志</text><text id="kity_text_15994" text-rendering="inherit" font-size="12" dy=".8em" y="15528.700000047684" x="83.5">可以解决时间窗口不是严格意义的限流，他会删除固定时间窗口中n秒前的请求，解决了明明是100个请求，移动一个窗口变200请求的问题，然后看是否满了，满了就拒绝，没满就通过请求并放入集合中</text><text id="kity_text_15995" text-rendering="inherit" font-size="12" dy=".8em" y="15546.700000047684" x="83.5">分布式情况下 怎么安全删除多的请求的问题</text><text id="kity_text_15996" text-rendering="inherit" font-size="12" dy=".8em" y="15564.700000047684" x="83.5">(5)滑动窗口(固定时间窗口+滑动日志)</text></g></g><g id="minder_node3078" display="none"><g id="node_expander3072" display="none" style="cursor: pointer;"><path id="kity_path_29738" fill="white" stroke="gray" d="M79.5,15446.5A6,6,0,1,1,67.5,15446.5A6,6,0,1,1,79.5,15446.5"></path><path id="kity_path_29739" fill="none" stroke="gray"></path></g><path id="node_outline3073" fill="none" stroke="none" d="M67.5,15419.5h326a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text3073" fill="black"><text id="kity_text_15978" text-rendering="inherit" font-size="12" dy=".8em" y="15420.700000047684" x="67.5">https://juejin.cn/post/6924084069462441991#heading-0</text><text id="kity_text_15979" text-rendering="inherit" font-size="12" dy=".8em" y="15438.700000047684" x="67.5">https://juejin.cn/post/6844904161604009997#heading-7</text><text id="kity_text_15980" text-rendering="inherit" font-size="12" dy=".8em" y="15456.700000047684" x="67.5">https://juejin.cn/post/6844903599571632136#heading-0</text></g></g><g id="minder_node3079" display="none"><g id="node_expander3076" display="none" style="cursor: pointer;"><path id="kity_path_29750" fill="white" stroke="gray" d="M111.5,15454.5A6,6,0,1,1,99.5,15454.5A6,6,0,1,1,111.5,15454.5"></path><path id="kity_path_29751" fill="none" stroke="gray"></path></g><path id="node_outline3077" fill="none" stroke="none" d="M99.5,15445.5h125a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-125a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3077" fill="black"><text id="kity_text_16008" text-rendering="inherit" font-size="12" dy=".8em" y="15446.700000047684" x="99.5">&#xa0;限流实现的方案有哪些</text></g></g><g id="minder_node3080" display="none"><g id="node_expander3075" display="none" style="cursor: pointer;"><path id="kity_path_29747" fill="white" stroke="gray" d="M95.5,15454.5A6,6,0,1,1,83.5,15454.5A6,6,0,1,1,95.5,15454.5"></path><path id="kity_path_29748" fill="none" stroke="gray"></path></g><path id="node_outline3076" fill="none" stroke="none" d="M83.5,15391.5h1299a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-1299a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text3076" fill="black"><text id="kity_text_16000" text-rendering="inherit" font-size="12" dy=".8em" y="15392.700000047684" x="83.5">1.限流在tomcat和nginx可以做限流</text><text id="kity_text_16001" text-rendering="inherit" font-size="12" dy=".8em" y="15410.700000047684" x="83.5">tomcat:Tomcat 的最大线程数，当请求的并发大于此值（maxThreads）时，请求就会排队执行，这样就完成了限流的目的。每开启一个线程需要耗用 1MB 的 JVM 内存空间用于作为线程栈之用，并且线程越多 GC 的负担也越重。</text><text id="kity_text_16002" text-rendering="inherit" font-size="12" dy=".8em" y="15428.700000047684" x="83.5">Windows 每个进程中的线程数不允许超过 2000，Linux 每个进程中的线程数不允许超过 1000。</text><text id="kity_text_16003" text-rendering="inherit" font-size="12" dy=".8em" y="15446.700000047684" x="83.5">nginx: 主要方式(1)控制速率，limit_req_zone 用来限制单位时间内的请求数.可以使用burst 关键字 控制一个 IP 单位总时间内的总访问次数。(2)控制并发连接数。可以限制单个 IP 同时最多能持有的连接数 和&#xa0; server 同时能处理并发连接的总数。</text><text id="kity_text_16004" text-rendering="inherit" font-size="12" dy=".8em" y="15464.700000047684" x="83.5">2.服务端限流：(1)令牌算法&#xa0; (2)漏桶算法&#xa0; (3)时间窗口算法</text><text id="kity_text_16005" text-rendering="inherit" font-size="12" dy=".8em" y="15482.700000047684" x="83.5">3.合法性验证限流：验证码、IP 黑名单等，这些手段可以有效的防止恶意攻击和爬虫采集；</text><text id="kity_text_16006" text-rendering="inherit" font-size="12" dy=".8em" y="15500.700000047684" x="83.5">4.分布式下可以通过 sentinel做全服务流控&#xa0; hystrix也可以做</text></g></g><g id="minder_node3081" display="none"><g id="node_expander3078" display="none" style="cursor: pointer;"><path id="kity_path_29756" fill="white" stroke="gray" d="M111.5,15462.5A6,6,0,1,1,99.5,15462.5A6,6,0,1,1,111.5,15462.5"></path><path id="kity_path_29757" fill="none" stroke="gray"></path></g><path id="node_outline3079" fill="none" stroke="none" d="M99.5,15453.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3079" fill="black"><text id="kity_text_16012" text-rendering="inherit" font-size="12" dy=".8em" y="15454.700000047684" x="99.5">继续上面那个问题说说令牌桶</text></g></g><g id="minder_node3082" display="none"><g id="node_expander3077" display="none" style="cursor: pointer;"><path id="kity_path_29753" fill="white" stroke="gray" d="M95.5,15462.5A6,6,0,1,1,83.5,15462.5A6,6,0,1,1,95.5,15462.5"></path><path id="kity_path_29754" fill="none" stroke="gray"></path></g><path id="node_outline3078" fill="none" stroke="none" d="M83.5,15453.5h34a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-34a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3078" fill="black"><text id="kity_text_16010" text-rendering="inherit" font-size="12" dy=".8em" y="15454.700000047684" x="83.5">1.同上</text></g></g><g id="minder_node3083" display="none"><g id="node_expander3080" display="none" style="cursor: pointer;"><path id="kity_path_29762" fill="white" stroke="gray" d="M111.5,15470.5A6,6,0,1,1,99.5,15470.5A6,6,0,1,1,111.5,15470.5"></path><path id="kity_path_29763" fill="none" stroke="gray"></path></g><path id="node_outline3081" fill="none" stroke="none" d="M99.5,15461.5h169a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-169a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3081" fill="black"><text id="kity_text_16016" text-rendering="inherit" font-size="12" dy=".8em" y="15462.700000047684" x="99.5">继续上面那个问题说说时间窗口</text></g></g><g id="minder_node3084" display="none"><g id="node_expander3079" display="none" style="cursor: pointer;"><path id="kity_path_29759" fill="white" stroke="gray" d="M95.5,15470.5A6,6,0,1,1,83.5,15470.5A6,6,0,1,1,95.5,15470.5"></path><path id="kity_path_29760" fill="none" stroke="gray"></path></g><path id="node_outline3080" fill="none" stroke="none" d="M83.5,15461.5h34a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-34a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3080" fill="black"><text id="kity_text_16014" text-rendering="inherit" font-size="12" dy=".8em" y="15462.700000047684" x="83.5">1.同上</text></g></g><g id="minder_node3085" display="none"><g id="node_expander3082" display="none" style="cursor: pointer;"><path id="kity_path_29768" fill="white" stroke="gray" d="M111.5,15478.5A6,6,0,1,1,99.5,15478.5A6,6,0,1,1,111.5,15478.5"></path><path id="kity_path_29769" fill="none" stroke="gray"></path></g><path id="node_outline3083" fill="none" stroke="none" d="M99.5,15469.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3083" fill="black"><text id="kity_text_16024" text-rendering="inherit" font-size="12" dy=".8em" y="15470.700000047684" x="99.5">接口限流的实现方法有哪些？</text></g></g><g id="minder_node3086" display="none"><g id="node_expander3081" display="none" style="cursor: pointer;"><path id="kity_path_29765" fill="white" stroke="gray" d="M95.5,15478.5A6,6,0,1,1,83.5,15478.5A6,6,0,1,1,95.5,15478.5"></path><path id="kity_path_29766" fill="none" stroke="gray"></path></g><path id="node_outline3082" fill="none" stroke="none" d="M83.5,15433.5h434a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-434a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text3082" fill="black"><text id="kity_text_16018" text-rendering="inherit" font-size="12" dy=".8em" y="15434.700000047684" x="83.5">1.用nginx 的limit_conn模块做限制 瞬时并发数</text><text id="kity_text_16019" text-rendering="inherit" font-size="12" dy=".8em" y="15452.700000047684" x="83.5">2.限制 时间窗⼝内的平均速率，如guava 的RateLimiter，nginx 的 limit_req模块</text><text id="kity_text_16020" text-rendering="inherit" font-size="12" dy=".8em" y="15470.700000047684" x="83.5">3.限制 远程接⼝ 调⽤速率</text><text id="kity_text_16021" text-rendering="inherit" font-size="12" dy=".8em" y="15488.700000047684" x="83.5">4.限制 MQ 的消费速率</text><text id="kity_text_16022" text-rendering="inherit" font-size="12" dy=".8em" y="15506.700000047684" x="83.5">5.可以根据⽹络连接数、⽹络流量、CPU或内存负载等来限流</text></g></g><g id="minder_node3087" display="none"><g id="node_expander3094" display="none" style="cursor: pointer;"><path id="kity_path_29804" fill="white" stroke="gray" d="M127.5,15486.5A6,6,0,1,1,115.5,15486.5A6,6,0,1,1,127.5,15486.5"></path><path id="kity_path_29805" fill="none" stroke="gray"></path></g><path id="node_outline3095" fill="none" stroke="none" d="M115.5,15477.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3095" fill="black"><text id="kity_text_16056" text-rendering="inherit" font-size="12" dy=".8em" y="15478.700000047684" x="115.5">服务调用</text></g></g><g id="minder_node3088" display="none"><g id="node_expander3086" display="none" style="cursor: pointer;"><path id="kity_path_29780" fill="white" stroke="gray" d="M111.5,15462.5A6,6,0,1,1,99.5,15462.5A6,6,0,1,1,111.5,15462.5"></path><path id="kity_path_29781" fill="none" stroke="gray"></path></g><path id="node_outline3087" fill="none" stroke="none" d="M99.5,15453.5h241a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-241a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3087" fill="black"><text id="kity_text_16034" text-rendering="inherit" font-size="12" dy=".8em" y="15454.700000047684" x="99.5">作为调用方和被调用放如何对避免服务雪崩？</text></g></g><g id="minder_node3089" display="none"><g id="node_expander3085" display="none" style="cursor: pointer;"><path id="kity_path_29777" fill="white" stroke="gray" d="M95.5,15462.5A6,6,0,1,1,83.5,15462.5A6,6,0,1,1,95.5,15462.5"></path><path id="kity_path_29778" fill="none" stroke="gray"></path></g><path id="node_outline3086" fill="none" stroke="none" d="M83.5,15435.5h463a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-463a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text3086" fill="black"><text id="kity_text_16030" text-rendering="inherit" font-size="12" dy=".8em" y="15436.700000047684" x="83.5">主要是从服务可靠性&#xa0; 可用性 考虑</text><text id="kity_text_16031" text-rendering="inherit" font-size="12" dy=".8em" y="15454.700000047684" x="83.5">1.调用方 页面拒绝， 关闭重试，提示页面，重新引导。</text><text id="kity_text_16032" text-rendering="inherit" font-size="12" dy=".8em" y="15472.700000047684" x="83.5">2.被调用方 服务熔断 服务降级 服务限流(网关限流，服务端限流，mq削峰) 缓存预加载&#xa0;</text></g></g><g id="minder_node3090" display="none"><g id="node_expander3084" display="none" style="cursor: pointer;"><path id="kity_path_29774" fill="white" stroke="gray" d="M79.5,15462.5A6,6,0,1,1,67.5,15462.5A6,6,0,1,1,79.5,15462.5"></path><path id="kity_path_29775" fill="none" stroke="gray"></path></g><path id="node_outline3085" fill="none" stroke="none" d="M67.5,15453.5h373a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-373a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3085" fill="black"><text id="kity_text_16028" text-rendering="inherit" font-size="12" dy=".8em" y="15454.700000047684" x="67.5">https://blog.csdn.net/sheinenggaosuwo/article/details/86592893</text></g></g><g id="minder_node3091" display="none"><g id="node_expander3089" display="none" style="cursor: pointer;"><path id="kity_path_29789" fill="white" stroke="gray" d="M111.5,15470.5A6,6,0,1,1,99.5,15470.5A6,6,0,1,1,111.5,15470.5"></path><path id="kity_path_29790" fill="none" stroke="gray"></path></g><path id="node_outline3090" fill="none" stroke="none" d="M99.5,15461.5h119a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-119a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3090" fill="black"><text id="kity_text_16043" text-rendering="inherit" font-size="12" dy=".8em" y="15462.700000047684" x="99.5">&#xa0;Feign为什么效率低？</text></g></g><g id="minder_node3092" display="none"><g id="node_expander3088" display="none" style="cursor: pointer;"><path id="kity_path_29786" fill="white" stroke="gray" d="M95.5,15470.5A6,6,0,1,1,83.5,15470.5A6,6,0,1,1,95.5,15470.5"></path><path id="kity_path_29787" fill="none" stroke="gray"></path></g><path id="node_outline3089" fill="none" stroke="none" d="M83.5,15452.5h651a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-651a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text3089" fill="black"><text id="kity_text_16040" text-rendering="inherit" font-size="12" dy=".8em" y="15453.700000047684" x="83.5">1.feign底层是jdk的HttpURLConnection&#xa0;建立连接且每次请求都建立一个新的连接</text><text id="kity_text_16041" text-rendering="inherit" font-size="12" dy=".8em" y="15471.700000047684" x="83.5">2.可以使用其他组件替换，比如说okhttp 和httpclient，引入 配置即可，他里面有通过连接池提高效率。方便我们指定参数</text></g></g><g id="minder_node3093" display="none"><g id="node_expander3087" display="none" style="cursor: pointer;"><path id="kity_path_29783" fill="white" stroke="gray" d="M79.5,15470.5A6,6,0,1,1,67.5,15470.5A6,6,0,1,1,79.5,15470.5"></path><path id="kity_path_29784" fill="none" stroke="gray"></path></g><path id="node_outline3088" fill="none" stroke="none" d="M67.5,15443.5h350a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-350a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text3088" fill="black"><text id="kity_text_16036" text-rendering="inherit" font-size="12" dy=".8em" y="15444.700000047684" x="67.5">1.https://blog.csdn.net/u010277958/article/details/88730889</text><text id="kity_text_16037" text-rendering="inherit" font-size="12" dy=".8em" y="15462.700000047684" x="67.5">2.https://blog.csdn.net/hry2015/article/details/79904815</text><text id="kity_text_16038" text-rendering="inherit" font-size="12" dy=".8em" y="15480.700000047684" x="67.5">3.https://www.jb51.net/article/176095.htm</text></g></g><g id="minder_node3094" display="none"><g id="node_expander3091" display="none" style="cursor: pointer;"><path id="kity_path_29795" fill="white" stroke="gray" d="M111.5,15478.5A6,6,0,1,1,99.5,15478.5A6,6,0,1,1,111.5,15478.5"></path><path id="kity_path_29796" fill="none" stroke="gray"></path></g><path id="node_outline3092" fill="none" stroke="none" d="M99.5,15469.5h122a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-122a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3092" fill="black"><text id="kity_text_16049" text-rendering="inherit" font-size="12" dy=".8em" y="15470.700000047684" x="99.5">服务之间怎么进行通信</text></g></g><g id="minder_node3095" display="none"><g id="node_expander3090" display="none" style="cursor: pointer;"><path id="kity_path_29792" fill="white" stroke="gray" d="M95.5,15478.5A6,6,0,1,1,83.5,15478.5A6,6,0,1,1,95.5,15478.5"></path><path id="kity_path_29793" fill="none" stroke="gray"></path></g><path id="node_outline3091" fill="none" stroke="none" d="M83.5,15451.5h611a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-611a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text3091" fill="black"><text id="kity_text_16045" text-rendering="inherit" font-size="12" dy=".8em" y="15452.700000047684" x="83.5">1.feign采用的是基于接口的注解，feign+ribbon(客户端负载) 实现远程调用，并且整合了Hystrix，具有熔断的能力</text><text id="kity_text_16046" text-rendering="inherit" font-size="12" dy=".8em" y="15470.700000047684" x="83.5">使用@EnableFeignClients，定义一个接口@FeignClient(name=“xxx”)指定调用哪个服务</text><text id="kity_text_16047" text-rendering="inherit" font-size="12" dy=".8em" y="15488.700000047684" x="83.5">2.openfeign 结合了上面两点</text></g></g><g id="minder_node3096" display="none"><g id="node_expander3093" display="none" style="cursor: pointer;"><path id="kity_path_29801" fill="white" stroke="gray" d="M111.5,15486.5A6,6,0,1,1,99.5,15486.5A6,6,0,1,1,111.5,15486.5"></path><path id="kity_path_29802" fill="none" stroke="gray"></path></g><path id="node_outline3094" fill="none" stroke="none" d="M99.5,15477.5h93a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-93a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3094" fill="black"><text id="kity_text_16054" text-rendering="inherit" font-size="12" dy=".8em" y="15478.700000047684" x="99.5">bus总线了解吗？</text></g></g><g id="minder_node3097" display="none"><g id="node_expander3092" display="none" style="cursor: pointer;"><path id="kity_path_29798" fill="white" stroke="gray" d="M95.5,15486.5A6,6,0,1,1,83.5,15486.5A6,6,0,1,1,95.5,15486.5"></path><path id="kity_path_29799" fill="none" stroke="gray"></path></g><path id="node_outline3093" fill="none" stroke="none" d="M83.5,15468.5h721a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-721a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text3093" fill="black"><text id="kity_text_16051" text-rendering="inherit" font-size="12" dy=".8em" y="15469.700000047684" x="83.5">1.spring cloud bus 将分布式的节点用轻量的消息代理连接起来，它可以用于广播配置文件的更改或者服务直接的通讯，也可用于监控。</text><text id="kity_text_16052" text-rendering="inherit" font-size="12" dy=".8em" y="15487.700000047684" x="83.5">如果修改了配置文件，发送一次请求，所有的客户端便会重新读取配置文件。</text></g></g><g id="minder_node3098" display="none"><g id="node_expander3108" display="none" style="cursor: pointer;"><path id="kity_path_29846" fill="white" stroke="gray" d="M127.5,15494.5A6,6,0,1,1,115.5,15494.5A6,6,0,1,1,127.5,15494.5"></path><path id="kity_path_29847" fill="none" stroke="gray"></path></g><path id="node_outline3109" fill="none" stroke="none" d="M115.5,15485.5h94a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-94a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3109" fill="black"><text id="kity_text_16101" text-rendering="inherit" font-size="12" dy=".8em" y="15486.700000047684" x="115.5">网关&amp;均衡等方面</text></g></g><g id="minder_node3099" display="none"><g id="node_expander3096" display="none" style="cursor: pointer;"><path id="kity_path_29810" fill="white" stroke="gray" d="M111.5,15454.5A6,6,0,1,1,99.5,15454.5A6,6,0,1,1,111.5,15454.5"></path><path id="kity_path_29811" fill="none" stroke="gray"></path></g><path id="node_outline3097" fill="none" stroke="none" d="M99.5,15445.5h129a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-129a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3097" fill="black"><text id="kity_text_16061" text-rendering="inherit" font-size="12" dy=".8em" y="15446.700000047684" x="99.5">说说Getway你了解哪些</text></g></g><g id="minder_node3100" display="none"><g id="node_expander3095" display="none" style="cursor: pointer;"><path id="kity_path_29807" fill="white" stroke="gray" d="M95.5,15454.5A6,6,0,1,1,83.5,15454.5A6,6,0,1,1,95.5,15454.5"></path><path id="kity_path_29808" fill="none" stroke="gray"></path></g><path id="node_outline3096" fill="none" stroke="none" d="M83.5,15436.5h548a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-548a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text3096" fill="black"><text id="kity_text_16058" text-rendering="inherit" font-size="12" dy=".8em" y="15437.700000047684" x="83.5">1.路由转发、权限校验、限流控制等作用。</text><text id="kity_text_16059" text-rendering="inherit" font-size="12" dy=".8em" y="15455.700000047684" x="83.5">2.通过添加各种predicates和filters，来对具体的请求做修改 判断 和根据规则路由到具体的route去处理</text></g></g><g id="minder_node3101" display="none"><g id="node_expander3097" display="none" style="cursor: pointer;"><path id="kity_path_29813" fill="white" stroke="gray" d="M111.5,15462.5A6,6,0,1,1,99.5,15462.5A6,6,0,1,1,111.5,15462.5"></path><path id="kity_path_29814" fill="none" stroke="gray"></path></g><path id="node_outline3098" fill="none" stroke="none" d="M99.5,15453.5h61a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-61a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3098" fill="black"><text id="kity_text_16063" text-rendering="inherit" font-size="12" dy=".8em" y="15454.700000047684" x="99.5">说一下zuul</text></g></g><g id="minder_node3102" display="none"><g id="node_expander3099" display="none" style="cursor: pointer;"><path id="kity_path_29819" fill="white" stroke="gray" d="M111.5,15470.5A6,6,0,1,1,99.5,15470.5A6,6,0,1,1,111.5,15470.5"></path><path id="kity_path_29820" fill="none" stroke="gray"></path></g><path id="node_outline3100" fill="none" stroke="none" d="M99.5,15461.5h197a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-197a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3100" fill="black"><text id="kity_text_16071" text-rendering="inherit" font-size="12" dy=".8em" y="15462.700000047684" x="99.5">说说ribbon?和nginx的区别？原理？</text></g></g><g id="minder_node3103" display="none"><g id="node_expander3098" display="none" style="cursor: pointer;"><path id="kity_path_29816" fill="white" stroke="gray" d="M95.5,15470.5A6,6,0,1,1,83.5,15470.5A6,6,0,1,1,95.5,15470.5"></path><path id="kity_path_29817" fill="none" stroke="gray"></path></g><path id="node_outline3099" fill="none" stroke="none" d="M83.5,15425.5h835a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-835a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text3099" fill="black"><text id="kity_text_16065" text-rendering="inherit" font-size="12" dy=".8em" y="15426.700000047684" x="83.5">1.ribbon主要功能是提供客户端的负载均衡，使用@LoadBalanced注解。可以配置重试次数，默认是一次，连接超时等。</text><text id="kity_text_16066" text-rendering="inherit" font-size="12" dy=".8em" y="15444.700000047684" x="83.5">相当于rabbin在配置文件中列出后面所有的服务地址，Ribbon会自动的帮助你基于某种规则（如简单轮询，随即连接，权重等）去连接这些机器</text><text id="kity_text_16067" text-rendering="inherit" font-size="12" dy=".8em" y="15462.700000047684" x="83.5">2.Nginx是反向代理同时可以实现负载均衡，nginx拦截客户端请求采用负载均衡策略根据upstream配置进行转发，相当于请求通过nginx服务器进行转发。</text><text id="kity_text_16068" text-rendering="inherit" font-size="12" dy=".8em" y="15480.700000047684" x="83.5">Ribbon是客户端负载均衡，从注册中心读取目标服务器信息，然后客户端采用轮询策略对服务直接访问，全程在客户端操作。</text><text id="kity_text_16069" text-rendering="inherit" font-size="12" dy=".8em" y="15498.700000047684" x="83.5">Ribbon使用discoveryClient从注册中心读取目标服务信息，对同一接口请求进行计数，使用%取余算法获取目标服务集群索引，返回获取到的目标服务信息。</text></g></g><g id="minder_node3104" display="none"><g id="node_expander3102" display="none" style="cursor: pointer;"><path id="kity_path_29828" fill="white" stroke="gray" d="M111.5,15478.5A6,6,0,1,1,99.5,15478.5A6,6,0,1,1,111.5,15478.5"></path><path id="kity_path_29829" fill="none" stroke="gray"></path></g><path id="node_outline3103" fill="none" stroke="none" d="M99.5,15469.5h111a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-111a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3103" fill="black"><text id="kity_text_16084" text-rendering="inherit" font-size="12" dy=".8em" y="15470.700000047684" x="99.5">ribbon负载均衡原理</text></g></g><g id="minder_node3105" display="none"><g id="node_expander3101" display="none" style="cursor: pointer;"><path id="kity_path_29825" fill="white" stroke="gray" d="M95.5,15478.5A6,6,0,1,1,83.5,15478.5A6,6,0,1,1,95.5,15478.5"></path><path id="kity_path_29826" fill="none" stroke="gray"></path></g><path id="node_outline3102" fill="none" stroke="none" d="M83.5,15415.5h640a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-640a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text3102" fill="black"><text id="kity_text_16076" text-rendering="inherit" font-size="12" dy=".8em" y="15416.700000047684" x="83.5">1.服务启动内部定时任务心跳每10秒拉取服务元数据并ping服务</text><text id="kity_text_16077" text-rendering="inherit" font-size="12" dy=".8em" y="15434.700000047684" x="83.5">如何根据具体的rule来实现负载均衡，比如轮询就是 第一次请求第一台，下一次 就是第二台</text><text id="kity_text_16078" text-rendering="inherit" font-size="12" dy=".8em" y="15452.700000047684" x="83.5">2.</text><text id="kity_text_16079" text-rendering="inherit" font-size="12" dy=".8em" y="15470.700000047684" x="83.5">2.1.RestTemplate发送的请求给注册的服务2.2.获取@LoadBalanced注解标记的RestTemplate</text><text id="kity_text_16080" text-rendering="inherit" font-size="12" dy=".8em" y="15488.700000047684" x="83.5">2.3.RestTemplate添加一个拦截器，当使用RestTemplate发起http调用时进行拦截</text><text id="kity_text_16081" text-rendering="inherit" font-size="12" dy=".8em" y="15506.700000047684" x="83.5">2.4.根据url中的服务名称 以及自身的负载均衡策略 去对应服务的服务列表中找到一个要调用的ip+端口号 localhost:8802</text><text id="kity_text_16082" text-rendering="inherit" font-size="12" dy=".8em" y="15524.700000047684" x="83.5">访问该目标服务，并获取返回结果</text></g></g><g id="minder_node3106" display="none"><g id="node_expander3100" display="none" style="cursor: pointer;"><path id="kity_path_29822" fill="white" stroke="gray" d="M79.5,15478.5A6,6,0,1,1,67.5,15478.5A6,6,0,1,1,79.5,15478.5"></path><path id="kity_path_29823" fill="none" stroke="gray"></path></g><path id="node_outline3101" fill="none" stroke="none" d="M67.5,15460.5h329a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-329a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text3101" fill="black"><text id="kity_text_16073" text-rendering="inherit" font-size="12" dy=".8em" y="15461.700000047684" x="67.5">https://zhuanlan.zhihu.com/p/103229614</text><text id="kity_text_16074" text-rendering="inherit" font-size="12" dy=".8em" y="15479.700000047684" x="67.5">https://www.cnblogs.com/bingyang-py/p/14277881.html</text></g></g><g id="minder_node3107" display="none"><g id="node_expander3104" display="none" style="cursor: pointer;"><path id="kity_path_29834" fill="white" stroke="gray" d="M111.5,15486.5A6,6,0,1,1,99.5,15486.5A6,6,0,1,1,111.5,15486.5"></path><path id="kity_path_29835" fill="none" stroke="gray"></path></g><path id="node_outline3105" fill="none" stroke="none" d="M99.5,15477.5h147a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-147a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3105" fill="black"><text id="kity_text_16088" text-rendering="inherit" font-size="12" dy=".8em" y="15478.700000047684" x="99.5">ribbon有哪些负载均衡策略</text></g></g><g id="minder_node3108" display="none"><g id="node_expander3103" display="none" style="cursor: pointer;"><path id="kity_path_29831" fill="white" stroke="gray" d="M95.5,15486.5A6,6,0,1,1,83.5,15486.5A6,6,0,1,1,95.5,15486.5"></path><path id="kity_path_29832" fill="none" stroke="gray"></path></g><path id="node_outline3104" fill="none" stroke="none" d="M83.5,15477.5h615a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-615a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3104" fill="black"><text id="kity_text_16086" text-rendering="inherit" font-size="12" dy=".8em" y="15478.700000047684" x="83.5">1.轮询 默认；随机；选择一个最小的并发请求的 Server；响应时间分配一个 Weight（权重）；不可用时重试下一个</text></g></g><g id="minder_node3109" display="none"><g id="node_expander3107" display="none" style="cursor: pointer;"><path id="kity_path_29843" fill="white" stroke="gray" d="M111.5,15494.5A6,6,0,1,1,99.5,15494.5A6,6,0,1,1,111.5,15494.5"></path><path id="kity_path_29844" fill="none" stroke="gray"></path></g><path id="node_outline3108" fill="none" stroke="none" d="M99.5,15485.5h123a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-123a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3108" fill="black"><text id="kity_text_16099" text-rendering="inherit" font-size="12" dy=".8em" y="15486.700000047684" x="99.5">ribbon怎么做负载均衡</text></g></g><g id="minder_node3110" display="none"><g id="node_expander3106" display="none" style="cursor: pointer;"><path id="kity_path_29840" fill="white" stroke="gray" d="M95.5,15494.5A6,6,0,1,1,83.5,15494.5A6,6,0,1,1,95.5,15494.5"></path><path id="kity_path_29841" fill="none" stroke="gray"></path></g><path id="node_outline3107" fill="none" stroke="none" d="M83.5,15458.5h672a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-672a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text3107" fill="black"><text id="kity_text_16094" text-rendering="inherit" font-size="12" dy=".8em" y="15459.700000047684" x="83.5">1.修改策略规则 (1)使用@LoadBalanced和@Bean创建一个RestTemplate，(2)然后指定IRule 并注入容器</text><text id="kity_text_16095" text-rendering="inherit" font-size="12" dy=".8em" y="15477.700000047684" x="83.5">或者使用nacos的话直接修改配置文件 的ribbon配置项</text><text id="kity_text_16096" text-rendering="inherit" font-size="12" dy=".8em" y="15495.700000047684" x="83.5">2.自定义负载均衡器，需要实现“IRule”接口</text><text id="kity_text_16097" text-rendering="inherit" font-size="12" dy=".8em" y="15513.700000047684" x="83.5">3.nacos默认集中了ribbon，通过配置文件就可以了，feign+ribbon就可以实现。而且nacos本身就有实现权重的负载均衡策略</text></g></g><g id="minder_node3111" display="none"><g id="node_expander3105" display="none" style="cursor: pointer;"><path id="kity_path_29837" fill="white" stroke="gray" d="M79.5,15494.5A6,6,0,1,1,67.5,15494.5A6,6,0,1,1,79.5,15494.5"></path><path id="kity_path_29838" fill="none" stroke="gray"></path></g><path id="node_outline3106" fill="none" stroke="none" d="M67.5,15467.5h358a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-358a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text3106" fill="black"><text id="kity_text_16090" text-rendering="inherit" font-size="12" dy=".8em" y="15468.700000047684" x="67.5">https://blog.csdn.net/cl66666666/article/details/114281840</text><text id="kity_text_16091" text-rendering="inherit" font-size="12" dy=".8em" y="15486.700000047684" x="67.5">https://www.cnblogs.com/lpxdbk/p/9811233.html</text><text id="kity_text_16092" text-rendering="inherit" font-size="12" dy=".8em" y="15504.700000047684" x="67.5">https://blog.csdn.net/RabirZuruzuru/article/details/108227042</text></g></g><g id="minder_node3112" display="none"><g id="node_expander3128" display="none" style="cursor: pointer;"><path id="kity_path_29906" fill="white" stroke="gray" d="M127.5,15502.5A6,6,0,1,1,115.5,15502.5A6,6,0,1,1,127.5,15502.5"></path><path id="kity_path_29907" fill="none" stroke="gray"></path></g><path id="node_outline3129" fill="none" stroke="none" d="M115.5,15493.5h62a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-62a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3129" fill="black"><text id="kity_text_16166" text-rendering="inherit" font-size="12" dy=".8em" y="15494.700000047684" x="115.5">分布式事务</text></g></g><g id="minder_node3113" display="none"><g id="node_expander3111" display="none" style="cursor: pointer;"><path id="kity_path_29855" fill="white" stroke="gray" d="M111.5,15446.5A6,6,0,1,1,99.5,15446.5A6,6,0,1,1,111.5,15446.5"></path><path id="kity_path_29856" fill="none" stroke="gray"></path></g><path id="node_outline3112" fill="none" stroke="none" d="M99.5,15437.5h242a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-242a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3112" fill="black"><text id="kity_text_16108" text-rendering="inherit" font-size="12" dy=".8em" y="15438.700000047684" x="99.5">&#xa0;分布式一致性协&#xa0; 说一下分布式事务解决方案,</text></g></g><g id="minder_node3114" display="none"><g id="node_expander3110" display="none" style="cursor: pointer;"><path id="kity_path_29852" fill="white" stroke="gray" d="M95.5,15446.5A6,6,0,1,1,83.5,15446.5A6,6,0,1,1,95.5,15446.5"></path><path id="kity_path_29853" fill="none" stroke="gray"></path></g><path id="node_outline3111" fill="none" stroke="none" d="M83.5,15428.5h1177a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1177a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text3111" fill="black"><text id="kity_text_16105" text-rendering="inherit" font-size="12" dy=".8em" y="15429.700000047684" x="83.5">1.一致性协议 对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。如果能容忍后续的部分或者全部访问不到，则是弱一致性。如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。</text><text id="kity_text_16106" text-rendering="inherit" font-size="12" dy=".8em" y="15447.700000047684" x="83.5">XA协议的 强一致性的 2PC 3PC&#xa0; &#xa0;柔性事务-TCC 事务补偿型方案 ，柔性事务-最大努力通知型方案，柔性事务-可靠消息+最终一致性方案（异步确保型），本地消息表(不熟悉)。</text></g></g><g id="minder_node3115" display="none"><g id="node_expander3109" display="none" style="cursor: pointer;"><path id="kity_path_29849" fill="white" stroke="gray" d="M79.5,15446.5A6,6,0,1,1,67.5,15446.5A6,6,0,1,1,79.5,15446.5"></path><path id="kity_path_29850" fill="none" stroke="gray"></path></g><path id="node_outline3110" fill="none" stroke="none" d="M67.5,15437.5h333a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3110" fill="black"><text id="kity_text_16103" text-rendering="inherit" font-size="12" dy=".8em" y="15438.700000047684" x="67.5">https://juejin.cn/post/6844903734753886216#heading-29</text></g></g><g id="minder_node3116" display="none"><g id="node_expander3113" display="none" style="cursor: pointer;"><path id="kity_path_29861" fill="white" stroke="gray" d="M111.5,15454.5A6,6,0,1,1,99.5,15454.5A6,6,0,1,1,111.5,15454.5"></path><path id="kity_path_29862" fill="none" stroke="gray"></path></g><path id="node_outline3114" fill="none" stroke="none" d="M99.5,15445.5h199a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-199a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3114" fill="black"><text id="kity_text_16121" text-rendering="inherit" font-size="12" dy=".8em" y="15446.700000047684" x="99.5">说一下2PC 3PC TCC补偿 和优缺点？</text></g></g><g id="minder_node3117" display="none"><g id="node_expander3112" display="none" style="cursor: pointer;"><path id="kity_path_29858" fill="white" stroke="gray" d="M95.5,15454.5A6,6,0,1,1,83.5,15454.5A6,6,0,1,1,95.5,15454.5"></path><path id="kity_path_29859" fill="none" stroke="gray"></path></g><path id="node_outline3113" fill="none" stroke="none" d="M83.5,15364.5h1301a5,5,0,0,1,5,5v170a5,5,0,0,1,-5,5h-1301a5,5,0,0,1,-5,-5v-170a5,5,0,0,1,5,-5z"></path><g id="node_text3113" fill="black"><text id="kity_text_16110" text-rendering="inherit" font-size="12" dy=".8em" y="15365.700000047684" x="83.5">1.2PC二阶段提交(准备阶段和提交阶段)-强一致性。主要是通过事务的参与者节点(事务的执行者)把操作成败通知协调者(事务的发起者)，然后协调者根据所有参与者的反馈情报决定各参与者是否要真正的提交或者回滚。</text><text id="kity_text_16111" text-rendering="inherit" font-size="12" dy=".8em" y="15383.700000047684" x="83.5">参与的事务先尝试后提交，并且要保持处理后所有的读操作都要能获得最新的数据。如果有任何一个数据库否决此次提交，那么所有数据库都会被要求回滚它们在此事务中的那部分信息。</text><text id="kity_text_16112" text-rendering="inherit" font-size="12" dy=".8em" y="15401.700000047684" x="83.5">优缺点：实现复杂。性能问题(事务在提交阶段是同步阻塞状态，占用系统资源，容易导致性能瓶颈)。可靠性问题(协调者出现单点故障问题，参与者会一直处于锁定状态)。数据一致性问题(提交阶段 局部网络问题，导致了节点之间数据的不一致)。</text><text id="kity_text_16113" text-rendering="inherit" font-size="12" dy=".8em" y="15419.700000047684" x="83.5">2.3PC三阶段提交(canCommit,preCommit,doCommit)-在2阶段中添加了超时处理。(1)发起者也就是协调者向所有参与者发送CanCommit命令，询问是否可以执行事务提交操作。全部响应进入下一个阶段。</text><text id="kity_text_16114" text-rendering="inherit" font-size="12" dy=".8em" y="15437.700000047684" x="83.5">(2)协调者向所有参与者 询问是否可以进行事务的预提交操作 如果参与者成功的执行了事务操作，记录undo 和redo日志，进入commit 阶段，如果出现网络超时等问题，所有参与者接受事务的中断回滚。</text><text id="kity_text_16115" text-rendering="inherit" font-size="12" dy=".8em" y="15455.700000047684" x="83.5">(3) commit 阶段，前两个阶段都是正确的ACK反馈，真正提交事务，走完整个流程。否则中断回滚事务。</text><text id="kity_text_16116" text-rendering="inherit" font-size="12" dy=".8em" y="15473.700000047684" x="83.5">优缺点：比2PC多超时机制。阶段3协调者出现问题时，参与者会继续提交事务。数据不一致问题依然存在，在阶段3 如果参与者在超时以后没有接受协调者的中断命令，超时以后会提交事务</text><text id="kity_text_16117" text-rendering="inherit" font-size="12" dy=".8em" y="15491.700000047684" x="83.5">3.TCC补偿-最终一致性。核心思想是-每一个接口方法你都要自己去处理它的调用，重试，补偿。通过在业务层面去实现。</text><text id="kity_text_16118" text-rendering="inherit" font-size="12" dy=".8em" y="15509.700000047684" x="83.5">(1)准备阶段&#xa0; (2)调用阶段&#xa0; (3)回滚阶段。比如说我下单减库存，准备阶段就是扣除库存预留资源。调用阶段就是 发起购买请求，真正提交事务。回滚就是有一个业务预留资源未成功，则取消所有业务资源的预留请求。</text><text id="kity_text_16119" text-rendering="inherit" font-size="12" dy=".8em" y="15527.700000047684" x="83.5">优缺点：TCC和之前的XA协议比较 控制业务资源锁的粒度变小。数据最终一致性 通过调用阶段和回滚阶段 保证事务最终完成确认或者取消，保证数据的一致性。但是为了要保证数据一致性 confirm 和 cancel 接口还必须实现幂等性。</text></g></g><g id="minder_node3118" display="none"><g id="node_expander3115" display="none" style="cursor: pointer;"><path id="kity_path_29867" fill="white" stroke="gray" d="M111.5,15462.5A6,6,0,1,1,99.5,15462.5A6,6,0,1,1,111.5,15462.5"></path><path id="kity_path_29868" fill="none" stroke="gray"></path></g><path id="node_outline3116" fill="none" stroke="none" d="M99.5,15453.5h293a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-293a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3116" fill="black"><text id="kity_text_16137" text-rendering="inherit" font-size="12" dy=".8em" y="15454.700000047684" x="99.5">最大努力通知和可靠性最终一致性 分别说说，优缺点？</text></g></g><g id="minder_node3119" display="none"><g id="node_expander3114" display="none" style="cursor: pointer;"><path id="kity_path_29864" fill="white" stroke="gray" d="M95.5,15462.5A6,6,0,1,1,83.5,15462.5A6,6,0,1,1,95.5,15462.5"></path><path id="kity_path_29865" fill="none" stroke="gray"></path></g><path id="node_outline3115" fill="none" stroke="none" d="M83.5,15345.5h1371a5,5,0,0,1,5,5v224a5,5,0,0,1,-5,5h-1371a5,5,0,0,1,-5,-5v-224a5,5,0,0,1,5,-5z"></path><g id="node_text3115" fill="black"><text id="kity_text_16123" text-rendering="inherit" font-size="12" dy=".8em" y="15346.700000047684" x="83.5">1.MQ可靠性消息做最终一致性方案。最主要是保证消息的可靠性，消费端需要保证幂等性，因为重试不能重复调用。首先事务发起方给mq发消息prepared，发送成功就执行发起方的本地事务，失败就不执行后续操作，</text><text id="kity_text_16124" text-rendering="inherit" font-size="12" dy=".8em" y="15364.700000047684" x="83.5">如果是本地事务执行失败 就发消息回滚prepared，这个发送成功就需要mq的可靠性投递做保障。</text><text id="kity_text_16125" text-rendering="inherit" font-size="12" dy=".8em" y="15382.700000047684" x="83.5">然后发起方本地事务执行成功后，就给MQ发送确认消息反馈。如果发起方不发送消息 或者延迟，那么就通过 自动定时轮询去消费prepared 消息 然后去调用发起方的接口去查询这一条消息在发起方是否成功。如果成功就再发送消息给MQ，失败就回滚消息。</text><text id="kity_text_16126" text-rendering="inherit" font-size="12" dy=".8em" y="15400.700000047684" x="83.5">消费方去接收到确认消息，然后执行本地的事务，如果本地事务执行成功则事务正常完成。如果失败 就重试。如果是业务网络暂时性的原因 重试基本都能成功，实在不成功 就记录日志 后期补偿+人工介入。</text><text id="kity_text_16127" text-rendering="inherit" font-size="12" dy=".8em" y="15418.700000047684" x="83.5">我们项目也是有这种方案的思想，我们的一般交易到了我们系统 从开始经办，那么需要减额度，也就是去占额度，办理后 还有核查，核查后面就是对款项进行转出转入。</text><text id="kity_text_16128" text-rendering="inherit" font-size="12" dy=".8em" y="15436.700000047684" x="83.5">那这个额度 主要是体现在 你经办办理业务这里，占额度，超过三天不办理后续流程 就把消息放到死消队列中，路由到主动释放额度交换机，然后让消费者去拉取message释放额度，释放额度也会去查一下看看业务状态是否是经办，然后做一个关闭操作。</text><text id="kity_text_16129" text-rendering="inherit" font-size="12" dy=".8em" y="15454.700000047684" x="83.5">那如果说是业务经办通过，复核也通过了以后，然后这个时侯取消了，那涉及到一些数据都是要回滚操作，额度也是要释放，做自动释放 ，自动关单等一系列操作，复核后取消涉及服务数据比较多一点。</text><text id="kity_text_16130" text-rendering="inherit" font-size="12" dy=".8em" y="15472.700000047684" x="83.5">那么除了经办复核过程中的额度释放，额度也是本身自己也要做释放的，时间是经办+复核 的一个最大业务等待时间，到了以后检查状态做释放。这个额度我们也是做分布式锁处理，不能因为额度同时去处理，导致用户说自己的最后一个总额度对不上。</text><text id="kity_text_16131" text-rendering="inherit" font-size="12" dy=".8em" y="15490.700000047684" x="83.5">分布式锁我们是用redis实现的。接下来就可以说一些分布式锁那一块了。可能接下来说一些mq的幂等 可靠性&#xa0; 重复性的问题了。那么可能99.99都是成功的，0.01是失败的，就会去做一些干预 补偿。一般是没有遇到，做好日志记录等</text><text id="kity_text_16132" text-rendering="inherit" font-size="12" dy=".8em" y="15508.700000047684" x="83.5">2.最大努力通知方案。用到mq。他不保证整体事务通知一定成功，但是可以在一定程度下允许少数的分布式事务失效。但是会提供一些接口和服务来进行核对，但是在最大次数以后，还不成功 就不重试了，那么可能需要对账等，最差就是去人工对。</text><text id="kity_text_16133" text-rendering="inherit" font-size="12" dy=".8em" y="15526.700000047684" x="83.5">所以一般是用在要求不是那么严格的场景下使用，就算失败了 也不会有大影响，比如说记录一个状态日志什么的，比如说部分不重要的通知短信什么的。</text><text id="kity_text_16134" text-rendering="inherit" font-size="12" dy=".8em" y="15544.700000047684" x="83.5">整体流程是，系统A本地事务执行完成，给MQ发事务消息，然后有一个服务，会去消费这个消息，然后记录下来保存这个信息，可以是系统B的数据库 也可以是内存队列。然后去调用系统B的接口，如果系统B执行失败，	就会去重试，</text><text id="kity_text_16135" text-rendering="inherit" font-size="12" dy=".8em" y="15562.700000047684" x="83.5">比如说 发5次消息，然后每一次相隔一定时间，像一些主流方案是这样用的。但是5次以后 还不行 就不发了，系统B的事务就不会执行成功。</text></g></g><g id="minder_node3120" display="none"><g id="node_expander3117" display="none" style="cursor: pointer;"><path id="kity_path_29873" fill="white" stroke="gray" d="M111.5,15470.5A6,6,0,1,1,99.5,15470.5A6,6,0,1,1,111.5,15470.5"></path><path id="kity_path_29874" fill="none" stroke="gray"></path></g><path id="node_outline3118" fill="none" stroke="none" d="M99.5,15461.5h289a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-289a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3118" fill="black"><text id="kity_text_16141" text-rendering="inherit" font-size="12" dy=".8em" y="15462.700000047684" x="99.5">你们项目分布式事务怎么做？什么原理？怎么实现的？</text></g></g><g id="minder_node3121" display="none"><g id="node_expander3116" display="none" style="cursor: pointer;"><path id="kity_path_29870" fill="white" stroke="gray" d="M95.5,15470.5A6,6,0,1,1,83.5,15470.5A6,6,0,1,1,95.5,15470.5"></path><path id="kity_path_29871" fill="none" stroke="gray"></path></g><path id="node_outline3117" fill="none" stroke="none" d="M83.5,15461.5h162a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-162a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3117" fill="black"><text id="kity_text_16139" text-rendering="inherit" font-size="12" dy=".8em" y="15462.700000047684" x="83.5">1.同上，mq可靠性最终一致性</text></g></g><g id="minder_node3122" display="none"><g id="node_expander3119" display="none" style="cursor: pointer;"><path id="kity_path_29879" fill="white" stroke="gray" d="M111.5,15478.5A6,6,0,1,1,99.5,15478.5A6,6,0,1,1,111.5,15478.5"></path><path id="kity_path_29880" fill="none" stroke="gray"></path></g><path id="node_outline3120" fill="none" stroke="none" d="M99.5,15469.5h252a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-252a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3120" fill="black"><text id="kity_text_16145" text-rendering="inherit" font-size="12" dy=".8em" y="15470.700000047684" x="99.5">出现过事务不一致性吗？为什么？怎么解决的？</text></g></g><g id="minder_node3123" display="none"><g id="node_expander3118" display="none" style="cursor: pointer;"><path id="kity_path_29876" fill="white" stroke="gray" d="M95.5,15478.5A6,6,0,1,1,83.5,15478.5A6,6,0,1,1,95.5,15478.5"></path><path id="kity_path_29877" fill="none" stroke="gray"></path></g><path id="node_outline3119" fill="none" stroke="none" d="M83.5,15469.5h298a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-298a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3119" fill="black"><text id="kity_text_16143" text-rendering="inherit" font-size="12" dy=".8em" y="15470.700000047684" x="83.5">1.同上，上面的解决方案就是来解决分布式事务问题的。</text></g></g><g id="minder_node3124" display="none"><g id="node_expander3123" display="none" style="cursor: pointer;"><path id="kity_path_29891" fill="white" stroke="gray" d="M111.5,15486.5A6,6,0,1,1,99.5,15486.5A6,6,0,1,1,111.5,15486.5"></path><path id="kity_path_29892" fill="none" stroke="gray"></path></g><path id="node_outline3124" fill="none" stroke="none" d="M99.5,15477.5h173a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-173a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3124" fill="black"><text id="kity_text_16156" text-rendering="inherit" font-size="12" dy=".8em" y="15478.700000047684" x="99.5">rabbitmq事务消息的处理流程？</text></g></g><g id="minder_node3125" display="none"><g id="node_expander3122" display="none" style="cursor: pointer;"><path id="kity_path_29888" fill="white" stroke="gray" d="M95.5,15486.5A6,6,0,1,1,83.5,15486.5A6,6,0,1,1,95.5,15486.5"></path><path id="kity_path_29889" fill="none" stroke="gray"></path></g><path id="node_outline3123" fill="none" stroke="none" d="M83.5,15450.5h759a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-759a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text3123" fill="black"><text id="kity_text_16151" text-rendering="inherit" font-size="12" dy=".8em" y="15451.700000047684" x="83.5">1.生产者会先给mq发送一条待确认状态的事务消息，如何MQ接收到消息先持久化，这样就存储了一条待发送的消息了。</text><text id="kity_text_16152" text-rendering="inherit" font-size="12" dy=".8em" y="15469.700000047684" x="83.5">2.然后mq返回ack给生产者，生产者执行本地事务，执行完成以后发送执行结果给mq，mq根据是删除还是更新前面的待发送状态信息为可发送</text><text id="kity_text_16153" text-rendering="inherit" font-size="12" dy=".8em" y="15487.700000047684" x="83.5">3.如果是可发送，mq把这一条消息push给消费者，消费者去处理后续流程，当然在处理之前可以去订单查询一下状态。</text><text id="kity_text_16154" text-rendering="inherit" font-size="12" dy=".8em" y="15505.700000047684" x="83.5">4.需要保证可靠性投递 和 消费端 幂等， 不要因为网络原因等 一条消息重复投递重复消费</text></g></g><g id="minder_node3126" display="none"><g id="node_expander3120" display="none" style="cursor: pointer;"><path id="kity_path_29882" fill="white" stroke="gray" d="M79.5,15478.5A6,6,0,1,1,67.5,15478.5A6,6,0,1,1,79.5,15478.5"></path><path id="kity_path_29883" fill="none" stroke="gray"></path></g><path id="node_outline3121" fill="none" stroke="none" d="M-7.5,15361.5h200a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-200a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text3121" fill="black"><text id="kity_text_16147" text-rendering="inherit" font-size="12" dy=".8em" y="15470.700000047684" x="67.5">分支主题</text></g><image id="kity_image_17103" xlink:href="https://xiaoboblog-bucket.oss-cn-hangzhou.aliyuncs.com/blog/20210428215251.png" x="-7.5" y="15364.5" width="200" height="103"></image></g><g id="minder_node3127" display="none"><g id="node_expander3121" display="none" style="cursor: pointer;"><path id="kity_path_29885" fill="white" stroke="gray" d="M79.5,15486.5A6,6,0,1,1,67.5,15486.5A6,6,0,1,1,79.5,15486.5"></path><path id="kity_path_29886" fill="none" stroke="gray"></path></g><path id="node_outline3122" fill="none" stroke="none" d="M67.5,15477.5h326a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3122" fill="black"><text id="kity_text_16149" text-rendering="inherit" font-size="12" dy=".8em" y="15478.700000047684" x="67.5">https://juejin.cn/post/6844903951448408071#heading-5</text></g></g><g id="minder_node3128" display="none"><g id="node_expander3125" display="none" style="cursor: pointer;"><path id="kity_path_29897" fill="white" stroke="gray" d="M111.5,15494.5A6,6,0,1,1,99.5,15494.5A6,6,0,1,1,111.5,15494.5"></path><path id="kity_path_29898" fill="none" stroke="gray"></path></g><path id="node_outline3126" fill="none" stroke="none" d="M99.5,15485.5h266a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-266a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3126" fill="black"><text id="kity_text_16160" text-rendering="inherit" font-size="12" dy=".8em" y="15486.700000047684" x="99.5">如果待发送消息一直感知不到上游处理结果怎么办</text></g></g><g id="minder_node3129" display="none"><g id="node_expander3124" display="none" style="cursor: pointer;"><path id="kity_path_29894" fill="white" stroke="gray" d="M95.5,15494.5A6,6,0,1,1,83.5,15494.5A6,6,0,1,1,95.5,15494.5"></path><path id="kity_path_29895" fill="none" stroke="gray"></path></g><path id="node_outline3125" fill="none" stroke="none" d="M83.5,15485.5h1378a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-1378a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3125" fill="black"><text id="kity_text_16158" text-rendering="inherit" font-size="12" dy=".8em" y="15486.700000047684" x="83.5">1.定时任务，去轮训状态为待发送的消息，然后给producer发送check请求，而producer必须实现一个check监听器，监听器的内容通常就是去检查与之对应的本地事务是否成功(一般就是查询DB)，如果成功了，则MQ会将消息设置为可发送，否则就删除消息。</text></g></g><g id="minder_node3130" display="none"><g id="node_expander3127" display="none" style="cursor: pointer;"><path id="kity_path_29903" fill="white" stroke="gray" d="M111.5,15502.5A6,6,0,1,1,99.5,15502.5A6,6,0,1,1,111.5,15502.5"></path><path id="kity_path_29904" fill="none" stroke="gray"></path></g><path id="node_outline3128" fill="none" stroke="none" d="M99.5,15493.5h67a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-67a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3128" fill="black"><text id="kity_text_16164" text-rendering="inherit" font-size="12" dy=".8em" y="15494.700000047684" x="99.5">知道seata吗</text></g></g><g id="minder_node3131" display="none"><g id="node_expander3126" display="none" style="cursor: pointer;"><path id="kity_path_29900" fill="white" stroke="gray" d="M95.5,15502.5A6,6,0,1,1,83.5,15502.5A6,6,0,1,1,95.5,15502.5"></path><path id="kity_path_29901" fill="none" stroke="gray"></path></g><path id="node_outline3127" fill="none" stroke="none" d="M83.5,15493.5h370a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-370a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3127" fill="black"><text id="kity_text_16162" text-rendering="inherit" font-size="12" dy=".8em" y="15494.700000047684" x="83.5">1.支持XA协议 2PC 3PC，是一个TCC协议的分布式事务组件 ali的产品</text></g></g><g id="minder_node3132" display="none"><g id="node_expander3139" display="none" style="cursor: pointer;"><path id="kity_path_29939" fill="white" stroke="gray" d="M127.5,15510.5A6,6,0,1,1,115.5,15510.5A6,6,0,1,1,127.5,15510.5"></path><path id="kity_path_29940" fill="none" stroke="gray"></path></g><path id="node_outline3140" fill="none" stroke="none" d="M115.5,15501.5h60a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-60a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3140" fill="black"><text id="kity_text_16197" text-rendering="inherit" font-size="12" dy=".8em" y="15502.700000047684" x="115.5">数据&amp;协议</text></g></g><g id="minder_node3133" display="none"><g id="node_expander3130" display="none" style="cursor: pointer;"><path id="kity_path_29912" fill="white" stroke="gray" d="M111.5,15478.5A6,6,0,1,1,99.5,15478.5A6,6,0,1,1,111.5,15478.5"></path><path id="kity_path_29913" fill="none" stroke="gray"></path></g><path id="node_outline3131" fill="none" stroke="none" d="M99.5,15469.5h149a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-149a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3131" fill="black"><text id="kity_text_16173" text-rendering="inherit" font-size="12" dy=".8em" y="15470.700000047684" x="99.5">分布式系统一致性hash算法</text></g></g><g id="minder_node3134" display="none"><g id="node_expander3129" display="none" style="cursor: pointer;"><path id="kity_path_29909" fill="white" stroke="gray" d="M95.5,15478.5A6,6,0,1,1,83.5,15478.5A6,6,0,1,1,95.5,15478.5"></path><path id="kity_path_29910" fill="none" stroke="gray"></path></g><path id="node_outline3130" fill="none" stroke="none" d="M83.5,15442.5h865a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-865a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text3130" fill="black"><text id="kity_text_16168" text-rendering="inherit" font-size="12" dy=".8em" y="15443.700000047684" x="83.5">1.解决分布式场景下 增加机器而导致数据混乱，原本 hash%3 然后 hash%4 结果不一样</text><text id="kity_text_16169" text-rendering="inherit" font-size="12" dy=".8em" y="15461.700000047684" x="83.5">一致性Hash算法是对2^32取模，把整个哈希值空间组织成一个虚拟的圆环。</text><text id="kity_text_16170" text-rendering="inherit" font-size="12" dy=".8em" y="15479.700000047684" x="83.5">对于节点的增减都只需重定位环空间中的一小部分数据，也就是如果某一个节点挂了，只影响逆时针遇到的第一个节点之间的数据，具有较好的容错性和可扩展性。</text><text id="kity_text_16171" text-rendering="inherit" font-size="12" dy=".8em" y="15497.700000047684" x="83.5">然后利用虚拟节点解决数据倾斜问题，原数据定位依然不变，只是增加虚拟节点 然后映射到实际节点；</text></g></g><g id="minder_node3135" display="none"><g id="node_expander3131" display="none" style="cursor: pointer;"><path id="kity_path_29915" fill="white" stroke="gray" d="M111.5,15486.5A6,6,0,1,1,99.5,15486.5A6,6,0,1,1,111.5,15486.5"></path><path id="kity_path_29916" fill="none" stroke="gray"></path></g><path id="node_outline3132" fill="none" stroke="none" d="M99.5,15477.5h256a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-256a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3132" fill="black"><text id="kity_text_16175" text-rendering="inherit" font-size="12" dy=".8em" y="15478.700000047684" x="99.5">让你自己实现一致性hash，你会用什么数据结构</text></g></g><g id="minder_node3136" display="none"><g id="node_expander3134" display="none" style="cursor: pointer;"><path id="kity_path_29924" fill="white" stroke="gray" d="M111.5,15494.5A6,6,0,1,1,99.5,15494.5A6,6,0,1,1,111.5,15494.5"></path><path id="kity_path_29925" fill="none" stroke="gray"></path></g><path id="node_outline3135" fill="none" stroke="none" d="M99.5,15485.5h81a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-81a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3135" fill="black"><text id="kity_text_16186" text-rendering="inherit" font-size="12" dy=".8em" y="15486.700000047684" x="99.5">知道raft协议吗</text></g></g><g id="minder_node3137" display="none"><g id="node_expander3133" display="none" style="cursor: pointer;"><path id="kity_path_29921" fill="white" stroke="gray" d="M95.5,15494.5A6,6,0,1,1,83.5,15494.5A6,6,0,1,1,95.5,15494.5"></path><path id="kity_path_29922" fill="none" stroke="gray"></path></g><path id="node_outline3134" fill="none" stroke="none" d="M83.5,15440.5h673a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-673a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text3134" fill="black"><text id="kity_text_16179" text-rendering="inherit" font-size="12" dy=".8em" y="15441.700000047684" x="83.5">1.Raft两个阶段领导选举和日志复制(只能从leader复制)，首先是选举阶段，然后通过选举出来的领导人带领进行正常操作。</text><text id="kity_text_16180" text-rendering="inherit" font-size="12" dy=".8em" y="15459.700000047684" x="83.5">集群中所有的节点开始的时候都是 follower 跟随者。当发现没有领导者的时候，</text><text id="kity_text_16181" text-rendering="inherit" font-size="12" dy=".8em" y="15477.700000047684" x="83.5">部分的跟随者会变成候选者，候选者会向跟随者发起投票请求。如果当前候选者获得了超过半数的选票，就自动变成了领导者。</text><text id="kity_text_16182" text-rendering="inherit" font-size="12" dy=".8em" y="15495.700000047684" x="83.5">如果集群中存在领导者，其他的候选者也会变成跟随者，所有的跟随者都会从领导者中进行数据同步，保证数据一致性。</text><text id="kity_text_16183" text-rendering="inherit" font-size="12" dy=".8em" y="15513.700000047684" x="83.5">2.raft保证安全。高可用，只要集群中的服务器有大多数(超过一半)可用，系统即是可用的。不依赖时序保证日志的一致性。</text><text id="kity_text_16184" text-rendering="inherit" font-size="12" dy=".8em" y="15531.700000047684" x="83.5">在通常情况下，只要集群中大部分服务器对过程调用做出响应，命令就可以完成，少数慢服务器不会影响整体系统性能。</text></g></g><g id="minder_node3138" display="none"><g id="node_expander3132" display="none" style="cursor: pointer;"><path id="kity_path_29918" fill="white" stroke="gray" d="M79.5,15494.5A6,6,0,1,1,67.5,15494.5A6,6,0,1,1,79.5,15494.5"></path><path id="kity_path_29919" fill="none" stroke="gray"></path></g><path id="node_outline3133" fill="none" stroke="none" d="M67.5,15485.5h326a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3133" fill="black"><text id="kity_text_16177" text-rendering="inherit" font-size="12" dy=".8em" y="15486.700000047684" x="67.5">https://juejin.cn/post/6907151199141625870#heading-2</text></g></g><g id="minder_node3139" display="none"><g id="node_expander3136" display="none" style="cursor: pointer;"><path id="kity_path_29930" fill="white" stroke="gray" d="M111.5,15502.5A6,6,0,1,1,99.5,15502.5A6,6,0,1,1,111.5,15502.5"></path><path id="kity_path_29931" fill="none" stroke="gray"></path></g><path id="node_outline3137" fill="none" stroke="none" d="M99.5,15493.5h95a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-95a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3137" fill="black"><text id="kity_text_16191" text-rendering="inherit" font-size="12" dy=".8em" y="15494.700000047684" x="99.5">知道paxos算法吗</text></g></g><g id="minder_node3140" display="none"><g id="node_expander3135" display="none" style="cursor: pointer;"><path id="kity_path_29927" fill="white" stroke="gray" d="M95.5,15502.5A6,6,0,1,1,83.5,15502.5A6,6,0,1,1,95.5,15502.5"></path><path id="kity_path_29928" fill="none" stroke="gray"></path></g><path id="node_outline3136" fill="none" stroke="none" d="M83.5,15484.5h333a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text3136" fill="black"><text id="kity_text_16188" text-rendering="inherit" font-size="12" dy=".8em" y="15485.700000047684" x="83.5">https://zhuanlan.zhihu.com/p/147691282</text><text id="kity_text_16189" text-rendering="inherit" font-size="12" dy=".8em" y="15503.700000047684" x="83.5">https://juejin.cn/post/6844903953948213261#heading-15</text></g></g><g id="minder_node3141" display="none"><g id="node_expander3138" display="none" style="cursor: pointer;"><path id="kity_path_29936" fill="white" stroke="gray" d="M111.5,15510.5A6,6,0,1,1,99.5,15510.5A6,6,0,1,1,111.5,15510.5"></path><path id="kity_path_29937" fill="none" stroke="gray"></path></g><path id="node_outline3139" fill="none" stroke="none" d="M99.5,15501.5h22a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-22a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3139" fill="black"><text id="kity_text_16195" text-rendering="inherit" font-size="12" dy=".8em" y="15502.700000047684" x="99.5">zab</text></g></g><g id="minder_node3142" display="none"><g id="node_expander3137" display="none" style="cursor: pointer;"><path id="kity_path_29933" fill="white" stroke="gray" d="M95.5,15510.5A6,6,0,1,1,83.5,15510.5A6,6,0,1,1,95.5,15510.5"></path><path id="kity_path_29934" fill="none" stroke="gray"></path></g><path id="node_outline3138" fill="none" stroke="none" d="M83.5,15501.5h64a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-64a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3138" fill="black"><text id="kity_text_16193" text-rendering="inherit" font-size="12" dy=".8em" y="15502.700000047684" x="83.5">ZK那部分有</text></g></g><g id="minder_node3143" display="none"><g id="node_expander3156" display="none" style="cursor: pointer;"><path id="kity_path_29990" fill="white" stroke="gray" d="M127.5,15518.5A6,6,0,1,1,115.5,15518.5A6,6,0,1,1,127.5,15518.5"></path><path id="kity_path_29991" fill="none" stroke="gray"></path></g><path id="node_outline3157" fill="none" stroke="none" d="M115.5,15509.5h18a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-18a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3157" fill="black"><text id="kity_text_16236" text-rendering="inherit" font-size="12" dy=".8em" y="15510.700000047684" x="115.5">rpc</text></g></g><g id="minder_node3144" display="none"><g id="node_expander3155" display="none" style="cursor: pointer;"><path id="kity_path_29987" fill="white" stroke="gray" d="M111.5,15518.5A6,6,0,1,1,99.5,15518.5A6,6,0,1,1,111.5,15518.5"></path><path id="kity_path_29988" fill="none" stroke="gray"></path></g><path id="node_outline3156" fill="none" stroke="none" d="M99.5,15509.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3156" fill="black"><text id="kity_text_16234" text-rendering="inherit" font-size="12" dy=".8em" y="15510.700000047684" x="99.5">基础</text></g></g><g id="minder_node3145" display="none"><g id="node_expander3140" display="none" style="cursor: pointer;"><path id="kity_path_29942" fill="white" stroke="gray" d="M95.5,15454.5A6,6,0,1,1,83.5,15454.5A6,6,0,1,1,95.5,15454.5"></path><path id="kity_path_29943" fill="none" stroke="gray"></path></g><path id="node_outline3141" fill="none" stroke="none" d="M83.5,15445.5h72a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-72a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3141" fill="black"><text id="kity_text_16199" text-rendering="inherit" font-size="12" dy=".8em" y="15446.700000047684" x="83.5">Thrift 是什么</text></g></g><g id="minder_node3146" display="none"><g id="node_expander3142" display="none" style="cursor: pointer;"><path id="kity_path_29948" fill="white" stroke="gray" d="M95.5,15462.5A6,6,0,1,1,83.5,15462.5A6,6,0,1,1,95.5,15462.5"></path><path id="kity_path_29949" fill="none" stroke="gray"></path></g><path id="node_outline3143" fill="none" stroke="none" d="M83.5,15453.5h132a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-132a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3143" fill="black"><text id="kity_text_16203" text-rendering="inherit" font-size="12" dy=".8em" y="15454.700000047684" x="83.5">你知道有哪些RPC框架？</text></g></g><g id="minder_node3147" display="none"><g id="node_expander3141" display="none" style="cursor: pointer;"><path id="kity_path_29945" fill="white" stroke="gray" d="M79.5,15462.5A6,6,0,1,1,67.5,15462.5A6,6,0,1,1,79.5,15462.5"></path><path id="kity_path_29946" fill="none" stroke="gray"></path></g><path id="node_outline3142" fill="none" stroke="none" d="M67.5,15453.5h256a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-256a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3142" fill="black"><text id="kity_text_16201" text-rendering="inherit" font-size="12" dy=".8em" y="15454.700000047684" x="67.5">1.dubbo springcloud grpc支持http 2.0&#xa0;&#xa0;Thrift </text></g></g><g id="minder_node3148" display="none"><g id="node_expander3144" display="none" style="cursor: pointer;"><path id="kity_path_29954" fill="white" stroke="gray" d="M95.5,15470.5A6,6,0,1,1,83.5,15470.5A6,6,0,1,1,95.5,15470.5"></path><path id="kity_path_29955" fill="none" stroke="gray"></path></g><path id="node_outline3145" fill="none" stroke="none" d="M83.5,15461.5h100a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-100a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3145" fill="black"><text id="kity_text_16208" text-rendering="inherit" font-size="12" dy=".8em" y="15462.700000047684" x="83.5">兄弟 为什么有RPC</text></g></g><g id="minder_node3149" display="none"><g id="node_expander3143" display="none" style="cursor: pointer;"><path id="kity_path_29951" fill="white" stroke="gray" d="M79.5,15470.5A6,6,0,1,1,67.5,15470.5A6,6,0,1,1,79.5,15470.5"></path><path id="kity_path_29952" fill="none" stroke="gray"></path></g><path id="node_outline3144" fill="none" stroke="none" d="M67.5,15452.5h886a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-886a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text3144" fill="black"><text id="kity_text_16205" text-rendering="inherit" font-size="12" dy=".8em" y="15453.700000047684" x="67.5">1.分布式下做远程调用 需要rpc做支持， RPC 远程过程调用就是让服务 A 像调用本地功能一样调用远端的服务 B 上的功能</text><text id="kity_text_16206" text-rendering="inherit" font-size="12" dy=".8em" y="15471.700000047684" x="67.5">2.rpc最基本需要考虑的是 call id 远程服务通过映射来调用其他服务，要能具体知道哪一个服务方法，就行自己调自己一样，然后是序列化和反序列化。然后是网络传输</text></g></g><g id="minder_node3150" display="none"><g id="node_expander3146" display="none" style="cursor: pointer;"><path id="kity_path_29960" fill="white" stroke="gray" d="M95.5,15478.5A6,6,0,1,1,83.5,15478.5A6,6,0,1,1,95.5,15478.5"></path><path id="kity_path_29961" fill="none" stroke="gray"></path></g><path id="node_outline3147" fill="none" stroke="none" d="M83.5,15469.5h108a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-108a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3147" fill="black"><text id="kity_text_16215" text-rendering="inherit" font-size="12" dy=".8em" y="15470.700000047684" x="83.5">RPC的组成简单说说</text></g></g><g id="minder_node3151" display="none"><g id="node_expander3145" display="none" style="cursor: pointer;"><path id="kity_path_29957" fill="white" stroke="gray" d="M79.5,15478.5A6,6,0,1,1,67.5,15478.5A6,6,0,1,1,79.5,15478.5"></path><path id="kity_path_29958" fill="none" stroke="gray"></path></g><path id="node_outline3146" fill="none" stroke="none" d="M67.5,15442.5h601a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-601a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text3146" fill="black"><text id="kity_text_16210" text-rendering="inherit" font-size="12" dy=".8em" y="15443.700000047684" x="67.5">客户端（Client），服务的调用方。</text><text id="kity_text_16211" text-rendering="inherit" font-size="12" dy=".8em" y="15461.700000047684" x="67.5">服务端（Server），真正的服务提供者。</text><text id="kity_text_16212" text-rendering="inherit" font-size="12" dy=".8em" y="15479.700000047684" x="67.5">客户端存根，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。</text><text id="kity_text_16213" text-rendering="inherit" font-size="12" dy=".8em" y="15497.700000047684" x="67.5">服务端存根，接收客户端发送过来的消息，将消息解包，并调用本地的方法。</text></g></g><g id="minder_node3152" display="none"><g id="node_expander3149" display="none" style="cursor: pointer;"><path id="kity_path_29969" fill="white" stroke="gray" d="M95.5,15486.5A6,6,0,1,1,83.5,15486.5A6,6,0,1,1,95.5,15486.5"></path><path id="kity_path_29970" fill="none" stroke="gray"></path></g><path id="node_outline3150" fill="none" stroke="none" d="M83.5,15477.5h138a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-138a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3150" fill="black"><text id="kity_text_16222" text-rendering="inherit" font-size="12" dy=".8em" y="15478.700000047684" x="83.5">RPC和HTTP的区别知道吗</text></g></g><g id="minder_node3153" display="none"><g id="node_expander3148" display="none" style="cursor: pointer;"><path id="kity_path_29966" fill="white" stroke="gray" d="M79.5,15486.5A6,6,0,1,1,67.5,15486.5A6,6,0,1,1,79.5,15486.5"></path><path id="kity_path_29967" fill="none" stroke="gray"></path></g><path id="node_outline3149" fill="none" stroke="none" d="M67.5,15468.5h1196a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1196a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text3149" fill="black"><text id="kity_text_16219" text-rendering="inherit" font-size="12" dy=".8em" y="15469.700000047684" x="67.5">1.RPC 服务和 HTTP 服务还是存在很多的不同点的，一般来说，RPC 服务主要是针对大型企业的，而 HTTP 服务主要是针对小企业的，因为 RPC 效率更高，而 HTTP 服务开发迭代会更快。rpc框架是面向服务的更高级的封装，</text><text id="kity_text_16220" text-rendering="inherit" font-size="12" dy=".8em" y="15487.700000047684" x="67.5">rpc可以是基于json&#xa0; 也可以基于 二进制</text></g></g><g id="minder_node3154" display="none"><g id="node_expander3147" display="none" style="cursor: pointer;"><path id="kity_path_29963" fill="white" stroke="gray" d="M63.5,15486.5A6,6,0,1,1,51.5,15486.5A6,6,0,1,1,63.5,15486.5"></path><path id="kity_path_29964" fill="none" stroke="gray"></path></g><path id="node_outline3148" fill="none" stroke="none" d="M51.5,15477.5h326a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3148" fill="black"><text id="kity_text_16217" text-rendering="inherit" font-size="12" dy=".8em" y="15478.700000047684" x="51.5">https://juejin.cn/post/6855129006019674125#heading-6</text></g></g><g id="minder_node3155" display="none"><g id="node_expander3150" display="none" style="cursor: pointer;"><path id="kity_path_29972" fill="white" stroke="gray" d="M95.5,15494.5A6,6,0,1,1,83.5,15494.5A6,6,0,1,1,95.5,15494.5"></path><path id="kity_path_29973" fill="none" stroke="gray"></path></g><path id="node_outline3151" fill="none" stroke="none" d="M83.5,15485.5h154a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-154a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3151" fill="black"><text id="kity_text_16224" text-rendering="inherit" font-size="12" dy=".8em" y="15486.700000047684" x="83.5">Thrift RPC过程是什么样子的</text></g></g><g id="minder_node3156" display="none"><g id="node_expander3151" display="none" style="cursor: pointer;"><path id="kity_path_29975" fill="white" stroke="gray" d="M95.5,15502.5A6,6,0,1,1,83.5,15502.5A6,6,0,1,1,95.5,15502.5"></path><path id="kity_path_29976" fill="none" stroke="gray"></path></g><path id="node_outline3152" fill="none" stroke="none" d="M83.5,15493.5h264a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-264a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3152" fill="black"><text id="kity_text_16226" text-rendering="inherit" font-size="12" dy=".8em" y="15494.700000047684" x="83.5">异构系统怎么完成通信，跟http相比什么优缺点？</text></g></g><g id="minder_node3157" display="none"><g id="node_expander3153" display="none" style="cursor: pointer;"><path id="kity_path_29981" fill="white" stroke="gray" d="M95.5,15510.5A6,6,0,1,1,83.5,15510.5A6,6,0,1,1,95.5,15510.5"></path><path id="kity_path_29982" fill="none" stroke="gray"></path></g><path id="node_outline3154" fill="none" stroke="none" d="M83.5,15501.5h194a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-194a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3154" fill="black"><text id="kity_text_16230" text-rendering="inherit" font-size="12" dy=".8em" y="15502.700000047684" x="83.5">服务之间调用用的什么协议，为什么</text></g></g><g id="minder_node3158" display="none"><g id="node_expander3152" display="none" style="cursor: pointer;"><path id="kity_path_29978" fill="white" stroke="gray" d="M79.5,15510.5A6,6,0,1,1,67.5,15510.5A6,6,0,1,1,79.5,15510.5"></path><path id="kity_path_29979" fill="none" stroke="gray"></path></g><path id="node_outline3153" fill="none" stroke="none" d="M67.5,15501.5h135a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-135a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3153" fill="black"><text id="kity_text_16228" text-rendering="inherit" font-size="12" dy=".8em" y="15502.700000047684" x="67.5">1.rpc openfeign 2. http&#xa0;</text></g></g><g id="minder_node3159" display="none"><g id="node_expander3154" display="none" style="cursor: pointer;"><path id="kity_path_29984" fill="white" stroke="gray" d="M95.5,15518.5A6,6,0,1,1,83.5,15518.5A6,6,0,1,1,95.5,15518.5"></path><path id="kity_path_29985" fill="none" stroke="gray"></path></g><path id="node_outline3155" fill="none" stroke="none" d="M83.5,15509.5h62a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-62a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3155" fill="black"><text id="kity_text_16232" text-rendering="inherit" font-size="12" dy=".8em" y="15510.700000047684" x="83.5">了解grpc吗</text></g></g><g id="minder_node3160" display="none"><g id="node_expander3164" display="none" style="cursor: pointer;"><path id="kity_path_30014" fill="white" stroke="gray" d="M127.5,15526.5A6,6,0,1,1,115.5,15526.5A6,6,0,1,1,127.5,15526.5"></path><path id="kity_path_30015" fill="none" stroke="gray"></path></g><path id="node_outline3165" fill="none" stroke="none" d="M115.5,15517.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3165" fill="black"><text id="kity_text_16255" text-rendering="inherit" font-size="12" dy=".8em" y="15518.700000047684" x="115.5">分布式锁</text></g></g><g id="minder_node3161" display="none"><g id="node_expander3158" display="none" style="cursor: pointer;"><path id="kity_path_29996" fill="white" stroke="gray" d="M111.5,15510.5A6,6,0,1,1,99.5,15510.5A6,6,0,1,1,111.5,15510.5"></path><path id="kity_path_29997" fill="none" stroke="gray"></path></g><path id="node_outline3159" fill="none" stroke="none" d="M99.5,15501.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3159" fill="black"><text id="kity_text_16241" text-rendering="inherit" font-size="12" dy=".8em" y="15502.700000047684" x="99.5">你是如何理解分布式锁的？</text></g></g><g id="minder_node3162" display="none"><g id="node_expander3157" display="none" style="cursor: pointer;"><path id="kity_path_29993" fill="white" stroke="gray" d="M95.5,15510.5A6,6,0,1,1,83.5,15510.5A6,6,0,1,1,95.5,15510.5"></path><path id="kity_path_29994" fill="none" stroke="gray"></path></g><path id="node_outline3158" fill="none" stroke="none" d="M83.5,15492.5h203a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-203a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text3158" fill="black"><text id="kity_text_16238" text-rendering="inherit" font-size="12" dy=".8em" y="15493.700000047684" x="83.5">1.本地锁完不成的 分布式来完成</text><text id="kity_text_16239" text-rendering="inherit" font-size="12" dy=".8em" y="15511.700000047684" x="83.5">2.本地事务完不成的分布式事务来完成</text></g></g><g id="minder_node3163" display="none"><g id="node_expander3161" display="none" style="cursor: pointer;"><path id="kity_path_30005" fill="white" stroke="gray" d="M111.5,15518.5A6,6,0,1,1,99.5,15518.5A6,6,0,1,1,111.5,15518.5"></path><path id="kity_path_30006" fill="none" stroke="gray"></path></g><path id="node_outline3162" fill="none" stroke="none" d="M99.5,15509.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3162" fill="black"><text id="kity_text_16247" text-rendering="inherit" font-size="12" dy=".8em" y="15510.700000047684" x="99.5">分布式锁有哪些实现方式，</text></g></g><g id="minder_node3164" display="none"><g id="node_expander3160" display="none" style="cursor: pointer;"><path id="kity_path_30002" fill="white" stroke="gray" d="M95.5,15518.5A6,6,0,1,1,83.5,15518.5A6,6,0,1,1,95.5,15518.5"></path><path id="kity_path_30003" fill="none" stroke="gray"></path></g><path id="node_outline3161" fill="none" stroke="none" d="M83.5,15509.5h156a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-156a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3161" fill="black"><text id="kity_text_16245" text-rendering="inherit" font-size="12" dy=".8em" y="15510.700000047684" x="83.5">1.数据库版本号， redis， ZK</text></g></g><g id="minder_node3165" display="none"><g id="node_expander3159" display="none" style="cursor: pointer;"><path id="kity_path_29999" fill="white" stroke="gray" d="M79.5,15518.5A6,6,0,1,1,67.5,15518.5A6,6,0,1,1,79.5,15518.5"></path><path id="kity_path_30000" fill="none" stroke="gray"></path></g><path id="node_outline3160" fill="none" stroke="none" d="M67.5,15509.5h333a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3160" fill="black"><text id="kity_text_16243" text-rendering="inherit" font-size="12" dy=".8em" y="15510.700000047684" x="67.5">https://juejin.cn/post/6844903688088059912#heading-12</text></g></g><g id="minder_node3166" display="none"><g id="node_expander3163" display="none" style="cursor: pointer;"><path id="kity_path_30011" fill="white" stroke="gray" d="M111.5,15526.5A6,6,0,1,1,99.5,15526.5A6,6,0,1,1,111.5,15526.5"></path><path id="kity_path_30012" fill="none" stroke="gray"></path></g><path id="node_outline3164" fill="none" stroke="none" d="M99.5,15517.5h182a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-182a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3164" fill="black"><text id="kity_text_16253" text-rendering="inherit" font-size="12" dy=".8em" y="15518.700000047684" x="99.5">继续上面问题，分别说说实现原理</text></g></g><g id="minder_node3167" display="none"><g id="node_expander3162" display="none" style="cursor: pointer;"><path id="kity_path_30008" fill="white" stroke="gray" d="M95.5,15526.5A6,6,0,1,1,83.5,15526.5A6,6,0,1,1,95.5,15526.5"></path><path id="kity_path_30009" fill="none" stroke="gray"></path></g><path id="node_outline3163" fill="none" stroke="none" d="M83.5,15499.5h213a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-213a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text3163" fill="black"><text id="kity_text_16249" text-rendering="inherit" font-size="12" dy=".8em" y="15500.700000047684" x="83.5">1.mysql的实现 在mysql 集群 那里</text><text id="kity_text_16250" text-rendering="inherit" font-size="12" dy=".8em" y="15518.700000047684" x="83.5">2.redis实现 在redis 应用 分布式锁 那里</text><text id="kity_text_16251" text-rendering="inherit" font-size="12" dy=".8em" y="15536.700000047684" x="83.5">3.ZK实现 在ZK进阶 分布式锁实现那里</text></g></g><g id="minder_node3168" display="none"><g id="node_expander3168" display="none" style="cursor: pointer;"><path id="kity_path_30026" fill="white" stroke="gray" d="M127.5,15534.5A6,6,0,1,1,115.5,15534.5A6,6,0,1,1,127.5,15534.5"></path><path id="kity_path_30027" fill="none" stroke="gray"></path></g><path id="node_outline3169" fill="none" stroke="none" d="M115.5,15525.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3169" fill="black"><text id="kity_text_16264" text-rendering="inherit" font-size="12" dy=".8em" y="15526.700000047684" x="115.5">部署方面</text></g></g><g id="minder_node3169" display="none"><g id="node_expander3165" display="none" style="cursor: pointer;"><path id="kity_path_30017" fill="white" stroke="gray" d="M111.5,15526.5A6,6,0,1,1,99.5,15526.5A6,6,0,1,1,111.5,15526.5"></path><path id="kity_path_30018" fill="none" stroke="gray"></path></g><path id="node_outline3166" fill="none" stroke="none" d="M99.5,15517.5h192a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-192a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3166" fill="black"><text id="kity_text_16257" text-rendering="inherit" font-size="12" dy=".8em" y="15518.700000047684" x="99.5">工作中采用的微服务是如何部署的？</text></g></g><g id="minder_node3170" display="none"><g id="node_expander3167" display="none" style="cursor: pointer;"><path id="kity_path_30023" fill="white" stroke="gray" d="M111.5,15534.5A6,6,0,1,1,99.5,15534.5A6,6,0,1,1,111.5,15534.5"></path><path id="kity_path_30024" fill="none" stroke="gray"></path></g><path id="node_outline3168" fill="none" stroke="none" d="M99.5,15525.5h86a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-86a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3168" fill="black"><text id="kity_text_16262" text-rendering="inherit" font-size="12" dy=".8em" y="15526.700000047684" x="99.5">服务发布怎么做</text></g></g><g id="minder_node3171" display="none"><g id="node_expander3166" display="none" style="cursor: pointer;"><path id="kity_path_30020" fill="white" stroke="gray" d="M95.5,15534.5A6,6,0,1,1,83.5,15534.5A6,6,0,1,1,95.5,15534.5"></path><path id="kity_path_30021" fill="none" stroke="gray"></path></g><path id="node_outline3167" fill="none" stroke="none" d="M83.5,15516.5h553a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-553a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text3167" fill="black"><text id="kity_text_16259" text-rendering="inherit" font-size="12" dy=".8em" y="15517.700000047684" x="83.5">1.springboot 正常流程，本地开发-》本地测试-》联测-》提代码-》测试环境-》准生产环境-》生产环境</text><text id="kity_text_16260" text-rendering="inherit" font-size="12" dy=".8em" y="15535.700000047684" x="83.5">2.没有用ciid那一套，可能以后会用到，现在规模 足够了，没必要过度设计</text></g></g><g id="minder_node3172" display="none"><g id="node_expander3176" display="none" style="cursor: pointer;"><path id="kity_path_30050" fill="white" stroke="gray" d="M127.5,15542.5A6,6,0,1,1,115.5,15542.5A6,6,0,1,1,127.5,15542.5"></path><path id="kity_path_30051" fill="none" stroke="gray"></path></g><path id="node_outline3177" fill="none" stroke="none" d="M115.5,15533.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3177" fill="black"><text id="kity_text_16289" text-rendering="inherit" font-size="12" dy=".8em" y="15534.700000047684" x="115.5">链路</text></g></g><g id="minder_node3173" display="none"><g id="node_expander3171" display="none" style="cursor: pointer;"><path id="kity_path_30035" fill="white" stroke="gray" d="M111.5,15526.5A6,6,0,1,1,99.5,15526.5A6,6,0,1,1,111.5,15526.5"></path><path id="kity_path_30036" fill="none" stroke="gray"></path></g><path id="node_outline3172" fill="none" stroke="none" d="M99.5,15517.5h158a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-158a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3172" fill="black"><text id="kity_text_16277" text-rendering="inherit" font-size="12" dy=".8em" y="15518.700000047684" x="99.5">微服务的链式调用异常怎么办</text></g></g><g id="minder_node3174" display="none"><g id="node_expander3170" display="none" style="cursor: pointer;"><path id="kity_path_30032" fill="white" stroke="gray" d="M95.5,15526.5A6,6,0,1,1,83.5,15526.5A6,6,0,1,1,95.5,15526.5"></path><path id="kity_path_30033" fill="none" stroke="gray"></path></g><path id="node_outline3171" fill="none" stroke="none" d="M83.5,15472.5h709a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-709a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text3171" fill="black"><text id="kity_text_16270" text-rendering="inherit" font-size="12" dy=".8em" y="15473.700000047684" x="83.5">1.可以使用springcloud 的zipkin+ali 的sleuth&#xa0; 或者 skywalking 做可视化调用链表追踪</text><text id="kity_text_16271" text-rendering="inherit" font-size="12" dy=".8em" y="15491.700000047684" x="83.5">2.skywalking</text><text id="kity_text_16272" text-rendering="inherit" font-size="12" dy=".8em" y="15509.700000047684" x="83.5">skywalking-agent：在被监控的服务启动时添加的探针，用来收集和推送数据到归集器，将数据通过gRPC方式发送给collector组件；</text><text id="kity_text_16273" text-rendering="inherit" font-size="12" dy=".8em" y="15527.700000047684" x="83.5">skywalking-collector：链路数据归集器，接收agent发送的数据并做处理，数据可以保存在H2、ElasticSearch、mysql等；</text><text id="kity_text_16274" text-rendering="inherit" font-size="12" dy=".8em" y="15545.700000047684" x="83.5">skywalking-web：web的可视化管理后台，对已经持久化的数据做回显，显示收集后的数据；</text><text id="kity_text_16275" text-rendering="inherit" font-size="12" dy=".8em" y="15563.700000047684" x="83.5">3.美团的cat，作者在国内，文档好，性能好。</text></g></g><g id="minder_node3175" display="none"><g id="node_expander3169" display="none" style="cursor: pointer;"><path id="kity_path_30029" fill="white" stroke="gray" d="M79.5,15526.5A6,6,0,1,1,67.5,15526.5A6,6,0,1,1,79.5,15526.5"></path><path id="kity_path_30030" fill="none" stroke="gray"></path></g><path id="node_outline3170" fill="none" stroke="none" d="M67.5,15499.5h406a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-406a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text3170" fill="black"><text id="kity_text_16266" text-rendering="inherit" font-size="12" dy=".8em" y="15500.700000047684" x="67.5">1.https://gitee.com/xiaobo97/viwmall#%E6%95%B4%E5%90%88sleuth</text><text id="kity_text_16267" text-rendering="inherit" font-size="12" dy=".8em" y="15518.700000047684" x="67.5">2.https://juejin.cn/post/6844903950089453582</text><text id="kity_text_16268" text-rendering="inherit" font-size="12" dy=".8em" y="15536.700000047684" x="67.5">https://juejin.cn/post/6844903816500871176#heading-16</text></g></g><g id="minder_node3176" display="none"><g id="node_expander3173" display="none" style="cursor: pointer;"><path id="kity_path_30041" fill="white" stroke="gray" d="M111.5,15534.5A6,6,0,1,1,99.5,15534.5A6,6,0,1,1,111.5,15534.5"></path><path id="kity_path_30042" fill="none" stroke="gray"></path></g><path id="node_outline3174" fill="none" stroke="none" d="M99.5,15525.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3174" fill="black"><text id="kity_text_16283" text-rendering="inherit" font-size="12" dy=".8em" y="15526.700000047684" x="99.5">链路跟踪Sleuth说一下？</text></g></g><g id="minder_node3177" display="none"><g id="node_expander3172" display="none" style="cursor: pointer;"><path id="kity_path_30038" fill="white" stroke="gray" d="M95.5,15534.5A6,6,0,1,1,83.5,15534.5A6,6,0,1,1,95.5,15534.5"></path><path id="kity_path_30039" fill="none" stroke="gray"></path></g><path id="node_outline3173" fill="none" stroke="none" d="M83.5,15507.5h1160a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1160a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text3173" fill="black"><text id="kity_text_16279" text-rendering="inherit" font-size="12" dy=".8em" y="15508.700000047684" x="83.5">1.Sleuth的实现是基于HTTP的，为了在数据的收集过程中不能影响到正常业务，Sleuth会在每个请求的Header上添加跟踪需求的重要信息。这样在数据收集时，只需要将Header上的相关信息发送 可视化工具就可以了，</text><text id="kity_text_16280" text-rendering="inherit" font-size="12" dy=".8em" y="15526.700000047684" x="83.5">2.sleuth有四个点，server-name：服务结点名称。main-traceId：一条链路唯一的ID，为TraceID。</text><text id="kity_text_16281" text-rendering="inherit" font-size="12" dy=".8em" y="15544.700000047684" x="83.5">sub-spanId：链路中每一环的ID，为SpanID。boolean：是否将信息输出到Zipkin等服务收集和展示。</text></g></g><g id="minder_node3178" display="none"><g id="node_expander3175" display="none" style="cursor: pointer;"><path id="kity_path_30047" fill="white" stroke="gray" d="M111.5,15542.5A6,6,0,1,1,99.5,15542.5A6,6,0,1,1,111.5,15542.5"></path><path id="kity_path_30048" fill="none" stroke="gray"></path></g><path id="node_outline3176" fill="none" stroke="none" d="M99.5,15533.5h182a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-182a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3176" fill="black"><text id="kity_text_16287" text-rendering="inherit" font-size="12" dy=".8em" y="15534.700000047684" x="99.5">怎么实现调用微服务中链路的记录</text></g></g><g id="minder_node3179" display="none"><g id="node_expander3174" display="none" style="cursor: pointer;"><path id="kity_path_30044" fill="white" stroke="gray" d="M95.5,15542.5A6,6,0,1,1,83.5,15542.5A6,6,0,1,1,95.5,15542.5"></path><path id="kity_path_30045" fill="none" stroke="gray"></path></g><path id="node_outline3175" fill="none" stroke="none" d="M83.5,15533.5h598a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-598a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3175" fill="black"><text id="kity_text_16285" text-rendering="inherit" font-size="12" dy=".8em" y="15534.700000047684" x="83.5">可以使用字节码增强技术，动态代理，改造 Request，在Request中记录一些 trace，然后带到下一个调用者中。</text></g></g><g id="minder_node3180" display="none"><g id="node_expander3182" display="none" style="cursor: pointer;"><path id="kity_path_30068" fill="white" stroke="gray" d="M127.5,15550.5A6,6,0,1,1,115.5,15550.5A6,6,0,1,1,127.5,15550.5"></path><path id="kity_path_30069" fill="none" stroke="gray"></path></g><path id="node_outline3183" fill="none" stroke="none" d="M115.5,15541.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3183" fill="black"><text id="kity_text_16311" text-rendering="inherit" font-size="12" dy=".8em" y="15542.700000047684" x="115.5">服务调度</text></g></g><g id="minder_node3181" display="none"><g id="node_expander3178" display="none" style="cursor: pointer;"><path id="kity_path_30056" fill="white" stroke="gray" d="M111.5,15542.5A6,6,0,1,1,99.5,15542.5A6,6,0,1,1,111.5,15542.5"></path><path id="kity_path_30057" fill="none" stroke="gray"></path></g><path id="node_outline3179" fill="none" stroke="none" d="M99.5,15533.5h196a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-196a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3179" fill="black"><text id="kity_text_16294" text-rendering="inherit" font-size="12" dy=".8em" y="15534.700000047684" x="99.5">&#xa0;分布式任务调度系统是怎么实现的？</text></g></g><g id="minder_node3182" display="none"><g id="node_expander3177" display="none" style="cursor: pointer;"><path id="kity_path_30053" fill="white" stroke="gray" d="M95.5,15542.5A6,6,0,1,1,83.5,15542.5A6,6,0,1,1,95.5,15542.5"></path><path id="kity_path_30054" fill="none" stroke="gray"></path></g><path id="node_outline3178" fill="none" stroke="none" d="M83.5,15524.5h203a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-203a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text3178" fill="black"><text id="kity_text_16291" text-rendering="inherit" font-size="12" dy=".8em" y="15525.700000047684" x="83.5">1.用的自带的任务schedule+async</text><text id="kity_text_16292" text-rendering="inherit" font-size="12" dy=".8em" y="15543.700000047684" x="83.5">2.也可以去用其他框架 xxl-job qurakz</text></g></g><g id="minder_node3183" display="none"><g id="node_expander3181" display="none" style="cursor: pointer;"><path id="kity_path_30065" fill="white" stroke="gray" d="M111.5,15550.5A6,6,0,1,1,99.5,15550.5A6,6,0,1,1,111.5,15550.5"></path><path id="kity_path_30066" fill="none" stroke="gray"></path></g><path id="node_outline3182" fill="none" stroke="none" d="M99.5,15541.5h221a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-221a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3182" fill="black"><text id="kity_text_16309" text-rendering="inherit" font-size="12" dy=".8em" y="15542.700000047684" x="99.5">分布式定时任务执行 服务器时间不一致？</text></g></g><g id="minder_node3184" display="none"><g id="node_expander3180" display="none" style="cursor: pointer;"><path id="kity_path_30062" fill="white" stroke="gray" d="M95.5,15550.5A6,6,0,1,1,83.5,15550.5A6,6,0,1,1,95.5,15550.5"></path><path id="kity_path_30063" fill="none" stroke="gray"></path></g><path id="node_outline3181" fill="none" stroke="none" d="M83.5,15487.5h818a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-818a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text3181" fill="black"><text id="kity_text_16301" text-rendering="inherit" font-size="12" dy=".8em" y="15488.700000047684" x="83.5">1.分布式任务调度多个机器会导致服务时间不一致而重复执行任务</text><text id="kity_text_16302" text-rendering="inherit" font-size="12" dy=".8em" y="15506.700000047684" x="83.5">(1)单独设置任务调度服务节点，定时任务通过去调用任务执行请求，网关把请求转发到某一个节点去这一次要执行的任务。(单点故障)</text><text id="kity_text_16303" text-rendering="inherit" font-size="12" dy=".8em" y="15524.700000047684" x="83.5">(2)通过redis锁来实现。通过每一个要自定义的定时任务的名字和ip 这样的键值对 再加上合适的过期时间来实现。</text><text id="kity_text_16304" text-rendering="inherit" font-size="12" dy=".8em" y="15542.700000047684" x="83.5">每一个节点在执行任务时都先去通过看是否存在key，不存在就把value设置为当前节点的ip，如果存在就去看是否是本机ip，是就执行，不是就不执行</text><text id="kity_text_16305" text-rendering="inherit" font-size="12" dy=".8em" y="15560.700000047684" x="83.5">(3)通过第三方开源的任务调度框架实现，XXL-JOB，，elastic-job(需要搭配ZK),LTS框架(文档不好，功能强大) Quartz的集群应用(复制并且需要11张表)，</text><text id="kity_text_16306" text-rendering="inherit" font-size="12" dy=".8em" y="15578.700000047684" x="83.5">(4)ZK的有序节点，（维护部署开销大，虽然稳定靠谱，如果redis解决不了再用ZK）</text><text id="kity_text_16307" text-rendering="inherit" font-size="12" dy=".8em" y="15596.700000047684" x="83.5">(5)利用数据库的版本号机制和锁，创建一个定时任务表，需要加锁和释放锁，不建议使用</text></g></g><g id="minder_node3185" display="none"><g id="node_expander3179" display="none" style="cursor: pointer;"><path id="kity_path_30059" fill="white" stroke="gray" d="M79.5,15550.5A6,6,0,1,1,67.5,15550.5A6,6,0,1,1,79.5,15550.5"></path><path id="kity_path_30060" fill="none" stroke="gray"></path></g><path id="node_outline3180" fill="none" stroke="none" d="M67.5,15514.5h346a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-346a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text3180" fill="black"><text id="kity_text_16296" text-rendering="inherit" font-size="12" dy=".8em" y="15515.700000047684" x="67.5">https://blog.csdn.net/ifrozen/article/details/77187635</text><text id="kity_text_16297" text-rendering="inherit" font-size="12" dy=".8em" y="15533.700000047684" x="67.5">https://www.cnblogs.com/fonxian/p/10858101.html</text><text id="kity_text_16298" text-rendering="inherit" font-size="12" dy=".8em" y="15551.700000047684" x="67.5">https://blog.csdn.net/Thousa_Ho/article/details/79847715</text><text id="kity_text_16299" text-rendering="inherit" font-size="12" dy=".8em" y="15569.700000047684" x="67.5">https://www.jianshu.com/p/41970ba48453?isappinstalled=0</text></g></g><g id="minder_node3186" display="none"><g id="node_expander3188" display="none" style="cursor: pointer;"><path id="kity_path_30086" fill="white" stroke="gray" d="M127.5,15558.5A6,6,0,1,1,115.5,15558.5A6,6,0,1,1,127.5,15558.5"></path><path id="kity_path_30087" fill="none" stroke="gray"></path></g><path id="node_outline3189" fill="none" stroke="none" d="M115.5,15549.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3189" fill="black"><text id="kity_text_16323" text-rendering="inherit" font-size="12" dy=".8em" y="15550.700000047684" x="115.5">服务监控</text></g></g><g id="minder_node3187" display="none"><g id="node_expander3183" display="none" style="cursor: pointer;"><path id="kity_path_30071" fill="white" stroke="gray" d="M111.5,15534.5A6,6,0,1,1,99.5,15534.5A6,6,0,1,1,111.5,15534.5"></path><path id="kity_path_30072" fill="none" stroke="gray"></path></g><path id="node_outline3184" fill="none" stroke="none" d="M99.5,15525.5h124a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-124a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3184" fill="black"><text id="kity_text_16313" text-rendering="inherit" font-size="12" dy=".8em" y="15526.700000047684" x="99.5">&#xa0;服务容灾是如何做的？</text></g></g><g id="minder_node3188" display="none"><g id="node_expander3185" display="none" style="cursor: pointer;"><path id="kity_path_30077" fill="white" stroke="gray" d="M111.5,15542.5A6,6,0,1,1,99.5,15542.5A6,6,0,1,1,111.5,15542.5"></path><path id="kity_path_30078" fill="none" stroke="gray"></path></g><path id="node_outline3186" fill="none" stroke="none" d="M99.5,15533.5h204a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-204a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3186" fill="black"><text id="kity_text_16317" text-rendering="inherit" font-size="12" dy=".8em" y="15534.700000047684" x="99.5">访问请求暴增怎么做？怎么缓解压力？</text></g></g><g id="minder_node3189" display="none"><g id="node_expander3184" display="none" style="cursor: pointer;"><path id="kity_path_30074" fill="white" stroke="gray" d="M95.5,15542.5A6,6,0,1,1,83.5,15542.5A6,6,0,1,1,95.5,15542.5"></path><path id="kity_path_30075" fill="none" stroke="gray"></path></g><path id="node_outline3185" fill="none" stroke="none" d="M83.5,15533.5h234a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-234a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3185" fill="black"><text id="kity_text_16315" text-rendering="inherit" font-size="12" dy=".8em" y="15534.700000047684" x="83.5">1.限流，接口优化，mq削峰，最后降级引导</text></g></g><g id="minder_node3190" display="none"><g id="node_expander3186" display="none" style="cursor: pointer;"><path id="kity_path_30080" fill="white" stroke="gray" d="M111.5,15550.5A6,6,0,1,1,99.5,15550.5A6,6,0,1,1,111.5,15550.5"></path><path id="kity_path_30081" fill="none" stroke="gray"></path></g><path id="node_outline3187" fill="none" stroke="none" d="M99.5,15541.5h214a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-214a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3187" fill="black"><text id="kity_text_16319" text-rendering="inherit" font-size="12" dy=".8em" y="15542.700000047684" x="99.5">cpu飙升怎么处理？load飙升怎么处理？</text></g></g><g id="minder_node3191" display="none"><g id="node_expander3187" display="none" style="cursor: pointer;"><path id="kity_path_30083" fill="white" stroke="gray" d="M111.5,15558.5A6,6,0,1,1,99.5,15558.5A6,6,0,1,1,111.5,15558.5"></path><path id="kity_path_30084" fill="none" stroke="gray"></path></g><path id="node_outline3188" fill="none" stroke="none" d="M99.5,15549.5h193a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-193a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3188" fill="black"><text id="kity_text_16321" text-rendering="inherit" font-size="12" dy=".8em" y="15550.700000047684" x="99.5">服务链路有关注？项目怎么处理的？</text></g></g><g id="minder_node3192" display="none"><g id="node_expander3191" display="none" style="cursor: pointer;"><path id="kity_path_30095" fill="white" stroke="gray" d="M127.5,15566.5A6,6,0,1,1,115.5,15566.5A6,6,0,1,1,127.5,15566.5"></path><path id="kity_path_30096" fill="none" stroke="gray"></path></g><path id="node_outline3192" fill="none" stroke="none" d="M115.5,15557.5h62a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-62a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3192" fill="black"><text id="kity_text_16329" text-rendering="inherit" font-size="12" dy=".8em" y="15558.700000047684" x="115.5">分布式缓存</text></g></g><g id="minder_node3193" display="none"><g id="node_expander3189" display="none" style="cursor: pointer;"><path id="kity_path_30089" fill="white" stroke="gray" d="M111.5,15558.5A6,6,0,1,1,99.5,15558.5A6,6,0,1,1,111.5,15558.5"></path><path id="kity_path_30090" fill="none" stroke="gray"></path></g><path id="node_outline3190" fill="none" stroke="none" d="M99.5,15549.5h211a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-211a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3190" fill="black"><text id="kity_text_16325" text-rendering="inherit" font-size="12" dy=".8em" y="15550.700000047684" x="99.5">你们项目数据是先写的mysql 还是redis</text></g></g><g id="minder_node3194" display="none"><g id="node_expander3190" display="none" style="cursor: pointer;"><path id="kity_path_30092" fill="white" stroke="gray" d="M111.5,15566.5A6,6,0,1,1,99.5,15566.5A6,6,0,1,1,111.5,15566.5"></path><path id="kity_path_30093" fill="none" stroke="gray"></path></g><path id="node_outline3191" fill="none" stroke="none" d="M99.5,15557.5h298a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-298a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3191" fill="black"><text id="kity_text_16327" text-rendering="inherit" font-size="12" dy=".8em" y="15558.700000047684" x="99.5">项目数据写的过程中&#xa0; redis挂了 或者 mysql挂 了怎么办</text></g></g><g id="minder_node3195" display="none"><g id="node_expander3193" display="none" style="cursor: pointer;"><path id="kity_path_30101" fill="white" stroke="gray" d="M127.5,15574.5A6,6,0,1,1,115.5,15574.5A6,6,0,1,1,127.5,15574.5"></path><path id="kity_path_30102" fill="none" stroke="gray"></path></g><path id="node_outline3194" fill="none" stroke="none" d="M115.5,15565.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3194" fill="black"><text id="kity_text_16333" text-rendering="inherit" font-size="12" dy=".8em" y="15566.700000047684" x="115.5">其它</text></g></g><g id="minder_node3196" display="none"><g id="node_expander3192" display="none" style="cursor: pointer;"><path id="kity_path_30098" fill="white" stroke="gray" d="M111.5,15574.5A6,6,0,1,1,99.5,15574.5A6,6,0,1,1,111.5,15574.5"></path><path id="kity_path_30099" fill="none" stroke="gray"></path></g><path id="node_outline3193" fill="none" stroke="none" d="M99.5,15565.5h164a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-164a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3193" fill="black"><text id="kity_text_16331" text-rendering="inherit" font-size="12" dy=".8em" y="15566.700000047684" x="99.5">响应流编程(reactive streams);</text></g></g><g id="minder_node3197" display="none"><g id="node_expander3204" display="none" style="cursor: pointer;"><path id="kity_path_30134" fill="white" stroke="gray" d="M143.5,15582.5A6,6,0,1,1,131.5,15582.5A6,6,0,1,1,143.5,15582.5"></path><path id="kity_path_30135" fill="none" stroke="gray"></path></g><path id="node_outline3205" fill="none" stroke="none" d="M131.5,15573.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3205" fill="black"><text id="kity_text_16361" text-rendering="inherit" font-size="12" dy=".8em" y="15574.700000047684" x="131.5">问题排查和分析优化</text></g></g><g id="minder_node3198" display="none"><g id="node_expander3195" display="none" style="cursor: pointer;"><path id="kity_path_30107" fill="white" stroke="gray" d="M127.5,15542.5A6,6,0,1,1,115.5,15542.5A6,6,0,1,1,127.5,15542.5"></path><path id="kity_path_30108" fill="none" stroke="gray"></path></g><path id="node_outline3196" fill="none" stroke="none" d="M115.5,15533.5h194a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-194a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3196" fill="black"><text id="kity_text_16337" text-rendering="inherit" font-size="12" dy=".8em" y="15534.700000047684" x="115.5">微服务你们怎么快速追踪与定位问题</text></g></g><g id="minder_node3199" display="none"><g id="node_expander3196" display="none" style="cursor: pointer;"><path id="kity_path_30110" fill="white" stroke="gray" d="M127.5,15550.5A6,6,0,1,1,115.5,15550.5A6,6,0,1,1,127.5,15550.5"></path><path id="kity_path_30111" fill="none" stroke="gray"></path></g><path id="node_outline3197" fill="none" stroke="none" d="M115.5,15541.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3197" fill="black"><text id="kity_text_16339" text-rendering="inherit" font-size="12" dy=".8em" y="15542.700000047684" x="115.5">你知道性能指标有哪些吗</text></g></g><g id="minder_node3200" display="none"><g id="node_expander3197" display="none" style="cursor: pointer;"><path id="kity_path_30113" fill="white" stroke="gray" d="M127.5,15558.5A6,6,0,1,1,115.5,15558.5A6,6,0,1,1,127.5,15558.5"></path><path id="kity_path_30114" fill="none" stroke="gray"></path></g><path id="node_outline3198" fill="none" stroke="none" d="M115.5,15549.5h98a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-98a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3198" fill="black"><text id="kity_text_16341" text-rendering="inherit" font-size="12" dy=".8em" y="15550.700000047684" x="115.5">如何发现性能瓶颈</text></g></g><g id="minder_node3201" display="none"><g id="node_expander3198" display="none" style="cursor: pointer;"><path id="kity_path_30116" fill="white" stroke="gray" d="M127.5,15566.5A6,6,0,1,1,115.5,15566.5A6,6,0,1,1,127.5,15566.5"></path><path id="kity_path_30117" fill="none" stroke="gray"></path></g><path id="node_outline3199" fill="none" stroke="none" d="M115.5,15557.5h110a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-110a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3199" fill="black"><text id="kity_text_16343" text-rendering="inherit" font-size="12" dy=".8em" y="15558.700000047684" x="115.5">性能调优的常见手段</text></g></g><g id="minder_node3202" display="none"><g id="node_expander3200" display="none" style="cursor: pointer;"><path id="kity_path_30122" fill="white" stroke="gray" d="M127.5,15574.5A6,6,0,1,1,115.5,15574.5A6,6,0,1,1,127.5,15574.5"></path><path id="kity_path_30123" fill="none" stroke="gray"></path></g><path id="node_outline3201" fill="none" stroke="none" d="M115.5,15565.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3201" fill="black"><text id="kity_text_16349" text-rendering="inherit" font-size="12" dy=".8em" y="15566.700000047684" x="115.5">服务注册中心宕机了怎么办？</text></g></g><g id="minder_node3203" display="none"><g id="node_expander3199" display="none" style="cursor: pointer;"><path id="kity_path_30119" fill="white" stroke="gray" d="M111.5,15574.5A6,6,0,1,1,99.5,15574.5A6,6,0,1,1,111.5,15574.5"></path><path id="kity_path_30120" fill="none" stroke="gray"></path></g><path id="node_outline3200" fill="none" stroke="none" d="M99.5,15547.5h780a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-780a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text3200" fill="black"><text id="kity_text_16345" text-rendering="inherit" font-size="12" dy=".8em" y="15548.700000047684" x="99.5">1.没遇到这种情况，如果要保证高可用，可以用集群，</text><text id="kity_text_16346" text-rendering="inherit" font-size="12" dy=".8em" y="15566.700000047684" x="99.5">如果集群挂了，还有服务信息的本地缓存 可以恢复。</text><text id="kity_text_16347" text-rendering="inherit" font-size="12" dy=".8em" y="15584.700000047684" x="99.5">2.或者准备备用方案。注册中心挂了，通过其他方式 保证最核心调用之间调用的不要挂，其他真的挂了 想办法恢复，然后做容灾上面 多做后备方案&#xa0;</text></g></g><g id="minder_node3204" display="none"><g id="node_expander3203" display="none" style="cursor: pointer;"><path id="kity_path_30131" fill="white" stroke="gray" d="M127.5,15582.5A6,6,0,1,1,115.5,15582.5A6,6,0,1,1,127.5,15582.5"></path><path id="kity_path_30132" fill="none" stroke="gray"></path></g><path id="node_outline3204" fill="none" stroke="none" d="M115.5,15573.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3204" fill="black"><text id="kity_text_16359" text-rendering="inherit" font-size="12" dy=".8em" y="15574.700000047684" x="115.5">服务雪崩效应产生的原因？</text></g></g><g id="minder_node3205" display="none"><g id="node_expander3202" display="none" style="cursor: pointer;"><path id="kity_path_30128" fill="white" stroke="gray" d="M111.5,15582.5A6,6,0,1,1,99.5,15582.5A6,6,0,1,1,111.5,15582.5"></path><path id="kity_path_30129" fill="none" stroke="gray"></path></g><path id="node_outline3203" fill="none" stroke="none" d="M99.5,15537.5h992a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-992a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text3203" fill="black"><text id="kity_text_16353" text-rendering="inherit" font-size="12" dy=".8em" y="15538.700000047684" x="99.5">1.服务提供者不可用，如缓存击穿，用户大量请求，程序bug。</text><text id="kity_text_16354" text-rendering="inherit" font-size="12" dy=".8em" y="15556.700000047684" x="99.5">2.重试加大流量，用户多次重试</text><text id="kity_text_16355" text-rendering="inherit" font-size="12" dy=".8em" y="15574.700000047684" x="99.5">3.服务调用者不可用，同步等待造成了资源浪费</text><text id="kity_text_16356" text-rendering="inherit" font-size="12" dy=".8em" y="15592.700000047684" x="99.5">4.tomcat默认情况只有一个线程池来维护客户端发送的所有的请求，某一接口在某一时刻被大量访问就会占据tomcat线程池中的所有线程，其他请求处于等待状态，无法连接到服务接口。</text><text id="kity_text_16357" text-rendering="inherit" font-size="12" dy=".8em" y="15610.700000047684" x="99.5">可以合适的调整tomcat并发相关配置，如最大处理请求线程数，活跃状态的线程数，等</text></g></g><g id="minder_node3206" display="none"><g id="node_expander3201" display="none" style="cursor: pointer;"><path id="kity_path_30125" fill="white" stroke="gray" d="M95.5,15582.5A6,6,0,1,1,83.5,15582.5A6,6,0,1,1,95.5,15582.5"></path><path id="kity_path_30126" fill="none" stroke="gray"></path></g><path id="node_outline3202" fill="none" stroke="none" d="M83.5,15573.5h347a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-347a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3202" fill="black"><text id="kity_text_16351" text-rendering="inherit" font-size="12" dy=".8em" y="15574.700000047684" x="83.5">https://blog.csdn.net/u012240455/article/details/104100149</text></g></g><g id="minder_node3207" display="none"><g id="node_expander3207" display="none" style="cursor: pointer;"><path id="kity_path_30143" fill="white" stroke="gray" d="M143.5,15590.5A6,6,0,1,1,131.5,15590.5A6,6,0,1,1,143.5,15590.5"></path><path id="kity_path_30144" fill="none" stroke="gray"></path></g><path id="node_outline3208" fill="none" stroke="none" d="M131.5,15581.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3208" fill="black"><text id="kity_text_16367" text-rendering="inherit" font-size="12" dy=".8em" y="15582.700000047684" x="131.5">场景</text></g></g><g id="minder_node3208" display="none"><g id="node_expander3206" display="none" style="cursor: pointer;"><path id="kity_path_30140" fill="white" stroke="gray" d="M127.5,15590.5A6,6,0,1,1,115.5,15590.5A6,6,0,1,1,127.5,15590.5"></path><path id="kity_path_30141" fill="none" stroke="gray"></path></g><path id="node_outline3207" fill="none" stroke="none" d="M115.5,15581.5h148a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-148a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3207" fill="black"><text id="kity_text_16365" text-rendering="inherit" font-size="12" dy=".8em" y="15582.700000047684" x="115.5">&#xa0;你们项目分布式事务的场景</text></g></g><g id="minder_node3209" display="none"><g id="node_expander3205" display="none" style="cursor: pointer;"><path id="kity_path_30137" fill="white" stroke="gray" d="M111.5,15590.5A6,6,0,1,1,99.5,15590.5A6,6,0,1,1,111.5,15590.5"></path><path id="kity_path_30138" fill="none" stroke="gray"></path></g><path id="node_outline3206" fill="none" stroke="none" d="M99.5,15581.5h143a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-143a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3206" fill="black"><text id="kity_text_16363" text-rendering="inherit" font-size="12" dy=".8em" y="15582.700000047684" x="99.5">1.如下分布式事务解决方案</text></g></g><g id="minder_node3210" display="none"><g id="node_expander3214" display="none" style="cursor: pointer;"><path id="kity_path_30164" fill="white" stroke="gray" d="M143.5,15598.5A6,6,0,1,1,131.5,15598.5A6,6,0,1,1,143.5,15598.5"></path><path id="kity_path_30165" fill="none" stroke="gray"></path></g><path id="node_outline3215" fill="none" stroke="none" d="M131.5,15589.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3215" fill="black"><text id="kity_text_16381" text-rendering="inherit" font-size="12" dy=".8em" y="15590.700000047684" x="131.5">安全</text></g></g><g id="minder_node3211" display="none"><g id="node_expander3208" display="none" style="cursor: pointer;"><path id="kity_path_30146" fill="white" stroke="gray" d="M127.5,15566.5A6,6,0,1,1,115.5,15566.5A6,6,0,1,1,127.5,15566.5"></path><path id="kity_path_30147" fill="none" stroke="gray"></path></g><path id="node_outline3209" fill="none" stroke="none" d="M115.5,15557.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3209" fill="black"><text id="kity_text_16369" text-rendering="inherit" font-size="12" dy=".8em" y="15558.700000047684" x="115.5">怎么防范常见的web攻击</text></g></g><g id="minder_node3212" display="none"><g id="node_expander3209" display="none" style="cursor: pointer;"><path id="kity_path_30149" fill="white" stroke="gray" d="M127.5,15574.5A6,6,0,1,1,115.5,15574.5A6,6,0,1,1,127.5,15574.5"></path><path id="kity_path_30150" fill="none" stroke="gray"></path></g><path id="node_outline3210" fill="none" stroke="none" d="M115.5,15565.5h295a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-295a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3210" fill="black"><text id="kity_text_16371" text-rendering="inherit" font-size="12" dy=".8em" y="15566.700000047684" x="115.5">你们项目中的接口安全怎么做的，怎么做一个安全的api</text></g></g><g id="minder_node3213" display="none"><g id="node_expander3210" display="none" style="cursor: pointer;"><path id="kity_path_30152" fill="white" stroke="gray" d="M127.5,15582.5A6,6,0,1,1,115.5,15582.5A6,6,0,1,1,127.5,15582.5"></path><path id="kity_path_30153" fill="none" stroke="gray"></path></g><path id="node_outline3211" fill="none" stroke="none" d="M115.5,15573.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3211" fill="black"><text id="kity_text_16373" text-rendering="inherit" font-size="12" dy=".8em" y="15574.700000047684" x="115.5">怎么基于角色的访问控制</text></g></g><g id="minder_node3214" display="none"><g id="node_expander3211" display="none" style="cursor: pointer;"><path id="kity_path_30155" fill="white" stroke="gray" d="M127.5,15590.5A6,6,0,1,1,115.5,15590.5A6,6,0,1,1,127.5,15590.5"></path><path id="kity_path_30156" fill="none" stroke="gray"></path></g><path id="node_outline3212" fill="none" stroke="none" d="M115.5,15581.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3212" fill="black"><text id="kity_text_16375" text-rendering="inherit" font-size="12" dy=".8em" y="15582.700000047684" x="115.5">基于数据的访问控制</text></g></g><g id="minder_node3215" display="none"><g id="node_expander3213" display="none" style="cursor: pointer;"><path id="kity_path_30161" fill="white" stroke="gray" d="M127.5,15598.5A6,6,0,1,1,115.5,15598.5A6,6,0,1,1,127.5,15598.5"></path><path id="kity_path_30162" fill="none" stroke="gray"></path></g><path id="node_outline3214" fill="none" stroke="none" d="M115.5,15589.5h73a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-73a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3214" fill="black"><text id="kity_text_16379" text-rendering="inherit" font-size="12" dy=".8em" y="15590.700000047684" x="115.5">如何接口防刷</text></g></g><g id="minder_node3216" display="none"><g id="node_expander3212" display="none" style="cursor: pointer;"><path id="kity_path_30158" fill="white" stroke="gray" d="M111.5,15598.5A6,6,0,1,1,99.5,15598.5A6,6,0,1,1,111.5,15598.5"></path><path id="kity_path_30159" fill="none" stroke="gray"></path></g><path id="node_outline3213" fill="none" stroke="none" d="M99.5,15589.5h326a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-326a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3213" fill="black"><text id="kity_text_16377" text-rendering="inherit" font-size="12" dy=".8em" y="15590.700000047684" x="99.5">https://juejin.cn/post/6844903874457763847#heading-1</text></g></g><g id="minder_node3217"><g id="node_expander3317" style="cursor: pointer;"><path id="kity_path_30473" fill="white" stroke="gray" d="M317.5,15640.5A6,6,0,1,1,305.5,15640.5A6,6,0,1,1,317.5,15640.5"></path><path id="kity_path_30474" fill="none" stroke="gray" d="M307,15640.5L316,15640.5M311.5,15636L311.5,15645"></path></g><path id="node_outline3318" fill="rgb(239, 238, 246)" stroke="rgb(123, 115, 191)" d="M121.5,15627.5h180a3,3,0,0,1,3,3v20a3,3,0,0,1,-3,3h-180a3,3,0,0,1,-3,-3v-20a3,3,0,0,1,3,-3z" stroke-width="1"></path><g id="node_text3318" fill="black"><text id="kity_text_16664" text-rendering="inherit" font-size="14" dy=".8em" y="15631.400000095367" x="138.5">19.系统设计和项目方面</text></g></g><g id="minder_node3218" display="none"><g id="node_expander3224" display="none" style="cursor: pointer;"><path id="kity_path_30194" fill="white" stroke="gray" d="M114.5,15584.5A6,6,0,1,1,102.5,15584.5A6,6,0,1,1,114.5,15584.5"></path><path id="kity_path_30195" fill="none" stroke="gray"></path></g><path id="node_outline3225" fill="none" stroke="none" d="M102.5,15575.5h77a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-77a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3225" fill="black"><text id="kity_text_16401" text-rendering="inherit" font-size="12" dy=".8em" y="15576.700000047684" x="102.5">&#xa0;项目提问流程</text></g></g><g id="minder_node3219" display="none"><g id="node_expander3216" display="none" style="cursor: pointer;"><path id="kity_path_30170" fill="white" stroke="gray" d="M98.5,15528.5A6,6,0,1,1,86.5,15528.5A6,6,0,1,1,98.5,15528.5"></path><path id="kity_path_30171" fill="none" stroke="gray"></path></g><path id="node_outline3217" fill="none" stroke="none" d="M86.5,15519.5h58a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-58a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3217" fill="black"><text id="kity_text_16385" text-rendering="inherit" font-size="12" dy=".8em" y="15520.700000047684" x="86.5">1.什么项目</text></g></g><g id="minder_node3220" display="none"><g id="node_expander3217" display="none" style="cursor: pointer;"><path id="kity_path_30173" fill="white" stroke="gray" d="M98.5,15536.5A6,6,0,1,1,86.5,15536.5A6,6,0,1,1,98.5,15536.5"></path><path id="kity_path_30174" fill="none" stroke="gray"></path></g><path id="node_outline3218" fill="none" stroke="none" d="M86.5,15527.5h106a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-106a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3218" fill="black"><text id="kity_text_16387" text-rendering="inherit" font-size="12" dy=".8em" y="15528.700000047684" x="86.5">2.你承担了什么角色</text></g></g><g id="minder_node3221" display="none"><g id="node_expander3218" display="none" style="cursor: pointer;"><path id="kity_path_30176" fill="white" stroke="gray" d="M98.5,15544.5A6,6,0,1,1,86.5,15544.5A6,6,0,1,1,98.5,15544.5"></path><path id="kity_path_30177" fill="none" stroke="gray"></path></g><path id="node_outline3219" fill="none" stroke="none" d="M86.5,15535.5h107a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-107a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3219" fill="black"><text id="kity_text_16389" text-rendering="inherit" font-size="12" dy=".8em" y="15536.700000047684" x="86.5">3.你为什么怎么设计</text></g></g><g id="minder_node3222" display="none"><g id="node_expander3219" display="none" style="cursor: pointer;"><path id="kity_path_30179" fill="white" stroke="gray" d="M98.5,15552.5A6,6,0,1,1,86.5,15552.5A6,6,0,1,1,98.5,15552.5"></path><path id="kity_path_30180" fill="none" stroke="gray"></path></g><path id="node_outline3220" fill="none" stroke="none" d="M86.5,15543.5h132a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-132a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3220" fill="black"><text id="kity_text_16391" text-rendering="inherit" font-size="12" dy=".8em" y="15544.700000047684" x="86.5">4.你这么设计有什么好处</text></g></g><g id="minder_node3223" display="none"><g id="node_expander3220" display="none" style="cursor: pointer;"><path id="kity_path_30182" fill="white" stroke="gray" d="M98.5,15560.5A6,6,0,1,1,86.5,15560.5A6,6,0,1,1,98.5,15560.5"></path><path id="kity_path_30183" fill="none" stroke="gray"></path></g><path id="node_outline3221" fill="none" stroke="none" d="M86.5,15551.5h95a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-95a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3221" fill="black"><text id="kity_text_16393" text-rendering="inherit" font-size="12" dy=".8em" y="15552.700000047684" x="86.5">5.遇到了什么问题</text></g></g><g id="minder_node3224" display="none"><g id="node_expander3221" display="none" style="cursor: pointer;"><path id="kity_path_30185" fill="white" stroke="gray" d="M98.5,15568.5A6,6,0,1,1,86.5,15568.5A6,6,0,1,1,98.5,15568.5"></path><path id="kity_path_30186" fill="none" stroke="gray"></path></g><path id="node_outline3222" fill="none" stroke="none" d="M86.5,15559.5h82a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-82a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3222" fill="black"><text id="kity_text_16395" text-rendering="inherit" font-size="12" dy=".8em" y="15560.700000047684" x="86.5">6.你怎么解决的</text></g></g><g id="minder_node3225" display="none"><g id="node_expander3222" display="none" style="cursor: pointer;"><path id="kity_path_30188" fill="white" stroke="gray" d="M98.5,15576.5A6,6,0,1,1,86.5,15576.5A6,6,0,1,1,98.5,15576.5"></path><path id="kity_path_30189" fill="none" stroke="gray"></path></g><path id="node_outline3223" fill="none" stroke="none" d="M86.5,15567.5h94a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-94a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3223" fill="black"><text id="kity_text_16397" text-rendering="inherit" font-size="12" dy=".8em" y="15568.700000047684" x="86.5">7.还能优化提升吗</text></g></g><g id="minder_node3226" display="none"><g id="node_expander3223" display="none" style="cursor: pointer;"><path id="kity_path_30191" fill="white" stroke="gray" d="M98.5,15584.5A6,6,0,1,1,86.5,15584.5A6,6,0,1,1,98.5,15584.5"></path><path id="kity_path_30192" fill="none" stroke="gray"></path></g><path id="node_outline3224" fill="none" stroke="none" d="M86.5,15575.5h582a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-582a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3224" fill="black"><text id="kity_text_16399" text-rendering="inherit" font-size="12" dy=".8em" y="15576.700000047684" x="86.5">8.遇到了xxx问题，经过分析以后发现xxx，和团队协商后，采用了xxx，优化解决了xxx，最后得到的效果是xxx</text></g></g><g id="minder_node3227" display="none"><g id="node_expander3249" display="none" style="cursor: pointer;"><path id="kity_path_30269" fill="white" stroke="gray" d="M114.5,15592.5A6,6,0,1,1,102.5,15592.5A6,6,0,1,1,114.5,15592.5"></path><path id="kity_path_30270" fill="none" stroke="gray"></path></g><path id="node_outline3250" fill="none" stroke="none" d="M102.5,15583.5h48a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-48a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3250" fill="black"><text id="kity_text_16483" text-rendering="inherit" font-size="12" dy=".8em" y="15584.700000047684" x="102.5">设计方面</text></g></g><g id="minder_node3228" display="none"><g id="node_expander3225" display="none" style="cursor: pointer;"><path id="kity_path_30197" fill="white" stroke="gray" d="M98.5,15488.5A6,6,0,1,1,86.5,15488.5A6,6,0,1,1,98.5,15488.5"></path><path id="kity_path_30198" fill="none" stroke="gray"></path></g><path id="node_outline3226" fill="none" stroke="none" d="M86.5,15479.5h174a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-174a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3226" fill="black"><text id="kity_text_16403" text-rendering="inherit" font-size="12" dy=".8em" y="15480.700000047684" x="86.5">让你设计个限流系统 你会怎么做</text></g></g><g id="minder_node3229" display="none"><g id="node_expander3226" display="none" style="cursor: pointer;"><path id="kity_path_30200" fill="white" stroke="gray" d="M98.5,15496.5A6,6,0,1,1,86.5,15496.5A6,6,0,1,1,98.5,15496.5"></path><path id="kity_path_30201" fill="none" stroke="gray"></path></g><path id="node_outline3227" fill="none" stroke="none" d="M86.5,15487.5h182a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-182a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3227" fill="black"><text id="kity_text_16405" text-rendering="inherit" font-size="12" dy=".8em" y="15488.700000047684" x="86.5">让你设计个延时任务系统你怎么做</text></g></g><g id="minder_node3230" display="none"><g id="node_expander3227" display="none" style="cursor: pointer;"><path id="kity_path_30203" fill="white" stroke="gray" d="M98.5,15504.5A6,6,0,1,1,86.5,15504.5A6,6,0,1,1,98.5,15504.5"></path><path id="kity_path_30204" fill="none" stroke="gray"></path></g><path id="node_outline3228" fill="none" stroke="none" d="M86.5,15495.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3228" fill="black"><text id="kity_text_16407" text-rendering="inherit" font-size="12" dy=".8em" y="15496.700000047684" x="86.5">秒杀库存如何设计的</text></g></g><g id="minder_node3231" display="none"><g id="node_expander3228" display="none" style="cursor: pointer;"><path id="kity_path_30206" fill="white" stroke="gray" d="M98.5,15512.5A6,6,0,1,1,86.5,15512.5A6,6,0,1,1,98.5,15512.5"></path><path id="kity_path_30207" fill="none" stroke="gray"></path></g><path id="node_outline3229" fill="none" stroke="none" d="M86.5,15503.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3229" fill="black"><text id="kity_text_16409" text-rendering="inherit" font-size="12" dy=".8em" y="15504.700000047684" x="86.5">数据库连接池怎么设计的</text></g></g><g id="minder_node3232" display="none"><g id="node_expander3229" display="none" style="cursor: pointer;"><path id="kity_path_30209" fill="white" stroke="gray" d="M98.5,15520.5A6,6,0,1,1,86.5,15520.5A6,6,0,1,1,98.5,15520.5"></path><path id="kity_path_30210" fill="none" stroke="gray"></path></g><path id="node_outline3230" fill="none" stroke="none" d="M86.5,15511.5h127a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-127a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3230" fill="black"><text id="kity_text_16411" text-rendering="inherit" font-size="12" dy=".8em" y="15512.700000047684" x="86.5">怎么设计一个安全的api</text></g></g><g id="minder_node3233" display="none"><g id="node_expander3230" display="none" style="cursor: pointer;"><path id="kity_path_30212" fill="white" stroke="gray" d="M98.5,15528.5A6,6,0,1,1,86.5,15528.5A6,6,0,1,1,98.5,15528.5"></path><path id="kity_path_30213" fill="none" stroke="gray"></path></g><path id="node_outline3231" fill="none" stroke="none" d="M86.5,15519.5h234a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-234a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3231" fill="black"><text id="kity_text_16413" text-rendering="inherit" font-size="12" dy=".8em" y="15520.700000047684" x="86.5">大并发/海量数量的情况下，怎么设计系统。</text></g></g><g id="minder_node3234" display="none"><g id="node_expander3232" display="none" style="cursor: pointer;"><path id="kity_path_30218" fill="white" stroke="gray" d="M98.5,15536.5A6,6,0,1,1,86.5,15536.5A6,6,0,1,1,98.5,15536.5"></path><path id="kity_path_30219" fill="none" stroke="gray"></path></g><path id="node_outline3233" fill="none" stroke="none" d="M86.5,15527.5h146a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-146a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3233" fill="black"><text id="kity_text_16421" text-rendering="inherit" font-size="12" dy=".8em" y="15528.700000047684" x="86.5">说说单点登录JWT实现流程</text></g></g><g id="minder_node3235" display="none"><g id="node_expander3231" display="none" style="cursor: pointer;"><path id="kity_path_30215" fill="white" stroke="gray" d="M82.5,15536.5A6,6,0,1,1,70.5,15536.5A6,6,0,1,1,82.5,15536.5"></path><path id="kity_path_30216" fill="none" stroke="gray"></path></g><path id="node_outline3232" fill="none" stroke="none" d="M70.5,15491.5h683a5,5,0,0,1,5,5v80a5,5,0,0,1,-5,5h-683a5,5,0,0,1,-5,-5v-80a5,5,0,0,1,5,-5z"></path><g id="node_text3232" fill="black"><text id="kity_text_16415" text-rendering="inherit" font-size="12" dy=".8em" y="15492.700000047684" x="70.5">1.调用接口登录 返回token令牌，</text><text id="kity_text_16416" text-rendering="inherit" font-size="12" dy=".8em" y="15510.700000047684" x="70.5">2.把token放到cookie，然后通过前端拦截器判断cookie中是否有token，如果有就把token放入header中，或者通过地址栏url中</text><text id="kity_text_16417" text-rendering="inherit" font-size="12" dy=".8em" y="15528.700000047684" x="70.5">3.根据token 调用接口，实习判断token是否有效，然后去后端请求获取用户信息，然后获取到的信息放入cookie中，</text><text id="kity_text_16418" text-rendering="inherit" font-size="12" dy=".8em" y="15546.700000047684" x="70.5">4.前端从cookie中获取用户信息</text><text id="kity_text_16419" text-rendering="inherit" font-size="12" dy=".8em" y="15564.700000047684" x="70.5">5.退出清除cookie</text></g></g><g id="minder_node3236" display="none"><g id="node_expander3234" display="none" style="cursor: pointer;"><path id="kity_path_30224" fill="white" stroke="gray" d="M98.5,15544.5A6,6,0,1,1,86.5,15544.5A6,6,0,1,1,98.5,15544.5"></path><path id="kity_path_30225" fill="none" stroke="gray"></path></g><path id="node_outline3235" fill="none" stroke="none" d="M86.5,15535.5h260a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-260a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3235" fill="black"><text id="kity_text_16428" text-rendering="inherit" font-size="12" dy=".8em" y="15536.700000047684" x="86.5">那顺便你说说spring cloud oauth2的原理了解吗</text></g></g><g id="minder_node3237" display="none"><g id="node_expander3233" display="none" style="cursor: pointer;"><path id="kity_path_30221" fill="white" stroke="gray" d="M82.5,15544.5A6,6,0,1,1,70.5,15544.5A6,6,0,1,1,82.5,15544.5"></path><path id="kity_path_30222" fill="none" stroke="gray"></path></g><path id="node_outline3234" fill="none" stroke="none" d="M70.5,15508.5h1098a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1098a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text3234" fill="black"><text id="kity_text_16423" text-rendering="inherit" font-size="12" dy=".8em" y="15509.700000047684" x="70.5">简单说就是&#xa0; 微信确认用户要通过微信登录我们应用，我们带着临时code和我们应用appid等信息 去获取access_token，获取到了就可以通过微信登录了，通过access_token还可以获取微信开放的用户信息。</text><text id="kity_text_16424" text-rendering="inherit" font-size="12" dy=".8em" y="15527.700000047684" x="70.5">1.outh2系统授权，比如说 微信用户请求登录我们应用，然后我们向微信开发平台请求微信oauth2授权登录，然后微信开发平台询问微信用户是否要登录，用户确认以后</text><text id="kity_text_16425" text-rendering="inherit" font-size="12" dy=".8em" y="15545.700000047684" x="70.5">2.微信平台带上临时code重定向到我们应用，我们带着临时code+我们应用的appid等授权给我们的信息，去换取access_token，然后微信给我们应用返回access_token，</text><text id="kity_text_16426" text-rendering="inherit" font-size="12" dy=".8em" y="15563.700000047684" x="70.5">3.如果类似于二维码的话，需要先向微信申请二维码</text></g></g><g id="minder_node3238" display="none"><g id="node_expander3236" display="none" style="cursor: pointer;"><path id="kity_path_30230" fill="white" stroke="gray" d="M98.5,15552.5A6,6,0,1,1,86.5,15552.5A6,6,0,1,1,98.5,15552.5"></path><path id="kity_path_30231" fill="none" stroke="gray"></path></g><path id="node_outline3237" fill="none" stroke="none" d="M86.5,15543.5h169a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-169a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3237" fill="black"><text id="kity_text_16434" text-rendering="inherit" font-size="12" dy=".8em" y="15544.700000047684" x="86.5">你怎么理解设计一个合格的接口</text></g></g><g id="minder_node3239" display="none"><g id="node_expander3235" display="none" style="cursor: pointer;"><path id="kity_path_30227" fill="white" stroke="gray" d="M82.5,15552.5A6,6,0,1,1,70.5,15552.5A6,6,0,1,1,82.5,15552.5"></path><path id="kity_path_30228" fill="none" stroke="gray"></path></g><path id="node_outline3236" fill="none" stroke="none" d="M70.5,15525.5h673a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-673a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text3236" fill="black"><text id="kity_text_16430" text-rendering="inherit" font-size="12" dy=".8em" y="15526.700000047684" x="70.5">1.接口的命名。请求参数。支持的协议。TPS、并发数、响应时长。数据存储。DB选型、缓存选型。是否需要依赖于第三方。</text><text id="kity_text_16431" text-rendering="inherit" font-size="12" dy=".8em" y="15544.700000047684" x="70.5">接口是否拆分。接口是否需要幂等。防刷。接口限流、降级。负载均衡器支持。如何部署。是否需要服务治理。是否存在单点。</text><text id="kity_text_16432" text-rendering="inherit" font-size="12" dy=".8em" y="15562.700000047684" x="70.5">接口是否资源包、预加载还是内置。是否需要本地缓存。是否需要分布式缓存、缓存穿透怎么办。是否需要白名单。</text></g></g><g id="minder_node3240" display="none"><g id="node_expander3238" display="none" style="cursor: pointer;"><path id="kity_path_30236" fill="white" stroke="gray" d="M98.5,15560.5A6,6,0,1,1,86.5,15560.5A6,6,0,1,1,98.5,15560.5"></path><path id="kity_path_30237" fill="none" stroke="gray"></path></g><path id="node_outline3239" fill="none" stroke="none" d="M86.5,15551.5h289a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-289a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3239" fill="black"><text id="kity_text_16438" text-rendering="inherit" font-size="12" dy=".8em" y="15552.700000047684" x="86.5">你们项目中是怎么做的服务拆分，服务拆分有哪些原则</text></g></g><g id="minder_node3241" display="none"><g id="node_expander3237" display="none" style="cursor: pointer;"><path id="kity_path_30233" fill="white" stroke="gray" d="M82.5,15560.5A6,6,0,1,1,70.5,15560.5A6,6,0,1,1,82.5,15560.5"></path><path id="kity_path_30234" fill="none" stroke="gray"></path></g><path id="node_outline3238" fill="none" stroke="none" d="M70.5,15551.5h83a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-83a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3238" fill="black"><text id="kity_text_16436" text-rendering="inherit" font-size="12" dy=".8em" y="15552.700000047684" x="70.5">1.按照交易类型</text></g></g><g id="minder_node3242" display="none"><g id="node_expander3241" display="none" style="cursor: pointer;"><path id="kity_path_30245" fill="white" stroke="gray" d="M98.5,15568.5A6,6,0,1,1,86.5,15568.5A6,6,0,1,1,98.5,15568.5"></path><path id="kity_path_30246" fill="none" stroke="gray"></path></g><path id="node_outline3242" fill="none" stroke="none" d="M86.5,15559.5h254a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-254a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3242" fill="black"><text id="kity_text_16446" text-rendering="inherit" font-size="12" dy=".8em" y="15560.700000047684" x="86.5">你们项目从单体应用做服务拆分遇到了哪些问题</text></g></g><g id="minder_node3243" display="none"><g id="node_expander3240" display="none" style="cursor: pointer;"><path id="kity_path_30242" fill="white" stroke="gray" d="M82.5,15568.5A6,6,0,1,1,70.5,15568.5A6,6,0,1,1,82.5,15568.5"></path><path id="kity_path_30243" fill="none" stroke="gray"></path></g><path id="node_outline3241" fill="none" stroke="none" d="M70.5,15541.5h238a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-238a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text3241" fill="black"><text id="kity_text_16442" text-rendering="inherit" font-size="12" dy=".8em" y="15542.700000047684" x="70.5">1.重写已经存在的程序。</text><text id="kity_text_16443" text-rendering="inherit" font-size="12" dy=".8em" y="15560.700000047684" x="70.5">2.职责、时间线和界限没有明确定义。</text><text id="kity_text_16444" text-rendering="inherit" font-size="12" dy=".8em" y="15578.700000047684" x="70.5">3.未能从一开始就实施和确定自动化的范围。</text></g></g><g id="minder_node3244" display="none"><g id="node_expander3239" display="none" style="cursor: pointer;"><path id="kity_path_30239" fill="white" stroke="gray" d="M66.5,15568.5A6,6,0,1,1,54.5,15568.5A6,6,0,1,1,66.5,15568.5"></path><path id="kity_path_30240" fill="none" stroke="gray"></path></g><path id="node_outline3240" fill="none" stroke="none" d="M54.5,15559.5h333a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3240" fill="black"><text id="kity_text_16440" text-rendering="inherit" font-size="12" dy=".8em" y="15560.700000047684" x="54.5">https://juejin.cn/post/6844903882355638286#heading-19</text></g></g><g id="minder_node3245" display="none"><g id="node_expander3244" display="none" style="cursor: pointer;"><path id="kity_path_30254" fill="white" stroke="gray" d="M98.5,15576.5A6,6,0,1,1,86.5,15576.5A6,6,0,1,1,98.5,15576.5"></path><path id="kity_path_30255" fill="none" stroke="gray"></path></g><path id="node_outline3245" fill="none" stroke="none" d="M86.5,15567.5h84a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-84a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3245" fill="black"><text id="kity_text_16459" text-rendering="inherit" font-size="12" dy=".8em" y="15568.700000047684" x="86.5">分布式id方案？</text></g></g><g id="minder_node3246" display="none"><g id="node_expander3243" display="none" style="cursor: pointer;"><path id="kity_path_30251" fill="white" stroke="gray" d="M82.5,15576.5A6,6,0,1,1,70.5,15576.5A6,6,0,1,1,82.5,15576.5"></path><path id="kity_path_30252" fill="none" stroke="gray"></path></g><path id="node_outline3244" fill="none" stroke="none" d="M70.5,15504.5h1128a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-1128a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text3244" fill="black"><text id="kity_text_16450" text-rendering="inherit" font-size="12" dy=".8em" y="15505.700000047684" x="70.5">1.基于UUID。无序影响性能，来做令牌token还差不多。</text><text id="kity_text_16451" text-rendering="inherit" font-size="12" dy=".8em" y="15523.700000047684" x="70.5">2.数据库自增id，单独用一个实例生成id，需要的时侯去插入一条并返回id，mysql单机瓶颈，性能问题，不好扩展</text><text id="kity_text_16452" text-rendering="inherit" font-size="12" dy=".8em" y="15541.700000047684" x="70.5">3.双主 甚至多主，通过设置步长，来实现多机之间有序。不好扩展，出现问题全停机修复，只是解决了单机问题。</text><text id="kity_text_16453" text-rendering="inherit" font-size="12" dy=".8em" y="15559.700000047684" x="70.5">4.号段模式，根据业务类型，批量生成id保存到内存，用完就更新，比如 1-1000，每一次增加1000，用完申请1000-2000,再利用版本号对乐观锁控制多业务端操作</text><text id="kity_text_16454" text-rendering="inherit" font-size="12" dy=".8em" y="15577.700000047684" x="70.5">5.redis的自增，多机步长自增</text><text id="kity_text_16455" text-rendering="inherit" font-size="12" dy=".8em" y="15595.700000047684" x="70.5">6.基于雪花算法（Snowflake）模式，依赖时间，有序。</text><text id="kity_text_16456" text-rendering="inherit" font-size="12" dy=".8em" y="15613.700000047684" x="70.5">7.美团Leaf同时支持号段模式和snowflake算法模式，可以切换使用。 只需要导源码，创建表，设置配置，可以通过http方式接入，也可以通过java客户端方式</text><text id="kity_text_16457" text-rendering="inherit" font-size="12" dy=".8em" y="15631.700000047684" x="70.5">8.滴滴，Tinyid是基于号段模式原理实现的与Leaf如出一辙，每个服务获取一个号段（1000,2000]、可以通过http方式接入，也可以通过java客户端方式。可以获取单个分布式自增ID。也可以按需批量分布式自增ID</text></g></g><g id="minder_node3247" display="none"><g id="node_expander3242" display="none" style="cursor: pointer;"><path id="kity_path_30248" fill="white" stroke="gray" d="M66.5,15576.5A6,6,0,1,1,54.5,15576.5A6,6,0,1,1,66.5,15576.5"></path><path id="kity_path_30249" fill="none" stroke="gray"></path></g><path id="node_outline3243" fill="none" stroke="none" d="M54.5,15567.5h333a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-333a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3243" fill="black"><text id="kity_text_16448" text-rendering="inherit" font-size="12" dy=".8em" y="15568.700000047684" x="54.5">https://juejin.cn/post/6844904065747402759#heading-17</text></g></g><g id="minder_node3248" display="none"><g id="node_expander3246" display="none" style="cursor: pointer;"><path id="kity_path_30260" fill="white" stroke="gray" d="M98.5,15584.5A6,6,0,1,1,86.5,15584.5A6,6,0,1,1,98.5,15584.5"></path><path id="kity_path_30261" fill="none" stroke="gray"></path></g><path id="node_outline3247" fill="none" stroke="none" d="M86.5,15575.5h169a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-169a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3247" fill="black"><text id="kity_text_16471" text-rendering="inherit" font-size="12" dy=".8em" y="15576.700000047684" x="86.5">如何设计一个分布式监控中心？</text></g></g><g id="minder_node3249" display="none"><g id="node_expander3245" display="none" style="cursor: pointer;"><path id="kity_path_30257" fill="white" stroke="gray" d="M82.5,15584.5A6,6,0,1,1,70.5,15584.5A6,6,0,1,1,82.5,15584.5"></path><path id="kity_path_30258" fill="none" stroke="gray"></path></g><path id="node_outline3246" fill="none" stroke="none" d="M70.5,15503.5h987a5,5,0,0,1,5,5v152a5,5,0,0,1,-5,5h-987a5,5,0,0,1,-5,-5v-152a5,5,0,0,1,5,-5z"></path><g id="node_text3246" fill="black"><text id="kity_text_16461" text-rendering="inherit" font-size="12" dy=".8em" y="15504.700000047684" x="70.5">监控中心的agent需要安装到被监控的主机上，它负责定期收集各项数据，并发送到监控中心server，监控中心server将数据存储到数据库，监控中心web在前端进行绘图。</text><text id="kity_text_16462" text-rendering="inherit" font-size="12" dy=".8em" y="15522.700000047684" x="70.5">1.四个基本功能：</text><text id="kity_text_16463" text-rendering="inherit" font-size="12" dy=".8em" y="15540.700000047684" x="70.5">1.1数据采集：</text><text id="kity_text_16464" text-rendering="inherit" font-size="12" dy=".8em" y="15558.700000047684" x="70.5">(1)主动：agent请求server获取主动的监控项列表，并主动将监控项内需要检测的数据提交给server/proxy</text><text id="kity_text_16465" text-rendering="inherit" font-size="12" dy=".8em" y="15576.700000047684" x="70.5">(2)server向agent请求获取监控项的数据，agent返回数据。</text><text id="kity_text_16466" text-rendering="inherit" font-size="12" dy=".8em" y="15594.700000047684" x="70.5">采集什么数据：可以自己埋点获取监控信息；代码运行时间统计、次数、错误次数；服务器系统信息、JVM 内存/GC信息、线程信息；SQL语句执行时长；各个进程的CPU和内存使用情况</text><text id="kity_text_16467" text-rendering="inherit" font-size="12" dy=".8em" y="15612.700000047684" x="70.5">1.2实时绘图；1.3告警；1.4.数据存储</text><text id="kity_text_16468" text-rendering="inherit" font-size="12" dy=".8em" y="15630.700000047684" x="70.5">2.常用组件；日志：ELKB</text><text id="kity_text_16469" text-rendering="inherit" font-size="12" dy=".8em" y="15648.700000047684" x="70.5">调用链APM：OpenTracing、Cat、Pinpoint、zipkin</text></g></g><g id="minder_node3250" display="none"><g id="node_expander3248" display="none" style="cursor: pointer;"><path id="kity_path_30266" fill="white" stroke="gray" d="M98.5,15592.5A6,6,0,1,1,86.5,15592.5A6,6,0,1,1,98.5,15592.5"></path><path id="kity_path_30267" fill="none" stroke="gray"></path></g><path id="node_outline3249" fill="none" stroke="none" d="M86.5,15583.5h146a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-146a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3249" fill="black"><text id="kity_text_16481" text-rendering="inherit" font-size="12" dy=".8em" y="15584.700000047684" x="86.5">如何统计网站每天的访问量</text></g></g><g id="minder_node3251" display="none"><g id="node_expander3247" display="none" style="cursor: pointer;"><path id="kity_path_30263" fill="white" stroke="gray" d="M82.5,15592.5A6,6,0,1,1,70.5,15592.5A6,6,0,1,1,82.5,15592.5"></path><path id="kity_path_30264" fill="none" stroke="gray"></path></g><path id="node_outline3248" fill="none" stroke="none" d="M70.5,15529.5h1246a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-1246a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text3248" fill="black"><text id="kity_text_16473" text-rendering="inherit" font-size="12" dy=".8em" y="15530.700000047684" x="70.5">1.hash，使用redis&#xa0; hset 请求+时间 进行拼凑&#xa0; 然后和用户的唯一标识， 统计长度就可以， 场景：简单，并发不大，占用内存后期过大</text><text id="kity_text_16474" text-rendering="inherit" font-size="12" dy=".8em" y="15548.700000047684" x="70.5">位图，比隆过滤器 等 1个32位的int 可以存32个用户，1亿用户也就12M 做好防重复点击 最后一个统计即可，场景：内存小&#xa0; 准确率有一定问题</text><text id="kity_text_16475" text-rendering="inherit" font-size="12" dy=".8em" y="15566.700000047684" x="70.5">redis hypeloglog 概率统计，统计集合中不重复的，统计页面不重复的访客</text><text id="kity_text_16476" text-rendering="inherit" font-size="12" dy=".8em" y="15584.700000047684" x="70.5">2.或者前端埋点</text><text id="kity_text_16477" text-rendering="inherit" font-size="12" dy=".8em" y="15602.700000047684" x="70.5">编写监控js和提供接口。接口返回的是监控网站对应的js文件，这个文件可在客户端标记和采集访客的信息；</text><text id="kity_text_16478" text-rendering="inherit" font-size="12" dy=".8em" y="15620.700000047684" x="70.5">访客访问该站点时,js文件就会被加载；然后标记和采集数据，比如新访客生产一个新cookie和标记访问次数，若是老用户则，读取 cookie信息，计算访问次数和最后访问时间等，这些客户端的信息处理完后，则向指定的服务器发送数据;</text><text id="kity_text_16479" text-rendering="inherit" font-size="12" dy=".8em" y="15638.700000047684" x="70.5">然后接收js提交过来的数据处理入库和后续的数据处理了。</text></g></g><g id="minder_node3252" display="none"><g id="node_expander3266" display="none" style="cursor: pointer;"><path id="kity_path_30320" fill="white" stroke="gray" d="M114.5,15600.5A6,6,0,1,1,102.5,15600.5A6,6,0,1,1,114.5,15600.5"></path><path id="kity_path_30321" fill="none" stroke="gray"></path></g><path id="node_outline3267" fill="none" stroke="none" d="M102.5,15591.5h170a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-170a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3267" fill="black"><text id="kity_text_16532" text-rendering="inherit" font-size="12" dy=".8em" y="15592.700000047684" x="102.5">高性能高并发高可用和问题分析</text></g></g><g id="minder_node3253" display="none"><g id="node_expander3250" display="none" style="cursor: pointer;"><path id="kity_path_30272" fill="white" stroke="gray" d="M98.5,15528.5A6,6,0,1,1,86.5,15528.5A6,6,0,1,1,98.5,15528.5"></path><path id="kity_path_30273" fill="none" stroke="gray"></path></g><path id="node_outline3251" fill="none" stroke="none" d="M86.5,15519.5h277a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-277a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3251" fill="black"><text id="kity_text_16485" text-rendering="inherit" font-size="12" dy=".8em" y="15520.700000047684" x="86.5">多部署机器能实现什么？，好处是什么，坏处是什么</text></g></g><g id="minder_node3254" display="none"><g id="node_expander3252" display="none" style="cursor: pointer;"><path id="kity_path_30278" fill="white" stroke="gray" d="M98.5,15536.5A6,6,0,1,1,86.5,15536.5A6,6,0,1,1,98.5,15536.5"></path><path id="kity_path_30279" fill="none" stroke="gray"></path></g><path id="node_outline3253" fill="none" stroke="none" d="M86.5,15527.5h97a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-97a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3253" fill="black"><text id="kity_text_16495" text-rendering="inherit" font-size="12" dy=".8em" y="15528.700000047684" x="86.5">怎么实现高可用？</text></g></g><g id="minder_node3255" display="none"><g id="node_expander3251" display="none" style="cursor: pointer;"><path id="kity_path_30275" fill="white" stroke="gray" d="M82.5,15536.5A6,6,0,1,1,70.5,15536.5A6,6,0,1,1,82.5,15536.5"></path><path id="kity_path_30276" fill="none" stroke="gray"></path></g><path id="node_outline3252" fill="none" stroke="none" d="M70.5,15473.5h562a5,5,0,0,1,5,5v116a5,5,0,0,1,-5,5h-562a5,5,0,0,1,-5,-5v-116a5,5,0,0,1,5,-5z"></path><g id="node_text3252" fill="black"><text id="kity_text_16487" text-rendering="inherit" font-size="12" dy=".8em" y="15474.700000047684" x="70.5">1.多副本，防止单点问题。例如 MYSQL 的 master-slave。</text><text id="kity_text_16488" text-rendering="inherit" font-size="12" dy=".8em" y="15492.700000047684" x="70.5">2.隔离，将系统资源分隔开，在系统发生故障时可以限定影响范围，不会出现雪球效应。</text><text id="kity_text_16489" text-rendering="inherit" font-size="12" dy=".8em" y="15510.700000047684" x="70.5">3.限流，例如网关限制并发数，业务层做限流，如数据库连接池；或者直接业务层面限流，秒杀限制人数。</text><text id="kity_text_16490" text-rendering="inherit" font-size="12" dy=".8em" y="15528.700000047684" x="70.5">4.熔断，当出现问题需要有自动熔断的机制，比如根据请求响应时间或者请求失败率。</text><text id="kity_text_16491" text-rendering="inherit" font-size="12" dy=".8em" y="15546.700000047684" x="70.5">5.降级，在核心业务压力很大时，可以对非核心业务进行降级。</text><text id="kity_text_16492" text-rendering="inherit" font-size="12" dy=".8em" y="15564.700000047684" x="70.5">6.监控体系，对资源监控、对系统监控，例如接口调用的时间、次数是否正常。</text><text id="kity_text_16493" text-rendering="inherit" font-size="12" dy=".8em" y="15582.700000047684" x="70.5">7.日志报警，帮助我们快速定位到问题。</text></g></g><g id="minder_node3256" display="none"><g id="node_expander3254" display="none" style="cursor: pointer;"><path id="kity_path_30284" fill="white" stroke="gray" d="M98.5,15544.5A6,6,0,1,1,86.5,15544.5A6,6,0,1,1,98.5,15544.5"></path><path id="kity_path_30285" fill="none" stroke="gray"></path></g><path id="node_outline3255" fill="none" stroke="none" d="M86.5,15535.5h108a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-108a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3255" fill="black"><text id="kity_text_16499" text-rendering="inherit" font-size="12" dy=".8em" y="15536.700000047684" x="86.5">系统怎么算高可用？</text></g></g><g id="minder_node3257" display="none"><g id="node_expander3253" display="none" style="cursor: pointer;"><path id="kity_path_30281" fill="white" stroke="gray" d="M82.5,15544.5A6,6,0,1,1,70.5,15544.5A6,6,0,1,1,82.5,15544.5"></path><path id="kity_path_30282" fill="none" stroke="gray"></path></g><path id="node_outline3254" fill="none" stroke="none" d="M70.5,15535.5h34a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-34a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3254" fill="black"><text id="kity_text_16497" text-rendering="inherit" font-size="12" dy=".8em" y="15536.700000047684" x="70.5">1.如上</text></g></g><g id="minder_node3258" display="none"><g id="node_expander3255" display="none" style="cursor: pointer;"><path id="kity_path_30287" fill="white" stroke="gray" d="M98.5,15552.5A6,6,0,1,1,86.5,15552.5A6,6,0,1,1,98.5,15552.5"></path><path id="kity_path_30288" fill="none" stroke="gray"></path></g><path id="node_outline3256" fill="none" stroke="none" d="M86.5,15543.5h156a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-156a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3256" fill="black"><text id="kity_text_16501" text-rendering="inherit" font-size="12" dy=".8em" y="15544.700000047684" x="86.5">多部署机器能实现高可用吗？</text></g></g><g id="minder_node3259" display="none"><g id="node_expander3256" display="none" style="cursor: pointer;"><path id="kity_path_30290" fill="white" stroke="gray" d="M98.5,15560.5A6,6,0,1,1,86.5,15560.5A6,6,0,1,1,98.5,15560.5"></path><path id="kity_path_30291" fill="none" stroke="gray"></path></g><path id="node_outline3257" fill="none" stroke="none" d="M86.5,15551.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3257" fill="black"><text id="kity_text_16503" text-rendering="inherit" font-size="12" dy=".8em" y="15552.700000047684" x="86.5">并发竞争和双写一致性？</text></g></g><g id="minder_node3260" display="none"><g id="node_expander3258" display="none" style="cursor: pointer;"><path id="kity_path_30296" fill="white" stroke="gray" d="M98.5,15568.5A6,6,0,1,1,86.5,15568.5A6,6,0,1,1,98.5,15568.5"></path><path id="kity_path_30297" fill="none" stroke="gray"></path></g><path id="node_outline3259" fill="none" stroke="none" d="M86.5,15559.5h193a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-193a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3259" fill="black"><text id="kity_text_16507" text-rendering="inherit" font-size="12" dy=".8em" y="15560.700000047684" x="86.5">缓存和数据库的双写一致性怎么保证</text></g></g><g id="minder_node3261" display="none"><g id="node_expander3257" display="none" style="cursor: pointer;"><path id="kity_path_30293" fill="white" stroke="gray" d="M82.5,15568.5A6,6,0,1,1,70.5,15568.5A6,6,0,1,1,82.5,15568.5"></path><path id="kity_path_30294" fill="none" stroke="gray"></path></g><path id="node_outline3258" fill="none" stroke="none" d="M70.5,15559.5h75a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-75a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3258" fill="black"><text id="kity_text_16505" text-rendering="inherit" font-size="12" dy=".8em" y="15560.700000047684" x="70.5">1.在redis部分</text></g></g><g id="minder_node3262" display="none"><g id="node_expander3259" display="none" style="cursor: pointer;"><path id="kity_path_30299" fill="white" stroke="gray" d="M98.5,15576.5A6,6,0,1,1,86.5,15576.5A6,6,0,1,1,98.5,15576.5"></path><path id="kity_path_30300" fill="none" stroke="gray"></path></g><path id="node_outline3260" fill="none" stroke="none" d="M86.5,15567.5h98a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-98a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3260" fill="black"><text id="kity_text_16509" text-rendering="inherit" font-size="12" dy=".8em" y="15568.700000047684" x="86.5">页面加载慢怎么办</text></g></g><g id="minder_node3263" display="none"><g id="node_expander3260" display="none" style="cursor: pointer;"><path id="kity_path_30302" fill="white" stroke="gray" d="M98.5,15584.5A6,6,0,1,1,86.5,15584.5A6,6,0,1,1,98.5,15584.5"></path><path id="kity_path_30303" fill="none" stroke="gray"></path></g><path id="node_outline3261" fill="none" stroke="none" d="M86.5,15575.5h241a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-241a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3261" fill="black"><text id="kity_text_16511" text-rendering="inherit" font-size="12" dy=".8em" y="15576.700000047684" x="86.5">线上的服务器监控指标有哪些需要重点关注的</text></g></g><g id="minder_node3264" display="none"><g id="node_expander3263" display="none" style="cursor: pointer;"><path id="kity_path_30311" fill="white" stroke="gray" d="M98.5,15592.5A6,6,0,1,1,86.5,15592.5A6,6,0,1,1,98.5,15592.5"></path><path id="kity_path_30312" fill="none" stroke="gray"></path></g><path id="node_outline3264" fill="none" stroke="none" d="M86.5,15583.5h152a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-152a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3264" fill="black"><text id="kity_text_16526" text-rendering="inherit" font-size="12" dy=".8em" y="15584.700000047684" x="86.5">(秒杀)高并发需要关注哪些？</text></g></g><g id="minder_node3265" display="none"><g id="node_expander3262" display="none" style="cursor: pointer;"><path id="kity_path_30308" fill="white" stroke="gray" d="M82.5,15592.5A6,6,0,1,1,70.5,15592.5A6,6,0,1,1,82.5,15592.5"></path><path id="kity_path_30309" fill="none" stroke="gray"></path></g><path id="node_outline3263" fill="none" stroke="none" d="M70.5,15520.5h610a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-610a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text3263" fill="black"><text id="kity_text_16517" text-rendering="inherit" font-size="12" dy=".8em" y="15521.700000047684" x="70.5">1.杀服务即使自己扛不住压力，挂掉。不要影响别人，服务单一职责+ 独立部署</text><text id="kity_text_16518" text-rendering="inherit" font-size="12" dy=".8em" y="15539.700000047684" x="70.5">2.防止恶意攻击，防止链接暴露，</text><text id="kity_text_16519" text-rendering="inherit" font-size="12" dy=".8em" y="15557.700000047684" x="70.5">3.读多写少。无需每次实时校验库存。我们库存预热，放到redis中。信号量控制进来秒杀的请求</text><text id="kity_text_16520" text-rendering="inherit" font-size="12" dy=".8em" y="15575.700000047684" x="70.5">4.nginx做好动静分离。保证秒杀和商品详情页的动态请求才打到后端的服务集群。使用CDN网络，分担本集群压力</text><text id="kity_text_16521" text-rendering="inherit" font-size="12" dy=".8em" y="15593.700000047684" x="70.5">5.网关层识别非法攻击请求并进行拦截，</text><text id="kity_text_16522" text-rendering="inherit" font-size="12" dy=".8em" y="15611.700000047684" x="70.5">6.流量分担，使用各种手段，将流量分担到更大宽度的时间点。比如验证码，加入购物车</text><text id="kity_text_16523" text-rendering="inherit" font-size="12" dy=".8em" y="15629.700000047684" x="70.5">7.限流&amp;熔断&amp;降级；前端限流+后端限流。限制次数，限制总量，快速失败降级运行，熔断隔离防止雪崩</text><text id="kity_text_16524" text-rendering="inherit" font-size="12" dy=".8em" y="15647.700000047684" x="70.5">8.队列削峰；所有秒杀成功的请求，进入队列，慢慢创建订单，扣减库存即可。</text></g></g><g id="minder_node3266" display="none"><g id="node_expander3261" display="none" style="cursor: pointer;"><path id="kity_path_30305" fill="white" stroke="gray" d="M66.5,15592.5A6,6,0,1,1,54.5,15592.5A6,6,0,1,1,66.5,15592.5"></path><path id="kity_path_30306" fill="none" stroke="gray"></path></g><path id="node_outline3262" fill="none" stroke="none" d="M54.5,15565.5h544a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-544a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text3262" fill="black"><text id="kity_text_16513" text-rendering="inherit" font-size="12" dy=".8em" y="15566.700000047684" x="54.5">1.服务单一，秒杀链接加盐；Redis集群：Nginx(负载均衡+动静分离)；按钮控制(秒杀前，按钮置灰)：</text><text id="kity_text_16514" text-rendering="inherit" font-size="12" dy=".8em" y="15584.700000047684" x="54.5">限流（前端限流和后端限流。）;库存预热：限流&amp;降级&amp;熔断&amp;隔离;削峰填谷：</text><text id="kity_text_16515" text-rendering="inherit" font-size="12" dy=".8em" y="15602.700000047684" x="54.5">2.异步下单；分而治之，将商品库存分开放。</text></g></g><g id="minder_node3267" display="none"><g id="node_expander3265" display="none" style="cursor: pointer;"><path id="kity_path_30317" fill="white" stroke="gray" d="M98.5,15600.5A6,6,0,1,1,86.5,15600.5A6,6,0,1,1,98.5,15600.5"></path><path id="kity_path_30318" fill="none" stroke="gray"></path></g><path id="node_outline3266" fill="none" stroke="none" d="M86.5,15591.5h74a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-74a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3266" fill="black"><text id="kity_text_16530" text-rendering="inherit" font-size="12" dy=".8em" y="15592.700000047684" x="86.5">秒杀怎么设计</text></g></g><g id="minder_node3268" display="none"><g id="node_expander3264" display="none" style="cursor: pointer;"><path id="kity_path_30314" fill="white" stroke="gray" d="M82.5,15600.5A6,6,0,1,1,70.5,15600.5A6,6,0,1,1,82.5,15600.5"></path><path id="kity_path_30315" fill="none" stroke="gray"></path></g><path id="node_outline3265" fill="none" stroke="none" d="M70.5,15591.5h34a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-34a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3265" fill="black"><text id="kity_text_16528" text-rendering="inherit" font-size="12" dy=".8em" y="15592.700000047684" x="70.5">1.如上</text></g></g><g id="minder_node3269" display="none"><g id="node_expander3279" display="none" style="cursor: pointer;"><path id="kity_path_30359" fill="white" stroke="gray" d="M114.5,15608.5A6,6,0,1,1,102.5,15608.5A6,6,0,1,1,114.5,15608.5"></path><path id="kity_path_30360" fill="none" stroke="gray"></path></g><path id="node_outline3280" fill="none" stroke="none" d="M102.5,15599.5h110a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-110a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3280" fill="black"><text id="kity_text_16568" text-rendering="inherit" font-size="12" dy=".8em" y="15600.700000047684" x="102.5">项目问题和场景分析</text></g></g><g id="minder_node3270" display="none"><g id="node_expander3268" display="none" style="cursor: pointer;"><path id="kity_path_30326" fill="white" stroke="gray" d="M98.5,15568.5A6,6,0,1,1,86.5,15568.5A6,6,0,1,1,98.5,15568.5"></path><path id="kity_path_30327" fill="none" stroke="gray"></path></g><path id="node_outline3269" fill="none" stroke="none" d="M86.5,15559.5h170a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-170a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3269" fill="black"><text id="kity_text_16538" text-rendering="inherit" font-size="12" dy=".8em" y="15560.700000047684" x="86.5">项目中的PV，TPS，QPS知道吗</text></g></g><g id="minder_node3271" display="none"><g id="node_expander3267" display="none" style="cursor: pointer;"><path id="kity_path_30323" fill="white" stroke="gray" d="M82.5,15568.5A6,6,0,1,1,70.5,15568.5A6,6,0,1,1,82.5,15568.5"></path><path id="kity_path_30324" fill="none" stroke="gray"></path></g><path id="node_outline3268" fill="none" stroke="none" d="M70.5,15541.5h319a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-319a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text3268" fill="black"><text id="kity_text_16534" text-rendering="inherit" font-size="12" dy=".8em" y="15542.700000047684" x="70.5">1.pv 是指页面被浏览的次数</text><text id="kity_text_16535" text-rendering="inherit" font-size="12" dy=".8em" y="15560.700000047684" x="70.5">2.tps是每秒事务数，每秒系统能够处理的事务次数。</text><text id="kity_text_16536" text-rendering="inherit" font-size="12" dy=".8em" y="15578.700000047684" x="70.5">3.qps是指每秒查询数，每秒系统能够处理的查询请求次数。</text></g></g><g id="minder_node3272" display="none"><g id="node_expander3270" display="none" style="cursor: pointer;"><path id="kity_path_30332" fill="white" stroke="gray" d="M98.5,15576.5A6,6,0,1,1,86.5,15576.5A6,6,0,1,1,98.5,15576.5"></path><path id="kity_path_30333" fill="none" stroke="gray"></path></g><path id="node_outline3271" fill="none" stroke="none" d="M86.5,15567.5h142a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-142a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3271" fill="black"><text id="kity_text_16543" text-rendering="inherit" font-size="12" dy=".8em" y="15568.700000047684" x="86.5">TPS仔细说说，怎么计算的</text></g></g><g id="minder_node3273" display="none"><g id="node_expander3269" display="none" style="cursor: pointer;"><path id="kity_path_30329" fill="white" stroke="gray" d="M82.5,15576.5A6,6,0,1,1,70.5,15576.5A6,6,0,1,1,82.5,15576.5"></path><path id="kity_path_30330" fill="none" stroke="gray"></path></g><path id="node_outline3270" fill="none" stroke="none" d="M70.5,15558.5h447a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-447a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text3270" fill="black"><text id="kity_text_16540" text-rendering="inherit" font-size="12" dy=".8em" y="15559.700000047684" x="70.5">1.事务表示客户端发起请求到收到服务端最终响应的整个过程，这是一个TPS</text><text id="kity_text_16541" text-rendering="inherit" font-size="12" dy=".8em" y="15577.700000047684" x="70.5">2.知道QPS，总请求数 / ( 进程总数 * 请求时间 )，可以利用工具来测试，平常会关注</text></g></g><g id="minder_node3274" display="none"><g id="node_expander3271" display="none" style="cursor: pointer;"><path id="kity_path_30335" fill="white" stroke="gray" d="M98.5,15584.5A6,6,0,1,1,86.5,15584.5A6,6,0,1,1,98.5,15584.5"></path><path id="kity_path_30336" fill="none" stroke="gray"></path></g><path id="node_outline3272" fill="none" stroke="none" d="M86.5,15575.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3272" fill="black"><text id="kity_text_16545" text-rendering="inherit" font-size="12" dy=".8em" y="15576.700000047684" x="86.5">怎么防止恶意刷接口</text></g></g><g id="minder_node3275" display="none"><g id="node_expander3274" display="none" style="cursor: pointer;"><path id="kity_path_30344" fill="white" stroke="gray" d="M98.5,15592.5A6,6,0,1,1,86.5,15592.5A6,6,0,1,1,98.5,15592.5"></path><path id="kity_path_30345" fill="none" stroke="gray"></path></g><path id="node_outline3275" fill="none" stroke="none" d="M86.5,15583.5h214a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-214a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3275" fill="black"><text id="kity_text_16558" text-rendering="inherit" font-size="12" dy=".8em" y="15584.700000047684" x="86.5">如果我 的cpu突然100%，怎么排查解决</text></g></g><g id="minder_node3276" display="none"><g id="node_expander3273" display="none" style="cursor: pointer;"><path id="kity_path_30341" fill="white" stroke="gray" d="M82.5,15592.5A6,6,0,1,1,70.5,15592.5A6,6,0,1,1,82.5,15592.5"></path><path id="kity_path_30342" fill="none" stroke="gray"></path></g><path id="node_outline3274" fill="none" stroke="none" d="M70.5,15520.5h519a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-519a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text3274" fill="black"><text id="kity_text_16549" text-rendering="inherit" font-size="12" dy=".8em" y="15521.700000047684" x="70.5">1.</text><text id="kity_text_16550" text-rendering="inherit" font-size="12" dy=".8em" y="15539.700000047684" x="70.5">htop 查询CPU使用率最高的进程</text><text id="kity_text_16551" text-rendering="inherit" font-size="12" dy=".8em" y="15557.700000047684" x="70.5">pidstat 监控该进程的变化并调试: pidstat -u -p pid</text><text id="kity_text_16552" text-rendering="inherit" font-size="12" dy=".8em" y="15575.700000047684" x="70.5">2.一般情况下是代码进入了死循环 或者&#xa0;当有大量小对象存在,则GC会非常占用资源</text><text id="kity_text_16553" text-rendering="inherit" font-size="12" dy=".8em" y="15593.700000047684" x="70.5">1).ps -ef |grep 或者top 查看进程cpu情况</text><text id="kity_text_16554" text-rendering="inherit" font-size="12" dy=".8em" y="15611.700000047684" x="70.5">2).top -Hp pid查询目标进程下所有线程的运行情况 :</text><text id="kity_text_16555" text-rendering="inherit" font-size="12" dy=".8em" y="15629.700000047684" x="70.5">3).对目标线程进行10进制到16进制转换： printf ‘%x\n’ 线程pid</text><text id="kity_text_16556" text-rendering="inherit" font-size="12" dy=".8em" y="15647.700000047684" x="70.5">4).用jstack 进程id | grep 16进制线程id 找到线程信息；调用路径以及当前所处方法,查看代码逻辑</text></g></g><g id="minder_node3277" display="none"><g id="node_expander3272" display="none" style="cursor: pointer;"><path id="kity_path_30338" fill="white" stroke="gray" d="M66.5,15592.5A6,6,0,1,1,54.5,15592.5A6,6,0,1,1,66.5,15592.5"></path><path id="kity_path_30339" fill="none" stroke="gray"></path></g><path id="node_outline3273" fill="none" stroke="none" d="M54.5,15578.5h359a5,5,0,0,1,5,5v18a5,5,0,0,1,-5,5h-359a5,5,0,0,1,-5,-5v-18a5,5,0,0,1,5,-5z"></path><g id="node_text3273" fill="black"><text id="kity_text_16547" text-rendering="inherit" font-size="12" dy=".8em" y="15584.700000047684" x="54.5">https://mp.weixin.qq.com/s/Bbv9Xl16Wsvda6EOdhWuxQ</text></g><a id="kity_a_16976" xlink:href="https://www.cnblogs.com/cmt/p/14580194.html?from=https%3A%2F%2Fwww.cnblogs.com%2Fnlskyfree%2Fp%2F9559789.html" target="_blank" xlink:title="https://www.cnblogs.com/cmt/p/14580194.html?from=https%3A%2F%2Fwww.cnblogs.com%2Fnlskyfree%2Fp%2F9559789.html" style="cursor: pointer;"><path id="kity_path_16978" fill="rgba(255, 255, 255, 0)" stroke="none" d="M393.5,15581.5h16a4,4,0,0,1,4,4v14a4,4,0,0,1,-4,4h-16a4,4,0,0,1,-4,-4v-14a4,4,0,0,1,4,-4z"></path><path id="kity_path_16977" fill="#666" stroke="none" d="M408.114,15597.724h-1.278c-1.668,0,-3.07,-1.07,-3.599,-2.556h4.877c0.707,0,1.278,-0.571,1.278,-1.278V15591.334c0,-0.707,-0.571,-1.278,-1.278,-1.278h-4.877C403.766,15588.571,405.168,15587.5,406.836,15587.5h1.278c2.116,0,3.834,1.716,3.834,3.834V15593.89C411.948,15596.008,410.23,15597.724,408.114,15597.724zM396.612,15592.612c0,-0.707,0.573,-1.278,1.278,-1.278h7.668c0.707,0,1.278,0.571,1.278,1.278S406.265,15593.89,405.558,15593.89H397.89C397.185,15593.89,396.612,15593.319,396.612,15592.612zM394.056,15591.334V15593.89c0,0.707,0.573,1.278,1.278,1.278h4.877c-0.528,1.486,-1.932,2.556,-3.599,2.556H395.334C393.216,15597.724,391.5,15596.008,391.5,15593.89V15591.334C391.5,15589.216,393.216,15587.5,395.334,15587.5h1.278c1.667,0,3.071,1.071,3.599,2.556H395.334C394.629,15590.056,394.056,15590.627,394.056,15591.334z"></path></a></g><g id="minder_node3278" display="none"><g id="node_expander3276" display="none" style="cursor: pointer;"><path id="kity_path_30350" fill="white" stroke="gray" d="M98.5,15600.5A6,6,0,1,1,86.5,15600.5A6,6,0,1,1,98.5,15600.5"></path><path id="kity_path_30351" fill="none" stroke="gray"></path></g><path id="node_outline3277" fill="none" stroke="none" d="M86.5,15591.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3277" fill="black"><text id="kity_text_16562" text-rendering="inherit" font-size="12" dy=".8em" y="15592.700000047684" x="86.5">&#xa0;阻塞状态线程会让CPU100？</text></g></g><g id="minder_node3279" display="none"><g id="node_expander3275" display="none" style="cursor: pointer;"><path id="kity_path_30347" fill="white" stroke="gray" d="M82.5,15600.5A6,6,0,1,1,70.5,15600.5A6,6,0,1,1,82.5,15600.5"></path><path id="kity_path_30348" fill="none" stroke="gray"></path></g><path id="node_outline3276" fill="none" stroke="none" d="M70.5,15591.5h715a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-715a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3276" fill="black"><text id="kity_text_16560" text-rendering="inherit" font-size="12" dy=".8em" y="15592.700000047684" x="70.5">CPU使用率的飙升更多是由于执行计算密集型任务导致的,而处于阻塞状态的线程在等待时间分片尚未执行,所以不会导致CPU使用率上升</text></g></g><g id="minder_node3280" display="none"><g id="node_expander3278" display="none" style="cursor: pointer;"><path id="kity_path_30356" fill="white" stroke="gray" d="M98.5,15608.5A6,6,0,1,1,86.5,15608.5A6,6,0,1,1,98.5,15608.5"></path><path id="kity_path_30357" fill="none" stroke="gray"></path></g><path id="node_outline3279" fill="none" stroke="none" d="M86.5,15599.5h141a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-141a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3279" fill="black"><text id="kity_text_16566" text-rendering="inherit" font-size="12" dy=".8em" y="15600.700000047684" x="86.5">死锁为啥会让CPU占用100</text></g></g><g id="minder_node3281" display="none"><g id="node_expander3277" display="none" style="cursor: pointer;"><path id="kity_path_30353" fill="white" stroke="gray" d="M82.5,15608.5A6,6,0,1,1,70.5,15608.5A6,6,0,1,1,82.5,15608.5"></path><path id="kity_path_30354" fill="none" stroke="gray"></path></g><path id="node_outline3278" fill="none" stroke="none" d="M70.5,15599.5h571a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-571a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3278" fill="black"><text id="kity_text_16564" text-rendering="inherit" font-size="12" dy=".8em" y="15600.700000047684" x="70.5">当出现锁竞争时,自旋锁会一直循环执行获取锁操作直至到达重试次数或者获取到锁,使得CPU陷入忙等待状态</text></g></g><g id="minder_node3282" display="none"><g id="node_expander3297" display="none" style="cursor: pointer;"><path id="kity_path_30413" fill="white" stroke="gray" d="M114.5,15616.5A6,6,0,1,1,102.5,15616.5A6,6,0,1,1,114.5,15616.5"></path><path id="kity_path_30414" fill="none" stroke="gray"></path></g><path id="node_outline3298" fill="none" stroke="none" d="M102.5,15607.5h48a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-48a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3298" fill="black"><text id="kity_text_16604" text-rendering="inherit" font-size="12" dy=".8em" y="15608.700000047684" x="102.5">电商项目</text></g></g><g id="minder_node3283" display="none"><g id="node_expander3282" display="none" style="cursor: pointer;"><path id="kity_path_30368" fill="white" stroke="gray" d="M98.5,15552.5A6,6,0,1,1,86.5,15552.5A6,6,0,1,1,98.5,15552.5"></path><path id="kity_path_30369" fill="none" stroke="gray"></path></g><path id="node_outline3283" fill="none" stroke="none" d="M86.5,15543.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3283" fill="black"><text id="kity_text_16574" text-rendering="inherit" font-size="12" dy=".8em" y="15544.700000047684" x="86.5">库存方面</text></g></g><g id="minder_node3284" display="none"><g id="node_expander3280" display="none" style="cursor: pointer;"><path id="kity_path_30362" fill="white" stroke="gray" d="M82.5,15544.5A6,6,0,1,1,70.5,15544.5A6,6,0,1,1,82.5,15544.5"></path><path id="kity_path_30363" fill="none" stroke="gray"></path></g><path id="node_outline3281" fill="none" stroke="none" d="M70.5,15535.5h302a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-302a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3281" fill="black"><text id="kity_text_16570" text-rendering="inherit" font-size="12" dy=".8em" y="15536.700000047684" x="70.5">高并发下只有一个人能减库存那如果库存还有很多怎么办</text></g></g><g id="minder_node3285" display="none"><g id="node_expander3281" display="none" style="cursor: pointer;"><path id="kity_path_30365" fill="white" stroke="gray" d="M82.5,15552.5A6,6,0,1,1,70.5,15552.5A6,6,0,1,1,82.5,15552.5"></path><path id="kity_path_30366" fill="none" stroke="gray"></path></g><path id="node_outline3282" fill="none" stroke="none" d="M70.5,15543.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3282" fill="black"><text id="kity_text_16572" text-rendering="inherit" font-size="12" dy=".8em" y="15544.700000047684" x="70.5">秒杀库存如何设计的</text></g></g><g id="minder_node3286" display="none"><g id="node_expander3285" display="none" style="cursor: pointer;"><path id="kity_path_30377" fill="white" stroke="gray" d="M98.5,15560.5A6,6,0,1,1,86.5,15560.5A6,6,0,1,1,98.5,15560.5"></path><path id="kity_path_30378" fill="none" stroke="gray"></path></g><path id="node_outline3286" fill="none" stroke="none" d="M86.5,15551.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3286" fill="black"><text id="kity_text_16580" text-rendering="inherit" font-size="12" dy=".8em" y="15552.700000047684" x="86.5">订单方面</text></g></g><g id="minder_node3287" display="none"><g id="node_expander3283" display="none" style="cursor: pointer;"><path id="kity_path_30371" fill="white" stroke="gray" d="M82.5,15552.5A6,6,0,1,1,70.5,15552.5A6,6,0,1,1,82.5,15552.5"></path><path id="kity_path_30372" fill="none" stroke="gray"></path></g><path id="node_outline3284" fill="none" stroke="none" d="M70.5,15543.5h73a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-73a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3284" fill="black"><text id="kity_text_16576" text-rendering="inherit" font-size="12" dy=".8em" y="15544.700000047684" x="70.5">如何防止超卖</text></g></g><g id="minder_node3288" display="none"><g id="node_expander3284" display="none" style="cursor: pointer;"><path id="kity_path_30374" fill="white" stroke="gray" d="M82.5,15560.5A6,6,0,1,1,70.5,15560.5A6,6,0,1,1,82.5,15560.5"></path><path id="kity_path_30375" fill="none" stroke="gray"></path></g><path id="node_outline3285" fill="none" stroke="none" d="M70.5,15551.5h229a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-229a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3285" fill="black"><text id="kity_text_16578" text-rendering="inherit" font-size="12" dy=".8em" y="15552.700000047684" x="70.5">订单号不能重复，你怎么设计生成订单号？</text></g></g><g id="minder_node3289" display="none"><g id="node_expander3287" display="none" style="cursor: pointer;"><path id="kity_path_30383" fill="white" stroke="gray" d="M98.5,15568.5A6,6,0,1,1,86.5,15568.5A6,6,0,1,1,98.5,15568.5"></path><path id="kity_path_30384" fill="none" stroke="gray"></path></g><path id="node_outline3288" fill="none" stroke="none" d="M86.5,15559.5h48a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-48a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3288" fill="black"><text id="kity_text_16584" text-rendering="inherit" font-size="12" dy=".8em" y="15560.700000047684" x="86.5">事务方面</text></g></g><g id="minder_node3290" display="none"><g id="node_expander3286" display="none" style="cursor: pointer;"><path id="kity_path_30380" fill="white" stroke="gray" d="M82.5,15568.5A6,6,0,1,1,70.5,15568.5A6,6,0,1,1,82.5,15568.5"></path><path id="kity_path_30381" fill="none" stroke="gray"></path></g><path id="node_outline3287" fill="none" stroke="none" d="M70.5,15559.5h637a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-637a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3287" fill="black"><text id="kity_text_16582" text-rendering="inherit" font-size="12" dy=".8em" y="15560.700000047684" x="70.5">双写过程会有分布事务问题，如何解决。如果采用最终一致性的思想，那么并发请求来了好几个发现数据不一致怎么办？</text></g></g><g id="minder_node3291" display="none"><g id="node_expander3288" display="none" style="cursor: pointer;"><path id="kity_path_30386" fill="white" stroke="gray" d="M98.5,15576.5A6,6,0,1,1,86.5,15576.5A6,6,0,1,1,98.5,15576.5"></path><path id="kity_path_30387" fill="none" stroke="gray"></path></g><path id="node_outline3289" fill="none" stroke="none" d="M86.5,15567.5h61a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-61a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3289" fill="black"><text id="kity_text_16586" text-rendering="inherit" font-size="12" dy=".8em" y="15568.700000047684" x="86.5">数据库方面</text></g></g><g id="minder_node3292" display="none"><g id="node_expander3290" display="none" style="cursor: pointer;"><path id="kity_path_30392" fill="white" stroke="gray" d="M98.5,15584.5A6,6,0,1,1,86.5,15584.5A6,6,0,1,1,98.5,15584.5"></path><path id="kity_path_30393" fill="none" stroke="gray"></path></g><path id="node_outline3291" fill="none" stroke="none" d="M86.5,15575.5h48a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-48a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3291" fill="black"><text id="kity_text_16590" text-rendering="inherit" font-size="12" dy=".8em" y="15576.700000047684" x="86.5">配置方面</text></g></g><g id="minder_node3293" display="none"><g id="node_expander3289" display="none" style="cursor: pointer;"><path id="kity_path_30389" fill="white" stroke="gray" d="M82.5,15584.5A6,6,0,1,1,70.5,15584.5A6,6,0,1,1,82.5,15584.5"></path><path id="kity_path_30390" fill="none" stroke="gray"></path></g><path id="node_outline3290" fill="none" stroke="none" d="M70.5,15575.5h385a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-385a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3290" fill="black"><text id="kity_text_16588" text-rendering="inherit" font-size="12" dy=".8em" y="15576.700000047684" x="70.5">我需要在项目启动时，将一些配置加载到内存中，你有什么方式能解决？</text></g></g><g id="minder_node3294" display="none"><g id="node_expander3291" display="none" style="cursor: pointer;"><path id="kity_path_30395" fill="white" stroke="gray" d="M98.5,15592.5A6,6,0,1,1,86.5,15592.5A6,6,0,1,1,98.5,15592.5"></path><path id="kity_path_30396" fill="none" stroke="gray"></path></g><path id="node_outline3292" fill="none" stroke="none" d="M86.5,15583.5h48a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-48a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3292" fill="black"><text id="kity_text_16592" text-rendering="inherit" font-size="12" dy=".8em" y="15584.700000047684" x="86.5">缓存方面</text></g></g><g id="minder_node3295" display="none"><g id="node_expander3292" display="none" style="cursor: pointer;"><path id="kity_path_30398" fill="white" stroke="gray" d="M98.5,15600.5A6,6,0,1,1,86.5,15600.5A6,6,0,1,1,98.5,15600.5"></path><path id="kity_path_30399" fill="none" stroke="gray"></path></g><path id="node_outline3293" fill="none" stroke="none" d="M86.5,15591.5h48a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-48a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3293" fill="black"><text id="kity_text_16594" text-rendering="inherit" font-size="12" dy=".8em" y="15592.700000047684" x="86.5">网络方面</text></g></g><g id="minder_node3296" display="none"><g id="node_expander3294" display="none" style="cursor: pointer;"><path id="kity_path_30404" fill="white" stroke="gray" d="M98.5,15608.5A6,6,0,1,1,86.5,15608.5A6,6,0,1,1,98.5,15608.5"></path><path id="kity_path_30405" fill="none" stroke="gray"></path></g><path id="node_outline3295" fill="none" stroke="none" d="M86.5,15599.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3295" fill="black"><text id="kity_text_16598" text-rendering="inherit" font-size="12" dy=".8em" y="15600.700000047684" x="86.5">并发方面</text></g></g><g id="minder_node3297" display="none"><g id="node_expander3293" display="none" style="cursor: pointer;"><path id="kity_path_30401" fill="white" stroke="gray" d="M82.5,15608.5A6,6,0,1,1,70.5,15608.5A6,6,0,1,1,82.5,15608.5"></path><path id="kity_path_30402" fill="none" stroke="gray"></path></g><path id="node_outline3294" fill="none" stroke="none" d="M70.5,15599.5h217a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-217a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3294" fill="black"><text id="kity_text_16596" text-rendering="inherit" font-size="12" dy=".8em" y="15600.700000047684" x="70.5">并发量很大，服务器宕机。你会怎么做？</text></g></g><g id="minder_node3298" display="none"><g id="node_expander3296" display="none" style="cursor: pointer;"><path id="kity_path_30410" fill="white" stroke="gray" d="M98.5,15616.5A6,6,0,1,1,86.5,15616.5A6,6,0,1,1,98.5,15616.5"></path><path id="kity_path_30411" fill="none" stroke="gray"></path></g><path id="node_outline3297" fill="none" stroke="none" d="M86.5,15607.5h73a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-73a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3297" fill="black"><text id="kity_text_16602" text-rendering="inherit" font-size="12" dy=".8em" y="15608.700000047684" x="86.5">服务监控方面</text></g></g><g id="minder_node3299" display="none"><g id="node_expander3295" display="none" style="cursor: pointer;"><path id="kity_path_30407" fill="white" stroke="gray" d="M82.5,15616.5A6,6,0,1,1,70.5,15616.5A6,6,0,1,1,82.5,15616.5"></path><path id="kity_path_30408" fill="none" stroke="gray"></path></g><path id="node_outline3296" fill="none" stroke="none" d="M70.5,15607.5h124a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-124a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3296" fill="black"><text id="kity_text_16600" text-rendering="inherit" font-size="12" dy=".8em" y="15608.700000047684" x="70.5">&#xa0;服务容灾是如何做的？</text></g></g><g id="minder_node3300" display="none"><g id="node_expander3299" display="none" style="cursor: pointer;"><path id="kity_path_30419" fill="white" stroke="gray" d="M114.5,15624.5A6,6,0,1,1,102.5,15624.5A6,6,0,1,1,114.5,15624.5"></path><path id="kity_path_30420" fill="none" stroke="gray"></path></g><path id="node_outline3300" fill="none" stroke="none" d="M102.5,15615.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3300" fill="black"><text id="kity_text_16608" text-rendering="inherit" font-size="12" dy=".8em" y="15616.700000047684" x="102.5">集群方面</text></g></g><g id="minder_node3301" display="none"><g id="node_expander3298" display="none" style="cursor: pointer;"><path id="kity_path_30416" fill="white" stroke="gray" d="M98.5,15624.5A6,6,0,1,1,86.5,15624.5A6,6,0,1,1,98.5,15624.5"></path><path id="kity_path_30417" fill="none" stroke="gray"></path></g><path id="node_outline3299" fill="none" stroke="none" d="M86.5,15615.5h346a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-346a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3299" fill="black"><text id="kity_text_16606" text-rendering="inherit" font-size="12" dy=".8em" y="15616.700000047684" x="86.5">https://blog.csdn.net/qq_22996201/article/details/98091210</text></g></g><g id="minder_node3302" display="none"><g id="node_expander3302" display="none" style="cursor: pointer;"><path id="kity_path_30428" fill="white" stroke="gray" d="M114.5,15632.5A6,6,0,1,1,102.5,15632.5A6,6,0,1,1,114.5,15632.5"></path><path id="kity_path_30429" fill="none" stroke="gray"></path></g><path id="node_outline3303" fill="none" stroke="none" d="M102.5,15623.5h73a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-73a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3303" fill="black"><text id="kity_text_16614" text-rendering="inherit" font-size="12" dy=".8em" y="15624.700000047684" x="102.5">系统优化排查</text></g></g><g id="minder_node3303" display="none"><g id="node_expander3301" display="none" style="cursor: pointer;"><path id="kity_path_30425" fill="white" stroke="gray" d="M98.5,15632.5A6,6,0,1,1,86.5,15632.5A6,6,0,1,1,98.5,15632.5"></path><path id="kity_path_30426" fill="none" stroke="gray"></path></g><path id="node_outline3302" fill="none" stroke="none" d="M86.5,15623.5h168a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-168a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3302" fill="black"><text id="kity_text_16612" text-rendering="inherit" font-size="12" dy=".8em" y="15624.700000047684" x="86.5">使用perf和火焰图分析系统性能</text></g></g><g id="minder_node3304" display="none"><g id="node_expander3300" display="none" style="cursor: pointer;"><path id="kity_path_30422" fill="white" stroke="gray" d="M82.5,15632.5A6,6,0,1,1,70.5,15632.5A6,6,0,1,1,82.5,15632.5"></path><path id="kity_path_30423" fill="none" stroke="gray"></path></g><path id="node_outline3301" fill="none" stroke="none" d="M70.5,15623.5h246a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-246a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3301" fill="black"><text id="kity_text_16610" text-rendering="inherit" font-size="12" dy=".8em" y="15624.700000047684" x="70.5">https://www.jianshu.com/p/ba7a42267234</text></g></g><g id="minder_node3305" display="none"><g id="node_expander3316" display="none" style="cursor: pointer;"><path id="kity_path_30470" fill="white" stroke="gray" d="M114.5,15640.5A6,6,0,1,1,102.5,15640.5A6,6,0,1,1,114.5,15640.5"></path><path id="kity_path_30471" fill="none" stroke="gray"></path></g><path id="node_outline3317" fill="none" stroke="none" d="M102.5,15631.5h74a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-74a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3317" fill="black"><text id="kity_text_16662" text-rendering="inherit" font-size="12" dy=".8em" y="15632.700000047684" x="102.5">海量数据处理</text></g></g><g id="minder_node3306" display="none"><g id="node_expander3304" display="none" style="cursor: pointer;"><path id="kity_path_30434" fill="white" stroke="gray" d="M98.5,15592.5A6,6,0,1,1,86.5,15592.5A6,6,0,1,1,98.5,15592.5"></path><path id="kity_path_30435" fill="none" stroke="gray"></path></g><path id="node_outline3305" fill="none" stroke="none" d="M86.5,15583.5h267a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-267a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3305" fill="black"><text id="kity_text_16621" text-rendering="inherit" font-size="12" dy=".8em" y="15584.700000047684" x="86.5">出现次数最多前10，频率最高的，和频率相关问题</text></g></g><g id="minder_node3307" display="none"><g id="node_expander3303" display="none" style="cursor: pointer;"><path id="kity_path_30431" fill="white" stroke="gray" d="M82.5,15592.5A6,6,0,1,1,70.5,15592.5A6,6,0,1,1,82.5,15592.5"></path><path id="kity_path_30432" fill="none" stroke="gray"></path></g><path id="node_outline3304" fill="none" stroke="none" d="M70.5,15556.5h743a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-743a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text3304" fill="black"><text id="kity_text_16616" text-rendering="inherit" font-size="12" dy=".8em" y="15557.700000047684" x="70.5">分而治之 + HashMap统计 + 堆/快速/归并排序</text><text id="kity_text_16617" text-rendering="inherit" font-size="12" dy=".8em" y="15575.700000047684" x="70.5">(1)分而治之/hash映射：由于数据量过大，内存不足于存储所有数据，所以要需要将大文件（取模映射）化成小文件，逐个解决，最后汇总。</text><text id="kity_text_16618" text-rendering="inherit" font-size="12" dy=".8em" y="15593.700000047684" x="70.5">(2)hashmap统计。当大文件转化了小文件后，那么便可以统计元素的出现次数，这里除了HasHMap，还可以使用搜索二叉树/红黑树</text><text id="kity_text_16619" text-rendering="inherit" font-size="12" dy=".8em" y="15611.700000047684" x="70.5">(3)统计完了之后便进行排序，可先在小文件采取堆排序，得到每个小文件TopN，最后归并排序，得到大文件TopN。</text></g></g><g id="minder_node3308" display="none"><g id="node_expander3306" display="none" style="cursor: pointer;"><path id="kity_path_30440" fill="white" stroke="gray" d="M98.5,15600.5A6,6,0,1,1,86.5,15600.5A6,6,0,1,1,98.5,15600.5"></path><path id="kity_path_30441" fill="none" stroke="gray"></path></g><path id="node_outline3307" fill="none" stroke="none" d="M86.5,15591.5h201a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-201a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3307" fill="black"><text id="kity_text_16628" text-rendering="inherit" font-size="12" dy=".8em" y="15592.700000047684" x="86.5">第k大，中位数，不重复或重复的数字</text></g></g><g id="minder_node3309" display="none"><g id="node_expander3305" display="none" style="cursor: pointer;"><path id="kity_path_30437" fill="white" stroke="gray" d="M82.5,15600.5A6,6,0,1,1,70.5,15600.5A6,6,0,1,1,82.5,15600.5"></path><path id="kity_path_30438" fill="none" stroke="gray"></path></g><path id="node_outline3306" fill="none" stroke="none" d="M70.5,15564.5h1344a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-1344a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text3306" fill="black"><text id="kity_text_16623" text-rendering="inherit" font-size="12" dy=".8em" y="15565.700000047684" x="70.5">1.因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行。</text><text id="kity_text_16624" text-rendering="inherit" font-size="12" dy=".8em" y="15583.700000047684" x="70.5">（1）2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数</text><text id="kity_text_16625" text-rendering="inherit" font-size="12" dy=".8em" y="15601.700000047684" x="70.5">整数个数为2^32,也就是，我们可以将这2^32个数，划分为2^8个区域(比如用单个文件代表一个区域)，然后将数据分离到不同的区域，然后不同的区域在利用bitmap（通过一个bit位来表示某个元素对应的值）就可以直接解决了</text><text id="kity_text_16626" text-rendering="inherit" font-size="12" dy=".8em" y="15619.700000047684" x="70.5">(2)首先我们将int划分为2^16个区域，然后读取数据统计落到各个区域里的数的个数，之后我们根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第几大数刚好是中位数。然后第二次扫描我们只统计落在这个区域中的那些数就可以了。</text></g></g><g id="minder_node3310" display="none"><g id="node_expander3308" display="none" style="cursor: pointer;"><path id="kity_path_30446" fill="white" stroke="gray" d="M98.5,15608.5A6,6,0,1,1,86.5,15608.5A6,6,0,1,1,98.5,15608.5"></path><path id="kity_path_30447" fill="none" stroke="gray"></path></g><path id="node_outline3309" fill="none" stroke="none" d="M86.5,15590.5h292a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-292a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text3309" fill="black"><text id="kity_text_16639" text-rendering="inherit" font-size="12" dy=".8em" y="15591.700000047684" x="86.5">用来实现数据字典，进行数据的判重，或者集合求交集;</text><text id="kity_text_16640" text-rendering="inherit" font-size="12" dy=".8em" y="15609.700000047684" x="86.5">用Bloom filter/Bitmap</text></g></g><g id="minder_node3311" display="none"><g id="node_expander3307" display="none" style="cursor: pointer;"><path id="kity_path_30443" fill="white" stroke="gray" d="M82.5,15608.5A6,6,0,1,1,70.5,15608.5A6,6,0,1,1,82.5,15608.5"></path><path id="kity_path_30444" fill="none" stroke="gray"></path></g><path id="node_outline3308" fill="none" stroke="none" d="M70.5,15536.5h1013a5,5,0,0,1,5,5v134a5,5,0,0,1,-5,5h-1013a5,5,0,0,1,-5,-5v-134a5,5,0,0,1,5,-5z"></path><g id="node_text3308" fill="black"><text id="kity_text_16630" text-rendering="inherit" font-size="12" dy=".8em" y="15537.700000047684" x="70.5">1.A,B两个文件，各存放50亿条URL，内存限制是4G，找出A,B文件共同的URL</text><text id="kity_text_16631" text-rendering="inherit" font-size="12" dy=".8em" y="15555.700000047684" x="70.5">(1)如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，</text><text id="kity_text_16632" text-rendering="inherit" font-size="12" dy=".8em" y="15573.700000047684" x="70.5">然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。</text><text id="kity_text_16633" text-rendering="inherit" font-size="12" dy=".8em" y="15591.700000047684" x="70.5">2.在2.5亿个整数中找出不重复的整数</text><text id="kity_text_16634" text-rendering="inherit" font-size="12" dy=".8em" y="15609.700000047684" x="70.5">采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。</text><text id="kity_text_16635" text-rendering="inherit" font-size="12" dy=".8em" y="15627.700000047684" x="70.5">然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。</text><text id="kity_text_16636" text-rendering="inherit" font-size="12" dy=".8em" y="15645.700000047684" x="70.5">3.给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？</text><text id="kity_text_16637" text-rendering="inherit" font-size="12" dy=".8em" y="15663.700000047684" x="70.5">用位图/Bitmap的方法，申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。</text></g></g><g id="minder_node3312" display="none"><g id="node_expander3310" display="none" style="cursor: pointer;"><path id="kity_path_30452" fill="white" stroke="gray" d="M98.5,15616.5A6,6,0,1,1,86.5,15616.5A6,6,0,1,1,98.5,15616.5"></path><path id="kity_path_30453" fill="none" stroke="gray"></path></g><path id="node_outline3311" fill="none" stroke="none" d="M86.5,15607.5h182a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-182a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3311" fill="black"><text id="kity_text_16646" text-rendering="inherit" font-size="12" dy=".8em" y="15608.700000047684" x="86.5">大数据的排序，去重；使用外排序</text></g></g><g id="minder_node3313" display="none"><g id="node_expander3309" display="none" style="cursor: pointer;"><path id="kity_path_30449" fill="white" stroke="gray" d="M82.5,15616.5A6,6,0,1,1,70.5,15616.5A6,6,0,1,1,82.5,15616.5"></path><path id="kity_path_30450" fill="none" stroke="gray"></path></g><path id="node_outline3310" fill="none" stroke="none" d="M70.5,15589.5h1067a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-1067a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text3310" fill="black"><text id="kity_text_16642" text-rendering="inherit" font-size="12" dy=".8em" y="15590.700000047684" x="70.5">外部排序指的是大文件的排序，即待排序的记录存储在外存储器上，待排序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序整个文件的目的。</text><text id="kity_text_16643" text-rendering="inherit" font-size="12" dy=".8em" y="15608.700000047684" x="70.5">1.按可用内存的大小，把外存上含有n个记录的文件分成若干个长度为L的子文件，把这些子文件依次读入内存，并利用有效的内部排序方法对它们进行排序，再将排序后得到的有序子文件重新写入外存。</text><text id="kity_text_16644" text-rendering="inherit" font-size="12" dy=".8em" y="15626.700000047684" x="70.5">对这些有序子文件逐趟归并，使其逐渐由小到大，直至得到整个有序文件为止。</text></g></g><g id="minder_node3314" display="none"><g id="node_expander3311" display="none" style="cursor: pointer;"><path id="kity_path_30455" fill="white" stroke="gray" d="M98.5,15624.5A6,6,0,1,1,86.5,15624.5A6,6,0,1,1,98.5,15624.5"></path><path id="kity_path_30456" fill="none" stroke="gray"></path></g><path id="node_outline3312" fill="none" stroke="none" d="M86.5,15615.5h252a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-252a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3312" fill="black"><text id="kity_text_16648" text-rendering="inherit" font-size="12" dy=".8em" y="15616.700000047684" x="86.5">两个含有50亿个url的文件，如何找到公共的url&#xa0;</text></g></g><g id="minder_node3315" display="none"><g id="node_expander3313" display="none" style="cursor: pointer;"><path id="kity_path_30461" fill="white" stroke="gray" d="M98.5,15632.5A6,6,0,1,1,86.5,15632.5A6,6,0,1,1,98.5,15632.5"></path><path id="kity_path_30462" fill="none" stroke="gray"></path></g><path id="node_outline3314" fill="none" stroke="none" d="M86.5,15623.5h212a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-212a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3314" fill="black"><text id="kity_text_16655" text-rendering="inherit" font-size="12" dy=".8em" y="15624.700000047684" x="86.5">10G整数文件中寻找中位数或者第K大数</text></g></g><g id="minder_node3316" display="none"><g id="node_expander3312" display="none" style="cursor: pointer;"><path id="kity_path_30458" fill="white" stroke="gray" d="M82.5,15632.5A6,6,0,1,1,70.5,15632.5A6,6,0,1,1,82.5,15632.5"></path><path id="kity_path_30459" fill="none" stroke="gray"></path></g><path id="node_outline3313" fill="none" stroke="none" d="M70.5,15596.5h778a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-778a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text3313" fill="black"><text id="kity_text_16650" text-rendering="inherit" font-size="12" dy=".8em" y="15597.700000047684" x="70.5">1.采用基于字节的桶排序将数字分到不同的桶中，比如找到第k大数，则先找出每个桶中的第k大数，在比较。</text><text id="kity_text_16651" text-rendering="inherit" font-size="12" dy=".8em" y="15615.700000047684" x="70.5">2.整形是4byte，有32位，先按高八位建255个桶</text><text id="kity_text_16652" text-rendering="inherit" font-size="12" dy=".8em" y="15633.700000047684" x="70.5">3.如果内存只有2g，则每次读取2g的数据遍历放到255个桶中，并统计255个桶的量，2g读取完后将每个桶的数据导出到磁盘，循环读完10g数据。</text><text id="kity_text_16653" text-rendering="inherit" font-size="12" dy=".8em" y="15651.700000047684" x="70.5">4.这时根据255个桶的计数计算出中位数在哪个桶，然后开始建后续8位的桶，直到最后低8位也分完，这时候对桶内数据进行快排即可。</text></g></g><g id="minder_node3317" display="none"><g id="node_expander3315" display="none" style="cursor: pointer;"><path id="kity_path_30467" fill="white" stroke="gray" d="M98.5,15640.5A6,6,0,1,1,86.5,15640.5A6,6,0,1,1,98.5,15640.5"></path><path id="kity_path_30468" fill="none" stroke="gray"></path></g><path id="node_outline3316" fill="none" stroke="none" d="M86.5,15631.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3316" fill="black"><text id="kity_text_16660" text-rendering="inherit" font-size="12" dy=".8em" y="15632.700000047684" x="86.5">参考文章</text></g></g><g id="minder_node3318" display="none"><g id="node_expander3314" display="none" style="cursor: pointer;"><path id="kity_path_30464" fill="white" stroke="gray" d="M82.5,15640.5A6,6,0,1,1,70.5,15640.5A6,6,0,1,1,82.5,15640.5"></path><path id="kity_path_30465" fill="none" stroke="gray"></path></g><path id="node_outline3315" fill="none" stroke="none" d="M70.5,15622.5h556a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-556a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text3315" fill="black"><text id="kity_text_16657" text-rendering="inherit" font-size="12" dy=".8em" y="15623.700000047684" x="70.5">https://www.csdn.net/tags/MtTaEg0sMTU4OTgtYmxvZwO0O0OO0O0O.html</text><text id="kity_text_16658" text-rendering="inherit" font-size="12" dy=".8em" y="15641.700000047684" x="70.5">https://github.com/zaiyunduan123/Java-Summarize/blob/master/notes/algorithms/Big-Data.md</text></g></g><g id="minder_node3319"><g id="node_expander3322" style="cursor: pointer;"><path id="kity_path_30488" fill="white" stroke="gray" d="M317.5,15682.5A6,6,0,1,1,305.5,15682.5A6,6,0,1,1,317.5,15682.5"></path><path id="kity_path_30489" fill="none" stroke="gray" d="M307,15682.5L316,15682.5M311.5,15678L311.5,15687"></path></g><path id="node_outline3323" fill="rgb(239, 238, 246)" stroke="rgb(123, 115, 191)" d="M191.5,15669.5h110a3,3,0,0,1,3,3v20a3,3,0,0,1,-3,3h-110a3,3,0,0,1,-3,-3v-20a3,3,0,0,1,3,-3z" stroke-width="1"></path><g id="node_text3323" fill="black"><text id="kity_text_16674" text-rendering="inherit" font-size="14" dy=".8em" y="15673.400000095367" x="208.5">20.安全方面</text></g></g><g id="minder_node3320" display="none"><g id="node_expander3318" display="none" style="cursor: pointer;"><path id="kity_path_30476" fill="white" stroke="gray" d="M184.5,15658.5A6,6,0,1,1,172.5,15658.5A6,6,0,1,1,184.5,15658.5"></path><path id="kity_path_30477" fill="none" stroke="gray"></path></g><path id="node_outline3319" fill="none" stroke="none" d="M172.5,15649.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3319" fill="black"><text id="kity_text_16666" text-rendering="inherit" font-size="12" dy=".8em" y="15650.700000047684" x="172.5">基础</text></g></g><g id="minder_node3321" display="none"><g id="node_expander3319" display="none" style="cursor: pointer;"><path id="kity_path_30479" fill="white" stroke="gray" d="M184.5,15666.5A6,6,0,1,1,172.5,15666.5A6,6,0,1,1,184.5,15666.5"></path><path id="kity_path_30480" fill="none" stroke="gray"></path></g><path id="node_outline3320" fill="none" stroke="none" d="M172.5,15657.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3320" fill="black"><text id="kity_text_16668" text-rendering="inherit" font-size="12" dy=".8em" y="15658.700000047684" x="172.5">进阶</text></g></g><g id="minder_node3322" display="none"><g id="node_expander3320" display="none" style="cursor: pointer;"><path id="kity_path_30482" fill="white" stroke="gray" d="M184.5,15674.5A6,6,0,1,1,172.5,15674.5A6,6,0,1,1,184.5,15674.5"></path><path id="kity_path_30483" fill="none" stroke="gray"></path></g><path id="node_outline3321" fill="none" stroke="none" d="M172.5,15665.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3321" fill="black"><text id="kity_text_16670" text-rendering="inherit" font-size="12" dy=".8em" y="15666.700000047684" x="172.5">场景</text></g></g><g id="minder_node3323" display="none"><g id="node_expander3321" display="none" style="cursor: pointer;"><path id="kity_path_30485" fill="white" stroke="gray" d="M184.5,15682.5A6,6,0,1,1,172.5,15682.5A6,6,0,1,1,184.5,15682.5"></path><path id="kity_path_30486" fill="none" stroke="gray"></path></g><path id="node_outline3322" fill="none" stroke="none" d="M172.5,15673.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3322" fill="black"><text id="kity_text_16672" text-rendering="inherit" font-size="12" dy=".8em" y="15674.700000047684" x="172.5">问题排查和优化</text></g></g><g id="minder_node3324"><g id="node_expander3334" style="cursor: pointer;"><path id="kity_path_30524" fill="white" stroke="gray" d="M317.5,15724.5A6,6,0,1,1,305.5,15724.5A6,6,0,1,1,317.5,15724.5"></path><path id="kity_path_30525" fill="none" stroke="gray" d="M307,15724.5L316,15724.5M311.5,15720L311.5,15729"></path></g><path id="node_outline3335" fill="rgb(239, 238, 246)" stroke="rgb(123, 115, 191)" d="M191.5,15711.5h110a3,3,0,0,1,3,3v20a3,3,0,0,1,-3,3h-110a3,3,0,0,1,-3,-3v-20a3,3,0,0,1,3,-3z" stroke-width="1"></path><g id="node_text3335" fill="black"><text id="kity_text_16701" text-rendering="inherit" font-size="14" dy=".8em" y="15715.400000095367" x="208.5">21.项目发布</text></g></g><g id="minder_node3325" display="none"><g id="node_expander3326" display="none" style="cursor: pointer;"><path id="kity_path_30500" fill="white" stroke="gray" d="M184.5,15716.5A6,6,0,1,1,172.5,15716.5A6,6,0,1,1,184.5,15716.5"></path><path id="kity_path_30501" fill="none" stroke="gray"></path></g><path id="node_outline3327" fill="none" stroke="none" d="M172.5,15707.5h93a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-93a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3327" fill="black"><text id="kity_text_16683" text-rendering="inherit" font-size="12" dy=".8em" y="15708.700000047684" x="172.5">springcloud相关</text></g></g><g id="minder_node3326" display="none"><g id="node_expander3325" display="none" style="cursor: pointer;"><path id="kity_path_30497" fill="white" stroke="gray" d="M168.5,15716.5A6,6,0,1,1,156.5,15716.5A6,6,0,1,1,168.5,15716.5"></path><path id="kity_path_30498" fill="none" stroke="gray"></path></g><path id="node_outline3326" fill="none" stroke="none" d="M156.5,15707.5h118a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-118a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3326" fill="black"><text id="kity_text_16681" text-rendering="inherit" font-size="12" dy=".8em" y="15708.700000047684" x="156.5">nacos怎么服务上下线</text></g></g><g id="minder_node3327" display="none"><g id="node_expander3324" display="none" style="cursor: pointer;"><path id="kity_path_30494" fill="white" stroke="gray" d="M152.5,15716.5A6,6,0,1,1,140.5,15716.5A6,6,0,1,1,152.5,15716.5"></path><path id="kity_path_30495" fill="none" stroke="gray"></path></g><path id="node_outline3325" fill="none" stroke="none" d="M140.5,15707.5h745a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-745a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3325" fill="black"><text id="kity_text_16679" text-rendering="inherit" font-size="12" dy=".8em" y="15708.700000047684" x="140.5">1.nacos支持服务上下线，但是ribbon是定时任务，可能一上线可以时间更新元数据会有延迟，需要调下rabbin实例 刷新时间 ，默认是30s；</text></g></g><g id="minder_node3328" display="none"><g id="node_expander3323" display="none" style="cursor: pointer;"><path id="kity_path_30491" fill="white" stroke="gray" d="M136.5,15716.5A6,6,0,1,1,124.5,15716.5A6,6,0,1,1,136.5,15716.5"></path><path id="kity_path_30492" fill="none" stroke="gray"></path></g><path id="node_outline3324" fill="none" stroke="none" d="M124.5,15698.5h329a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-329a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text3324" fill="black"><text id="kity_text_16676" text-rendering="inherit" font-size="12" dy=".8em" y="15699.700000047684" x="124.5">https://juejin.cn/post/6844903871827935239</text><text id="kity_text_16677" text-rendering="inherit" font-size="12" dy=".8em" y="15717.700000047684" x="124.5">https://blog.csdn.net/suxingrui/article/details/103795148</text></g></g><g id="minder_node3329" display="none"><g id="node_expander3333" display="none" style="cursor: pointer;"><path id="kity_path_30521" fill="white" stroke="gray" d="M184.5,15724.5A6,6,0,1,1,172.5,15724.5A6,6,0,1,1,184.5,15724.5"></path><path id="kity_path_30522" fill="none" stroke="gray"></path></g><path id="node_outline3334" fill="none" stroke="none" d="M172.5,15715.5h28a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-28a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3334" fill="black"><text id="kity_text_16699" text-rendering="inherit" font-size="12" dy=".8em" y="15716.700000047684" x="172.5">ci/cd</text></g></g><g id="minder_node3330" display="none"><g id="node_expander3328" display="none" style="cursor: pointer;"><path id="kity_path_30506" fill="white" stroke="gray" d="M168.5,15708.5A6,6,0,1,1,156.5,15708.5A6,6,0,1,1,168.5,15708.5"></path><path id="kity_path_30507" fill="none" stroke="gray"></path></g><path id="node_outline3329" fill="none" stroke="none" d="M156.5,15699.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3329" fill="black"><text id="kity_text_16688" text-rendering="inherit" font-size="12" dy=".8em" y="15700.700000047684" x="156.5">灰度发布</text></g></g><g id="minder_node3331" display="none"><g id="node_expander3327" display="none" style="cursor: pointer;"><path id="kity_path_30503" fill="white" stroke="gray" d="M152.5,15708.5A6,6,0,1,1,140.5,15708.5A6,6,0,1,1,152.5,15708.5"></path><path id="kity_path_30504" fill="none" stroke="gray"></path></g><path id="node_outline3328" fill="none" stroke="none" d="M140.5,15690.5h1249a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1249a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text3328" fill="black"><text id="kity_text_16685" text-rendering="inherit" font-size="12" dy=".8em" y="15691.700000047684" x="140.5">1.使用ribbon 实现irule接口，继承 AbstractLoadBalancerRule 类</text><text id="kity_text_16686" text-rendering="inherit" font-size="12" dy=".8em" y="15709.700000047684" x="140.5">灰度发布是能够平滑过渡的一种发布方式，在发布过程中，先发布一部分应用，让指定的用户使用刚发布的应用，等到测试没有问题后，再将其他的全部应用发布。如果新发布的有问题，只需要将这部分恢复即可，不用恢复所有的应用。</text></g></g><g id="minder_node3332" display="none"><g id="node_expander3330" display="none" style="cursor: pointer;"><path id="kity_path_30512" fill="white" stroke="gray" d="M168.5,15716.5A6,6,0,1,1,156.5,15716.5A6,6,0,1,1,168.5,15716.5"></path><path id="kity_path_30513" fill="none" stroke="gray"></path></g><path id="node_outline3331" fill="none" stroke="none" d="M156.5,15707.5h60a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-60a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3331" fill="black"><text id="kity_text_16692" text-rendering="inherit" font-size="12" dy=".8em" y="15708.700000047684" x="156.5">多版本隔离</text></g></g><g id="minder_node3333" display="none"><g id="node_expander3329" display="none" style="cursor: pointer;"><path id="kity_path_30509" fill="white" stroke="gray" d="M152.5,15716.5A6,6,0,1,1,140.5,15716.5A6,6,0,1,1,152.5,15716.5"></path><path id="kity_path_30510" fill="none" stroke="gray"></path></g><path id="node_outline3330" fill="none" stroke="none" d="M140.5,15707.5h888a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-888a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3330" fill="black"><text id="kity_text_16690" text-rendering="inherit" font-size="12" dy=".8em" y="15708.700000047684" x="140.5">多版本隔离跟灰度发布类似，为了兼容或者过度，某些应用会有多个版本，这个时候如何保证 1.0 版本的客户端不会调用到 1.1 版本的服务，就是我们需要考虑的问题。</text></g></g><g id="minder_node3334" display="none"><g id="node_expander3332" display="none" style="cursor: pointer;"><path id="kity_path_30518" fill="white" stroke="gray" d="M168.5,15724.5A6,6,0,1,1,156.5,15724.5A6,6,0,1,1,168.5,15724.5"></path><path id="kity_path_30519" fill="none" stroke="gray"></path></g><path id="node_outline3333" fill="none" stroke="none" d="M156.5,15715.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3333" fill="black"><text id="kity_text_16697" text-rendering="inherit" font-size="12" dy=".8em" y="15716.700000047684" x="156.5">故障隔离</text></g></g><g id="minder_node3335" display="none"><g id="node_expander3331" display="none" style="cursor: pointer;"><path id="kity_path_30515" fill="white" stroke="gray" d="M152.5,15724.5A6,6,0,1,1,140.5,15724.5A6,6,0,1,1,152.5,15724.5"></path><path id="kity_path_30516" fill="none" stroke="gray"></path></g><path id="node_outline3332" fill="none" stroke="none" d="M140.5,15706.5h1045a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-1045a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text3332" fill="black"><text id="kity_text_16694" text-rendering="inherit" font-size="12" dy=".8em" y="15707.700000047684" x="140.5">1.当线上某个实例发生故障后，为了不影响用户，先留存证据，比如：线程信息、JVM 信息等，然后将这个实例重启或直接停止。然后线下根据一些信息分析故障原因；</text><text id="kity_text_16695" text-rendering="inherit" font-size="12" dy=".8em" y="15725.700000047684" x="140.5">做到故障隔离，就可以直接将出问题的实例隔离，不让正常的用户请求访问到这个出问题的实例，只让指定的用户访问，这样就可以单独用特定的用户来对这个出问题的实例进行测试、故障分析等。</text></g></g><g id="minder_node3336"><g id="node_expander3382" style="cursor: pointer;"><path id="kity_path_30668" fill="white" stroke="gray" d="M317.5,15766.5A6,6,0,1,1,305.5,15766.5A6,6,0,1,1,317.5,15766.5"></path><path id="kity_path_30669" fill="none" stroke="gray" d="M307,15766.5L316,15766.5M311.5,15762L311.5,15771"></path></g><path id="node_outline3383" fill="rgb(239, 238, 246)" stroke="rgb(123, 115, 191)" d="M23.5,15753.5h278a3,3,0,0,1,3,3v20a3,3,0,0,1,-3,3h-278a3,3,0,0,1,-3,-3v-20a3,3,0,0,1,3,-3z" stroke-width="1"></path><g id="node_text3383" fill="black"><text id="kity_text_16809" text-rendering="inherit" font-size="14" dy=".8em" y="15757.400000095367" x="40.5">22.其它开发组件或整合或工具或第三方</text></g></g><g id="minder_node3337" display="none"><g id="node_expander3347" display="none" style="cursor: pointer;"><path id="kity_path_30563" fill="white" stroke="gray" d="M16.5,15726.5A6,6,0,1,1,4.5,15726.5A6,6,0,1,1,16.5,15726.5"></path><path id="kity_path_30564" fill="none" stroke="gray"></path></g><path id="node_outline3348" fill="none" stroke="none" d="M4.5,15717.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3348" fill="black"><text id="kity_text_16727" text-rendering="inherit" font-size="12" dy=".8em" y="15718.700000047684" x="4.5">本地缓存</text></g></g><g id="minder_node3338" display="none"><g id="node_expander3340" display="none" style="cursor: pointer;"><path id="kity_path_30542" fill="white" stroke="gray" d="M0.5,15718.5A6,6,0,1,1,-11.5,15718.5A6,6,0,1,1,0.5,15718.5"></path><path id="kity_path_30543" fill="none" stroke="gray"></path></g><path id="node_outline3341" fill="none" stroke="none" d="M-11.5,15709.5h35a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-35a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3341" fill="black"><text id="kity_text_16713" text-rendering="inherit" font-size="12" dy=".8em" y="15710.700000047684" x="-11.5">guava</text></g></g><g id="minder_node3339" display="none"><g id="node_expander3336" display="none" style="cursor: pointer;"><path id="kity_path_30530" fill="white" stroke="gray" d="M-15.5,15694.5A6,6,0,1,1,-27.5,15694.5A6,6,0,1,1,-15.5,15694.5"></path><path id="kity_path_30531" fill="none" stroke="gray"></path></g><path id="node_outline3337" fill="none" stroke="none" d="M-27.5,15685.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3337" fill="black"><text id="kity_text_16705" text-rendering="inherit" font-size="12" dy=".8em" y="15686.700000047684" x="-27.5">基础</text></g></g><g id="minder_node3340" display="none"><g id="node_expander3335" display="none" style="cursor: pointer;"><path id="kity_path_30527" fill="white" stroke="gray" d="M-31.5,15694.5A6,6,0,1,1,-43.5,15694.5A6,6,0,1,1,-31.5,15694.5"></path><path id="kity_path_30528" fill="none" stroke="gray"></path></g><path id="node_outline3336" fill="none" stroke="none" d="M-43.5,15685.5h203a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-203a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3336" fill="black"><text id="kity_text_16703" text-rendering="inherit" font-size="12" dy=".8em" y="15686.700000047684" x="-43.5">guava是什么？用过吗？用在哪些方面</text></g></g><g id="minder_node3341" display="none"><g id="node_expander3337" display="none" style="cursor: pointer;"><path id="kity_path_30533" fill="white" stroke="gray" d="M-15.5,15702.5A6,6,0,1,1,-27.5,15702.5A6,6,0,1,1,-15.5,15702.5"></path><path id="kity_path_30534" fill="none" stroke="gray"></path></g><path id="node_outline3338" fill="none" stroke="none" d="M-27.5,15693.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3338" fill="black"><text id="kity_text_16707" text-rendering="inherit" font-size="12" dy=".8em" y="15694.700000047684" x="-27.5">进阶</text></g></g><g id="minder_node3342" display="none"><g id="node_expander3338" display="none" style="cursor: pointer;"><path id="kity_path_30536" fill="white" stroke="gray" d="M-15.5,15710.5A6,6,0,1,1,-27.5,15710.5A6,6,0,1,1,-15.5,15710.5"></path><path id="kity_path_30537" fill="none" stroke="gray"></path></g><path id="node_outline3339" fill="none" stroke="none" d="M-27.5,15701.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3339" fill="black"><text id="kity_text_16709" text-rendering="inherit" font-size="12" dy=".8em" y="15702.700000047684" x="-27.5">场景问题</text></g></g><g id="minder_node3343" display="none"><g id="node_expander3339" display="none" style="cursor: pointer;"><path id="kity_path_30539" fill="white" stroke="gray" d="M-15.5,15718.5A6,6,0,1,1,-27.5,15718.5A6,6,0,1,1,-15.5,15718.5"></path><path id="kity_path_30540" fill="none" stroke="gray"></path></g><path id="node_outline3340" fill="none" stroke="none" d="M-27.5,15709.5h62a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-62a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3340" fill="black"><text id="kity_text_16711" text-rendering="inherit" font-size="12" dy=".8em" y="15710.700000047684" x="-27.5">优化和排查</text></g></g><g id="minder_node3344" display="none"><g id="node_expander3346" display="none" style="cursor: pointer;"><path id="kity_path_30560" fill="white" stroke="gray" d="M0.5,15726.5A6,6,0,1,1,-11.5,15726.5A6,6,0,1,1,0.5,15726.5"></path><path id="kity_path_30561" fill="none" stroke="gray"></path></g><path id="node_outline3347" fill="none" stroke="none" d="M-11.5,15717.5h47a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-47a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3347" fill="black"><text id="kity_text_16725" text-rendering="inherit" font-size="12" dy=".8em" y="15718.700000047684" x="-11.5">Caffeine</text></g></g><g id="minder_node3345" display="none"><g id="node_expander3342" display="none" style="cursor: pointer;"><path id="kity_path_30548" fill="white" stroke="gray" d="M-15.5,15702.5A6,6,0,1,1,-27.5,15702.5A6,6,0,1,1,-15.5,15702.5"></path><path id="kity_path_30549" fill="none" stroke="gray"></path></g><path id="node_outline3343" fill="none" stroke="none" d="M-27.5,15693.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3343" fill="black"><text id="kity_text_16717" text-rendering="inherit" font-size="12" dy=".8em" y="15694.700000047684" x="-27.5">基础</text></g></g><g id="minder_node3346" display="none"><g id="node_expander3341" display="none" style="cursor: pointer;"><path id="kity_path_30545" fill="white" stroke="gray" d="M-31.5,15702.5A6,6,0,1,1,-43.5,15702.5A6,6,0,1,1,-31.5,15702.5"></path><path id="kity_path_30546" fill="none" stroke="gray"></path></g><path id="node_outline3342" fill="none" stroke="none" d="M-43.5,15693.5h202a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-202a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3342" fill="black"><text id="kity_text_16715" text-rendering="inherit" font-size="12" dy=".8em" y="15694.700000047684" x="-43.5">Caffeine了解过吗？和guava有区别？</text></g></g><g id="minder_node3347" display="none"><g id="node_expander3343" display="none" style="cursor: pointer;"><path id="kity_path_30551" fill="white" stroke="gray" d="M-15.5,15710.5A6,6,0,1,1,-27.5,15710.5A6,6,0,1,1,-15.5,15710.5"></path><path id="kity_path_30552" fill="none" stroke="gray"></path></g><path id="node_outline3344" fill="none" stroke="none" d="M-27.5,15701.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3344" fill="black"><text id="kity_text_16719" text-rendering="inherit" font-size="12" dy=".8em" y="15702.700000047684" x="-27.5">进阶</text></g></g><g id="minder_node3348" display="none"><g id="node_expander3344" display="none" style="cursor: pointer;"><path id="kity_path_30554" fill="white" stroke="gray" d="M-15.5,15718.5A6,6,0,1,1,-27.5,15718.5A6,6,0,1,1,-15.5,15718.5"></path><path id="kity_path_30555" fill="none" stroke="gray"></path></g><path id="node_outline3345" fill="none" stroke="none" d="M-27.5,15709.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3345" fill="black"><text id="kity_text_16721" text-rendering="inherit" font-size="12" dy=".8em" y="15710.700000047684" x="-27.5">场景问题</text></g></g><g id="minder_node3349" display="none"><g id="node_expander3345" display="none" style="cursor: pointer;"><path id="kity_path_30557" fill="white" stroke="gray" d="M-15.5,15726.5A6,6,0,1,1,-27.5,15726.5A6,6,0,1,1,-15.5,15726.5"></path><path id="kity_path_30558" fill="none" stroke="gray"></path></g><path id="node_outline3346" fill="none" stroke="none" d="M-27.5,15717.5h62a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-62a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3346" fill="black"><text id="kity_text_16723" text-rendering="inherit" font-size="12" dy=".8em" y="15718.700000047684" x="-27.5">优化和排查</text></g></g><g id="minder_node3350" display="none"><g id="node_expander3350" display="none" style="cursor: pointer;"><path id="kity_path_30572" fill="white" stroke="gray" d="M16.5,15734.5A6,6,0,1,1,4.5,15734.5A6,6,0,1,1,16.5,15734.5"></path><path id="kity_path_30573" fill="none" stroke="gray"></path></g><path id="node_outline3351" fill="none" stroke="none" d="M4.5,15725.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3351" fill="black"><text id="kity_text_16733" text-rendering="inherit" font-size="12" dy=".8em" y="15726.700000047684" x="4.5">微信</text></g></g><g id="minder_node3351" display="none"><g id="node_expander3348" display="none" style="cursor: pointer;"><path id="kity_path_30566" fill="white" stroke="gray" d="M0.5,15726.5A6,6,0,1,1,-11.5,15726.5A6,6,0,1,1,0.5,15726.5"></path><path id="kity_path_30567" fill="none" stroke="gray"></path></g><path id="node_outline3349" fill="none" stroke="none" d="M-11.5,15717.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3349" fill="black"><text id="kity_text_16729" text-rendering="inherit" font-size="12" dy=".8em" y="15718.700000047684" x="-11.5">微信登录</text></g></g><g id="minder_node3352" display="none"><g id="node_expander3349" display="none" style="cursor: pointer;"><path id="kity_path_30569" fill="white" stroke="gray" d="M0.5,15734.5A6,6,0,1,1,-11.5,15734.5A6,6,0,1,1,0.5,15734.5"></path><path id="kity_path_30570" fill="none" stroke="gray"></path></g><path id="node_outline3350" fill="none" stroke="none" d="M-11.5,15725.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3350" fill="black"><text id="kity_text_16731" text-rendering="inherit" font-size="12" dy=".8em" y="15726.700000047684" x="-11.5">微信支付</text></g></g><g id="minder_node3353" display="none"><g id="node_expander3361" display="none" style="cursor: pointer;"><path id="kity_path_30605" fill="white" stroke="gray" d="M16.5,15742.5A6,6,0,1,1,4.5,15742.5A6,6,0,1,1,16.5,15742.5"></path><path id="kity_path_30606" fill="none" stroke="gray"></path></g><path id="node_outline3362" fill="none" stroke="none" d="M4.5,15733.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3362" fill="black"><text id="kity_text_16763" text-rendering="inherit" font-size="12" dy=".8em" y="15734.700000047684" x="4.5">阿里</text></g></g><g id="minder_node3354" display="none"><g id="node_expander3351" display="none" style="cursor: pointer;"><path id="kity_path_30575" fill="white" stroke="gray" d="M0.5,15718.5A6,6,0,1,1,-11.5,15718.5A6,6,0,1,1,0.5,15718.5"></path><path id="kity_path_30576" fill="none" stroke="gray"></path></g><path id="node_outline3352" fill="none" stroke="none" d="M-11.5,15709.5h61a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-61a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3352" fill="black"><text id="kity_text_16735" text-rendering="inherit" font-size="12" dy=".8em" y="15710.700000047684" x="-11.5">支付宝支付</text></g></g><g id="minder_node3355" display="none"><g id="node_expander3352" display="none" style="cursor: pointer;"><path id="kity_path_30578" fill="white" stroke="gray" d="M0.5,15726.5A6,6,0,1,1,-11.5,15726.5A6,6,0,1,1,0.5,15726.5"></path><path id="kity_path_30579" fill="none" stroke="gray"></path></g><path id="node_outline3353" fill="none" stroke="none" d="M-11.5,15717.5h55a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-55a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3353" fill="black"><text id="kity_text_16737" text-rendering="inherit" font-size="12" dy=".8em" y="15718.700000047684" x="-11.5">阿里云oss</text></g></g><g id="minder_node3356" display="none"><g id="node_expander3353" display="none" style="cursor: pointer;"><path id="kity_path_30581" fill="white" stroke="gray" d="M0.5,15734.5A6,6,0,1,1,-11.5,15734.5A6,6,0,1,1,0.5,15734.5"></path><path id="kity_path_30582" fill="none" stroke="gray"></path></g><path id="node_outline3354" fill="none" stroke="none" d="M-11.5,15725.5h85a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-85a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3354" fill="black"><text id="kity_text_16739" text-rendering="inherit" font-size="12" dy=".8em" y="15726.700000047684" x="-11.5">阿里云视频播放</text></g></g><g id="minder_node3357" display="none"><g id="node_expander3360" display="none" style="cursor: pointer;"><path id="kity_path_30602" fill="white" stroke="gray" d="M0.5,15742.5A6,6,0,1,1,-11.5,15742.5A6,6,0,1,1,0.5,15742.5"></path><path id="kity_path_30603" fill="none" stroke="gray"></path></g><path id="node_outline3361" fill="none" stroke="none" d="M-11.5,15733.5h36a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-36a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3361" fill="black"><text id="kity_text_16761" text-rendering="inherit" font-size="12" dy=".8em" y="15734.700000047684" x="-11.5">arthas</text></g></g><g id="minder_node3358" display="none"><g id="node_expander3355" display="none" style="cursor: pointer;"><path id="kity_path_30587" fill="white" stroke="gray" d="M-15.5,15726.5A6,6,0,1,1,-27.5,15726.5A6,6,0,1,1,-15.5,15726.5"></path><path id="kity_path_30588" fill="none" stroke="gray"></path></g><path id="node_outline3356" fill="none" stroke="none" d="M-27.5,15717.5h96a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-96a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3356" fill="black"><text id="kity_text_16748" text-rendering="inherit" font-size="12" dy=".8em" y="15718.700000047684" x="-27.5">怎么使用arthas的</text></g></g><g id="minder_node3359" display="none"><g id="node_expander3354" display="none" style="cursor: pointer;"><path id="kity_path_30584" fill="white" stroke="gray" d="M-31.5,15726.5A6,6,0,1,1,-43.5,15726.5A6,6,0,1,1,-31.5,15726.5"></path><path id="kity_path_30585" fill="none" stroke="gray"></path></g><path id="node_outline3355" fill="none" stroke="none" d="M-43.5,15672.5h513a5,5,0,0,1,5,5v98a5,5,0,0,1,-5,5h-513a5,5,0,0,1,-5,-5v-98a5,5,0,0,1,5,-5z"></path><g id="node_text3355" fill="black"><text id="kity_text_16741" text-rendering="inherit" font-size="12" dy=".8em" y="15673.700000047684" x="-43.5">1.dashborad 查看数据面版 ；</text><text id="kity_text_16742" text-rendering="inherit" font-size="12" dy=".8em" y="15691.700000047684" x="-43.5">2.watch 查看方法入参 异常 出参</text><text id="kity_text_16743" text-rendering="inherit" font-size="12" dy=".8em" y="15709.700000047684" x="-43.5">3.查看加载的类信息 和类方法信息 sc&#xa0; 然后 jad 反编译某一个类&#xa0;</text><text id="kity_text_16744" text-rendering="inherit" font-size="12" dy=".8em" y="15727.700000047684" x="-43.5">4.thread&#xa0; 查看线程堆栈信息 然后是thread -n 查看cpu&#xa0; 使用率 高 的线程。 thread -b查看死锁</text><text id="kity_text_16745" text-rendering="inherit" font-size="12" dy=".8em" y="15745.700000047684" x="-43.5">比如 我们 报500的错误 trace 查看异常方法&#xa0; &#xa0;tt -i id 排查方法查看具体原因 是否是空指针之类的</text><text id="kity_text_16746" text-rendering="inherit" font-size="12" dy=".8em" y="15763.700000047684" x="-43.5">比如 接口响应时间变慢 trace 输出方法调用路径，输出耗时</text></g></g><g id="minder_node3360" display="none"><g id="node_expander3357" display="none" style="cursor: pointer;"><path id="kity_path_30593" fill="white" stroke="gray" d="M-15.5,15734.5A6,6,0,1,1,-27.5,15734.5A6,6,0,1,1,-15.5,15734.5"></path><path id="kity_path_30594" fill="none" stroke="gray"></path></g><path id="node_outline3358" fill="none" stroke="none" d="M-27.5,15725.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3358" fill="black"><text id="kity_text_16754" text-rendering="inherit" font-size="12" dy=".8em" y="15726.700000047684" x="-27.5">原理</text></g></g><g id="minder_node3361" display="none"><g id="node_expander3356" display="none" style="cursor: pointer;"><path id="kity_path_30590" fill="white" stroke="gray" d="M-31.5,15734.5A6,6,0,1,1,-43.5,15734.5A6,6,0,1,1,-31.5,15734.5"></path><path id="kity_path_30591" fill="none" stroke="gray"></path></g><path id="node_outline3357" fill="none" stroke="none" d="M-43.5,15707.5h903a5,5,0,0,1,5,5v44a5,5,0,0,1,-5,5h-903a5,5,0,0,1,-5,-5v-44a5,5,0,0,1,5,-5z"></path><g id="node_text3357" fill="black"><text id="kity_text_16750" text-rendering="inherit" font-size="12" dy=".8em" y="15708.700000047684" x="-43.5">1.启动的时侯 使用自定义的类加载器，会调用本对jps命令 查看进程</text><text id="kity_text_16751" text-rendering="inherit" font-size="12" dy=".8em" y="15726.700000047684" x="-43.5">2.然后会去下载一些核心文件&#xa0; 通过反射来启动客户端&#xa0; &#xa0;服务端，</text><text id="kity_text_16752" text-rendering="inherit" font-size="12" dy=".8em" y="15744.700000047684" x="-43.5">3.然后就是执行自己的main方法 加载解析配置文件数据&#xa0; 然后加载自己的加载器去隔离目标线程类 和本身类 ，然后就是字节码增强织入目标方法 然后就是去启动监听线程&#xa0;</text></g></g><g id="minder_node3362" display="none"><g id="node_expander3359" display="none" style="cursor: pointer;"><path id="kity_path_30599" fill="white" stroke="gray" d="M-15.5,15742.5A6,6,0,1,1,-27.5,15742.5A6,6,0,1,1,-15.5,15742.5"></path><path id="kity_path_30600" fill="none" stroke="gray"></path></g><path id="node_outline3360" fill="none" stroke="none" d="M-27.5,15733.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3360" fill="black"><text id="kity_text_16759" text-rendering="inherit" font-size="12" dy=".8em" y="15734.700000047684" x="-27.5">参考文章</text></g></g><g id="minder_node3363" display="none"><g id="node_expander3358" display="none" style="cursor: pointer;"><path id="kity_path_30596" fill="white" stroke="gray" d="M-31.5,15742.5A6,6,0,1,1,-43.5,15742.5A6,6,0,1,1,-31.5,15742.5"></path><path id="kity_path_30597" fill="none" stroke="gray"></path></g><path id="node_outline3359" fill="none" stroke="none" d="M-43.5,15724.5h259a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-259a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text3359" fill="black"><text id="kity_text_16756" text-rendering="inherit" font-size="12" dy=".8em" y="15725.700000047684" x="-43.5">https://juejin.cn/post/6844903998730797070</text><text id="kity_text_16757" text-rendering="inherit" font-size="12" dy=".8em" y="15743.700000047684" x="-43.5">https://juejin.cn/post/6889621266194497543</text></g></g><g id="minder_node3364" display="none"><g id="node_expander3375" display="none" style="cursor: pointer;"><path id="kity_path_30647" fill="white" stroke="gray" d="M16.5,15750.5A6,6,0,1,1,4.5,15750.5A6,6,0,1,1,16.5,15750.5"></path><path id="kity_path_30648" fill="none" stroke="gray"></path></g><path id="node_outline3376" fill="none" stroke="none" d="M4.5,15741.5h16a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-16a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3376" fill="black"><text id="kity_text_16795" text-rendering="inherit" font-size="12" dy=".8em" y="15742.700000047684" x="4.5">git</text></g></g><g id="minder_node3365" display="none"><g id="node_expander3374" display="none" style="cursor: pointer;"><path id="kity_path_30644" fill="white" stroke="gray" d="M0.5,15750.5A6,6,0,1,1,-11.5,15750.5A6,6,0,1,1,0.5,15750.5"></path><path id="kity_path_30645" fill="none" stroke="gray"></path></g><path id="node_outline3375" fill="none" stroke="none" d="M-11.5,15741.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3375" fill="black"><text id="kity_text_16793" text-rendering="inherit" font-size="12" dy=".8em" y="15742.700000047684" x="-11.5">基础</text></g></g><g id="minder_node3366" display="none"><g id="node_expander3363" display="none" style="cursor: pointer;"><path id="kity_path_30611" fill="white" stroke="gray" d="M-15.5,15710.5A6,6,0,1,1,-27.5,15710.5A6,6,0,1,1,-15.5,15710.5"></path><path id="kity_path_30612" fill="none" stroke="gray"></path></g><path id="node_outline3364" fill="none" stroke="none" d="M-27.5,15701.5h177a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-177a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3364" fill="black"><text id="kity_text_16767" text-rendering="inherit" font-size="12" dy=".8em" y="15702.700000047684" x="-27.5">知道git 解决冲突吗，有哪些方式</text></g></g><g id="minder_node3367" display="none"><g id="node_expander3362" display="none" style="cursor: pointer;"><path id="kity_path_30608" fill="white" stroke="gray" d="M-31.5,15710.5A6,6,0,1,1,-43.5,15710.5A6,6,0,1,1,-31.5,15710.5"></path><path id="kity_path_30609" fill="none" stroke="gray"></path></g><path id="node_outline3363" fill="none" stroke="none" d="M-43.5,15701.5h418a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-418a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3363" fill="black"><text id="kity_text_16765" text-rendering="inherit" font-size="12" dy=".8em" y="15702.700000047684" x="-43.5">1.一般小问题和开发的人说明一下，如果复杂就在一起讨论一下具体怎么解决。</text></g></g><g id="minder_node3368" display="none"><g id="node_expander3365" display="none" style="cursor: pointer;"><path id="kity_path_30617" fill="white" stroke="gray" d="M-15.5,15718.5A6,6,0,1,1,-27.5,15718.5A6,6,0,1,1,-15.5,15718.5"></path><path id="kity_path_30618" fill="none" stroke="gray"></path></g><path id="node_outline3366" fill="none" stroke="none" d="M-27.5,15709.5h122a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-122a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3366" fill="black"><text id="kity_text_16771" text-rendering="inherit" font-size="12" dy=".8em" y="15710.700000047684" x="-27.5">git rebase 会发生什么</text></g></g><g id="minder_node3369" display="none"><g id="node_expander3364" display="none" style="cursor: pointer;"><path id="kity_path_30614" fill="white" stroke="gray" d="M-31.5,15718.5A6,6,0,1,1,-43.5,15718.5A6,6,0,1,1,-31.5,15718.5"></path><path id="kity_path_30615" fill="none" stroke="gray"></path></g><path id="node_outline3365" fill="none" stroke="none" d="M-43.5,15709.5h182a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-182a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3365" fill="black"><text id="kity_text_16769" text-rendering="inherit" font-size="12" dy=".8em" y="15710.700000047684" x="-43.5">1.合并多个commit为一个commit</text></g></g><g id="minder_node3370" display="none"><g id="node_expander3367" display="none" style="cursor: pointer;"><path id="kity_path_30623" fill="white" stroke="gray" d="M-15.5,15726.5A6,6,0,1,1,-27.5,15726.5A6,6,0,1,1,-15.5,15726.5"></path><path id="kity_path_30624" fill="none" stroke="gray"></path></g><path id="node_outline3368" fill="none" stroke="none" d="M-27.5,15717.5h166a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-166a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3368" fill="black"><text id="kity_text_16775" text-rendering="inherit" font-size="12" dy=".8em" y="15718.700000047684" x="-27.5">git add和git stage 有什么区别</text></g></g><g id="minder_node3371" display="none"><g id="node_expander3366" display="none" style="cursor: pointer;"><path id="kity_path_30620" fill="white" stroke="gray" d="M-31.5,15726.5A6,6,0,1,1,-43.5,15726.5A6,6,0,1,1,-31.5,15726.5"></path><path id="kity_path_30621" fill="none" stroke="gray"></path></g><path id="node_outline3367" fill="none" stroke="none" d="M-43.5,15717.5h243a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-243a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3367" fill="black"><text id="kity_text_16773" text-rendering="inherit" font-size="12" dy=".8em" y="15718.700000047684" x="-43.5">含义相同，推荐git stage，把文件加入暂存区</text></g></g><g id="minder_node3372" display="none"><g id="node_expander3369" display="none" style="cursor: pointer;"><path id="kity_path_30629" fill="white" stroke="gray" d="M-15.5,15734.5A6,6,0,1,1,-27.5,15734.5A6,6,0,1,1,-15.5,15734.5"></path><path id="kity_path_30630" fill="none" stroke="gray"></path></g><path id="node_outline3370" fill="none" stroke="none" d="M-27.5,15725.5h104a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-104a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3370" fill="black"><text id="kity_text_16779" text-rendering="inherit" font-size="12" dy=".8em" y="15726.700000047684" x="-27.5">git 三个基本区说说</text></g></g><g id="minder_node3373" display="none"><g id="node_expander3368" display="none" style="cursor: pointer;"><path id="kity_path_30626" fill="white" stroke="gray" d="M-31.5,15734.5A6,6,0,1,1,-43.5,15734.5A6,6,0,1,1,-31.5,15734.5"></path><path id="kity_path_30627" fill="none" stroke="gray"></path></g><path id="node_outline3369" fill="none" stroke="none" d="M-43.5,15725.5h509a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-509a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3369" fill="black"><text id="kity_text_16777" text-rendering="inherit" font-size="12" dy=".8em" y="15726.700000047684" x="-43.5">1.工作区间。2.暂存区间。3.历史区间。git add(1-&gt;2)。git commit(2-&gt;3) 。git reset(3-&gt;2)。</text></g></g><g id="minder_node3374" display="none"><g id="node_expander3371" display="none" style="cursor: pointer;"><path id="kity_path_30635" fill="white" stroke="gray" d="M-15.5,15742.5A6,6,0,1,1,-27.5,15742.5A6,6,0,1,1,-15.5,15742.5"></path><path id="kity_path_30636" fill="none" stroke="gray"></path></g><path id="node_outline3372" fill="none" stroke="none" d="M-27.5,15733.5h234a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-234a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3372" fill="black"><text id="kity_text_16786" text-rendering="inherit" font-size="12" dy=".8em" y="15734.700000047684" x="-27.5">git reset和git checkout 和git revert的区别</text></g></g><g id="minder_node3375" display="none"><g id="node_expander3370" display="none" style="cursor: pointer;"><path id="kity_path_30632" fill="white" stroke="gray" d="M-31.5,15742.5A6,6,0,1,1,-43.5,15742.5A6,6,0,1,1,-31.5,15742.5"></path><path id="kity_path_30633" fill="none" stroke="gray"></path></g><path id="node_outline3371" fill="none" stroke="none" d="M-43.5,15706.5h430a5,5,0,0,1,5,5v62a5,5,0,0,1,-5,5h-430a5,5,0,0,1,-5,-5v-62a5,5,0,0,1,5,-5z"></path><g id="node_text3371" fill="black"><text id="kity_text_16781" text-rendering="inherit" font-size="12" dy=".8em" y="15707.700000047684" x="-43.5">共同点是撤销代码仓库中的某些修改。</text><text id="kity_text_16782" text-rendering="inherit" font-size="12" dy=".8em" y="15725.700000047684" x="-43.5">git reset是直接删除commit后的记录，不能在公共分支使用。</text><text id="kity_text_16783" text-rendering="inherit" font-size="12" dy=".8em" y="15743.700000047684" x="-43.5">git checkout 是切换工作目录，然后把头指针移向新的所在分支。</text><text id="kity_text_16784" text-rendering="inherit" font-size="12" dy=".8em" y="15761.700000047684" x="-43.5">git revert 会创建新的commit 然后删除之前的commit 相当于 git reset比较安全</text></g></g><g id="minder_node3376" display="none"><g id="node_expander3373" display="none" style="cursor: pointer;"><path id="kity_path_30641" fill="white" stroke="gray" d="M-15.5,15750.5A6,6,0,1,1,-27.5,15750.5A6,6,0,1,1,-15.5,15750.5"></path><path id="kity_path_30642" fill="none" stroke="gray"></path></g><path id="node_outline3374" fill="none" stroke="none" d="M-27.5,15741.5h127a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-127a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3374" fill="black"><text id="kity_text_16791" text-rendering="inherit" font-size="12" dy=".8em" y="15742.700000047684" x="-27.5">rebase 和merge的区别</text></g></g><g id="minder_node3377" display="none"><g id="node_expander3372" display="none" style="cursor: pointer;"><path id="kity_path_30638" fill="white" stroke="gray" d="M-31.5,15750.5A6,6,0,1,1,-43.5,15750.5A6,6,0,1,1,-31.5,15750.5"></path><path id="kity_path_30639" fill="none" stroke="gray"></path></g><path id="node_outline3373" fill="none" stroke="none" d="M-43.5,15732.5h578a5,5,0,0,1,5,5v26a5,5,0,0,1,-5,5h-578a5,5,0,0,1,-5,-5v-26a5,5,0,0,1,5,-5z"></path><g id="node_text3373" fill="black"><text id="kity_text_16788" text-rendering="inherit" font-size="12" dy=".8em" y="15733.700000047684" x="-43.5">两个解决冲突时，rebase不会新建commit ，merge会</text><text id="kity_text_16789" text-rendering="inherit" font-size="12" dy=".8em" y="15751.700000047684" x="-43.5">比如合并代码时 git merfe --no-ff会自动创建commit，git pull -rebase有冲突时比较麻烦需要解决很多冲突</text></g></g><g id="minder_node3378" display="none"><g id="node_expander3379" display="none" style="cursor: pointer;"><path id="kity_path_30659" fill="white" stroke="gray" d="M16.5,15758.5A6,6,0,1,1,4.5,15758.5A6,6,0,1,1,16.5,15758.5"></path><path id="kity_path_30660" fill="none" stroke="gray"></path></g><path id="node_outline3380" fill="none" stroke="none" d="M4.5,15749.5h38a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-38a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3380" fill="black"><text id="kity_text_16803" text-rendering="inherit" font-size="12" dy=".8em" y="15750.700000047684" x="4.5">maven</text></g></g><g id="minder_node3379" display="none"><g id="node_expander3378" display="none" style="cursor: pointer;"><path id="kity_path_30656" fill="white" stroke="gray" d="M0.5,15758.5A6,6,0,1,1,-11.5,15758.5A6,6,0,1,1,0.5,15758.5"></path><path id="kity_path_30657" fill="none" stroke="gray"></path></g><path id="node_outline3379" fill="none" stroke="none" d="M-11.5,15749.5h25a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-25a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3379" fill="black"><text id="kity_text_16801" text-rendering="inherit" font-size="12" dy=".8em" y="15750.700000047684" x="-11.5">基础</text></g></g><g id="minder_node3380" display="none"><g id="node_expander3377" display="none" style="cursor: pointer;"><path id="kity_path_30653" fill="white" stroke="gray" d="M-15.5,15758.5A6,6,0,1,1,-27.5,15758.5A6,6,0,1,1,-15.5,15758.5"></path><path id="kity_path_30654" fill="none" stroke="gray"></path></g><path id="node_outline3378" fill="none" stroke="none" d="M-27.5,15749.5h98a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-98a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3378" fill="black"><text id="kity_text_16799" text-rendering="inherit" font-size="12" dy=".8em" y="15750.700000047684" x="-27.5">怎么解决依赖冲突</text></g></g><g id="minder_node3381" display="none"><g id="node_expander3376" display="none" style="cursor: pointer;"><path id="kity_path_30650" fill="white" stroke="gray" d="M-31.5,15758.5A6,6,0,1,1,-43.5,15758.5A6,6,0,1,1,-31.5,15758.5"></path><path id="kity_path_30651" fill="none" stroke="gray"></path></g><path id="node_outline3377" fill="none" stroke="none" d="M-43.5,15749.5h23a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-23a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3377" fill="black"><text id="kity_text_16797" text-rendering="inherit" font-size="12" dy=".8em" y="15750.700000047684" x="-43.5">1.父</text></g></g><g id="minder_node3382" display="none"><g id="node_expander3381" display="none" style="cursor: pointer;"><path id="kity_path_30665" fill="white" stroke="gray" d="M16.5,15766.5A6,6,0,1,1,4.5,15766.5A6,6,0,1,1,16.5,15766.5"></path><path id="kity_path_30666" fill="none" stroke="gray"></path></g><path id="node_outline3382" fill="none" stroke="none" d="M4.5,15757.5h41a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-41a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3382" fill="black"><text id="kity_text_16807" text-rendering="inherit" font-size="12" dy=".8em" y="15758.700000047684" x="4.5">apache</text></g></g><g id="minder_node3383" display="none"><g id="node_expander3380" display="none" style="cursor: pointer;"><path id="kity_path_30662" fill="white" stroke="gray" d="M0.5,15766.5A6,6,0,1,1,-11.5,15766.5A6,6,0,1,1,0.5,15766.5"></path><path id="kity_path_30663" fill="none" stroke="gray"></path></g><path id="node_outline3381" fill="none" stroke="none" d="M-11.5,15757.5h29a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-29a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3381" fill="black"><text id="kity_text_16805" text-rendering="inherit" font-size="12" dy=".8em" y="15758.700000047684" x="-11.5">shiro</text></g></g><g id="minder_node3384"><g id="node_expander3420" style="cursor: pointer;"><path id="kity_path_30782" fill="white" stroke="gray" d="M317.5,15808.5A6,6,0,1,1,305.5,15808.5A6,6,0,1,1,317.5,15808.5"></path><path id="kity_path_30783" fill="none" stroke="gray" d="M307,15808.5L316,15808.5M311.5,15804L311.5,15813"></path></g><path id="node_outline3421" fill="rgb(239, 238, 246)" stroke="rgb(123, 115, 191)" d="M107.5,15795.5h194a3,3,0,0,1,3,3v20a3,3,0,0,1,-3,3h-194a3,3,0,0,1,-3,-3v-20a3,3,0,0,1,3,-3z" stroke-width="1"></path><g id="node_text3421" fill="black"><text id="kity_text_16885" text-rendering="inherit" font-size="14" dy=".8em" y="15799.400000095367" x="124.5">23.方案实现思路和软实力</text></g></g><g id="minder_node3385" display="none"><g id="node_expander3419" display="none" style="cursor: pointer;"><path id="kity_path_30779" fill="white" stroke="gray" d="M100.5,15808.5A6,6,0,1,1,88.5,15808.5A6,6,0,1,1,100.5,15808.5"></path><path id="kity_path_30780" fill="none" stroke="gray"></path></g><path id="node_outline3420" fill="none" stroke="none" d="M88.5,15799.5h122a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-122a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3420" fill="black"><text id="kity_text_16883" text-rendering="inherit" font-size="12" dy=".8em" y="15800.700000047684" x="88.5">非功能设计开放性问题</text></g></g><g id="minder_node3386" display="none"><g id="node_expander3383" display="none" style="cursor: pointer;"><path id="kity_path_30671" fill="white" stroke="gray" d="M84.5,15744.5A6,6,0,1,1,72.5,15744.5A6,6,0,1,1,84.5,15744.5"></path><path id="kity_path_30672" fill="none" stroke="gray"></path></g><path id="node_outline3384" fill="none" stroke="none" d="M72.5,15735.5h49a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-49a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3384" fill="black"><text id="kity_text_16811" text-rendering="inherit" font-size="12" dy=".8em" y="15736.700000047684" x="72.5">日志规范</text></g></g><g id="minder_node3387" display="none"><g id="node_expander3387" display="none" style="cursor: pointer;"><path id="kity_path_30683" fill="white" stroke="gray" d="M84.5,15752.5A6,6,0,1,1,72.5,15752.5A6,6,0,1,1,84.5,15752.5"></path><path id="kity_path_30684" fill="none" stroke="gray"></path></g><path id="node_outline3388" fill="none" stroke="none" d="M72.5,15743.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3388" fill="black"><text id="kity_text_16819" text-rendering="inherit" font-size="12" dy=".8em" y="15744.700000047684" x="72.5">代码规范</text></g></g><g id="minder_node3388" display="none"><g id="node_expander3384" display="none" style="cursor: pointer;"><path id="kity_path_30674" fill="white" stroke="gray" d="M68.5,15736.5A6,6,0,1,1,56.5,15736.5A6,6,0,1,1,68.5,15736.5"></path><path id="kity_path_30675" fill="none" stroke="gray"></path></g><path id="node_outline3385" fill="none" stroke="none" d="M56.5,15727.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3385" fill="black"><text id="kity_text_16813" text-rendering="inherit" font-size="12" dy=".8em" y="15728.700000047684" x="56.5">你觉得好的代码是怎么样的</text></g></g><g id="minder_node3389" display="none"><g id="node_expander3385" display="none" style="cursor: pointer;"><path id="kity_path_30677" fill="white" stroke="gray" d="M68.5,15744.5A6,6,0,1,1,56.5,15744.5A6,6,0,1,1,68.5,15744.5"></path><path id="kity_path_30678" fill="none" stroke="gray"></path></g><path id="node_outline3386" fill="none" stroke="none" d="M56.5,15735.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3386" fill="black"><text id="kity_text_16815" text-rendering="inherit" font-size="12" dy=".8em" y="15736.700000047684" x="56.5">怎么样才能写出优雅的代码</text></g></g><g id="minder_node3390" display="none"><g id="node_expander3386" display="none" style="cursor: pointer;"><path id="kity_path_30680" fill="white" stroke="gray" d="M68.5,15752.5A6,6,0,1,1,56.5,15752.5A6,6,0,1,1,68.5,15752.5"></path><path id="kity_path_30681" fill="none" stroke="gray"></path></g><path id="node_outline3387" fill="none" stroke="none" d="M56.5,15743.5h122a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-122a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3387" fill="black"><text id="kity_text_16817" text-rendering="inherit" font-size="12" dy=".8em" y="15744.700000047684" x="56.5">你觉得代码规范是什么</text></g></g><g id="minder_node3391" display="none"><g id="node_expander3390" display="none" style="cursor: pointer;"><path id="kity_path_30692" fill="white" stroke="gray" d="M84.5,15760.5A6,6,0,1,1,72.5,15760.5A6,6,0,1,1,84.5,15760.5"></path><path id="kity_path_30693" fill="none" stroke="gray"></path></g><path id="node_outline3391" fill="none" stroke="none" d="M72.5,15751.5h73a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-73a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3391" fill="black"><text id="kity_text_16825" text-rendering="inherit" font-size="12" dy=".8em" y="15752.700000047684" x="72.5">软实力书方面</text></g></g><g id="minder_node3392" display="none"><g id="node_expander3388" display="none" style="cursor: pointer;"><path id="kity_path_30686" fill="white" stroke="gray" d="M68.5,15752.5A6,6,0,1,1,56.5,15752.5A6,6,0,1,1,68.5,15752.5"></path><path id="kity_path_30687" fill="none" stroke="gray"></path></g><path id="node_outline3389" fill="none" stroke="none" d="M56.5,15743.5h73a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-73a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3389" fill="black"><text id="kity_text_16821" text-rendering="inherit" font-size="12" dy=".8em" y="15744.700000047684" x="56.5">你看过什么书</text></g></g><g id="minder_node3393" display="none"><g id="node_expander3389" display="none" style="cursor: pointer;"><path id="kity_path_30689" fill="white" stroke="gray" d="M68.5,15760.5A6,6,0,1,1,56.5,15760.5A6,6,0,1,1,68.5,15760.5"></path><path id="kity_path_30690" fill="none" stroke="gray"></path></g><path id="node_outline3390" fill="none" stroke="none" d="M56.5,15751.5h229a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-229a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3390" fill="black"><text id="kity_text_16823" text-rendering="inherit" font-size="12" dy=".8em" y="15752.700000047684" x="56.5">那你说说阿里巴巴开发手册给你带来了什么</text></g></g><g id="minder_node3394" display="none"><g id="node_expander3392" display="none" style="cursor: pointer;"><path id="kity_path_30698" fill="white" stroke="gray" d="M84.5,15768.5A6,6,0,1,1,72.5,15768.5A6,6,0,1,1,84.5,15768.5"></path><path id="kity_path_30699" fill="none" stroke="gray"></path></g><path id="node_outline3393" fill="none" stroke="none" d="M72.5,15759.5h86a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-86a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3393" fill="black"><text id="kity_text_16829" text-rendering="inherit" font-size="12" dy=".8em" y="15760.700000047684" x="72.5">软实力技能扩展</text></g></g><g id="minder_node3395" display="none"><g id="node_expander3391" display="none" style="cursor: pointer;"><path id="kity_path_30695" fill="white" stroke="gray" d="M68.5,15768.5A6,6,0,1,1,56.5,15768.5A6,6,0,1,1,68.5,15768.5"></path><path id="kity_path_30696" fill="none" stroke="gray"></path></g><path id="node_outline3392" fill="none" stroke="none" d="M56.5,15759.5h98a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-98a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3392" fill="black"><text id="kity_text_16827" text-rendering="inherit" font-size="12" dy=".8em" y="15760.700000047684" x="56.5">你用过哪些中间件</text></g></g><g id="minder_node3396" display="none"><g id="node_expander3394" display="none" style="cursor: pointer;"><path id="kity_path_30704" fill="white" stroke="gray" d="M84.5,15776.5A6,6,0,1,1,72.5,15776.5A6,6,0,1,1,84.5,15776.5"></path><path id="kity_path_30705" fill="none" stroke="gray"></path></g><path id="node_outline3395" fill="none" stroke="none" d="M72.5,15767.5h86a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-86a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3395" fill="black"><text id="kity_text_16833" text-rendering="inherit" font-size="12" dy=".8em" y="15768.700000047684" x="72.5">软实力自我展现</text></g></g><g id="minder_node3397" display="none"><g id="node_expander3393" display="none" style="cursor: pointer;"><path id="kity_path_30701" fill="white" stroke="gray" d="M68.5,15776.5A6,6,0,1,1,56.5,15776.5A6,6,0,1,1,68.5,15776.5"></path><path id="kity_path_30702" fill="none" stroke="gray"></path></g><path id="node_outline3394" fill="none" stroke="none" d="M56.5,15767.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3394" fill="black"><text id="kity_text_16831" text-rendering="inherit" font-size="12" dy=".8em" y="15768.700000047684" x="56.5">你觉得你有什么亮点</text></g></g><g id="minder_node3398" display="none"><g id="node_expander3396" display="none" style="cursor: pointer;"><path id="kity_path_30710" fill="white" stroke="gray" d="M84.5,15784.5A6,6,0,1,1,72.5,15784.5A6,6,0,1,1,84.5,15784.5"></path><path id="kity_path_30711" fill="none" stroke="gray"></path></g><path id="node_outline3397" fill="none" stroke="none" d="M72.5,15775.5h86a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-86a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3397" fill="black"><text id="kity_text_16837" text-rendering="inherit" font-size="12" dy=".8em" y="15776.700000047684" x="72.5">软实力自我定位</text></g></g><g id="minder_node3399" display="none"><g id="node_expander3395" display="none" style="cursor: pointer;"><path id="kity_path_30707" fill="white" stroke="gray" d="M68.5,15784.5A6,6,0,1,1,56.5,15784.5A6,6,0,1,1,68.5,15784.5"></path><path id="kity_path_30708" fill="none" stroke="gray"></path></g><path id="node_outline3396" fill="none" stroke="none" d="M56.5,15775.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3396" fill="black"><text id="kity_text_16835" text-rendering="inherit" font-size="12" dy=".8em" y="15776.700000047684" x="56.5">你觉得技术专家是怎么样的</text></g></g><g id="minder_node3400" display="none"><g id="node_expander3401" display="none" style="cursor: pointer;"><path id="kity_path_30725" fill="white" stroke="gray" d="M84.5,15792.5A6,6,0,1,1,72.5,15792.5A6,6,0,1,1,84.5,15792.5"></path><path id="kity_path_30726" fill="none" stroke="gray"></path></g><path id="node_outline3402" fill="none" stroke="none" d="M72.5,15783.5h50a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-50a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3402" fill="black"><text id="kity_text_16847" text-rendering="inherit" font-size="12" dy=".8em" y="15784.700000047684" x="72.5">项目沟通</text></g></g><g id="minder_node3401" display="none"><g id="node_expander3397" display="none" style="cursor: pointer;"><path id="kity_path_30713" fill="white" stroke="gray" d="M68.5,15776.5A6,6,0,1,1,56.5,15776.5A6,6,0,1,1,68.5,15776.5"></path><path id="kity_path_30714" fill="none" stroke="gray"></path></g><path id="node_outline3398" fill="none" stroke="none" d="M56.5,15767.5h145a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-145a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3398" fill="black"><text id="kity_text_16839" text-rendering="inherit" font-size="12" dy=".8em" y="15768.700000047684" x="56.5">你们项目是怎么日常沟通的</text></g></g><g id="minder_node3402" display="none"><g id="node_expander3398" display="none" style="cursor: pointer;"><path id="kity_path_30716" fill="white" stroke="gray" d="M68.5,15784.5A6,6,0,1,1,56.5,15784.5A6,6,0,1,1,68.5,15784.5"></path><path id="kity_path_30717" fill="none" stroke="gray"></path></g><path id="node_outline3399" fill="none" stroke="none" d="M56.5,15775.5h229a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-229a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3399" fill="black"><text id="kity_text_16841" text-rendering="inherit" font-size="12" dy=".8em" y="15776.700000047684" x="56.5">你觉得你们之前项目沟通有什么可以改进的</text></g></g><g id="minder_node3403" display="none"><g id="node_expander3400" display="none" style="cursor: pointer;"><path id="kity_path_30722" fill="white" stroke="gray" d="M68.5,15792.5A6,6,0,1,1,56.5,15792.5A6,6,0,1,1,68.5,15792.5"></path><path id="kity_path_30723" fill="none" stroke="gray"></path></g><path id="node_outline3401" fill="none" stroke="none" d="M56.5,15783.5h129a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-129a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3401" fill="black"><text id="kity_text_16845" text-rendering="inherit" font-size="12" dy=".8em" y="15784.700000047684" x="56.5">为什么需要code review</text></g></g><g id="minder_node3404" display="none"><g id="node_expander3399" display="none" style="cursor: pointer;"><path id="kity_path_30719" fill="white" stroke="gray" d="M52.5,15792.5A6,6,0,1,1,40.5,15792.5A6,6,0,1,1,52.5,15792.5"></path><path id="kity_path_30720" fill="none" stroke="gray"></path></g><path id="node_outline3400" fill="none" stroke="none" d="M40.5,15783.5h475a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-475a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3400" fill="black"><text id="kity_text_16843" text-rendering="inherit" font-size="12" dy=".8em" y="15784.700000047684" x="40.5">1.提高代码质量。2.及早发现潜在缺陷与BUG，降低事故成本。3.帮助更多的人理解系统。</text></g></g><g id="minder_node3405" display="none"><g id="node_expander3403" display="none" style="cursor: pointer;"><path id="kity_path_30731" fill="white" stroke="gray" d="M84.5,15800.5A6,6,0,1,1,72.5,15800.5A6,6,0,1,1,84.5,15800.5"></path><path id="kity_path_30732" fill="none" stroke="gray"></path></g><path id="node_outline3404" fill="none" stroke="none" d="M72.5,15791.5h26a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-26a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3404" fill="black"><text id="kity_text_16851" text-rendering="inherit" font-size="12" dy=".8em" y="15792.700000047684" x="72.5">未来</text></g></g><g id="minder_node3406" display="none"><g id="node_expander3402" display="none" style="cursor: pointer;"><path id="kity_path_30728" fill="white" stroke="gray" d="M68.5,15800.5A6,6,0,1,1,56.5,15800.5A6,6,0,1,1,68.5,15800.5"></path><path id="kity_path_30729" fill="none" stroke="gray"></path></g><path id="node_outline3403" fill="none" stroke="none" d="M56.5,15791.5h158a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-158a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3403" fill="black"><text id="kity_text_16849" text-rendering="inherit" font-size="12" dy=".8em" y="15792.700000047684" x="56.5">你怎么定位你的未来技术路线</text></g></g><g id="minder_node3407" display="none"><g id="node_expander3418" display="none" style="cursor: pointer;"><path id="kity_path_30776" fill="white" stroke="gray" d="M84.5,15808.5A6,6,0,1,1,72.5,15808.5A6,6,0,1,1,84.5,15808.5"></path><path id="kity_path_30777" fill="none" stroke="gray"></path></g><path id="node_outline3419" fill="none" stroke="none" d="M72.5,15799.5h12a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-12a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3419" fill="black"><text id="kity_text_16881" text-rendering="inherit" font-size="12" dy=".8em" y="15800.700000047684" x="72.5">hr</text></g></g><g id="minder_node3408" display="none"><g id="node_expander3404" display="none" style="cursor: pointer;"><path id="kity_path_30734" fill="white" stroke="gray" d="M68.5,15704.5A6,6,0,1,1,56.5,15704.5A6,6,0,1,1,68.5,15704.5"></path><path id="kity_path_30735" fill="none" stroke="gray"></path></g><path id="node_outline3405" fill="none" stroke="none" d="M56.5,15695.5h74a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-74a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3405" fill="black"><text id="kity_text_16853" text-rendering="inherit" font-size="12" dy=".8em" y="15696.700000047684" x="56.5">你为什么离职</text></g></g><g id="minder_node3409" display="none"><g id="node_expander3405" display="none" style="cursor: pointer;"><path id="kity_path_30737" fill="white" stroke="gray" d="M68.5,15712.5A6,6,0,1,1,56.5,15712.5A6,6,0,1,1,68.5,15712.5"></path><path id="kity_path_30738" fill="none" stroke="gray"></path></g><path id="node_outline3406" fill="none" stroke="none" d="M56.5,15703.5h122a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-122a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3406" fill="black"><text id="kity_text_16855" text-rendering="inherit" font-size="12" dy=".8em" y="15704.700000047684" x="56.5">你为什么选择年前离职</text></g></g><g id="minder_node3410" display="none"><g id="node_expander3406" display="none" style="cursor: pointer;"><path id="kity_path_30740" fill="white" stroke="gray" d="M68.5,15720.5A6,6,0,1,1,56.5,15720.5A6,6,0,1,1,68.5,15720.5"></path><path id="kity_path_30741" fill="none" stroke="gray"></path></g><path id="node_outline3407" fill="none" stroke="none" d="M56.5,15711.5h121a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-121a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3407" fill="black"><text id="kity_text_16857" text-rendering="inherit" font-size="12" dy=".8em" y="15712.700000047684" x="56.5">你为什么选择我们公司</text></g></g><g id="minder_node3411" display="none"><g id="node_expander3407" display="none" style="cursor: pointer;"><path id="kity_path_30743" fill="white" stroke="gray" d="M68.5,15728.5A6,6,0,1,1,56.5,15728.5A6,6,0,1,1,68.5,15728.5"></path><path id="kity_path_30744" fill="none" stroke="gray"></path></g><path id="node_outline3408" fill="none" stroke="none" d="M56.5,15719.5h109a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-109a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3408" fill="black"><text id="kity_text_16859" text-rendering="inherit" font-size="12" dy=".8em" y="15720.700000047684" x="56.5">你了解过我们公司吗</text></g></g><g id="minder_node3412" display="none"><g id="node_expander3408" display="none" style="cursor: pointer;"><path id="kity_path_30746" fill="white" stroke="gray" d="M68.5,15736.5A6,6,0,1,1,56.5,15736.5A6,6,0,1,1,68.5,15736.5"></path><path id="kity_path_30747" fill="none" stroke="gray"></path></g><path id="node_outline3409" fill="none" stroke="none" d="M56.5,15727.5h133a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-133a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3409" fill="black"><text id="kity_text_16861" text-rendering="inherit" font-size="12" dy=".8em" y="15728.700000047684" x="56.5">你平常是怎么释放压力的</text></g></g><g id="minder_node3413" display="none"><g id="node_expander3409" display="none" style="cursor: pointer;"><path id="kity_path_30749" fill="white" stroke="gray" d="M68.5,15744.5A6,6,0,1,1,56.5,15744.5A6,6,0,1,1,68.5,15744.5"></path><path id="kity_path_30750" fill="none" stroke="gray"></path></g><path id="node_outline3410" fill="none" stroke="none" d="M56.5,15735.5h157a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-157a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3410" fill="black"><text id="kity_text_16863" text-rendering="inherit" font-size="12" dy=".8em" y="15736.700000047684" x="56.5">你有规划过自己的业余时间吗</text></g></g><g id="minder_node3414" display="none"><g id="node_expander3410" display="none" style="cursor: pointer;"><path id="kity_path_30752" fill="white" stroke="gray" d="M68.5,15752.5A6,6,0,1,1,56.5,15752.5A6,6,0,1,1,68.5,15752.5"></path><path id="kity_path_30753" fill="none" stroke="gray"></path></g><path id="node_outline3411" fill="none" stroke="none" d="M56.5,15743.5h122a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-122a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3411" fill="black"><text id="kity_text_16865" text-rendering="inherit" font-size="12" dy=".8em" y="15744.700000047684" x="56.5">你业余时间平常会干嘛</text></g></g><g id="minder_node3415" display="none"><g id="node_expander3411" display="none" style="cursor: pointer;"><path id="kity_path_30755" fill="white" stroke="gray" d="M68.5,15760.5A6,6,0,1,1,56.5,15760.5A6,6,0,1,1,68.5,15760.5"></path><path id="kity_path_30756" fill="none" stroke="gray"></path></g><path id="node_outline3412" fill="none" stroke="none" d="M56.5,15751.5h278a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-278a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3412" fill="black"><text id="kity_text_16867" text-rendering="inherit" font-size="12" dy=".8em" y="15752.700000047684" x="56.5">你期望薪资是多少，如果我们给不了，你能不能降低</text></g></g><g id="minder_node3416" display="none"><g id="node_expander3412" display="none" style="cursor: pointer;"><path id="kity_path_30758" fill="white" stroke="gray" d="M68.5,15768.5A6,6,0,1,1,56.5,15768.5A6,6,0,1,1,68.5,15768.5"></path><path id="kity_path_30759" fill="none" stroke="gray"></path></g><path id="node_outline3413" fill="none" stroke="none" d="M56.5,15759.5h98a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-98a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3413" fill="black"><text id="kity_text_16869" text-rendering="inherit" font-size="12" dy=".8em" y="15760.700000047684" x="56.5">你上家的薪资多少</text></g></g><g id="minder_node3417" display="none"><g id="node_expander3413" display="none" style="cursor: pointer;"><path id="kity_path_30761" fill="white" stroke="gray" d="M68.5,15776.5A6,6,0,1,1,56.5,15776.5A6,6,0,1,1,68.5,15776.5"></path><path id="kity_path_30762" fill="none" stroke="gray"></path></g><path id="node_outline3414" fill="none" stroke="none" d="M56.5,15767.5h124a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-124a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3414" fill="black"><text id="kity_text_16871" text-rendering="inherit" font-size="12" dy=".8em" y="15768.700000047684" x="56.5">你现在有其他offer吗，</text></g></g><g id="minder_node3418" display="none"><g id="node_expander3414" display="none" style="cursor: pointer;"><path id="kity_path_30764" fill="white" stroke="gray" d="M68.5,15784.5A6,6,0,1,1,56.5,15784.5A6,6,0,1,1,68.5,15784.5"></path><path id="kity_path_30765" fill="none" stroke="gray"></path></g><path id="node_outline3415" fill="none" stroke="none" d="M56.5,15775.5h254a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-254a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3415" fill="black"><text id="kity_text_16873" text-rendering="inherit" font-size="12" dy=".8em" y="15776.700000047684" x="56.5">你怎么看待加班的，你觉得你的抗压能力怎么样</text></g></g><g id="minder_node3419" display="none"><g id="node_expander3415" display="none" style="cursor: pointer;"><path id="kity_path_30767" fill="white" stroke="gray" d="M68.5,15792.5A6,6,0,1,1,56.5,15792.5A6,6,0,1,1,68.5,15792.5"></path><path id="kity_path_30768" fill="none" stroke="gray"></path></g><path id="node_outline3416" fill="none" stroke="none" d="M56.5,15783.5h266a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-266a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3416" fill="black"><text id="kity_text_16875" text-rendering="inherit" font-size="12" dy=".8em" y="15784.700000047684" x="56.5">领导给你任务，你觉得给你的工期不够你会怎么办</text></g></g><g id="minder_node3420" display="none"><g id="node_expander3416" display="none" style="cursor: pointer;"><path id="kity_path_30770" fill="white" stroke="gray" d="M68.5,15800.5A6,6,0,1,1,56.5,15800.5A6,6,0,1,1,68.5,15800.5"></path><path id="kity_path_30771" fill="none" stroke="gray"></path></g><path id="node_outline3417" fill="none" stroke="none" d="M56.5,15791.5h132a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-132a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3417" fill="black"><text id="kity_text_16877" text-rendering="inherit" font-size="12" dy=".8em" y="15792.700000047684" x="56.5">那领导着急要这个功能呢</text></g></g><g id="minder_node3421" display="none"><g id="node_expander3417" display="none" style="cursor: pointer;"><path id="kity_path_30773" fill="white" stroke="gray" d="M68.5,15808.5A6,6,0,1,1,56.5,15808.5A6,6,0,1,1,68.5,15808.5"></path><path id="kity_path_30774" fill="none" stroke="gray"></path></g><path id="node_outline3418" fill="none" stroke="none" d="M56.5,15799.5h173a5,5,0,0,1,5,5v8a5,5,0,0,1,-5,5h-173a5,5,0,0,1,-5,-5v-8a5,5,0,0,1,5,-5z"></path><g id="node_text3418" fill="black"><text id="kity_text_16879" text-rendering="inherit" font-size="12" dy=".8em" y="15800.700000047684" x="56.5">你简历上的这一段空档期在干嘛&#xa0;</text></g></g></g></g></svg>